/******************************************************************************/
/*  BSD 3-clause Clear License                                                */
/*                                                                            */
/*  Copyright (c) 2023                                                        */
/*    Arm Limited (or its affiliates),                                        */
/*    Thomas Bauereiss,                                                       */
/*    Brian Campbell,                                                         */
/*    Alasdair Armstrong,                                                     */
/*    Alastair Reid,                                                          */
/*    Peter Sewell                                                            */
/*                                                                            */
/*  All rights reserved.                                                      */
/*                                                                            */
/*  Redistribution and use in source and binary forms, with or without        */
/*  modification, are permitted (subject to the limitations in the            */
/*  disclaimer below) provided that the following conditions are met:         */
/*                                                                            */
/*    * Redistributions of source code must retain the above copyright        */
/*      notice, this list of conditions and the following disclaimer.         */
/*    * Redistributions in binary form must reproduce the above copyright     */
/*      notice, this list of conditions and the following disclaimer in the   */
/*      documentation and/or other materials provided with the distribution.  */
/*    * Neither the name of ARM Limited nor the names of its contributors     */
/*      may be used to endorse or promote products derived from this          */
/*      software without specific prior written permission.                   */
/*                                                                            */
/*  NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED   */
/*  BY THIS LICENSE. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND   */
/*  CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,    */
/*  BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND         */
/*  FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE   */
/*  COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,      */
/*  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  */
/*  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF      */
/*  USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON    */
/*  ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT   */
/*  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  */
/*  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.         */
/******************************************************************************/

bitfield Configuration_Type : bits(32) =
  {
    Cp15SDisable2 : 25,
    disableNIDebug : 24,
    CfgNMFI : 23,
    ExceptInit : 22,
    Cp15SDisable : 20,
    disableSPNIDebug : 19,
    disableSPIDebug : 18,
    CONFIG64 : 14,
    CFGEND : 2,
    RW : 1,
    HIVECS : 0
  }

bitfield DormantCtl_Type : bits(32) =
  {
    dbgrstreq : 12,
    dbgpwrupreq : 11,
    standbywfe : 10,
    etmpwrdwnreq : 8,
    etmpwrupreq : 7,
    ResetCatchStatus : 6,
    TestResetCatch : 5,
    PowerDownStatusSupport : 4,
    nPU : 3,
    nDbgpwrdwnreq : 2,
    Dbgnopwrdwn : 1,
    standbywfi : 0
  }

enum Feature = {
  FEAT_AA32EL0,
  FEAT_AA32EL1,
  FEAT_AA32EL2,
  FEAT_AA32EL3,
  FEAT_AA64EL0,
  FEAT_AA64EL1,
  FEAT_AA64EL2,
  FEAT_AA64EL3,
  FEAT_EL0,
  FEAT_EL1,
  FEAT_EL2,
  FEAT_EL3,
  FEAT_AES,
  FEAT_AdvSIMD,
  FEAT_CSV2_1p1,
  FEAT_CSV2_1p2,
  FEAT_CSV2_2,
  FEAT_CSV2_3,
  FEAT_DoubleLock,
  FEAT_ETMv4,
  FEAT_ETMv4p1,
  FEAT_ETMv4p2,
  FEAT_ETMv4p3,
  FEAT_ETMv4p4,
  FEAT_ETMv4p5,
  FEAT_ETMv4p6,
  FEAT_ETS2,
  FEAT_FP,
  FEAT_GICv3,
  FEAT_GICv3_LEGACY,
  FEAT_GICv3_TDIR,
  FEAT_GICv3p1,
  FEAT_GICv4,
  FEAT_GICv4p1,
  FEAT_IVIPT,
  FEAT_PCSRv8,
  FEAT_PMULL,
  FEAT_PMUv3,
  FEAT_PMUv3_EXT,
  FEAT_PMUv3_EXT32,
  FEAT_SHA1,
  FEAT_SHA256,
  FEAT_TRC_EXT,
  FEAT_TRC_SR,
  FEAT_nTLBPA,
  FEAT_CRC32,
  FEAT_Debugv8p1,
  FEAT_HAFDBS,
  FEAT_HPDS,
  FEAT_LOR,
  FEAT_LSE,
  FEAT_PAN,
  FEAT_PMUv3p1,
  FEAT_RDM,
  FEAT_VHE,
  FEAT_VMID16,
  FEAT_AA32BF16,
  FEAT_AA32HPD,
  FEAT_AA32I8MM,
  FEAT_ASMv8p2,
  FEAT_DPB,
  FEAT_Debugv8p2,
  FEAT_EDHSR,
  FEAT_F32MM,
  FEAT_F64MM,
  FEAT_FP16,
  FEAT_HPDS2,
  FEAT_I8MM,
  FEAT_IESB,
  FEAT_LPA,
  FEAT_LSMAOC,
  FEAT_LVA,
  FEAT_MPAM,
  FEAT_PAN2,
  FEAT_PCSRv8p2,
  FEAT_RAS,
  FEAT_SHA3,
  FEAT_SHA512,
  FEAT_SM3,
  FEAT_SM4,
  FEAT_SPE,
  FEAT_SVE,
  FEAT_TTCNP,
  FEAT_UAO,
  FEAT_VPIPT,
  FEAT_XNX,
  FEAT_CCIDX,
  FEAT_CONSTPACFIELD,
  FEAT_EPAC,
  FEAT_FCMA,
  FEAT_FPAC,
  FEAT_FPACCOMBINE,
  FEAT_JSCVT,
  FEAT_LRCPC,
  FEAT_NV,
  FEAT_PACIMP,
  FEAT_PACQARMA3,
  FEAT_PACQARMA5,
  FEAT_PAuth,
  FEAT_SPEv1p1,
  FEAT_AMUv1,
  FEAT_BBM,
  FEAT_CNTSC,
  FEAT_DIT,
  FEAT_Debugv8p4,
  FEAT_DotProd,
  FEAT_DoubleFault,
  FEAT_FHM,
  FEAT_FlagM,
  FEAT_IDST,
  FEAT_LRCPC2,
  FEAT_LSE2,
  FEAT_NV2,
  FEAT_PMUv3p4,
  FEAT_RASSAv1p1,
  FEAT_RASv1p1,
  FEAT_S2FWB,
  FEAT_SEL2,
  FEAT_TLBIOS,
  FEAT_TLBIRANGE,
  FEAT_TRF,
  FEAT_TTL,
  FEAT_TTST,
  FEAT_BTI,
  FEAT_CSV2,
  FEAT_CSV3,
  FEAT_DPB2,
  FEAT_E0PD,
  FEAT_EVT,
  FEAT_ExS,
  FEAT_FRINTTS,
  FEAT_FlagM2,
  FEAT_GTG,
  FEAT_MTE,
  FEAT_MTE2,
  FEAT_PMUv3p5,
  FEAT_RNG,
  FEAT_RNG_TRAP,
  FEAT_SB,
  FEAT_SPECRES,
  FEAT_SSBS,
  FEAT_SSBS2,
  FEAT_AMUv1p1,
  FEAT_BF16,
  FEAT_DGH,
  FEAT_ECV,
  FEAT_FGT,
  FEAT_HPMN0,
  FEAT_MPAMv0p1,
  FEAT_MPAMv1p1,
  FEAT_MTPMU,
  FEAT_PAuth2,
  FEAT_TWED,
  FEAT_AFP,
  FEAT_EBF16,
  FEAT_HCX,
  FEAT_LPA2,
  FEAT_LS64,
  FEAT_LS64_ACCDATA,
  FEAT_LS64_V,
  FEAT_MTE3,
  FEAT_PAN3,
  FEAT_PMUv3p7,
  FEAT_RPRES,
  FEAT_SPEv1p2,
  FEAT_WFxT,
  FEAT_XS,
  FEAT_CMOW,
  FEAT_Debugv8p8,
  FEAT_GICv3_NMI,
  FEAT_HBC,
  FEAT_MOPS,
  FEAT_NMI,
  FEAT_PMUv3_EXT64,
  FEAT_PMUv3_TH,
  FEAT_PMUv3p8,
  FEAT_SCTLR2,
  FEAT_SPEv1p3,
  FEAT_TCR2,
  FEAT_TIDCP1,
  FEAT_ADERR,
  FEAT_AIE,
  FEAT_ANERR,
  FEAT_CLRBHB,
  FEAT_CSSC,
  FEAT_Debugv8p9,
  FEAT_DoubleFault2,
  FEAT_ECBHB,
  FEAT_FGT2,
  FEAT_HAFT,
  FEAT_LRCPC3,
  FEAT_MTE4,
  FEAT_MTE_ASYM_FAULT,
  FEAT_MTE_ASYNC,
  FEAT_MTE_CANONICAL_TAGS,
  FEAT_MTE_NO_ADDRESS_TAGS,
  FEAT_MTE_PERM,
  FEAT_MTE_STORE_ONLY,
  FEAT_MTE_TAGGED_FAR,
  FEAT_PCSRv8p9,
  FEAT_PFAR,
  FEAT_PMUv3_EDGE,
  FEAT_PMUv3_ICNTR,
  FEAT_PMUv3_SS,
  FEAT_PMUv3p9,
  FEAT_PRFMSLC,
  FEAT_RASSAv2,
  FEAT_RASv2,
  FEAT_RPRFM,
  FEAT_S1PIE,
  FEAT_S1POE,
  FEAT_S2PIE,
  FEAT_S2POE,
  FEAT_SPECRES2,
  FEAT_SPE_CRR,
  FEAT_SPE_FDS,
  FEAT_SPEv1p4,
  FEAT_SPMU,
  FEAT_THE,
  FEAT_DoPD,
  FEAT_ETE,
  FEAT_SVE2,
  FEAT_SVE_AES,
  FEAT_SVE_BitPerm,
  FEAT_SVE_PMULL128,
  FEAT_SVE_SHA3,
  FEAT_SVE_SM4,
  FEAT_TME,
  FEAT_TRBE,
  FEAT_ETEv1p1,
  FEAT_BRBE,
  FEAT_ETEv1p2,
  FEAT_RME,
  FEAT_SME,
  FEAT_SME_F64F64,
  FEAT_SME_FA64,
  FEAT_SME_I16I64,
  FEAT_BRBEv1p1,
  FEAT_MEC,
  FEAT_SME2,
  FEAT_ABLE,
  FEAT_CHK,
  FEAT_D128,
  FEAT_EBEP,
  FEAT_ETEv1p3,
  FEAT_GCS,
  FEAT_ITE,
  FEAT_LSE128,
  FEAT_LVA3,
  FEAT_SEBEP,
  FEAT_SME2p1,
  FEAT_SME_F16F16,
  FEAT_SVE2p1,
  FEAT_SVE_B16B16,
  FEAT_SYSINSTR128,
  FEAT_SYSREG128,
  FEAT_TRBE_EXT,
  FEAT_TRBE_MPAM
}

enum ArchVersion = {
  v8Ap0,
  v8Ap1,
  v8Ap2,
  v8Ap3,
  v8Ap4,
  v8Ap5,
  v8Ap6,
  v8Ap7,
  v8Ap8,
  v8Ap9,
  v9Ap0,
  v9Ap1,
  v9Ap2,
  v9Ap3,
  v9Ap4
}

register FEAT_AA32EL0_IMPLEMENTED : bool = true

register FEAT_AA32EL1_IMPLEMENTED : bool = false

register FEAT_AA32EL2_IMPLEMENTED : bool = false

register FEAT_AA32EL3_IMPLEMENTED : bool = false

register FEAT_AA64EL0_IMPLEMENTED : bool = true

register FEAT_AA64EL1_IMPLEMENTED : bool = true

register FEAT_AA64EL2_IMPLEMENTED : bool = true

register FEAT_AA64EL3_IMPLEMENTED : bool = true

register FEAT_EL0_IMPLEMENTED : bool = true

register FEAT_EL1_IMPLEMENTED : bool = true

register FEAT_EL2_IMPLEMENTED : bool = true

register FEAT_EL3_IMPLEMENTED : bool = true

register FEAT_AES_IMPLEMENTED : bool = true

register FEAT_AdvSIMD_IMPLEMENTED : bool = true

register FEAT_CSV2_1p1_IMPLEMENTED : bool = true

register FEAT_CSV2_1p2_IMPLEMENTED : bool = true

register FEAT_CSV2_2_IMPLEMENTED : bool = true

register FEAT_CSV2_3_IMPLEMENTED : bool = true

register FEAT_DoubleLock_IMPLEMENTED : bool = true

register FEAT_ETMv4_IMPLEMENTED : bool = false

register FEAT_ETMv4p1_IMPLEMENTED : bool = true

register FEAT_ETMv4p2_IMPLEMENTED : bool = true

register FEAT_ETMv4p3_IMPLEMENTED : bool = true

register FEAT_ETMv4p4_IMPLEMENTED : bool = true

register FEAT_ETMv4p5_IMPLEMENTED : bool = true

register FEAT_ETMv4p6_IMPLEMENTED : bool = true

register FEAT_ETS2_IMPLEMENTED : bool = true

register FEAT_FP_IMPLEMENTED : bool = true

register FEAT_GICv3_IMPLEMENTED : bool = true

register FEAT_GICv3_LEGACY_IMPLEMENTED : bool = true

register FEAT_GICv3_TDIR_IMPLEMENTED : bool = true

register FEAT_GICv3p1_IMPLEMENTED : bool = true

register FEAT_GICv4_IMPLEMENTED : bool = true

register FEAT_GICv4p1_IMPLEMENTED : bool = true

register FEAT_IVIPT_IMPLEMENTED : bool = true

register FEAT_PCSRv8_IMPLEMENTED : bool = true

register FEAT_PMULL_IMPLEMENTED : bool = true

register FEAT_PMUv3_IMPLEMENTED : bool = true

register FEAT_PMUv3_EXT_IMPLEMENTED : bool = true

register FEAT_PMUv3_EXT32_IMPLEMENTED : bool = true

register FEAT_SHA1_IMPLEMENTED : bool = true

register FEAT_SHA256_IMPLEMENTED : bool = true

register FEAT_TRC_EXT_IMPLEMENTED : bool = true

register FEAT_TRC_SR_IMPLEMENTED : bool = true

register FEAT_nTLBPA_IMPLEMENTED : bool = true

register FEAT_CRC32_IMPLEMENTED : bool = true

register FEAT_Debugv8p1_IMPLEMENTED : bool = true

register FEAT_HAFDBS_IMPLEMENTED : bool = true

register FEAT_HPDS_IMPLEMENTED : bool = true

register FEAT_LOR_IMPLEMENTED : bool = true

register FEAT_LSE_IMPLEMENTED : bool = true

register FEAT_PAN_IMPLEMENTED : bool = true

register FEAT_PMUv3p1_IMPLEMENTED : bool = true

register FEAT_RDM_IMPLEMENTED : bool = true

register FEAT_VHE_IMPLEMENTED : bool = true

register FEAT_VMID16_IMPLEMENTED : bool = true

register FEAT_AA32BF16_IMPLEMENTED : bool = true

register FEAT_AA32HPD_IMPLEMENTED : bool = true

register FEAT_AA32I8MM_IMPLEMENTED : bool = true

register FEAT_ASMv8p2_IMPLEMENTED : bool = true

register FEAT_DPB_IMPLEMENTED : bool = true

register FEAT_Debugv8p2_IMPLEMENTED : bool = true

register FEAT_EDHSR_IMPLEMENTED : bool = true

register FEAT_F32MM_IMPLEMENTED : bool = true

register FEAT_F64MM_IMPLEMENTED : bool = true

register FEAT_FP16_IMPLEMENTED : bool = true

register FEAT_HPDS2_IMPLEMENTED : bool = true

register FEAT_I8MM_IMPLEMENTED : bool = true

register FEAT_IESB_IMPLEMENTED : bool = true

register FEAT_LPA_IMPLEMENTED : bool = true

register FEAT_LSMAOC_IMPLEMENTED : bool = true

register FEAT_LVA_IMPLEMENTED : bool = true

register FEAT_MPAM_IMPLEMENTED : bool = true

register FEAT_PAN2_IMPLEMENTED : bool = true

register FEAT_PCSRv8p2_IMPLEMENTED : bool = true

register FEAT_RAS_IMPLEMENTED : bool = true

register FEAT_SHA3_IMPLEMENTED : bool = true

register FEAT_SHA512_IMPLEMENTED : bool = true

register FEAT_SM3_IMPLEMENTED : bool = true

register FEAT_SM4_IMPLEMENTED : bool = true

register FEAT_SPE_IMPLEMENTED : bool = true

register FEAT_SVE_IMPLEMENTED : bool = true

register FEAT_TTCNP_IMPLEMENTED : bool = true

register FEAT_UAO_IMPLEMENTED : bool = true

register FEAT_VPIPT_IMPLEMENTED : bool = true

register FEAT_XNX_IMPLEMENTED : bool = true

register FEAT_CCIDX_IMPLEMENTED : bool = true

register FEAT_CONSTPACFIELD_IMPLEMENTED : bool = false

register FEAT_EPAC_IMPLEMENTED : bool = false

register FEAT_FCMA_IMPLEMENTED : bool = true

register FEAT_FPAC_IMPLEMENTED : bool = true

register FEAT_FPACCOMBINE_IMPLEMENTED : bool = true

register FEAT_JSCVT_IMPLEMENTED : bool = true

register FEAT_LRCPC_IMPLEMENTED : bool = true

register FEAT_NV_IMPLEMENTED : bool = true

register FEAT_PACIMP_IMPLEMENTED : bool = false

register FEAT_PACQARMA3_IMPLEMENTED : bool = false

register FEAT_PACQARMA5_IMPLEMENTED : bool = true

register FEAT_PAuth_IMPLEMENTED : bool = true

register FEAT_SPEv1p1_IMPLEMENTED : bool = true

register FEAT_AMUv1_IMPLEMENTED : bool = true

register FEAT_BBM_IMPLEMENTED : bool = true

register FEAT_CNTSC_IMPLEMENTED : bool = true

register FEAT_DIT_IMPLEMENTED : bool = true

register FEAT_Debugv8p4_IMPLEMENTED : bool = true

register FEAT_DotProd_IMPLEMENTED : bool = true

register FEAT_DoubleFault_IMPLEMENTED : bool = true

register FEAT_FHM_IMPLEMENTED : bool = true

register FEAT_FlagM_IMPLEMENTED : bool = true

register FEAT_IDST_IMPLEMENTED : bool = true

register FEAT_LRCPC2_IMPLEMENTED : bool = true

register FEAT_LSE2_IMPLEMENTED : bool = true

register FEAT_NV2_IMPLEMENTED : bool = true

register FEAT_PMUv3p4_IMPLEMENTED : bool = true

register FEAT_RASSAv1p1_IMPLEMENTED : bool = true

register FEAT_RASv1p1_IMPLEMENTED : bool = true

register FEAT_S2FWB_IMPLEMENTED : bool = true

register FEAT_SEL2_IMPLEMENTED : bool = true

register FEAT_TLBIOS_IMPLEMENTED : bool = true

register FEAT_TLBIRANGE_IMPLEMENTED : bool = true

register FEAT_TRF_IMPLEMENTED : bool = true

register FEAT_TTL_IMPLEMENTED : bool = true

register FEAT_TTST_IMPLEMENTED : bool = true

register FEAT_BTI_IMPLEMENTED : bool = true

register FEAT_CSV2_IMPLEMENTED : bool = true

register FEAT_CSV3_IMPLEMENTED : bool = true

register FEAT_DPB2_IMPLEMENTED : bool = true

register FEAT_E0PD_IMPLEMENTED : bool = true

register FEAT_EVT_IMPLEMENTED : bool = true

register FEAT_ExS_IMPLEMENTED : bool = true

register FEAT_FRINTTS_IMPLEMENTED : bool = true

register FEAT_FlagM2_IMPLEMENTED : bool = true

register FEAT_GTG_IMPLEMENTED : bool = true

register FEAT_MTE_IMPLEMENTED : bool = true

register FEAT_MTE2_IMPLEMENTED : bool = true

register FEAT_PMUv3p5_IMPLEMENTED : bool = true

register FEAT_RNG_IMPLEMENTED : bool = true

register FEAT_RNG_TRAP_IMPLEMENTED : bool = true

register FEAT_SB_IMPLEMENTED : bool = true

register FEAT_SPECRES_IMPLEMENTED : bool = true

register FEAT_SSBS_IMPLEMENTED : bool = true

register FEAT_SSBS2_IMPLEMENTED : bool = true

register FEAT_AMUv1p1_IMPLEMENTED : bool = true

register FEAT_BF16_IMPLEMENTED : bool = true

register FEAT_DGH_IMPLEMENTED : bool = true

register FEAT_ECV_IMPLEMENTED : bool = true

register FEAT_FGT_IMPLEMENTED : bool = true

register FEAT_HPMN0_IMPLEMENTED : bool = true

register FEAT_MPAMv0p1_IMPLEMENTED : bool = true

register FEAT_MPAMv1p1_IMPLEMENTED : bool = true

register FEAT_MTPMU_IMPLEMENTED : bool = true

register FEAT_PAuth2_IMPLEMENTED : bool = true

register FEAT_TWED_IMPLEMENTED : bool = true

register FEAT_AFP_IMPLEMENTED : bool = true

register FEAT_EBF16_IMPLEMENTED : bool = true

register FEAT_HCX_IMPLEMENTED : bool = true

register FEAT_LPA2_IMPLEMENTED : bool = true

register FEAT_LS64_IMPLEMENTED : bool = true

register FEAT_LS64_ACCDATA_IMPLEMENTED : bool = true

register FEAT_LS64_V_IMPLEMENTED : bool = true

register FEAT_MTE3_IMPLEMENTED : bool = true

register FEAT_PAN3_IMPLEMENTED : bool = true

register FEAT_PMUv3p7_IMPLEMENTED : bool = true

register FEAT_RPRES_IMPLEMENTED : bool = true

register FEAT_SPEv1p2_IMPLEMENTED : bool = true

register FEAT_WFxT_IMPLEMENTED : bool = true

register FEAT_XS_IMPLEMENTED : bool = true

register FEAT_CMOW_IMPLEMENTED : bool = true

register FEAT_Debugv8p8_IMPLEMENTED : bool = true

register FEAT_GICv3_NMI_IMPLEMENTED : bool = true

register FEAT_HBC_IMPLEMENTED : bool = true

register FEAT_MOPS_IMPLEMENTED : bool = true

register FEAT_NMI_IMPLEMENTED : bool = true

register FEAT_PMUv3_EXT64_IMPLEMENTED : bool = true

register FEAT_PMUv3_TH_IMPLEMENTED : bool = true

register FEAT_PMUv3p8_IMPLEMENTED : bool = true

register FEAT_SCTLR2_IMPLEMENTED : bool = true

register FEAT_SPEv1p3_IMPLEMENTED : bool = true

register FEAT_TCR2_IMPLEMENTED : bool = true

register FEAT_TIDCP1_IMPLEMENTED : bool = true

register FEAT_ADERR_IMPLEMENTED : bool = true

register FEAT_AIE_IMPLEMENTED : bool = true

register FEAT_ANERR_IMPLEMENTED : bool = true

register FEAT_CLRBHB_IMPLEMENTED : bool = true

register FEAT_CSSC_IMPLEMENTED : bool = true

register FEAT_Debugv8p9_IMPLEMENTED : bool = true

register FEAT_DoubleFault2_IMPLEMENTED : bool = true

register FEAT_ECBHB_IMPLEMENTED : bool = true

register FEAT_FGT2_IMPLEMENTED : bool = true

register FEAT_HAFT_IMPLEMENTED : bool = true

register FEAT_LRCPC3_IMPLEMENTED : bool = true

register FEAT_MTE4_IMPLEMENTED : bool = true

register FEAT_MTE_ASYM_FAULT_IMPLEMENTED : bool = true

register FEAT_MTE_ASYNC_IMPLEMENTED : bool = true

register FEAT_MTE_CANONICAL_TAGS_IMPLEMENTED : bool = true

register FEAT_MTE_NO_ADDRESS_TAGS_IMPLEMENTED : bool = true

register FEAT_MTE_PERM_IMPLEMENTED : bool = true

register FEAT_MTE_STORE_ONLY_IMPLEMENTED : bool = true

register FEAT_MTE_TAGGED_FAR_IMPLEMENTED : bool = true

register FEAT_PCSRv8p9_IMPLEMENTED : bool = true

register FEAT_PFAR_IMPLEMENTED : bool = true

register FEAT_PMUv3_EDGE_IMPLEMENTED : bool = true

register FEAT_PMUv3_ICNTR_IMPLEMENTED : bool = true

register FEAT_PMUv3_SS_IMPLEMENTED : bool = true

register FEAT_PMUv3p9_IMPLEMENTED : bool = true

register FEAT_PRFMSLC_IMPLEMENTED : bool = true

register FEAT_RASSAv2_IMPLEMENTED : bool = true

register FEAT_RASv2_IMPLEMENTED : bool = true

register FEAT_RPRFM_IMPLEMENTED : bool = true

register FEAT_S1PIE_IMPLEMENTED : bool = true

register FEAT_S1POE_IMPLEMENTED : bool = true

register FEAT_S2PIE_IMPLEMENTED : bool = true

register FEAT_S2POE_IMPLEMENTED : bool = true

register FEAT_SPECRES2_IMPLEMENTED : bool = true

register FEAT_SPE_CRR_IMPLEMENTED : bool = true

register FEAT_SPE_FDS_IMPLEMENTED : bool = true

register FEAT_SPEv1p4_IMPLEMENTED : bool = true

register FEAT_SPMU_IMPLEMENTED : bool = true

register FEAT_THE_IMPLEMENTED : bool = true

register FEAT_DoPD_IMPLEMENTED : bool = true

register FEAT_ETE_IMPLEMENTED : bool = true

register FEAT_SVE2_IMPLEMENTED : bool = true

register FEAT_SVE_AES_IMPLEMENTED : bool = true

register FEAT_SVE_BitPerm_IMPLEMENTED : bool = true

register FEAT_SVE_PMULL128_IMPLEMENTED : bool = true

register FEAT_SVE_SHA3_IMPLEMENTED : bool = true

register FEAT_SVE_SM4_IMPLEMENTED : bool = true

register FEAT_TME_IMPLEMENTED : bool = true

register FEAT_TRBE_IMPLEMENTED : bool = true

register FEAT_ETEv1p1_IMPLEMENTED : bool = true

register FEAT_BRBE_IMPLEMENTED : bool = true

register FEAT_ETEv1p2_IMPLEMENTED : bool = true

register FEAT_RME_IMPLEMENTED : bool = true

register FEAT_SME_IMPLEMENTED : bool = true

register FEAT_SME_F64F64_IMPLEMENTED : bool = true

register FEAT_SME_FA64_IMPLEMENTED : bool = true

register FEAT_SME_I16I64_IMPLEMENTED : bool = true

register FEAT_BRBEv1p1_IMPLEMENTED : bool = true

register FEAT_MEC_IMPLEMENTED : bool = true

register FEAT_SME2_IMPLEMENTED : bool = true

register FEAT_ABLE_IMPLEMENTED : bool = true

register FEAT_CHK_IMPLEMENTED : bool = true

register FEAT_D128_IMPLEMENTED : bool = true

register FEAT_EBEP_IMPLEMENTED : bool = true

register FEAT_ETEv1p3_IMPLEMENTED : bool = true

register FEAT_GCS_IMPLEMENTED : bool = true

register FEAT_ITE_IMPLEMENTED : bool = true

register FEAT_LSE128_IMPLEMENTED : bool = true

register FEAT_LVA3_IMPLEMENTED : bool = true

register FEAT_SEBEP_IMPLEMENTED : bool = true

register FEAT_SME2p1_IMPLEMENTED : bool = true

register FEAT_SME_F16F16_IMPLEMENTED : bool = true

register FEAT_SVE2p1_IMPLEMENTED : bool = true

register FEAT_SVE_B16B16_IMPLEMENTED : bool = true

register FEAT_SYSINSTR128_IMPLEMENTED : bool = true

register FEAT_SYSREG128_IMPLEMENTED : bool = true

register FEAT_TRBE_EXT_IMPLEMENTED : bool = true

register FEAT_TRBE_MPAM_IMPLEMENTED : bool = true

register v8Ap0_IMPLEMENTED : bool = true

register v8Ap1_IMPLEMENTED : bool = true

register v8Ap2_IMPLEMENTED : bool = true

register v8Ap3_IMPLEMENTED : bool = true

register v8Ap4_IMPLEMENTED : bool = true

register v8Ap5_IMPLEMENTED : bool = true

register v8Ap6_IMPLEMENTED : bool = true

register v8Ap7_IMPLEMENTED : bool = true

register v8Ap8_IMPLEMENTED : bool = true

register v8Ap9_IMPLEMENTED : bool = true

register v9Ap0_IMPLEMENTED : bool = true

register v9Ap1_IMPLEMENTED : bool = true

register v9Ap2_IMPLEMENTED : bool = true

register v9Ap3_IMPLEMENTED : bool = true

register v9Ap4_IMPLEMENTED : bool = true

register FeatureImpl : vector(259, bool)

val InitFeatureImpl : unit -> unit

function InitFeatureImpl () = {
    FeatureImpl[num_of_Feature(FEAT_AA32EL0)] = FEAT_AA32EL0_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_AA32EL1)] = FEAT_AA32EL1_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_AA32EL2)] = FEAT_AA32EL2_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_AA32EL3)] = FEAT_AA32EL3_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_AA64EL0)] = FEAT_AA64EL0_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_AA64EL1)] = FEAT_AA64EL1_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_AA64EL2)] = FEAT_AA64EL2_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_AA64EL3)] = FEAT_AA64EL3_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_EL0)] = FEAT_EL0_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_EL1)] = FEAT_EL1_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_EL2)] = FEAT_EL2_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_EL3)] = FEAT_EL3_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_AES)] = FEAT_AES_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_AdvSIMD)] = FEAT_AdvSIMD_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_CSV2_1p1)] = FEAT_CSV2_1p1_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_CSV2_1p2)] = FEAT_CSV2_1p2_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_CSV2_2)] = FEAT_CSV2_2_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_CSV2_3)] = FEAT_CSV2_3_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_DoubleLock)] = FEAT_DoubleLock_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_ETMv4)] = FEAT_ETMv4_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_ETMv4p1)] = FEAT_ETMv4p1_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_ETMv4p2)] = FEAT_ETMv4p2_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_ETMv4p3)] = FEAT_ETMv4p3_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_ETMv4p4)] = FEAT_ETMv4p4_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_ETMv4p5)] = FEAT_ETMv4p5_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_ETMv4p6)] = FEAT_ETMv4p6_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_ETS2)] = FEAT_ETS2_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_FP)] = FEAT_FP_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_GICv3)] = FEAT_GICv3_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_GICv3_LEGACY)] = FEAT_GICv3_LEGACY_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_GICv3_TDIR)] = FEAT_GICv3_TDIR_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_GICv3p1)] = FEAT_GICv3p1_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_GICv4)] = FEAT_GICv4_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_GICv4p1)] = FEAT_GICv4p1_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_IVIPT)] = FEAT_IVIPT_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_PCSRv8)] = FEAT_PCSRv8_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_PMULL)] = FEAT_PMULL_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_PMUv3)] = FEAT_PMUv3_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_PMUv3_EXT)] = FEAT_PMUv3_EXT_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_PMUv3_EXT32)] = FEAT_PMUv3_EXT32_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_SHA1)] = FEAT_SHA1_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_SHA256)] = FEAT_SHA256_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_TRC_EXT)] = FEAT_TRC_EXT_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_TRC_SR)] = FEAT_TRC_SR_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_nTLBPA)] = FEAT_nTLBPA_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_CRC32)] = FEAT_CRC32_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_Debugv8p1)] = FEAT_Debugv8p1_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_HAFDBS)] = FEAT_HAFDBS_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_HPDS)] = FEAT_HPDS_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_LOR)] = FEAT_LOR_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_LSE)] = FEAT_LSE_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_PAN)] = FEAT_PAN_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_PMUv3p1)] = FEAT_PMUv3p1_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_RDM)] = FEAT_RDM_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_VHE)] = FEAT_VHE_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_VMID16)] = FEAT_VMID16_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_AA32BF16)] = FEAT_AA32BF16_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_AA32HPD)] = FEAT_AA32HPD_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_AA32I8MM)] = FEAT_AA32I8MM_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_ASMv8p2)] = FEAT_ASMv8p2_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_DPB)] = FEAT_DPB_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_Debugv8p2)] = FEAT_Debugv8p2_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_EDHSR)] = FEAT_EDHSR_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_F32MM)] = FEAT_F32MM_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_F64MM)] = FEAT_F64MM_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_FP16)] = FEAT_FP16_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_HPDS2)] = FEAT_HPDS2_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_I8MM)] = FEAT_I8MM_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_IESB)] = FEAT_IESB_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_LPA)] = FEAT_LPA_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_LSMAOC)] = FEAT_LSMAOC_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_LVA)] = FEAT_LVA_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_MPAM)] = FEAT_MPAM_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_PAN2)] = FEAT_PAN2_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_PCSRv8p2)] = FEAT_PCSRv8p2_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_RAS)] = FEAT_RAS_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_SHA3)] = FEAT_SHA3_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_SHA512)] = FEAT_SHA512_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_SM3)] = FEAT_SM3_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_SM4)] = FEAT_SM4_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_SPE)] = FEAT_SPE_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_SVE)] = FEAT_SVE_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_TTCNP)] = FEAT_TTCNP_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_UAO)] = FEAT_UAO_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_VPIPT)] = FEAT_VPIPT_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_XNX)] = FEAT_XNX_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_CCIDX)] = FEAT_CCIDX_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_CONSTPACFIELD)] = FEAT_CONSTPACFIELD_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_EPAC)] = FEAT_EPAC_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_FCMA)] = FEAT_FCMA_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_FPAC)] = FEAT_FPAC_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_FPACCOMBINE)] = FEAT_FPACCOMBINE_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_JSCVT)] = FEAT_JSCVT_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_LRCPC)] = FEAT_LRCPC_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_NV)] = FEAT_NV_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_PACIMP)] = FEAT_PACIMP_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_PACQARMA3)] = FEAT_PACQARMA3_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_PACQARMA5)] = FEAT_PACQARMA5_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_PAuth)] = FEAT_PAuth_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_SPEv1p1)] = FEAT_SPEv1p1_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_AMUv1)] = FEAT_AMUv1_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_BBM)] = FEAT_BBM_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_CNTSC)] = FEAT_CNTSC_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_DIT)] = FEAT_DIT_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_Debugv8p4)] = FEAT_Debugv8p4_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_DotProd)] = FEAT_DotProd_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_DoubleFault)] = FEAT_DoubleFault_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_FHM)] = FEAT_FHM_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_FlagM)] = FEAT_FlagM_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_IDST)] = FEAT_IDST_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_LRCPC2)] = FEAT_LRCPC2_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_LSE2)] = FEAT_LSE2_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_NV2)] = FEAT_NV2_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_PMUv3p4)] = FEAT_PMUv3p4_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_RASSAv1p1)] = FEAT_RASSAv1p1_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_RASv1p1)] = FEAT_RASv1p1_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_S2FWB)] = FEAT_S2FWB_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_SEL2)] = FEAT_SEL2_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_TLBIOS)] = FEAT_TLBIOS_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_TLBIRANGE)] = FEAT_TLBIRANGE_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_TRF)] = FEAT_TRF_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_TTL)] = FEAT_TTL_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_TTST)] = FEAT_TTST_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_BTI)] = FEAT_BTI_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_CSV2)] = FEAT_CSV2_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_CSV3)] = FEAT_CSV3_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_DPB2)] = FEAT_DPB2_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_E0PD)] = FEAT_E0PD_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_EVT)] = FEAT_EVT_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_ExS)] = FEAT_ExS_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_FRINTTS)] = FEAT_FRINTTS_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_FlagM2)] = FEAT_FlagM2_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_GTG)] = FEAT_GTG_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_MTE)] = FEAT_MTE_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_MTE2)] = FEAT_MTE2_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_PMUv3p5)] = FEAT_PMUv3p5_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_RNG)] = FEAT_RNG_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_RNG_TRAP)] = FEAT_RNG_TRAP_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_SB)] = FEAT_SB_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_SPECRES)] = FEAT_SPECRES_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_SSBS)] = FEAT_SSBS_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_SSBS2)] = FEAT_SSBS2_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_AMUv1p1)] = FEAT_AMUv1p1_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_BF16)] = FEAT_BF16_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_DGH)] = FEAT_DGH_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_ECV)] = FEAT_ECV_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_FGT)] = FEAT_FGT_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_HPMN0)] = FEAT_HPMN0_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_MPAMv0p1)] = FEAT_MPAMv0p1_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_MPAMv1p1)] = FEAT_MPAMv1p1_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_MTPMU)] = FEAT_MTPMU_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_PAuth2)] = FEAT_PAuth2_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_TWED)] = FEAT_TWED_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_AFP)] = FEAT_AFP_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_EBF16)] = FEAT_EBF16_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_HCX)] = FEAT_HCX_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_LPA2)] = FEAT_LPA2_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_LS64)] = FEAT_LS64_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_LS64_ACCDATA)] = FEAT_LS64_ACCDATA_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_LS64_V)] = FEAT_LS64_V_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_MTE3)] = FEAT_MTE3_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_PAN3)] = FEAT_PAN3_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_PMUv3p7)] = FEAT_PMUv3p7_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_RPRES)] = FEAT_RPRES_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_SPEv1p2)] = FEAT_SPEv1p2_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_WFxT)] = FEAT_WFxT_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_XS)] = FEAT_XS_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_CMOW)] = FEAT_CMOW_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_Debugv8p8)] = FEAT_Debugv8p8_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_GICv3_NMI)] = FEAT_GICv3_NMI_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_HBC)] = FEAT_HBC_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_MOPS)] = FEAT_MOPS_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_NMI)] = FEAT_NMI_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_PMUv3_EXT64)] = FEAT_PMUv3_EXT64_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_PMUv3_TH)] = FEAT_PMUv3_TH_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_PMUv3p8)] = FEAT_PMUv3p8_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_SCTLR2)] = FEAT_SCTLR2_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_SPEv1p3)] = FEAT_SPEv1p3_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_TCR2)] = FEAT_TCR2_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_TIDCP1)] = FEAT_TIDCP1_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_ADERR)] = FEAT_ADERR_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_AIE)] = FEAT_AIE_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_ANERR)] = FEAT_ANERR_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_CLRBHB)] = FEAT_CLRBHB_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_CSSC)] = FEAT_CSSC_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_Debugv8p9)] = FEAT_Debugv8p9_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_DoubleFault2)] = FEAT_DoubleFault2_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_ECBHB)] = FEAT_ECBHB_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_FGT2)] = FEAT_FGT2_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_HAFT)] = FEAT_HAFT_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_LRCPC3)] = FEAT_LRCPC3_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_MTE4)] = FEAT_MTE4_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_MTE_ASYM_FAULT)] = FEAT_MTE_ASYM_FAULT_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_MTE_ASYNC)] = FEAT_MTE_ASYNC_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_MTE_CANONICAL_TAGS)] = FEAT_MTE_CANONICAL_TAGS_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_MTE_NO_ADDRESS_TAGS)] = FEAT_MTE_NO_ADDRESS_TAGS_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_MTE_PERM)] = FEAT_MTE_PERM_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_MTE_STORE_ONLY)] = FEAT_MTE_STORE_ONLY_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_MTE_TAGGED_FAR)] = FEAT_MTE_TAGGED_FAR_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_PCSRv8p9)] = FEAT_PCSRv8p9_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_PFAR)] = FEAT_PFAR_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_PMUv3_EDGE)] = FEAT_PMUv3_EDGE_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_PMUv3_ICNTR)] = FEAT_PMUv3_ICNTR_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_PMUv3_SS)] = FEAT_PMUv3_SS_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_PMUv3p9)] = FEAT_PMUv3p9_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_PRFMSLC)] = FEAT_PRFMSLC_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_RASSAv2)] = FEAT_RASSAv2_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_RASv2)] = FEAT_RASv2_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_RPRFM)] = FEAT_RPRFM_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_S1PIE)] = FEAT_S1PIE_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_S1POE)] = FEAT_S1POE_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_S2PIE)] = FEAT_S2PIE_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_S2POE)] = FEAT_S2POE_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_SPECRES2)] = FEAT_SPECRES2_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_SPE_CRR)] = FEAT_SPE_CRR_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_SPE_FDS)] = FEAT_SPE_FDS_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_SPEv1p4)] = FEAT_SPEv1p4_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_SPMU)] = FEAT_SPMU_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_THE)] = FEAT_THE_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_DoPD)] = FEAT_DoPD_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_ETE)] = FEAT_ETE_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_SVE2)] = FEAT_SVE2_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_SVE_AES)] = FEAT_SVE_AES_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_SVE_BitPerm)] = FEAT_SVE_BitPerm_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_SVE_PMULL128)] = FEAT_SVE_PMULL128_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_SVE_SHA3)] = FEAT_SVE_SHA3_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_SVE_SM4)] = FEAT_SVE_SM4_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_TME)] = FEAT_TME_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_TRBE)] = FEAT_TRBE_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_ETEv1p1)] = FEAT_ETEv1p1_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_BRBE)] = FEAT_BRBE_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_ETEv1p2)] = FEAT_ETEv1p2_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_RME)] = FEAT_RME_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_SME)] = FEAT_SME_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_SME_F64F64)] = FEAT_SME_F64F64_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_SME_FA64)] = FEAT_SME_FA64_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_SME_I16I64)] = FEAT_SME_I16I64_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_BRBEv1p1)] = FEAT_BRBEv1p1_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_MEC)] = FEAT_MEC_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_SME2)] = FEAT_SME2_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_ABLE)] = FEAT_ABLE_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_CHK)] = FEAT_CHK_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_D128)] = FEAT_D128_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_EBEP)] = FEAT_EBEP_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_ETEv1p3)] = FEAT_ETEv1p3_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_GCS)] = FEAT_GCS_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_ITE)] = FEAT_ITE_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_LSE128)] = FEAT_LSE128_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_LVA3)] = FEAT_LVA3_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_SEBEP)] = FEAT_SEBEP_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_SME2p1)] = FEAT_SME2p1_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_SME_F16F16)] = FEAT_SME_F16F16_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_SVE2p1)] = FEAT_SVE2p1_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_SVE_B16B16)] = FEAT_SVE_B16B16_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_SYSINSTR128)] = FEAT_SYSINSTR128_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_SYSREG128)] = FEAT_SYSREG128_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_TRBE_EXT)] = FEAT_TRBE_EXT_IMPLEMENTED;
    FeatureImpl[num_of_Feature(FEAT_TRBE_MPAM)] = FEAT_TRBE_MPAM_IMPLEMENTED;
    return()
}

register VariantImplemented : vector(16, bool)

val InitVariantImplemented : unit -> unit

function InitVariantImplemented () = {
    VariantImplemented[num_of_ArchVersion(v8Ap0)] = v8Ap0_IMPLEMENTED;
    VariantImplemented[num_of_ArchVersion(v8Ap1)] = v8Ap1_IMPLEMENTED;
    VariantImplemented[num_of_ArchVersion(v8Ap2)] = v8Ap2_IMPLEMENTED;
    VariantImplemented[num_of_ArchVersion(v8Ap3)] = v8Ap3_IMPLEMENTED;
    VariantImplemented[num_of_ArchVersion(v8Ap4)] = v8Ap4_IMPLEMENTED;
    VariantImplemented[num_of_ArchVersion(v8Ap5)] = v8Ap5_IMPLEMENTED;
    VariantImplemented[num_of_ArchVersion(v8Ap6)] = v8Ap6_IMPLEMENTED;
    VariantImplemented[num_of_ArchVersion(v8Ap7)] = v8Ap7_IMPLEMENTED;
    VariantImplemented[num_of_ArchVersion(v8Ap8)] = v8Ap8_IMPLEMENTED;
    VariantImplemented[num_of_ArchVersion(v8Ap9)] = v8Ap9_IMPLEMENTED;
    VariantImplemented[num_of_ArchVersion(v9Ap0)] = v9Ap0_IMPLEMENTED;
    VariantImplemented[num_of_ArchVersion(v9Ap1)] = v9Ap1_IMPLEMENTED;
    VariantImplemented[num_of_ArchVersion(v9Ap2)] = v9Ap2_IMPLEMENTED;
    VariantImplemented[num_of_ArchVersion(v9Ap3)] = v9Ap3_IMPLEMENTED;
    VariantImplemented[num_of_ArchVersion(v9Ap4)] = v9Ap4_IMPLEMENTED;
    return()
}

val IsFeatureImplemented : Feature -> bool

function IsFeatureImplemented feat = {
    return(FeatureImpl[num_of_Feature(feat)])
}

register NUM_AMU_COUNTER_GROUPS : int = 2

register NUM_AMU_CG0_MONITORS : int = 4

register NUM_AMU_CG1_MONITORS : int = 16

register NUM_PMU_COUNTERS : int = 31

register NUM_BRBE_RECORDS : int = 64

register NUM_GIC_PREEMPTION_BITS : int = 5

register NUM_GIC_PRIORITY_BITS : int = 5

register NUM_GIC_LIST_REGS : int = 16

register NUM_BREAKPOINTS : int = negate(1)

register NUM_WATCHPOINTS : int = negate(1)

register __trcclaim_tags : bits(32)

register __cycle_count : int

register CP15SDISABLE : Signal

register CP15SDISABLE2 : Signal

register IsWFIsleep : bool

register IsWFEsleep : bool

register _ConfigReg : Configuration_Type

register _DormantCtlReg : DormantCtl_Type

register PMUEventAccumulator : vector(31, int)

register PMULastThresholdValue : vector(31, bool)

let CYCLE_COUNTER_ID : int(31) = 31

let INSTRUCTION_COUNTER_ID : int(32) = 32

register __clock_divider : int

let PMU_EVENT_SW_INCR : bits(16) = 0x0000

let PMU_EVENT_L1D_CACHE_REFILL : bits(16) = 0x0003

let PMU_EVENT_L1D_CACHE : bits(16) = 0x0004

let PMU_EVENT_INST_RETIRED : bits(16) = 0x0008

let PMU_EVENT_EXC_TAKEN : bits(16) = 0x0009

let PMU_EVENT_BR_MIS_PRED : bits(16) = 0x0010

let PMU_EVENT_CPU_CYCLES : bits(16) = 0x0011

let PMU_EVENT_INST_SPEC : bits(16) = 0x001B

let PMU_EVENT_CHAIN : bits(16) = 0x001E

let PMU_EVENT_BR_MIS_PRED_RETIRED : bits(16) = 0x0022

let PMU_EVENT_L1D_TLB : bits(16) = 0x0025

let PMU_EVENT_REMOTE_ACCESS : bits(16) = 0x0031

let PMU_EVENT_LL_CACHE : bits(16) = 0x0032

let PMU_EVENT_LL_CACHE_MISS : bits(16) = 0x0033

let PMU_EVENT_DTLB_WALK : bits(16) = 0x0034

let PMU_EVENT_L1D_CACHE_LMISS_RD : bits(16) = 0x0039

let PMU_EVENT_L2D_CACHE_RD : bits(16) = 0x0050

let PMU_EVENT_SAMPLE_POP : bits(16) = 0x4000

let PMU_EVENT_SAMPLE_FEED : bits(16) = 0x4001

let PMU_EVENT_SAMPLE_FILTRATE : bits(16) = 0x4002

let PMU_EVENT_SAMPLE_COLLISION : bits(16) = 0x4003

let PMU_EVENT_L2D_CACHE_LMISS_RD : bits(16) = 0x4009

let PMU_EVENT_LDST_ALIGN_LAT : bits(16) = 0x4020

let PMU_EVENT_SVE_PRED_EMPTY_SPEC : bits(16) = 0x8075

let PMU_EVENT_SVE_PRED_PARTIAL_SPEC : bits(16) = 0x8077

let PMU_EVENT_BRB_FILTRATE : bits(16) = 0x811F

let PMU_EVENT_SAMPLE_WRAP : bits(16) = 0x8123

let PMU_EVENT_SAMPLE_FEED_BR : bits(16) = 0x812A

let PMU_EVENT_SAMPLE_FEED_LD : bits(16) = 0x812B

let PMU_EVENT_SAMPLE_FEED_ST : bits(16) = 0x812C

let PMU_EVENT_SAMPLE_FEED_OP : bits(16) = 0x812D

let PMU_EVENT_SAMPLE_FEED_EVENT : bits(16) = 0x812E

let PMU_EVENT_SAMPLE_FEED_LAT : bits(16) = 0x812F

let PMU_EVENT_DSNP_HIT_RD : bits(16) = 0x8194

let PMU_EVENT_L1D_CACHE_HITM_RD : bits(16) = 0x8214

let PMU_EVENT_L2D_CACHE_HITM_RD : bits(16) = 0x8215

let PMU_EVENT_L3D_CACHE_HITM_RD : bits(16) = 0x8216

let PMU_EVENT_LL_CACHE_HITM_RD : bits(16) = 0x8217

let PMU_EVENT_L1D_LFB_HIT_RD : bits(16) = 0x8244

let PMU_EVENT_L2D_LFB_HIT_RD : bits(16) = 0x8245

let PMU_EVENT_L3D_LFB_HIT_RD : bits(16) = 0x8246

let PMU_EVENT_LL_LFB_HIT_RD : bits(16) = 0x8247

let M32_User : bits(5) = 0b10000

let M32_FIQ : bits(5) = 0b10001

let M32_IRQ : bits(5) = 0b10010

let M32_Svc : bits(5) = 0b10011

let M32_Monitor : bits(5) = 0b10110

let M32_Abort : bits(5) = 0b10111

let M32_Hyp : bits(5) = 0b11010

let M32_Undef : bits(5) = 0b11011

let M32_System : bits(5) = 0b11111

let EL3 : bits(2) = 0b11

let EL2 : bits(2) = 0b10

let EL1 : bits(2) = 0b01

let EL0 : bits(2) = 0b00

struct ProcState = {
  N : bits(1),
  Z : bits(1),
  C : bits(1),
  V : bits(1),
  D : bits(1),
  A : bits(1),
  I : bits(1),
  F : bits(1),
  EXLOCK : bits(1),
  PAN : bits(1),
  UAO : bits(1),
  DIT : bits(1),
  TCO : bits(1),
  PM : bits(1),
  PPEND : bits(1),
  BTYPE : bits(2),
  ZA : bits(1),
  SM : bits(1),
  ALLINT : bits(1),
  SS : bits(1),
  IL : bits(1),
  EL : bits(2),
  nRW : bits(1),
  SP : bits(1),
  Q : bits(1),
  GE : bits(4),
  SSBS : bits(1),
  IT : bits(8),
  J : bits(1),
  T : bits(1),
  E : bits(1),
  M : bits(5)
}

register PSTATE : ProcState

register ShouldAdvanceIT : bool

register ShouldAdvanceSS : bool

enum PrivilegeLevel = {PL3, PL2, PL1, PL0}

enum InstrSet = {InstrSet_A64, InstrSet_A32, InstrSet_T32}

enum DSBAlias = {DSBAlias_SSBB, DSBAlias_PSSBB, DSBAlias_DSB}

enum WFxType = {WFxType_WFE, WFxType_WFI, WFxType_WFET, WFxType_WFIT}

register EventRegister : bits(1)

enum ExceptionalOccurrenceTargetState = {
  AArch32_NonDebugState,
  AArch64_NonDebugState,
  DebugState
}

struct PhysMemRetStatus = {
  statuscode : Fault,
  extflag : bits(1),
  merrorstate : ErrorState,
  store64bstatus : bits(64)
}

val __UNKNOWN_PhysMemRetStatus : unit -> PhysMemRetStatus

function __UNKNOWN_PhysMemRetStatus () = undefined

struct S1AccessControls = {
  r : bits(1),
  w : bits(1),
  x : bits(1),
  gcs : bits(1),
  overlay : bool,
  or : bits(1),
  ow : bits(1),
  ox : bits(1),
  wxn : bits(1)
}

struct S2AccessControls = {
  r : bits(1),
  w : bits(1),
  x : bits(1),
  r_rcw : bits(1),
  w_rcw : bits(1),
  r_mmu : bits(1),
  w_mmu : bits(1),
  toplevel0 : bits(1),
  toplevel1 : bits(1),
  overlay : bool,
  or : bits(1),
  ow : bits(1),
  ox : bits(1),
  or_rcw : bits(1),
  ow_rcw : bits(1),
  or_mmu : bits(1),
  ow_mmu : bits(1)
}

enum PrefetchHint = {Prefetch_READ, Prefetch_WRITE, Prefetch_EXEC}

enum Unpredictable = {
  Unpredictable_VMSR,
  Unpredictable_WBOVERLAPLD,
  Unpredictable_WBOVERLAPST,
  Unpredictable_LDPOVERLAP,
  Unpredictable_BASEOVERLAP,
  Unpredictable_DATAOVERLAP,
  Unpredictable_DEVPAGE2,
  Unpredictable_INSTRDEVICE,
  Unpredictable_RESCPACR,
  Unpredictable_RESMAIR,
  Unpredictable_S1CTAGGED,
  Unpredictable_S2RESMEMATTR,
  Unpredictable_RESTEXCB,
  Unpredictable_RESPRRR,
  Unpredictable_RESDACR,
  Unpredictable_RESVTCRS,
  Unpredictable_RESTnSZ,
  Unpredictable_RESTCF,
  Unpredictable_DEVICETAGSTORE,
  Unpredictable_OORTnSZ,
  Unpredictable_LARGEIPA,
  Unpredictable_ESRCONDPASS,
  Unpredictable_ILZEROIT,
  Unpredictable_ILZEROT,
  Unpredictable_BPVECTORCATCHPRI,
  Unpredictable_VCMATCHHALF,
  Unpredictable_VCMATCHDAPA,
  Unpredictable_WPMASKANDBAS,
  Unpredictable_WPBASCONTIGUOUS,
  Unpredictable_RESWPMASK,
  Unpredictable_WPMASKEDBITS,
  Unpredictable_RESBPWPCTRL,
  Unpredictable_BPNOTIMPL,
  Unpredictable_RESBPTYPE,
  Unpredictable_RESMDSELR,
  Unpredictable_BPNOTCTXCMP,
  Unpredictable_BPMATCHHALF,
  Unpredictable_BPMISMATCHHALF,
  Unpredictable_BPLINKINGDISABLED,
  Unpredictable_RESBPMASK,
  Unpredictable_BPMASK,
  Unpredictable_BPMASKEDBITS,
  Unpredictable_BPLINKEDADDRMATCH,
  Unpredictable_RESTARTALIGNPC,
  Unpredictable_RESTARTZEROUPPERPC,
  Unpredictable_ZEROUPPER,
  Unpredictable_ERETZEROUPPERPC,
  Unpredictable_A32FORCEALIGNPC,
  Unpredictable_SMD,
  Unpredictable_NONFAULT,
  Unpredictable_SVEZEROUPPER,
  Unpredictable_SVELDNFDATA,
  Unpredictable_SVELDNFZERO,
  Unpredictable_CHECKSPNONEACTIVE,
  Unpredictable_SMEZEROUPPER,
  Unpredictable_NVNV1,
  Unpredictable_Shareability,
  Unpredictable_AFUPDATE,
  Unpredictable_DBUPDATE,
  Unpredictable_IESBinDebug,
  Unpredictable_BADPMSFCR,
  Unpredictable_ZEROBTYPE,
  Unpredictable_EL2TIMESTAMP,
  Unpredictable_EL1TIMESTAMP,
  Unpredictable_RESERVEDNSxB,
  Unpredictable_WFxTDEBUG,
  Unpredictable_LS64UNSUPPORTED,
  Unpredictable_MISALIGNEDATOMIC,
  Unpredictable_CLEARERRITEZERO,
  Unpredictable_ALUEXCEPTIONRETURN,
  Unpredictable_IGNORETRAPINDEBUG,
  Unpredictable_DBGxVR_RESS,
  Unpredictable_PMUEVENTCOUNTER,
  Unpredictable_PMSCR_PCT,
  Unpredictable_CounterReservedForEL2,
  Unpredictable_BRBFILTRATE,
  Unpredictable_MOPSOVERLAP31,
  Unpredictable_STOREONLYTAGCHECKEDCAS,
  Unpredictable_RESTC
}

enum Constraint = {
  Constraint_NONE,
  Constraint_UNKNOWN,
  Constraint_UNDEF,
  Constraint_UNDEFEL0,
  Constraint_NOP,
  Constraint_TRUE,
  Constraint_FALSE,
  Constraint_DISABLED,
  Constraint_UNCOND,
  Constraint_COND,
  Constraint_ADDITIONAL_DECODE,
  Constraint_WBSUPPRESS,
  Constraint_FAULT,
  Constraint_LIMITED_ATOMICITY,
  Constraint_NVNV1_00,
  Constraint_NVNV1_01,
  Constraint_NVNV1_11,
  Constraint_EL1TIMESTAMP,
  Constraint_EL2TIMESTAMP,
  Constraint_OSH,
  Constraint_ISH,
  Constraint_NSH,
  Constraint_NC,
  Constraint_WT,
  Constraint_WB,
  Constraint_FORCE,
  Constraint_FORCENOSLCHECK,
  Constraint_MAPTOALLOCATED,
  Constraint_PMSCR_PCT_VIRT
}

val __UNKNOWN_Constraint : unit -> Constraint

function __UNKNOWN_Constraint () = undefined

enum RestrictType = {
  RestrictType_DataValue,
  RestrictType_ControlFlow,
  RestrictType_CachePrefetch,
  RestrictType_Other
}

struct ExecutionCntxt = {
  is_vmid_valid : bool,
  all_vmid : bool,
  vmid : bits(16),
  is_asid_valid : bool,
  all_asid : bool,
  asid : bits(16),
  target_el : bits(2),
  security : SecurityState,
  restriction : RestrictType
}

enum FPExc = {
  FPExc_InvalidOp,
  FPExc_DivideByZero,
  FPExc_Overflow,
  FPExc_Underflow,
  FPExc_Inexact,
  FPExc_InputDenorm
}

enum FPRounding = {
  FPRounding_TIEEVEN,
  FPRounding_POSINF,
  FPRounding_NEGINF,
  FPRounding_ZERO,
  FPRounding_TIEAWAY,
  FPRounding_ODD
}

enum FPType = {
  FPType_Zero,
  FPType_Denormal,
  FPType_Nonzero,
  FPType_Infinity,
  FPType_QNaN,
  FPType_SNaN
}

/* register _R : vector(31, inc, bits(64)) */

register R0 : bits(64)
register R1 : bits(64)
register R2 : bits(64)
register R3 : bits(64)
register R4 : bits(64)
register R5 : bits(64)
register R6 : bits(64)
register R7 : bits(64)
register R8 : bits(64)
register R9 : bits(64)
register R10 : bits(64)
register R11 : bits(64)
register R12 : bits(64)
register R13 : bits(64)
register R14 : bits(64)
register R15 : bits(64)
register R16 : bits(64)
register R17 : bits(64)
register R18 : bits(64)
register R19 : bits(64)
register R20 : bits(64)
register R21 : bits(64)
register R22 : bits(64)
register R23 : bits(64)
register R24 : bits(64)
register R25 : bits(64)
register R26 : bits(64)
register R27 : bits(64)
register R28 : bits(64)
register R29 : bits(64)
register R30 : bits(64)

val read_gpr : forall 'n, 0 <= 'n <= 30. int('n) -> bits(64) effect {rreg}

function read_gpr(n) = {
    match n {
        0 => R0,
        1 => R1,
        2 => R2,
        3 => R3,
        4 => R4,
        5 => R5,
        6 => R6,
        7 => R7,
        8 => R8,
        9 => R9,
        10 => R10,
        11 => R11,
        12 => R12,
        13 => R13,
        14 => R14,
        15 => R15,
        16 => R16,
        17 => R17,
        18 => R18,
        19 => R19,
        20 => R20,
        21 => R21,
        22 => R22,
        23 => R23,
        24 => R24,
        25 => R25,
        26 => R26,
        27 => R27,
        28 => R28,
        29 => R29,
        _ => R30
    }
}

val write_gpr_bits : forall 'n 'lo 'hi, 0 <= 'n <= 30 & 0 <= 'lo <= 'hi <= 63.
    (int('n), int('hi), int('lo), bits(('hi - 'lo) + 1)) -> unit effect {wreg}

function write_gpr_bits(n, hi, lo, v) = {
    match n {
        0 => R0[hi .. lo] = v,
        1 => R1[hi .. lo] = v,
        2 => R2[hi .. lo] = v,
        3 => R3[hi .. lo] = v,
        4 => R4[hi .. lo] = v,
        5 => R5[hi .. lo] = v,
        6 => R6[hi .. lo] = v,
        7 => R7[hi .. lo] = v,
        8 => R8[hi .. lo] = v,
        9 => R9[hi .. lo] = v,
        10 => R10[hi .. lo] = v,
        11 => R11[hi .. lo] = v,
        12 => R12[hi .. lo] = v,
        13 => R13[hi .. lo] = v,
        14 => R14[hi .. lo] = v,
        15 => R15[hi .. lo] = v,
        16 => R16[hi .. lo] = v,
        17 => R17[hi .. lo] = v,
        18 => R18[hi .. lo] = v,
        19 => R19[hi .. lo] = v,
        20 => R20[hi .. lo] = v,
        21 => R21[hi .. lo] = v,
        22 => R22[hi .. lo] = v,
        23 => R23[hi .. lo] = v,
        24 => R24[hi .. lo] = v,
        25 => R25[hi .. lo] = v,
        26 => R26[hi .. lo] = v,
        27 => R27[hi .. lo] = v,
        28 => R28[hi .. lo] = v,
        29 => R29[hi .. lo] = v,
        _ => R30[hi .. lo] = v
    }
}

val write_gpr : forall 'n, 0 <= 'n <= 30. (int('n), bits(64)) -> unit effect {wreg}

function write_gpr(n, v) = {
    match n {
        0 => R0 = v,
        1 => R1 = v,
        2 => R2 = v,
        3 => R3 = v,
        4 => R4 = v,
        5 => R5 = v,
        6 => R6 = v,
        7 => R7 = v,
        8 => R8 = v,
        9 => R9 = v,
        10 => R10 = v,
        11 => R11 = v,
        12 => R12 = v,
        13 => R13 = v,
        14 => R14 = v,
        15 => R15 = v,
        16 => R16 = v,
        17 => R17 = v,
        18 => R18 = v,
        19 => R19 = v,
        20 => R20 = v,
        21 => R21 = v,
        22 => R22 = v,
        23 => R23 = v,
        24 => R24 = v,
        25 => R25 = v,
        26 => R26 = v,
        27 => R27 = v,
        28 => R28 = v,
        29 => R29 = v,
        _ => R30 = v
    }
}

$ifdef SYMBOLIC
let GPRs : vector(31, dec, register(bits(64))) = [
    ref R30,
    ref R29,
    ref R28,
    ref R27,
    ref R26,
    ref R25,
    ref R24,
    ref R23,
    ref R22,
    ref R21,
    ref R20,
    ref R19,
    ref R18,
    ref R17,
    ref R16,
    ref R15,
    ref R14,
    ref R13,
    ref R12,
    ref R11,
    ref R10,
    ref R9,
    ref R8,
    ref R7,
    ref R6,
    ref R5,
    ref R4,
    ref R3,
    ref R2,
    ref R1,
    ref R0
]

register __isla_vector_gpr: bool = false

val read_gpr_from_vector = monadic "read_register_from_vector" : forall 'n, 0 <= 'n <= 30. (int('n), vector(31, dec, register(bits(64)))) -> bits(64)

val get_R : forall 'n, 0 <= 'n <= 30. int('n) -> bits(64) effect {rreg}

function get_R(n) = if __isla_vector_gpr then read_gpr_from_vector(n, GPRs) else read_gpr(n)

val write_gpr_from_vector = monadic "write_register_from_vector" : forall 'n, 0 <= 'n <= 30. (int('n), bits(64), vector(31, dec, register(bits(64)))) -> unit

val set_R_bits : forall 'n 'lo 'hi, 0 <= 'n <= 30 & 0 <= 'lo <= 'hi <= 63.
    (int('n), int('hi), int('lo), bits(('hi - 'lo) + 1)) -> unit effect {wreg}

function set_R_bits(n, hi, lo, v) = {
    if __isla_vector_gpr then {
        let all_bits = read_gpr_from_vector(n, GPRs);
        write_gpr_from_vector(n, SetSlice((hi - lo) + 1, all_bits, lo, v), GPRs)
    } else {
        write_gpr_bits(n, hi, lo, v)
    }
}

val set_R : forall 'n, 0 <= 'n <= 30. (int('n), bits(64)) -> unit effect {wreg}

function set_R(n, v) = {
    if __isla_vector_gpr then write_gpr_from_vector(n, v, GPRs) else write_gpr(n, v)
}
$else
val get_R : forall 'n, 0 <= 'n <= 30. int('n) -> bits(64) effect {rreg}

function get_R(n) = read_gpr(n)

val set_R : forall 'n, 0 <= 'n <= 30. (int('n), bits(64)) -> unit effect {wreg}

function set_R(n, v) = write_gpr(n, v)

val set_R_bits : forall 'n 'lo 'hi, 0 <= 'n <= 30 & 0 <= 'lo <= 'hi <= 63.
    (int('n), int('hi), int('lo), bits(('hi - 'lo) + 1)) -> unit effect {wreg}

function set_R_bits(n, hi, lo, v) = {
    write_gpr_bits(n, hi, lo, v)
}
$endif

overload _R = {get_R, set_R, set_R_bits}

val register_ref : forall 'n, 0 <= 'n <= 30. int('n) -> register(bits(64))

function register_ref(n) = {
    match n {
        0 => ref R0,
        1 => ref R1,
        2 => ref R2,
        3 => ref R3,
        4 => ref R4,
        5 => ref R5,
        6 => ref R6,
        7 => ref R7,
        8 => ref R8,
        9 => ref R9,
        10 => ref R10,
        11 => ref R11,
        12 => ref R12,
        13 => ref R13,
        14 => ref R14,
        15 => ref R15,
        16 => ref R16,
        17 => ref R17,
        18 => ref R18,
        19 => ref R19,
        20 => ref R20,
        21 => ref R21,
        22 => ref R22,
        23 => ref R23,
        24 => ref R24,
        25 => ref R25,
        26 => ref R26,
        27 => ref R27,
        28 => ref R28,
        29 => ref R29,
        _ => ref R30
    }
}

val ignore_data_dependency : forall 'n, 0 <= 'n <= 31. int('n) -> unit

function ignore_data_dependency(n) = {
    if n <= 30 then {
       sail_ignore_write_to(register_ref(n))
    }
}

val ignore_dependency_edge : forall 'n 'm, 0 <= 'n <= 31 & 0 <= 'm <= 31. (int('n), int('m)) -> unit

function ignore_dependency_edge(n, m) = {
    if n <= 30 & m <= 30 then {
        sail_mark_register_pair(register_ref(n), register_ref(m), "ignore_edge")
    }
}

register _PC : bits(64)

enum BranchType = {
  BranchType_DIRCALL,
  BranchType_INDCALL,
  BranchType_ERET,
  BranchType_DBGEXIT,
  BranchType_RET,
  BranchType_DIR,
  BranchType_INDIR,
  BranchType_EXCEPTION,
  BranchType_TMFAIL,
  BranchType_RESET,
  BranchType_UNKNOWN
}

register PhysicalCount : bits(88)

enum InterruptID = {
  InterruptID_PMUIRQ,
  InterruptID_COMMIRQ,
  InterruptID_CTIIRQ,
  InterruptID_COMMRX,
  InterruptID_COMMTX,
  InterruptID_CNTP,
  InterruptID_CNTHP,
  InterruptID_CNTHPS,
  InterruptID_CNTPS,
  InterruptID_CNTV,
  InterruptID_CNTHV,
  InterruptID_CNTHVS,
  InterruptID_PMBIRQ
}

let DefaultPARTID : PARTIDtype = 0[15 .. 0]

let DefaultPMG : PMGtype = 0[7 .. 0]

let FINAL_LEVEL : int(3) = 3

register RC : vector(5, bits(64))

register InGuardedPage : bool

register BTypeNext : bits(2)

register BTypeCompatible : bool

enum SVECmp = {Cmp_EQ, Cmp_NE, Cmp_GE, Cmp_GT, Cmp_LT, Cmp_LE, Cmp_UN}

let MAX_VL : int(2048) = 2048

type MAX_VL : Int = 2048

let MAX_PL : int(256) = 256

type MAX_PL : Int = 256

let ZT0_LEN : int(512) = 512

register _Z : vector(32, bits(MAX_VL))

register _P : vector(16, bits(MAX_PL))

register _FFR : bits(MAX_PL)

enum SMEExceptionType = {
  SMEExceptionType_AccessTrap,
  SMEExceptionType_Streaming,
  SMEExceptionType_NotStreaming,
  SMEExceptionType_InactiveZA,
  SMEExceptionType_InaccessibleZT0
}

register _ZA : vector(256, bits(MAX_VL))

register _ZT0 : bits(512)

enum GCSInstruction = {
  GCSInstType_PRET,
  GCSInstType_POPM,
  GCSInstType_PRETAA,
  GCSInstType_PRETAB,
  GCSInstType_SS1,
  GCSInstType_SS2,
  GCSInstType_POPCX,
  GCSInstType_POPX
}

enum MOPSStage = {MOPSStage_Prologue, MOPSStage_Main, MOPSStage_Epilogue}

let DEFAULT_MECID : bits(16) = Zeros(16)

bitfield FPCR_Type : bits(64) =
  {
    AHP : 26..26,
    DN : 25..25,
    FZ : 24..24,
    RMode : 23..22,
    Stride : 21..20,
    FZ16 : 19..19,
    length : 18..16,
    IDE : 15..15,
    EBF : 13..13,
    IXE : 12..12,
    UFE : 11..11,
    OFE : 10..10,
    DZE : 9..9,
    IOE : 8..8,
    NEP : 2..2,
    AH : 1..1,
    FIZ : 0..0
  }

register FPCR : FPCR_Type

bitfield FPSR_Type : bits(64) =
  {
    N : 31..31,
    Z : 30..30,
    C : 29..29,
    V : 28..28,
    QC : 27..27,
    IDC : 7..7,
    IXC : 4..4,
    UFC : 3..3,
    OFC : 2..2,
    DZC : 1..1,
    IOC : 0..0
  }

register FPSR : FPSR_Type

bitfield ICC_PMR_EL1_Type : bits(64) = {Priority : 7..0}

register ICC_PMR_EL1 : ICC_PMR_EL1_Type

struct TMState = {
  depth : int,
  Rt : int,
  nPC : bits(64),
  X : vector(31, bits(64)),
  Z : vector(32, bits(MAX_VL)),
  P : vector(16, bits(MAX_PL)),
  FFR : bits(MAX_PL),
  SP : bits(64),
  FPCR : bits(64),
  FPSR : bits(64),
  ICC_PMR_EL1 : bits(64),
  GCSPR_ELx : bits(64),
  nzcv : bits(4),
  D : bits(1),
  A : bits(1),
  I : bits(1),
  F : bits(1)
}

register TSTATE : TMState

enum TMFailure = {
  TMFailure_CNCL,
  TMFailure_DBG,
  TMFailure_ERR,
  TMFailure_NEST,
  TMFailure_SIZE,
  TMFailure_MEM,
  TMFailure_TRIVIAL,
  TMFailure_IMP
}

enum PGSe = {PGS_4KB, PGS_16KB, PGS_64KB}

let GPT_NoAccess : bits(4) = 0b0000

let GPT_Table : bits(4) = 0b0011

let GPT_Block : bits(4) = 0b0001

let GPT_Contig : bits(4) = 0b0001

let GPT_Secure : bits(4) = 0b1000

let GPT_NonSecure : bits(4) = 0b1001

let GPT_Root : bits(4) = 0b1010

let GPT_Realm : bits(4) = 0b1011

let GPT_Any : bits(4) = 0b1111

let GPTRange_4KB : int(12) = 12

let GPTRange_16KB : int(14) = 14

let GPTRange_64KB : int(16) = 16

let GPTRange_2MB : int(21) = 21

let GPTRange_32MB : int(25) = 25

let GPTRange_512MB : int(29) = 29

let GPTRange_1GB : int(30) = 30

let GPTRange_16GB : int(34) = 34

let GPTRange_64GB : int(36) = 36

let GPTRange_512GB : int(39) = 39

struct GPTTable = {address : bits(56)}

val __UNKNOWN_GPTTable : unit -> GPTTable

function __UNKNOWN_GPTTable () = undefined

struct GPTEntry = {
  gpi : bits(4),
  size : int,
  contig_size : int,
  level : int,
  pa : bits(56)
}

val __UNKNOWN_GPTEntry : unit -> GPTEntry

function __UNKNOWN_GPTEntry () = undefined

let SPEMaxAddrs : int(32) = 32

let SPEMaxCounters : int(32) = 32

let SPEMaxRecordSize : int(64) = 64

enum TimeStamp = {
  TimeStamp_None,
  TimeStamp_CoreSight,
  TimeStamp_Physical,
  TimeStamp_OffsetPhysical,
  TimeStamp_Virtual
}

enum OpType = {
  OpType_Load,
  OpType_Store,
  OpType_LoadAtomic,
  OpType_Branch,
  OpType_Other
}

let SPEAddrPosPCVirtual : int(0) = 0

let SPEAddrPosBranchTarget : int(1) = 1

let SPEAddrPosDataVirtual : int(2) = 2

let SPEAddrPosDataPhysical : int(3) = 3

let SPEAddrPosPrevBranchTarget : int(4) = 4

let SPECounterPosTotalLatency : int(0) = 0

let SPECounterPosIssueLatency : int(1) = 1

let SPECounterPosTranslationLatency : int(2) = 2

register SPESampleInFlight : bool

register SPESampleContextEL1 : bits(32)

register SPESampleContextEL1Valid : bool

register SPESampleContextEL2 : bits(32)

register SPESampleContextEL2Valid : bool

register SPESampleInstIsNV2 : bool

register SPESamplePreviousBranchAddress : bits(64)

register SPESamplePreviousBranchAddressValid : bool

register SPESampleDataSource : bits(16)

register SPESampleDataSourceValid : bool

register SPESampleOpType : OpType

register SPESampleClass : bits(2)

register SPESampleSubclass : bits(8)

register SPESampleSubclassValid : bool

register SPESampleTimestamp : bits(64)

register SPESampleTimestampValid : bool

register SPESampleEvents : bits(64)

register __SPE_LFSR : bits(24)

register __SPE_LFSR_initialized : bool

register SPERecordSize : int

register __last_cycle_count : int

register __last_branch_valid : bool

enum CountOp = {CountOp_CLZ, CountOp_CLS, CountOp_CNT}

enum ExtendType = {
  ExtendType_SXTB,
  ExtendType_SXTH,
  ExtendType_SXTW,
  ExtendType_SXTX,
  ExtendType_UXTB,
  ExtendType_UXTH,
  ExtendType_UXTW,
  ExtendType_UXTX
}

enum FPMaxMinOp = {
  FPMaxMinOp_MAX,
  FPMaxMinOp_MIN,
  FPMaxMinOp_MAXNUM,
  FPMaxMinOp_MINNUM
}

enum FPUnaryOp = {FPUnaryOp_ABS, FPUnaryOp_MOV, FPUnaryOp_NEG, FPUnaryOp_SQRT}

enum FPConvOp = {
  FPConvOp_CVT_FtoI,
  FPConvOp_CVT_ItoF,
  FPConvOp_MOV_FtoI,
  FPConvOp_MOV_ItoF,
  FPConvOp_CVT_FtoI_JS
}

enum MoveWideOp = {MoveWideOp_N, MoveWideOp_Z, MoveWideOp_K}

enum ShiftType = {ShiftType_LSL, ShiftType_LSR, ShiftType_ASR, ShiftType_ROR}

enum LogicalOp = {LogicalOp_AND, LogicalOp_EOR, LogicalOp_ORR}

enum SystemHintOp = {
  SystemHintOp_NOP,
  SystemHintOp_YIELD,
  SystemHintOp_WFE,
  SystemHintOp_WFI,
  SystemHintOp_SEV,
  SystemHintOp_SEVL,
  SystemHintOp_DGH,
  SystemHintOp_ESB,
  SystemHintOp_PSB,
  SystemHintOp_TSB,
  SystemHintOp_BTI,
  SystemHintOp_WFET,
  SystemHintOp_WFIT,
  SystemHintOp_CLRBHB,
  SystemHintOp_GCSB,
  SystemHintOp_CHKFEAT,
  SystemHintOp_CSDB
}

enum PSTATEField = {
  PSTATEField_DAIFSet,
  PSTATEField_DAIFClr,
  PSTATEField_PAN,
  PSTATEField_UAO,
  PSTATEField_DIT,
  PSTATEField_SSBS,
  PSTATEField_TCO,
  PSTATEField_SVCRSM,
  PSTATEField_SVCRZA,
  PSTATEField_SVCRSMZA,
  PSTATEField_ALLINT,
  PSTATEField_PM,
  PSTATEField_SP
}

let MAX_ZERO_BLOCK_SIZE : int(2048) = 2048

enum VBitOp = {VBitOp_VBIF, VBitOp_VBIT, VBitOp_VBSL, VBitOp_VEOR}

enum CompareOp = {
  CompareOp_GT,
  CompareOp_GE,
  CompareOp_EQ,
  CompareOp_LE,
  CompareOp_LT
}

enum ImmediateOp = {
  ImmediateOp_MOVI,
  ImmediateOp_MVNI,
  ImmediateOp_ORR,
  ImmediateOp_BIC
}

enum ReduceOp = {
  ReduceOp_FMINNUM,
  ReduceOp_FMAXNUM,
  ReduceOp_FMIN,
  ReduceOp_FMAX,
  ReduceOp_FADD,
  ReduceOp_ADD
}

register DBGEN : Signal

register NIDEN : Signal

register SPIDEN : Signal

register SPNIDEN : Signal

register RLPIDEN : Signal

register RTPIDEN : Signal

enum CrossTriggerIn = {
  CrossTriggerIn_CrossHalt,
  CrossTriggerIn_PMUOverflow,
  CrossTriggerIn_RSVD2,
  CrossTriggerIn_RSVD3,
  CrossTriggerIn_TraceExtOut0,
  CrossTriggerIn_TraceExtOut1,
  CrossTriggerIn_TraceExtOut2,
  CrossTriggerIn_TraceExtOut3
}

let DebugHalt_Breakpoint : bits(6) = 0b000111

let DebugHalt_EDBGRQ : bits(6) = 0b010011

let DebugHalt_Step_Normal : bits(6) = 0b011011

let DebugHalt_Step_Exclusive : bits(6) = 0b011111

let DebugHalt_OSUnlockCatch : bits(6) = 0b100011

let DebugHalt_ResetCatch : bits(6) = 0b100111

let DebugHalt_Watchpoint : bits(6) = 0b101011

let DebugHalt_HaltInstruction : bits(6) = 0b101111

let DebugHalt_SoftwareAccess : bits(6) = 0b110011

let DebugHalt_ExceptionCatch : bits(6) = 0b110111

let DebugHalt_Step_NoSyndrome : bits(6) = 0b111011

struct TLBLine = {tlbrecord : TLBRecord, valid_name : bool}

val __UNKNOWN_TLBLine : unit -> TLBLine

function __UNKNOWN_TLBLine () = undefined

struct GPTTLBLine = {gpt_entry : GPTEntry, valid_name : bool}

val __UNKNOWN_GPTTLBLine : unit -> GPTTLBLine

function __UNKNOWN_GPTTLBLine () = undefined

let RCW64_PROTECTED_BIT : int(52) = 52

let RCW128_PROTECTED_BIT : int(114) = 114

register __InstructionStep : bool

struct InterruptReq = {
  take_SE : bool,
  take_vSE : bool,
  take_IRQ : bool,
  take_vIRQ : bool,
  take_FIQ : bool,
  take_vFIQ : bool,
  iesb_req : bool
}

register __CNTReadBase : bits(56)

register __CNTBaseN : bits(56)

register __CNTEL0BaseN : bits(56)

register __CNTCTLBase : bits(56)

register __RD_base : bits(56)

register __SGI_base : bits(56)

register __VLPI_base : bits(56)

register __ETEBase : bits(56)

enum __InstrEnc = {__A64, __A32, __T16, __T32}

register __ThisInstr : bits(32)

register __ThisInstrEnc : __InstrEnc

register __currentCond : bits(4)

register Branchtypetaken : BranchType

register __BranchTaken : bool

register __ExclusiveMonitorSet : bool

let lst_64bv : bits(2) = 0b01

let lst_64b : bits(2) = 0b10

let lst_64bv0 : bits(2) = 0b11

register __highest_el_aarch32 : bool

register __ICACHE_CCSIDR_RESET : vector(7, bits(64))

register __DCACHE_CCSIDR_RESET : vector(7, bits(64))

let CFG_ID_AA64PFR0_EL1_EL0 : bits(4) = 0b0010

let CFG_ID_AA64PFR0_EL1_EL1 : bits(4) = 0b0001

let CFG_ID_AA64PFR0_EL1_EL2 : bits(4) = 0b0001

let CFG_ID_AA64PFR0_EL1_EL3 : bits(4) = 0b0001

let CFG_PMCR_IDCODE : bits(8) = 0b00000000

let CFG_MPAM_none : bits(4) = 0b0000

let CFG_MPAM_v0p1 : bits(4) = 0b0000

let CFG_MPAM_v1p1 : bits(4) = 0b0001

let CFG_MPAM_frac_none : bits(4) = 0b0000

let CFG_MPAM_frac_v0p1 : bits(4) = 0b0001

let CFG_MPAM_frac_v1p1 : bits(4) = 0b0001

register sp_rel_access_pc : bits(64)

enum SRType = {SRType_LSL, SRType_LSR, SRType_ASR, SRType_ROR, SRType_RRX}

enum VCGEType = {VCGEType_signed, VCGEType_unsigned, VCGEType_fp}

enum VFPNegMul = {VFPNegMul_VNMLA, VFPNegMul_VNMLS, VFPNegMul_VNMUL}

enum VCGTtype = {VCGTtype_signed, VCGTtype_unsigned, VCGTtype_fp}

enum VBitOps = {VBitOps_VBIF, VBitOps_VBIT, VBitOps_VBSL}

register SP_mon : bits(32)

register LR_mon : bits(32)

register _Dclone : vector(32, bits(64))

let DebugException_Breakpoint : bits(4) = 0b0001

let DebugException_BKPT : bits(4) = 0b0011

let DebugException_VectorCatch : bits(4) = 0b0101

let DebugException_Watchpoint : bits(4) = 0b1010

bitfield HCR_EL2_Type : bits(64) =
  {
    TWEDEL : 63..60,
    TWEDEn : 59..59,
    TID5 : 58..58,
    DCT : 57..57,
    ATA : 56..56,
    TTLBOS : 55..55,
    TTLBIS : 54..54,
    EnSCXT : 53..53,
    TOCU : 52..52,
    AMVOFFEN : 51..51,
    TICAB : 50..50,
    TID4 : 49..49,
    GPF : 48..48,
    FIEN : 47..47,
    FWB : 46..46,
    NV2 : 45..45,
    AT : 44..44,
    NV1 : 43..43,
    NV : 42..42,
    API : 41..41,
    APK : 40..40,
    TME : 39..39,
    MIOCNCE : 38..38,
    TEA : 37..37,
    TERR : 36..36,
    TLOR : 35..35,
    E2H : 34..34,
    ID : 33..33,
    CD : 32..32,
    RW : 31..31,
    TRVM : 30..30,
    HCD : 29..29,
    TDZ : 28..28,
    TGE : 27..27,
    TVM : 26..26,
    TTLB : 25..25,
    TPU : 24..24,
    TPCP : 23..23,
    TPC : 23..23,
    TSW : 22..22,
    TACR : 21..21,
    TIDCP : 20..20,
    TSC : 19..19,
    TID3 : 18..18,
    TID2 : 17..17,
    TID1 : 16..16,
    TID0 : 15..15,
    TWE : 14..14,
    TWI : 13..13,
    DC : 12..12,
    BSU : 11..10,
    FB : 9..9,
    VSE : 8..8,
    VI : 7..7,
    VF : 6..6,
    AMO : 5..5,
    IMO : 4..4,
    FMO : 3..3,
    PTW : 2..2,
    SWIO : 1..1,
    VM : 0..0
  }

register HCR_EL2 : HCR_EL2_Type

val HaveAArch32EL : bits(2) -> bool

val HaveAArch64 : unit -> bool

function HaveAArch64 () = {
    return(((IsFeatureImplemented(FEAT_AA64EL0) | IsFeatureImplemented(FEAT_AA64EL1)) | IsFeatureImplemented(FEAT_AA64EL2)) | IsFeatureImplemented(FEAT_AA64EL3))
}

val HaveEL : bits(2) -> bool

val HaveSecureEL2Ext : unit -> bool

function HaveSecureEL2Ext () = {
    return(IsFeatureImplemented(FEAT_SEL2))
}

val HaveVirtHostExt : unit -> bool

function HaveVirtHostExt () = {
    return(IsFeatureImplemented(FEAT_VHE))
}

bitfield SCR_EL3_Type : bits(64) =
  {
    NSE : 62..62,
    FGTEn2 : 59..59,
    EnIDCP128 : 55..55,
    PFAREn : 53..53,
    TWERR : 52..52,
    TMEA : 51..51,
    MECEn : 49..49,
    GPF : 48..48,
    D128En : 47..47,
    AIEn : 46..46,
    PIEn : 45..45,
    SCTLR2En : 44..44,
    TCR2En : 43..43,
    RCWMASKEn : 42..42,
    EnTP2 : 41..41,
    TRNDR : 40..40,
    GCSEn : 39..39,
    HXEn : 38..38,
    ADEn : 37..37,
    EnAS0 : 36..36,
    AMVOFFEN : 35..35,
    TME : 34..34,
    TWEDEL : 33..30,
    TWEDEn : 29..29,
    ECVEn : 28..28,
    FGTEn : 27..27,
    ATA : 26..26,
    EnSCXT : 25..25,
    FIEN : 21..21,
    NMEA : 20..20,
    EASE : 19..19,
    EEL2 : 18..18,
    API : 17..17,
    APK : 16..16,
    TERR : 15..15,
    TLOR : 14..14,
    TWE : 13..13,
    TWI : 12..12,
    ST : 11..11,
    RW : 10..10,
    SIF : 9..9,
    HCE : 8..8,
    SMD : 7..7,
    EA : 3..3,
    FIQ : 2..2,
    IRQ : 1..1,
    NS : 0..0
  }

register SCR_EL3 : SCR_EL3_Type

val ELStateUsingAArch32K : forall ('secure : Bool).
  (bits(2), bool('secure)) -> (bool, bool)

function ELStateUsingAArch32K (el, secure) = {
    if not_bool(HaveAArch32EL(el)) then {
        return((true, false))
    } else if secure & el == EL2 then {
        return((true, false))
    } else if not_bool(HaveAArch64()) then {
        return((true, true))
    } else ();
    aarch32 : bool = __UNKNOWN_boolean();
    known : bool = true;
    let aarch32_below_el3 : bool = (HaveEL(EL3) & ((not_bool(secure) | not_bool(HaveSecureEL2Ext())) | SCR_EL3[EEL2] == 0b0)) & SCR_EL3[RW] == 0b0;
    let aarch32_at_el1 : bool = aarch32_below_el3 | ((HaveEL(EL2) & (not_bool(secure) | HaveSecureEL2Ext() & SCR_EL3[EEL2] == 0b1)) & not_bool(HaveVirtHostExt() & (HCR_EL2[E2H] @ HCR_EL2[TGE]) == 0b11)) & HCR_EL2[RW] == 0b0;
    if el == EL0 & not_bool(aarch32_at_el1) then {
        if PSTATE.EL == EL0 then {
            aarch32 = PSTATE.nRW == 0b1
        } else {
            known = false
        }
    } else {
        aarch32 = aarch32_below_el3 & el != EL3 | aarch32_at_el1 & (el == EL1 | el == EL0)
    };
    if not_bool(known) then {
        aarch32 = __UNKNOWN_boolean()
    };
    return((known, aarch32))
}

val ELStateUsingAArch32 : forall ('secure : Bool).
  (bits(2), bool('secure)) -> bool

function ELStateUsingAArch32 (el, secure) = {
    aarch32 : bool = undefined;
    known : bool = undefined;
    (known, aarch32) = ELStateUsingAArch32K(el, secure);
    assert(known);
    return(aarch32)
}

bitfield SCR_Type : bits(32) =
  {
    TERR : 15..15,
    TWE : 13..13,
    TWI : 12..12,
    SIF : 9..9,
    HCE : 8..8,
    SCD : 7..7,
    nET : 6..6,
    AW : 5..5,
    FW : 4..4,
    EA : 3..3,
    FIQ : 2..2,
    IRQ : 1..1,
    NS : 0..0
  }

register SCR : SCR_Type

val SCR_GEN_read : unit -> SCRType

function SCR_GEN_read () = {
    assert(HaveEL(EL3));
    r : bits(64) = undefined;
    if not_bool(HaveAArch64()) then {
        r = ZeroExtend(SCR.bits, 64)
    } else {
        r = SCR_EL3.bits
    };
    return(Mk_SCRType(r))
}

val HasArchVersion : ArchVersion -> bool

val HaveStatisticalProfilingv1p2 : unit -> bool

function HaveStatisticalProfilingv1p2 () = {
    return(IsFeatureImplemented(FEAT_SPEv1p2))
}

val HighestEL : unit -> bits(2)

function HighestEL () = {
    if HaveEL(EL3) then {
        return(EL3)
    } else if HaveEL(EL2) then {
        return(EL2)
    } else {
        return(EL1)
    }
}

register __apply_effective_shareability : bool = true

register __cpy_mops_option_a_supported : bool = true

register __cpyf_mops_option_a_supported : bool = true

register __empam_force_ns_RAO : bool = false

register __empam_force_ns_implemented : bool = false

register __empam_sdeflt_implemented : bool = false

register __empam_tidr_implemented : bool = false

register __feat_rpres : bool = true

register __has_sme_priority_control : bool = true

register __isb_is_branch : bool = true

register __mpam_frac : bits(4) = CFG_MPAM_frac_none

register __mpam_major : bits(4) = CFG_MPAM_none

register __mte_implemented : bits(4) = 0b0010

register __set_mops_option_a_supported : bool = true

register __setg_mops_option_a_supported : bool = true

register __sme_only : bool = false

val ELUsingAArch32 : bits(2) -> bool

val IsSecureBelowEL3 : unit -> bool

function ELUsingAArch32 el = {
    return(ELStateUsingAArch32(el, IsSecureBelowEL3()))
}

function IsSecureBelowEL3 () = {
    if HaveEL(EL3) then {
        return(SCR_GEN_read()[NS] == 0b0)
    } else if HaveEL(EL2) & (not_bool(HaveSecureEL2Ext()) | not_bool(HaveAArch64())) then {
        return(false)
    } else {
        return(__IMPDEF_boolean("Secure-only implementation"))
    }
}

val __get_FPCR : FPCR_Type -> FPCR_Type

function __get_FPCR value_name = {
    tmp : FPCR_Type = value_name;
    tmp : FPCR_Type = Mk_FPCR_Type(tmp.bits & not_vec(0xfffffffff80040f8));
    if not_bool(__IMPDEF_boolean("IMPLEMENTED_trapping of Invalid Operation floating-point exceptions")) then {
        tmp = Mk_FPCR_Type(tmp.bits & not_vec(ZeroExtend(0x100, 64)))
    };
    if not_bool(__IMPDEF_boolean("IMPLEMENTED_trapping of Divide by Zero floating-point exceptions")) then {
        tmp = Mk_FPCR_Type(tmp.bits & not_vec(ZeroExtend(0x200, 64)))
    };
    if not_bool(__IMPDEF_boolean("IMPLEMENTED_trapping of Overflow floating-point exceptions")) then {
        tmp = Mk_FPCR_Type(tmp.bits & not_vec(ZeroExtend(0x400, 64)))
    };
    if not_bool(__IMPDEF_boolean("IMPLEMENTED_trapping of Underflow floating-point exceptions")) then {
        tmp = Mk_FPCR_Type(tmp.bits & not_vec(ZeroExtend(0x800, 64)))
    };
    if not_bool(__IMPDEF_boolean("IMPLEMENTED_trapping of Inexact floating-point exceptions")) then {
        tmp = Mk_FPCR_Type(tmp.bits & not_vec(ZeroExtend(0x1000, 64)))
    };
    if not_bool(__IMPDEF_boolean("IMPLEMENTED_trapping of Input Denormal floating-point exceptions")) then {
        tmp = Mk_FPCR_Type(tmp.bits & not_vec(ZeroExtend(0x8000, 64)))
    };
    if __IMPDEF_boolean("IMPLEMENTED_FPSCR.LEN,STRIDE as RAZ") then {
        tmp = Mk_FPCR_Type(tmp.bits & not_vec(ZeroExtend(0x370000, 64)))
    };
    return(tmp)
}

val FPCR_read : unit -> FPCRType

function FPCR_read () = {
    let r : bits(64) = __get_FPCR(FPCR).bits;
    return(Mk_FPCRType(r))
}

bitfield FPSCR_Type : bits(32) =
  {
    N : 31..31,
    Z : 30..30,
    C : 29..29,
    V : 28..28,
    QC : 27..27,
    AHP : 26..26,
    DN : 25..25,
    FZ : 24..24,
    RMode : 23..22,
    Stride : 21..20,
    FZ16 : 19..19,
    length : 18..16,
    IDE : 15..15,
    IXE : 12..12,
    UFE : 11..11,
    OFE : 10..10,
    DZE : 9..9,
    IOE : 8..8,
    IDC : 7..7,
    IXC : 4..4,
    UFC : 3..3,
    OFC : 2..2,
    DZC : 1..1,
    IOC : 0..0
  }

register _FPSCR : FPSCR_Type

val __get_FPSCR : FPSCR_Type -> FPSCR_Type

function __get_FPSCR value_name = {
    tmp : FPSCR_Type = value_name;
    tmp : FPSCR_Type = Mk_FPSCR_Type(tmp.bits & not_vec(ZeroExtend(0x6060, 32)));
    if not_bool(__IMPDEF_boolean("IMPLEMENTED_trapping of Invalid Operation floating-point exceptions")) then {
        tmp = Mk_FPSCR_Type(tmp.bits & not_vec(ZeroExtend(0x100, 32)))
    };
    if not_bool(__IMPDEF_boolean("IMPLEMENTED_trapping of Divide by Zero floating-point exceptions")) then {
        tmp = Mk_FPSCR_Type(tmp.bits & not_vec(ZeroExtend(0x200, 32)))
    };
    if not_bool(__IMPDEF_boolean("IMPLEMENTED_trapping of Overflow floating-point exceptions")) then {
        tmp = Mk_FPSCR_Type(tmp.bits & not_vec(ZeroExtend(0x400, 32)))
    };
    if not_bool(__IMPDEF_boolean("IMPLEMENTED_trapping of Underflow floating-point exceptions")) then {
        tmp = Mk_FPSCR_Type(tmp.bits & not_vec(ZeroExtend(0x800, 32)))
    };
    if not_bool(__IMPDEF_boolean("IMPLEMENTED_trapping of Inexact floating-point exceptions")) then {
        tmp = Mk_FPSCR_Type(tmp.bits & not_vec(ZeroExtend(0x1000, 32)))
    };
    if not_bool(__IMPDEF_boolean("IMPLEMENTED_trapping of Input Denormal floating-point exceptions")) then {
        tmp = Mk_FPSCR_Type(tmp.bits & not_vec(ZeroExtend(0x8000, 32)))
    };
    if __IMPDEF_boolean("IMPLEMENTED_FPSCR.LEN,STRIDE as RAZ") then {
        tmp = Mk_FPSCR_Type(tmp.bits & not_vec(ZeroExtend(0x370000, 32)))
    };
    return(tmp)
}

val FPSCR_read : unit -> FPCRType

val FPSCR_read__1 : unit -> FPSCR_Type

function FPSCR_read__1 () = {
    r : FPSCR_Type = _FPSCR;
    r.bits[31 .. 27] = Slice(FPSR.bits, 27, 5);
    r.bits[7] = Bit(Slice(FPSR.bits, 7, 1));
    r.bits[4 .. 0] = Slice(FPSR.bits, 0, 5);
    r.bits[26 .. 15] = Slice(FPCR.bits, 15, 12);
    r.bits[12 .. 8] = Slice(FPCR.bits, 8, 5);
    return(r)
}

function FPSCR_read () = {
    let r : bits(64) = Zeros(32) @ __get_FPSCR(FPSCR_read__1()).bits;
    return(Mk_FPCRType(r))
}

register RVBAR : bits(32)

bitfield ERRnFR_ElemType : bits(64) =
  {
    CE : 54..53,
    DE : 52..52,
    UEO : 51..51,
    UER : 50..50,
    UEU : 49..49,
    UC : 48..48,
    FRX : 31..31,
    TS : 25..24,
    CI : 23..22,
    INJ : 21..20,
    CEO : 19..18,
    DUI : 17..16,
    RP : 15..15,
    CEC : 14..12,
    CFI : 11..10,
    UE : 9..8,
    FI : 7..6,
    UI : 5..4,
    ED : 1..0
  }

register ERRnFR : vector(4, ERRnFR_ElemType)

val SPMEVCNTR_EL0_read : forall 'n 's. (int('s), int('n)) -> bits(64)

val SPMEVCNTR_EL0_set : forall 'n 's. (int('s), int('n), bits(64)) -> unit

val SPMEVTYPER_EL0_read : forall 'n 's. (int('s), int('n)) -> bits(64)

val SPMEVTYPER_EL0_set : forall 'n 's. (int('s), int('n), bits(64)) -> unit

val SPMEVFILTR_EL0_read : forall 'n 's. (int('s), int('n)) -> bits(64)

val SPMEVFILTR_EL0_set : forall 'n 's. (int('s), int('n), bits(64)) -> unit

val SPMEVFILT2R_EL0_read : forall 'n 's. (int('s), int('n)) -> bits(64)

val SPMEVFILT2R_EL0_set : forall 'n 's. (int('s), int('n), bits(64)) -> unit

val SPMOVSCLR_EL0_read : forall 's. int('s) -> bits(64)

val SPMOVSCLR_EL0_set : forall 's. (int('s), bits(64)) -> unit

val SPMCFGR_EL1_read : forall 's. int('s) -> bits(64)

val SPMCGCR_EL1_read : forall 's. int('s) -> bits(64)

val SPMCNTENCLR_EL0_read : forall 's. int('s) -> bits(64)

val SPMCNTENCLR_EL0_set : forall 's. (int('s), bits(64)) -> unit

val SPMCNTENSET_EL0_read : forall 's. int('s) -> bits(64)

val SPMCNTENSET_EL0_set : forall 's. (int('s), bits(64)) -> unit

val SPMCR_EL0_read : forall 's. int('s) -> bits(64)

val SPMCR_EL0_set : forall 's. (int('s), bits(64)) -> unit

val SPMDEVAFF_EL1_read : forall 's. int('s) -> bits(64)

val SPMDEVARCH_EL1_read : forall 's. int('s) -> bits(64)

val SPMIIDR_EL1_read : forall 's. int('s) -> bits(64)

val SPMINTENCLR_EL1_read : forall 's. int('s) -> bits(64)

val SPMINTENCLR_EL1_set : forall 's. (int('s), bits(64)) -> unit

val SPMINTENSET_EL1_read : forall 's. int('s) -> bits(64)

val SPMINTENSET_EL1_set : forall 's. (int('s), bits(64)) -> unit

val SPMOVSSET_EL0_read : forall 's. int('s) -> bits(64)

val SPMOVSSET_EL0_set : forall 's. (int('s), bits(64)) -> unit

val SPMROOTCR_EL3_read : forall 's. int('s) -> bits(64)

val SPMROOTCR_EL3_set : forall 's. (int('s), bits(64)) -> unit

val SPMSCR_EL1_read : forall 's. int('s) -> bits(64)

val SPMSCR_EL1_set : forall 's. (int('s), bits(64)) -> unit

val getISR : unit -> bits(32)

val genRandomNum : forall ('isRNDRRS : Bool). bool('isRNDRRS) -> bits(64)

val getCacheID : forall ('data_cache : Bool) 'level.
  (int('level), bool('data_cache)) -> bits(64)

val CacheConfigRead : bits(4) -> bits(64)

val AArch64_SysRegRead : forall 'crm 'crn 'op0 'op1 'op2 't.
  (int('op0), int('op1), int('crn), int('crm), int('op2), int('t)) -> unit

val AArch64_SysRegWrite : forall 'crm 'crn 'op0 'op1 'op2 't.
  (int('op0), int('op1), int('crn), int('crm), int('op2), int('t)) -> unit

val AArch64_SysInstr : forall 'crm 'crn 'op0 'op1 'op2 't.
  (int('op0), int('op1), int('crn), int('crm), int('op2), int('t)) -> unit

val AArch64_SysInstrWithResult : forall 'crm 'crn 'op0 'op1 'op2 't.
  (int('op0), int('op1), int('crn), int('crm), int('op2), int('t)) -> unit

val AArch64_UnallocatedSysRegAccess : forall ('read : Bool) 't.
  (bits(2), bits(3), bits(4), bits(3), bits(4), bool('read), int('t)) -> unit

val AArch64_SysRegRead128 : forall 'crm 'crn 'op0 'op1 'op2 't 't2.
  (int('op0), int('op1), int('crn), int('crm), int('op2), int('t), int('t2)) -> unit

val AArch64_SysRegWrite128 : forall 'crm 'crn 'op0 'op1 'op2 't 't2.
  (int('op0), int('op1), int('crn), int('crm), int('op2), int('t), int('t2)) -> unit

val AArch64_SysInstr128 : forall 'crm 'crn 'op0 'op1 'op2 't 't2.
  (int('op0), int('op1), int('crn), int('crm), int('op2), int('t), int('t2)) -> unit

val AArch32_SysRegRead : forall 'cp_num.
  (int('cp_num), bits(32), bits(32)) -> unit

val AArch32_SysRegRead__1 : forall 'cp_num 't.
  (int('cp_num), bits(32), int('t)) -> unit

val AArch32_SysRegWriteM : forall 'cp_num.
  (int('cp_num), bits(32), bits(32)) -> unit

val AArch32_SysRegRead64 : forall 'cp_num 't 't2.
  (int('cp_num), bits(32), int('t), int('t2)) -> unit

val AArch32_SysRegWrite : forall 'cp_num 't.
  (int('cp_num), bits(32), int('t)) -> unit

val AArch32_SysRegWrite64 : forall 'cp_num 't 't2.
  (int('cp_num), bits(32), int('t), int('t2)) -> unit

val GetNreg : unit -> int

val AArch32_UnallocatedSysRegAccess : forall ('read : Bool) 't.
  (bits(4), bits(3), bits(4), bits(3), bits(4), bool('read), int('t)) -> unit

val AArch64_ImpDefSysRegRead : forall 't.
  (bits(2), bits(3), bits(4), bits(4), bits(3), int('t)) -> unit

val AArch64_ImpDefSysRegWrite : forall 't.
  (bits(2), bits(3), bits(4), bits(4), bits(3), int('t)) -> unit

val AArch64_ImpDefSysRegRead128 : forall 't 't2.
  (bits(2), bits(3), bits(4), bits(4), bits(3), int('t), int('t2)) -> unit

val AArch64_ImpDefSysRegWrite128 : forall 't 't2.
  (bits(2), bits(3), bits(4), bits(4), bits(3), int('t), int('t2)) -> unit

val AArch64_ImpDefSysInstr128 : forall 'el 't 't2.
  (int('el), bits(3), bits(4), bits(4), bits(3), int('t), int('t2)) -> unit

val VirtualIRQPending : unit -> bool

val VirtualFIQPending : unit -> bool

val IsPhysicalSErrorPending : unit -> bool

val ClearPendingPhysicalSError : unit -> unit

val FIQPending : unit -> (bool, bool)

val IRQPending : unit -> (bool, bool)

bitfield CTR_EL0_Type : bits(64) =
  {
    TminLine : 37..32,
    DIC : 29..29,
    IDC : 28..28,
    CWG : 27..24,
    ERG : 23..20,
    DminLine : 19..16,
    L1Ip : 15..14,
    IminLine : 3..0
  }

register CTR_EL0 : CTR_EL0_Type

register __block_bbm_implemented : int = UInt(0x2)

register __has_sve_extended_bf16 : int = 2

register __max_implemented_smeveclen : int = 512

register __max_implemented_sveveclen : int = 2048

register __supported_pa_size : int = 56

val getNumBreakpoints : unit -> int

val getNumCtxBreakpoints : unit -> int

val getNumWatchpoints : unit -> int

val GetNumEventCounters : unit -> int

function GetNumEventCounters () = {
    return(__IMPDEF_integer("Number of event counters"))
}

val ConstrainUnpredictableInteger : forall 'high 'low.
  (int('low), int('high), Unpredictable) -> (Constraint, int)

val SecureOnlyImplementation : unit -> bool

function SecureOnlyImplementation () = {
    return(__IMPDEF_boolean("Secure-only implementation"))
}

val IsSecureEL2Enabled : unit -> bool

function IsSecureEL2Enabled () = {
    if HaveEL(EL2) & HaveSecureEL2Ext() then {
        if HaveEL(EL3) then {
            if not_bool(ELUsingAArch32(EL3)) & SCR_EL3[EEL2] == 0b1 then {
                return(true)
            } else {
                return(false)
            }
        } else {
            return(SecureOnlyImplementation())
        }
    } else {
        return(false)
    }
}

val EL2Enabled : unit -> bool

function EL2Enabled () = {
    return(HaveEL(EL2) & ((not_bool(HaveEL(EL3)) | SCR_GEN_read()[NS] == 0b1) | IsSecureEL2Enabled()))
}

bitfield HDCR_Type : bits(32) =
  {
    HPMFZO : 29..29,
    MTPME : 28..28,
    TDCC : 27..27,
    HLP : 26..26,
    HCCD : 23..23,
    TTRF : 19..19,
    HPMD : 17..17,
    TDRA : 11..11,
    TDOSA : 10..10,
    TDA : 9..9,
    TDE : 8..8,
    HPME : 7..7,
    TPM : 6..6,
    TPMCR : 5..5,
    HPMN : 4..0
  }

bitfield MDCR_EL2_Type : bits(64) =
  {
    EBWE : 43..43,
    PMEE : 41..40,
    HPMFZS : 36..36,
    PMSSE : 31..30,
    HPMFZO : 29..29,
    MTPME : 28..28,
    TDCC : 27..27,
    HLP : 26..26,
    HCCD : 23..23,
    TTRF : 19..19,
    HPMD : 17..17,
    EnSPM : 15..15,
    TPMS : 14..14,
    E2PB : 13..12,
    TDRA : 11..11,
    TDOSA : 10..10,
    TDA : 9..9,
    TDE : 8..8,
    HPME : 7..7,
    TPM : 6..6,
    TPMCR : 5..5,
    HPMN : 4..0
  }

register MDCR_EL2 : MDCR_EL2_Type

register _HDCR : HDCR_Type

val HDCR_read : unit -> HDCR_Type

function HDCR_read () = {
    r : HDCR_Type = _HDCR;
    r.bits[31 .. 0] = Slice(MDCR_EL2.bits, 0, 32);
    return(r)
}

val HaveFeatHPMN0 : unit -> bool

function HaveFeatHPMN0 () = {
    return(IsFeatureImplemented(FEAT_HPMN0))
}

val AArch32_GetNumEventCountersAccessible : unit -> int

function AArch32_GetNumEventCountersAccessible () = {
    n : int = undefined;
    let 'total_counters = GetNumEventCounters();
    if (PSTATE.EL == EL1 | PSTATE.EL == EL0) & EL2Enabled() then {
        n = UInt(if not_bool(ELUsingAArch32(EL2)) then MDCR_EL2[HPMN] else
          HDCR_read()[HPMN]);
        if n > total_counters | not_bool(HaveFeatHPMN0()) & n == 0 then {
            let (_, __tup_1 : int) = ConstrainUnpredictableInteger(0, total_counters, Unpredictable_PMUEVENTCOUNTER);
            n = __tup_1
        };
        ()
    } else {
        n = total_counters
    };
    let 'n = n;
    return(n)
}

val AArch64_GetNumEventCountersAccessible : unit -> int

function AArch64_GetNumEventCountersAccessible () = {
    n : int = undefined;
    let 'total_counters = GetNumEventCounters();
    if (PSTATE.EL == EL1 | PSTATE.EL == EL0) & EL2Enabled() then {
        n = UInt(MDCR_EL2[HPMN]);
        if n > total_counters | not_bool(HaveFeatHPMN0()) & n == 0 then {
            let (_, __tup_1 : int) = ConstrainUnpredictableInteger(0, total_counters, Unpredictable_PMUEVENTCOUNTER);
            n = __tup_1
        };
        ()
    } else {
        n = total_counters
    };
    let 'n = n;
    return(n)
}

val HavePMUv3ICNTR : unit -> bool

function HavePMUv3ICNTR () = {
    return(IsFeatureImplemented(FEAT_PMUv3_ICNTR))
}

val HaveAArch32 : unit -> bool

val UsingAArch32 : unit -> bool

function UsingAArch32 () = {
    let aarch32 : bool = PSTATE.nRW == 0b1;
    if not_bool(HaveAArch32()) then {
        assert(not_bool(aarch32))
    };
    if not_bool(HaveAArch64()) then {
        assert(aarch32)
    };
    return(aarch32)
}

val PMUCounterMask : unit -> bits(64)

function PMUCounterMask () = {
    n : int = undefined;
    if UsingAArch32() then {
        n = AArch32_GetNumEventCountersAccessible()
    } else {
        n = AArch64_GetNumEventCountersAccessible()
    };
    let 'n = n;
    assert(constraint('n >= 0));
    assert(constraint(64 >= 'n));
    mask : bits(64) = ZeroExtend(Ones(n), 64);
    mask[CYCLE_COUNTER_ID] = Bit(0b1);
    if HaveAArch64() & HavePMUv3ICNTR() then {
        mask[INSTRUCTION_COUNTER_ID] = Bit(0b1)
    };
    return(mask)
}

val HavePMUv3 : unit -> bool

function HavePMUv3 () = {
    return(IsFeatureImplemented(FEAT_PMUv3))
}

val HaveRME : unit -> bool

function HaveRME () = {
    return(IsFeatureImplemented(FEAT_RME))
}

val HaveSecureState : unit -> bool

function HaveSecureState () = {
    if not_bool(HaveEL(EL3)) then {
        return(SecureOnlyImplementation())
    };
    if HaveRME() & not_bool(HaveSecureEL2Ext()) then {
        return(false)
    };
    return(true)
}

val EffectiveSCR_EL3_NS : unit -> bits(1)

function EffectiveSCR_EL3_NS () = {
    if not_bool(HaveSecureState()) then {
        return(0b1)
    } else if not_bool(HaveEL(EL3)) then {
        return(0b0)
    } else {
        return(SCR_EL3[NS])
    }
}

val Unreachable : unit -> unit

function Unreachable () = {
    assert(false)
}

val SecurityStateAtEL : bits(2) -> SecurityState

function SecurityStateAtEL EL = {
    effective_nse_ns : bits(2) = undefined;
    if HaveRME() then {
        if EL == EL3 then {
            return(SS_Root)
        };
        let effective_nse_ns : bits(2) = SCR_EL3[NSE] @ EffectiveSCR_EL3_NS();
        match effective_nse_ns {
          0b00 => {
              if HaveSecureEL2Ext() then {
                  return(SS_Secure)
              } else {
                  Unreachable()
              }
          },
          0b01 => {
              return(SS_NonSecure)
          },
          0b11 => {
              return(SS_Realm)
          },
          _ => {
              Unreachable()
          }
        }
    };
    if not_bool(HaveEL(EL3)) then {
        if SecureOnlyImplementation() then {
            return(SS_Secure)
        } else {
            return(SS_NonSecure)
        }
    } else if EL == EL3 then {
        return(SS_Secure)
    } else {
        assert(EL != EL2 | EL2Enabled());
        if not_bool(ELUsingAArch32(EL3)) then {
            return(if SCR_EL3[NS] == 0b1 then SS_NonSecure else SS_Secure)
        } else {
            return(if SCR[NS] == 0b1 then SS_NonSecure else SS_Secure)
        }
    }
}

val CurrentSecurityState : unit -> SecurityState

function CurrentSecurityState () = {
    return(SecurityStateAtEL(PSTATE.EL))
}

val ExternalInvasiveDebugEnabled : unit -> bool

function ExternalInvasiveDebugEnabled () = {
    return(DBGEN == Signal_High)
}

val HaveNoninvasiveDebugAuth : unit -> bool

function HaveNoninvasiveDebugAuth () = {
    return(not_bool(IsFeatureImplemented(FEAT_Debugv8p4)))
}

val ExternalNoninvasiveDebugEnabled : unit -> bool

function ExternalNoninvasiveDebugEnabled () = {
    return((not_bool(HaveNoninvasiveDebugAuth()) | ExternalInvasiveDebugEnabled()) | NIDEN == Signal_High)
}

val ExternalSecureInvasiveDebugEnabled : unit -> bool

function ExternalSecureInvasiveDebugEnabled () = {
    if not_bool(HaveEL(EL3)) & not_bool(SecureOnlyImplementation()) then {
        return(false)
    };
    return(ExternalInvasiveDebugEnabled() & SPIDEN == Signal_High)
}

val ExternalSecureNoninvasiveDebugEnabled : unit -> bool

function ExternalSecureNoninvasiveDebugEnabled () = {
    if not_bool(HaveEL(EL3)) & not_bool(SecureOnlyImplementation()) then {
        return(false)
    };
    if HaveNoninvasiveDebugAuth() then {
        return(ExternalNoninvasiveDebugEnabled() & (SPIDEN == Signal_High | SPNIDEN == Signal_High))
    } else {
        return(ExternalSecureInvasiveDebugEnabled())
    }
}

bitfield EDSCR_Type : bits(32) =
  {
    TFO : 31..31,
    RXfull : 30..30,
    TXfull : 29..29,
    ITO : 28..28,
    RXO : 27..27,
    TXU : 26..26,
    PipeAdv : 25..25,
    ITE : 24..24,
    INTdis : 23..22,
    TDA : 21..21,
    MA : 20..20,
    SC2 : 19..19,
    NS : 18..18,
    SDD : 16..16,
    NSE : 15..15,
    HDE : 14..14,
    RW : 13..10,
    EL : 9..8,
    A : 7..7,
    ERR : 6..6,
    STATUS : 5..0
  }

bitfield MDCCSR_EL0_Type : bits(64) = {RXfull : 30..30, TXfull : 29..29}

register MDCCSR_EL0 : MDCCSR_EL0_Type

register _EDSCR : EDSCR_Type

val EDSCR_read : unit -> EDSCR_Type

function EDSCR_read () = {
    r : EDSCR_Type = _EDSCR;
    r.bits[30 .. 29] = Slice(MDCCSR_EL0.bits, 29, 2);
    return(r)
}

val Halted : unit -> bool

function Halted () = {
    return(not_bool(EDSCR_read()[STATUS] == 0b000001 | EDSCR_read()[STATUS] == 0b000010))
}

val HaveHPMDExt : unit -> bool

function HaveHPMDExt () = {
    return(IsFeatureImplemented(FEAT_PMUv3p1))
}

val HaveNoSecurePMUDisableOverride : unit -> bool

function HaveNoSecurePMUDisableOverride () = {
    return(IsFeatureImplemented(FEAT_Debugv8p2))
}

val HavePMUv3p5 : unit -> bool

function HavePMUv3p5 () = {
    return(IsFeatureImplemented(FEAT_PMUv3p5))
}

val HavePMUv3p7 : unit -> bool

function HavePMUv3p7 () = {
    return(IsFeatureImplemented(FEAT_PMUv3p7))
}

bitfield PMCNTENCLR_EL0_Type : bits(64) =
  {
    F0 : 32..32,
    C : 31..31,
    P30 : 30..30,
    P29 : 29..29,
    P28 : 28..28,
    P27 : 27..27,
    P26 : 26..26,
    P25 : 25..25,
    P24 : 24..24,
    P23 : 23..23,
    P22 : 22..22,
    P21 : 21..21,
    P20 : 20..20,
    P19 : 19..19,
    P18 : 18..18,
    P17 : 17..17,
    P16 : 16..16,
    P15 : 15..15,
    P14 : 14..14,
    P13 : 13..13,
    P12 : 12..12,
    P11 : 11..11,
    P10 : 10..10,
    P9 : 9..9,
    P8 : 8..8,
    P7 : 7..7,
    P6 : 6..6,
    P5 : 5..5,
    P4 : 4..4,
    P3 : 3..3,
    P2 : 2..2,
    P1 : 1..1,
    P0 : 0..0
  }

register PMCNTENCLR_EL0 : PMCNTENCLR_EL0_Type

bitfield PMCNTENCLR_Type : bits(32) =
  {
    C : 31..31,
    P30 : 30..30,
    P29 : 29..29,
    P28 : 28..28,
    P27 : 27..27,
    P26 : 26..26,
    P25 : 25..25,
    P24 : 24..24,
    P23 : 23..23,
    P22 : 22..22,
    P21 : 21..21,
    P20 : 20..20,
    P19 : 19..19,
    P18 : 18..18,
    P17 : 17..17,
    P16 : 16..16,
    P15 : 15..15,
    P14 : 14..14,
    P13 : 13..13,
    P12 : 12..12,
    P11 : 11..11,
    P10 : 10..10,
    P9 : 9..9,
    P8 : 8..8,
    P7 : 7..7,
    P6 : 6..6,
    P5 : 5..5,
    P4 : 4..4,
    P3 : 3..3,
    P2 : 2..2,
    P1 : 1..1,
    P0 : 0..0
  }

register _PMCNTENCLR : PMCNTENCLR_Type

val PMCNTENCLR_read : unit -> PMCNTENCLR_Type

function PMCNTENCLR_read () = {
    r : PMCNTENCLR_Type = _PMCNTENCLR;
    r.bits[31 .. 0] = Slice(PMCNTENCLR_EL0.bits, 0, 32);
    return(r)
}

bitfield PMCR_EL0_Type : bits(64) =
  {
    FZS : 32..32,
    IMP : 31..24,
    IDCODE : 23..16,
    N : 15..11,
    FZO : 9..9,
    LP : 7..7,
    LC : 6..6,
    DP : 5..5,
    X : 4..4,
    D : 3..3,
    C : 2..2,
    P : 1..1,
    E : 0..0
  }

register PMCR_EL0 : PMCR_EL0_Type

bitfield PMCR_Type : bits(32) =
  {
    IMP : 31..24,
    IDCODE : 23..16,
    N : 15..11,
    FZO : 9..9,
    LP : 7..7,
    LC : 6..6,
    DP : 5..5,
    X : 4..4,
    D : 3..3,
    C : 2..2,
    P : 1..1,
    E : 0..0
  }

register _PMCR : PMCR_Type

val PMCR_read : unit -> PMCR_Type

function PMCR_read () = {
    r : PMCR_Type = _PMCR;
    r.bits[31 .. 0] = Slice(PMCR_EL0.bits, 0, 32);
    return(r)
}

bitfield PMINTENCLR_EL1_Type : bits(64) =
  {
    F0 : 32..32,
    C : 31..31,
    P30 : 30..30,
    P29 : 29..29,
    P28 : 28..28,
    P27 : 27..27,
    P26 : 26..26,
    P25 : 25..25,
    P24 : 24..24,
    P23 : 23..23,
    P22 : 22..22,
    P21 : 21..21,
    P20 : 20..20,
    P19 : 19..19,
    P18 : 18..18,
    P17 : 17..17,
    P16 : 16..16,
    P15 : 15..15,
    P14 : 14..14,
    P13 : 13..13,
    P12 : 12..12,
    P11 : 11..11,
    P10 : 10..10,
    P9 : 9..9,
    P8 : 8..8,
    P7 : 7..7,
    P6 : 6..6,
    P5 : 5..5,
    P4 : 4..4,
    P3 : 3..3,
    P2 : 2..2,
    P1 : 1..1,
    P0 : 0..0
  }

register PMINTENCLR_EL1 : PMINTENCLR_EL1_Type

bitfield PMINTENCLR_Type : bits(32) =
  {
    C : 31..31,
    P30 : 30..30,
    P29 : 29..29,
    P28 : 28..28,
    P27 : 27..27,
    P26 : 26..26,
    P25 : 25..25,
    P24 : 24..24,
    P23 : 23..23,
    P22 : 22..22,
    P21 : 21..21,
    P20 : 20..20,
    P19 : 19..19,
    P18 : 18..18,
    P17 : 17..17,
    P16 : 16..16,
    P15 : 15..15,
    P14 : 14..14,
    P13 : 13..13,
    P12 : 12..12,
    P11 : 11..11,
    P10 : 10..10,
    P9 : 9..9,
    P8 : 8..8,
    P7 : 7..7,
    P6 : 6..6,
    P5 : 5..5,
    P4 : 4..4,
    P3 : 3..3,
    P2 : 2..2,
    P1 : 1..1,
    P0 : 0..0
  }

register _PMINTENCLR : PMINTENCLR_Type

val PMINTENCLR_read : unit -> PMINTENCLR_Type

function PMINTENCLR_read () = {
    r : PMINTENCLR_Type = _PMINTENCLR;
    r.bits[31 .. 0] = Slice(PMINTENCLR_EL1.bits, 0, 32);
    return(r)
}

bitfield PMOVSCLR_EL0_Type : bits(64) =
  {
    F0 : 32..32,
    C : 31..31,
    P30 : 30..30,
    P29 : 29..29,
    P28 : 28..28,
    P27 : 27..27,
    P26 : 26..26,
    P25 : 25..25,
    P24 : 24..24,
    P23 : 23..23,
    P22 : 22..22,
    P21 : 21..21,
    P20 : 20..20,
    P19 : 19..19,
    P18 : 18..18,
    P17 : 17..17,
    P16 : 16..16,
    P15 : 15..15,
    P14 : 14..14,
    P13 : 13..13,
    P12 : 12..12,
    P11 : 11..11,
    P10 : 10..10,
    P9 : 9..9,
    P8 : 8..8,
    P7 : 7..7,
    P6 : 6..6,
    P5 : 5..5,
    P4 : 4..4,
    P3 : 3..3,
    P2 : 2..2,
    P1 : 1..1,
    P0 : 0..0
  }

register PMOVSCLR_EL0 : PMOVSCLR_EL0_Type

bitfield PMOVSR_Type : bits(32) =
  {
    C : 31..31,
    P30 : 30..30,
    P29 : 29..29,
    P28 : 28..28,
    P27 : 27..27,
    P26 : 26..26,
    P25 : 25..25,
    P24 : 24..24,
    P23 : 23..23,
    P22 : 22..22,
    P21 : 21..21,
    P20 : 20..20,
    P19 : 19..19,
    P18 : 18..18,
    P17 : 17..17,
    P16 : 16..16,
    P15 : 15..15,
    P14 : 14..14,
    P13 : 13..13,
    P12 : 12..12,
    P11 : 11..11,
    P10 : 10..10,
    P9 : 9..9,
    P8 : 8..8,
    P7 : 7..7,
    P6 : 6..6,
    P5 : 5..5,
    P4 : 4..4,
    P3 : 3..3,
    P2 : 2..2,
    P1 : 1..1,
    P0 : 0..0
  }

register _PMOVSR : PMOVSR_Type

val PMOVSR_read : unit -> PMOVSR_Type

function PMOVSR_read () = {
    r : PMOVSR_Type = _PMOVSR;
    r.bits[31 .. 0] = Slice(PMOVSCLR_EL0.bits, 0, 32);
    return(r)
}

val ConstrainUnpredictableBool : Unpredictable -> bool

val PMUCounterIsHyp : forall 'n. int('n) -> bool

function PMUCounterIsHyp n = {
    if n == INSTRUCTION_COUNTER_ID then {
        return(false)
    };
    if n == CYCLE_COUNTER_ID then {
        return(false)
    };
    resvd_for_el2 : bool = undefined;
    if HaveEL(EL2) then {
        let hpmn_bits : bits(5) = if HaveAArch64() then MDCR_EL2[HPMN] else
          HDCR_read()[HPMN];
        resvd_for_el2 = n >= UInt(hpmn_bits);
        if UInt(hpmn_bits) > GetNumEventCounters() | not_bool(HaveFeatHPMN0()) & IsZero(hpmn_bits) then {
            resvd_for_el2 = ConstrainUnpredictableBool(Unpredictable_CounterReservedForEL2)
        };
        ()
    } else {
        resvd_for_el2 = false
    };
    return(resvd_for_el2)
}

val PMUOverflowCondition : forall ('check_cnten : Bool) ('check_e : Bool) ('check_inten : Bool) ('exclude_cyc : Bool) ('exclude_sync : Bool) ('include_hi_name : Bool) ('include_lo_name : Bool).
  (bool('check_e), bool('check_cnten), bool('check_inten), bool('include_hi_name), bool('include_lo_name), bool('exclude_cyc), bool('exclude_sync)) -> bool

function PMUOverflowCondition (check_e, check_cnten, check_inten, include_hi_name, include_lo_name, exclude_cyc, exclude_sync) = {
    let 'counters = GetNumEventCounters();
    ovsf : bits(64) = undefined;
    if HaveAArch64() then {
        ovsf = PMOVSCLR_EL0.bits;
        ovsf[63 .. 33] = Zeros(31);
        if not_bool(HavePMUv3ICNTR()) then {
            ovsf[INSTRUCTION_COUNTER_ID] = Bit(0b0)
        };
        ()
    } else {
        ovsf = ZeroExtend(PMOVSR_read().bits, 64)
    };
    if counters < 31 then {
        assert(constraint((0 <= 'counters & 'counters <= 30)));
        ovsf[30 .. counters] = Zeros(31 - counters)
    };
    foreach (idx from 0 to (counters - 1) by 1 in inc) {
        E : bits(1) = undefined;
        let is_hyp : bool = PMUCounterIsHyp(idx);
        if HaveAArch64() then {
            E = if is_hyp then MDCR_EL2[HPME] else PMCR_EL0[E]
        } else {
            E = if is_hyp then HDCR_read()[HPME] else PMCR_read()[E]
        };
        if check_e then {
            assert(constraint((0 <= 'loop_idx & 'loop_idx < 64)));
            ovsf[idx] = Bit([ovsf[idx]] & E)
        };
        if not_bool(is_hyp) & not_bool(include_lo_name) | is_hyp & not_bool(include_hi_name) then {
            assert(constraint((0 <= 'loop_idx & 'loop_idx < 64)));
            ovsf[idx] = Bit(0b0)
        };
        ()
    };
    if exclude_cyc | not_bool(include_lo_name) then {
        ovsf[CYCLE_COUNTER_ID] = Bit(0b0)
    };
    if check_e then {
        ovsf[CYCLE_COUNTER_ID] = Bit([ovsf[CYCLE_COUNTER_ID]] & PMCR_EL0[E])
    };
    if HaveAArch64() & HavePMUv3ICNTR() then {
        if not_bool(include_lo_name) then {
            ovsf[INSTRUCTION_COUNTER_ID] = Bit(0b0)
        };
        if check_e then {
            ovsf[INSTRUCTION_COUNTER_ID] = Bit([ovsf[INSTRUCTION_COUNTER_ID]] & PMCR_EL0[E])
        };
        ()
    };
    if check_cnten then {
        let cnten : bits(64) = if HaveAArch64() then PMCNTENCLR_EL0.bits else
          ZeroExtend(PMCNTENCLR_read().bits, 64);
        ovsf = ovsf & cnten
    };
    if check_inten then {
        let inten : bits(64) = if HaveAArch64() then PMINTENCLR_EL1.bits else
          ZeroExtend(PMINTENCLR_read().bits, 64);
        ovsf = ovsf & inten
    };
    return(not_bool(IsZero(ovsf)))
}

val HiLoPMUOverflow : forall ('resvd_for_el2 : Bool).
  bool('resvd_for_el2) -> bool

function HiLoPMUOverflow resvd_for_el2 = {
    let check_cnten : bool = false;
    let check_e : bool = false;
    let check_inten : bool = false;
    let include_lo_name : bool = not_bool(resvd_for_el2);
    let include_hi_name : bool = resvd_for_el2;
    let exclude_cyc : bool = false;
    let exclude_sync : bool = false;
    let overflow : bool = PMUOverflowCondition(check_e, check_cnten, check_inten, include_hi_name, include_lo_name, exclude_cyc, exclude_sync);
    return(overflow)
}

bitfield MDCR_EL3_Type : bits(64) =
  {
    EPMSSAD : 46..45,
    EnPMSS : 44..44,
    EBWE : 43..43,
    EnPMS3 : 42..42,
    PMEE : 41..40,
    E3BREC : 38..38,
    E3BREW : 37..37,
    EnPMSN : 36..36,
    MPMX : 35..35,
    MCCD : 34..34,
    SBRBE : 33..32,
    PMSSE : 31..30,
    MTPME : 28..28,
    TDCC : 27..27,
    SCCD : 23..23,
    EPMAD : 21..21,
    EDAD : 20..20,
    TTRF : 19..19,
    STE : 18..18,
    SPME : 17..17,
    SDD : 16..16,
    SPD32 : 15..14,
    NSPB : 13..12,
    NSPBE : 11..11,
    TDOSA : 10..10,
    TDA : 9..9,
    EnPM2 : 7..7,
    TPM : 6..6,
    EDADE : 4..4,
    EPMADE : 2..2,
    RLTE : 0..0
  }

register MDCR_EL3 : MDCR_EL3_Type

bitfield PMCCFILTR_EL0_Type : bits(64) =
  {
    P : 31..31,
    U : 30..30,
    NSK : 29..29,
    NSU : 28..28,
    NSH : 27..27,
    M : 26..26,
    SH : 24..24,
    T : 23..23,
    RLK : 22..22,
    RLU : 21..21,
    RLH : 20..20
  }

register PMCCFILTR_EL0 : PMCCFILTR_EL0_Type

bitfield PMCCFILTR_Type : bits(32) =
  {
    P : 31..31,
    U : 30..30,
    NSK : 29..29,
    NSU : 28..28,
    NSH : 27..27,
    RLU : 21..21
  }

register _PMCCFILTR : PMCCFILTR_Type

val PMCCFILTR_read : unit -> PMCCFILTR_Type

function PMCCFILTR_read () = {
    r : PMCCFILTR_Type = _PMCCFILTR;
    r.bits[31 .. 0] = Slice(PMCCFILTR_EL0.bits, 0, 32);
    return(r)
}

bitfield PMCNTENSET_EL0_Type : bits(64) =
  {
    F0 : 32..32,
    C : 31..31,
    P30 : 30..30,
    P29 : 29..29,
    P28 : 28..28,
    P27 : 27..27,
    P26 : 26..26,
    P25 : 25..25,
    P24 : 24..24,
    P23 : 23..23,
    P22 : 22..22,
    P21 : 21..21,
    P20 : 20..20,
    P19 : 19..19,
    P18 : 18..18,
    P17 : 17..17,
    P16 : 16..16,
    P15 : 15..15,
    P14 : 14..14,
    P13 : 13..13,
    P12 : 12..12,
    P11 : 11..11,
    P10 : 10..10,
    P9 : 9..9,
    P8 : 8..8,
    P7 : 7..7,
    P6 : 6..6,
    P5 : 5..5,
    P4 : 4..4,
    P3 : 3..3,
    P2 : 2..2,
    P1 : 1..1,
    P0 : 0..0
  }

register PMCNTENSET_EL0 : PMCNTENSET_EL0_Type

bitfield PMCNTENSET_Type : bits(32) =
  {
    C : 31..31,
    P30 : 30..30,
    P29 : 29..29,
    P28 : 28..28,
    P27 : 27..27,
    P26 : 26..26,
    P25 : 25..25,
    P24 : 24..24,
    P23 : 23..23,
    P22 : 22..22,
    P21 : 21..21,
    P20 : 20..20,
    P19 : 19..19,
    P18 : 18..18,
    P17 : 17..17,
    P16 : 16..16,
    P15 : 15..15,
    P14 : 14..14,
    P13 : 13..13,
    P12 : 12..12,
    P11 : 11..11,
    P10 : 10..10,
    P9 : 9..9,
    P8 : 8..8,
    P7 : 7..7,
    P6 : 6..6,
    P5 : 5..5,
    P4 : 4..4,
    P3 : 3..3,
    P2 : 2..2,
    P1 : 1..1,
    P0 : 0..0
  }

register _PMCNTENSET : PMCNTENSET_Type

val PMCNTENSET_read : unit -> PMCNTENSET_Type

function PMCNTENSET_read () = {
    r : PMCNTENSET_Type = _PMCNTENSET;
    r.bits[31 .. 0] = Slice(PMCNTENSET_EL0.bits, 0, 32);
    return(r)
}

bitfield PMEVTYPER_EL0_Type : bits(64) =
  {
    TC : 63..61,
    TE : 60..60,
    SYNC : 58..58,
    TH : 43..32,
    P : 31..31,
    U : 30..30,
    NSK : 29..29,
    NSU : 28..28,
    NSH : 27..27,
    M : 26..26,
    MT : 25..25,
    SH : 24..24,
    T : 23..23,
    RLK : 22..22,
    RLU : 21..21,
    RLH : 20..20,
    evtCount : (15..10 @ 9..0)
  }

register PMEVTYPER_EL0 : vector(32, PMEVTYPER_EL0_Type)

bitfield PMEVTYPER_Type : bits(32) =
  {
    P : 31..31,
    U : 30..30,
    NSK : 29..29,
    NSU : 28..28,
    NSH : 27..27,
    MT : 25..25,
    RLU : 21..21,
    evtCount : (15..10 @ 9..0)
  }

register _PMEVTYPER : vector(31, PMEVTYPER_Type)

val PMEVTYPER_read : forall 'n, (0 <= 'n & 'n < 31). int('n) -> PMEVTYPER_Type

function PMEVTYPER_read n = {
    r : PMEVTYPER_Type = _PMEVTYPER[n];
    r.bits[31 .. 0] = Slice(PMEVTYPER_EL0[n].bits, 0, 32);
    return(r)
}

bitfield PMICFILTR_EL0_Type : bits(64) =
  {
    SYNC : 58..58,
    P : 31..31,
    U : 30..30,
    NSK : 29..29,
    NSU : 28..28,
    NSH : 27..27,
    M : 26..26,
    SH : 24..24,
    T : 23..23,
    RLK : 22..22,
    RLU : 21..21,
    RLH : 20..20,
    evtCount : 15..0
  }

register PMICFILTR_EL0 : PMICFILTR_EL0_Type

bitfield SDCR_Type : bits(32) =
  {
    MTPME : 28..28,
    TDCC : 27..27,
    SCCD : 23..23,
    EPMAD : 21..21,
    EDAD : 20..20,
    TTRF : 19..19,
    STE : 18..18,
    SPME : 17..17,
    SPD : 15..14
  }

register SDCR : SDCR_Type

bitfield SDER32_EL2_Type : bits(64) = {SUNIDEN : 1..1, SUIDEN : 0..0}

register SDER32_EL2 : SDER32_EL2_Type

bitfield SDER32_EL3_Type : bits(64) = {SUNIDEN : 1..1, SUIDEN : 0..0}

register _SDER32_EL3 : SDER32_EL3_Type

val SDER32_EL3_read : unit -> SDER32_EL3_Type

function SDER32_EL3_read () = {
    r : SDER32_EL3_Type = _SDER32_EL3;
    r.bits[63 .. 0] = Slice(SDER32_EL2.bits, 0, 64);
    return(r)
}

bitfield SDER_Type : bits(32) = {SUNIDEN : 1..1, SUIDEN : 0..0}

register _SDER : SDER_Type

val SDER_read : unit -> SDER_Type

function SDER_read () = {
    r : SDER_Type = _SDER;
    if HaveEL(EL3) then {
        r.bits[31 .. 0] = Slice(SDER32_EL3_read().bits, 0, 32)
    } else {
        r.bits[31 .. 0] = Slice(SDER32_EL2.bits, 0, 32)
    };
    return(r)
}

val CountPMUEvents : forall 'idx, (0 <= 'idx & 'idx <= 32). int('idx) -> bool

function CountPMUEvents idx = {
    dp : bits(1) = undefined;
    hccd : bits(1) = undefined;
    hpmd : bits(1) = undefined;
    sccd : bits(1) = undefined;
    let 'num_counters = GetNumEventCounters();
    assert((idx == CYCLE_COUNTER_ID | idx < num_counters) | idx == INSTRUCTION_COUNTER_ID & HavePMUv3ICNTR());
    enabled : bool = undefined;
    filtered : bool = undefined;
    E : bits(1) = undefined;
    let debug : bool = Halted();
    let resvd_for_el2 : bool = PMUCounterIsHyp(idx);
    ss : SecurityState = CurrentSecurityState();
    match idx {
      ? if ? == INSTRUCTION_COUNTER_ID => {
          assert(HaveAArch64());
          enabled = PMCR_EL0[E] == 0b1 & PMCNTENSET_EL0[F0] == 0b1
      },
      ? if ? == CYCLE_COUNTER_ID => {
          if HaveAArch64() then {
              enabled = PMCR_EL0[E] == 0b1 & PMCNTENSET_EL0[C] == 0b1
          } else {
              enabled = PMCR_read()[E] == 0b1 & PMCNTENSET_read()[C] == 0b1
          }
      },
      _ => {
          if resvd_for_el2 then {
              E = if HaveAArch64() then MDCR_EL2[HPME] else HDCR_read()[HPME]
          } else {
              E = if HaveAArch64() then PMCR_EL0[E] else PMCR_read()[E]
          };
          if HaveAArch64() then {
              enabled = E == 0b1 & [PMCNTENSET_EL0.bits[idx]] == 0b1
          } else {
              assert(constraint((0 <= 'idx & 'idx < 32)));
              enabled = E == 0b1 & [PMCNTENSET_read().bits[idx]] == 0b1
          }
      }
    };
    prohibited : bool = false;
    if HaveEL(EL3) & ss == SS_Secure then {
        if not_bool(ELUsingAArch32(EL3)) then {
            prohibited = (MDCR_EL3[SPME] == 0b0 & HavePMUv3p7()) & MDCR_EL3[MPMX] == 0b0
        } else {
            prohibited = SDCR[SPME] == 0b0
        };
        if prohibited & PSTATE.EL == EL0 then {
            if ELUsingAArch32(EL3) then {
                prohibited = SDER_read()[SUNIDEN] == 0b0
            } else if ELUsingAArch32(EL1) then {
                prohibited = SDER32_EL3_read()[SUNIDEN] == 0b0
            } else ()
        };
        ()
    };
    if ((not_bool(prohibited) & HavePMUv3p7()) & PSTATE.EL == EL3) & HaveAArch64() then {
        prohibited = MDCR_EL3[MPMX] == 0b1 & (MDCR_EL3[SPME] == 0b0 | not_bool(resvd_for_el2))
    };
    if ((not_bool(prohibited) & PSTATE.EL == EL2) & HaveHPMDExt()) & not_bool(resvd_for_el2) then {
        let hpmd : bits(1) = if HaveAArch64() then MDCR_EL2[HPMD] else
          HDCR_read()[HPMD];
        prohibited = hpmd == 0b1
    };
    if prohibited & not_bool(HaveNoSecurePMUDisableOverride()) then {
        prohibited = not_bool(ExternalSecureNoninvasiveDebugEnabled())
    };
    frozen : bool = false;
    if HavePMUv3p7() then {
        FZ : bits(1) = undefined;
        if resvd_for_el2 then {
            FZ = if HaveAArch64() then MDCR_EL2[HPMFZO] else HDCR_read()[HPMFZO]
        } else {
            FZ = if HaveAArch64() then PMCR_EL0[FZO] else PMCR_read()[FZO]
        };
        frozen = FZ == 0b1 & HiLoPMUOverflow(resvd_for_el2)
    };
    if (prohibited | frozen) & idx == CYCLE_COUNTER_ID then {
        let dp : bits(1) = if HaveAArch64() then PMCR_EL0[DP] else
          PMCR_read()[DP];
        enabled = enabled & dp == 0b0;
        prohibited = false;
        frozen = false
    };
    if HavePMUv3p5() & idx == CYCLE_COUNTER_ID then {
        if HaveEL(EL3) & ss == SS_Secure then {
            let sccd : bits(1) = if HaveAArch64() then MDCR_EL3[SCCD] else
              SDCR[SCCD];
            if sccd == 0b1 then {
                prohibited = true
            };
            ()
        };
        if PSTATE.EL == EL2 then {
            let hccd : bits(1) = if HaveAArch64() then MDCR_EL2[HCCD] else
              HDCR_read()[HCCD];
            if hccd == 0b1 then {
                prohibited = true
            };
            ()
        };
        ()
    };
    if HavePMUv3p7() & idx == CYCLE_COUNTER_ID then {
        if (PSTATE.EL == EL3 & HaveAArch64()) & MDCR_EL3[MCCD] == 0b1 then {
            prohibited = true
        };
        ()
    };
    filter : bits(32) = undefined;
    match idx {
      ? if ? == INSTRUCTION_COUNTER_ID => {
          filter = PMICFILTR_EL0.bits[31 .. 0]
      },
      ? if ? == CYCLE_COUNTER_ID => {
          filter = if HaveAArch64() then PMCCFILTR_EL0.bits[31 .. 0] else
            PMCCFILTR_read().bits
      },
      _ => {
          filter = if HaveAArch64() then {
              assert(constraint((0 <= 'idx & 'idx < 32)));
              PMEVTYPER_EL0[idx].bits[31 .. 0]
          } else {
              assert(constraint((0 <= 'idx & 'idx < 31)));
              PMEVTYPER_read(idx).bits
          }
      }
    };
    let filter = filter;
    let P : bits(1) = [filter[31]];
    let U : bits(1) = [filter[30]];
    let NSK : bits(1) = if HaveEL(EL3) then [filter[29]] else 0b0;
    let NSU : bits(1) = if HaveEL(EL3) then [filter[28]] else 0b0;
    let NSH : bits(1) = if HaveEL(EL2) then [filter[27]] else 0b0;
    let M : bits(1) = if HaveEL(EL3) & HaveAArch64() then [filter[26]] else 0b0;
    let SH : bits(1) = if HaveEL(EL3) & HaveSecureEL2Ext() then [filter[24]]
    else
      0b0;
    let RLK : bits(1) = if HaveRME() then [filter[22]] else 0b0;
    let RLU : bits(1) = if HaveRME() then [filter[21]] else 0b0;
    let RLH : bits(1) = if HaveRME() then [filter[20]] else 0b0;
    let ss : SecurityState = CurrentSecurityState();
    match PSTATE.EL {
      ? if ? == EL0 => {
          match ss {
            SS_NonSecure => {
                filtered = U != NSU
            },
            SS_Secure => {
                filtered = U == 0b1
            },
            SS_Realm => {
                filtered = U != RLU
            },
            _ => ()
          }
      },
      ? if ? == EL1 => {
          match ss {
            SS_NonSecure => {
                filtered = P != NSK
            },
            SS_Secure => {
                filtered = P == 0b1
            },
            SS_Realm => {
                filtered = P != RLK
            },
            _ => ()
          }
      },
      ? if ? == EL2 => {
          match ss {
            SS_NonSecure => {
                filtered = NSH == 0b0
            },
            SS_Secure => {
                filtered = NSH == SH
            },
            SS_Realm => {
                filtered = NSH == RLH
            },
            _ => ()
          }
      },
      ? if ? == EL3 => {
          if HaveAArch64() then {
              filtered = M != P
          } else {
              filtered = P == 0b1
          }
      },
      _ => ()
    };
    return((((not_bool(debug) & enabled) & not_bool(prohibited)) & not_bool(filtered)) & not_bool(frozen))
}

bitfield PMICNTR_EL0_Type : bits(64) = {ICNT : 63..0}

register PMICNTR_EL0 : PMICNTR_EL0_Type

bitfield PMOVSSET_EL0_Type : bits(64) =
  {
    F0 : 32..32,
    C : 31..31,
    P30 : 30..30,
    P29 : 29..29,
    P28 : 28..28,
    P27 : 27..27,
    P26 : 26..26,
    P25 : 25..25,
    P24 : 24..24,
    P23 : 23..23,
    P22 : 22..22,
    P21 : 21..21,
    P20 : 20..20,
    P19 : 19..19,
    P18 : 18..18,
    P17 : 17..17,
    P16 : 16..16,
    P15 : 15..15,
    P14 : 14..14,
    P13 : 13..13,
    P12 : 12..12,
    P11 : 11..11,
    P10 : 10..10,
    P9 : 9..9,
    P8 : 8..8,
    P7 : 7..7,
    P6 : 6..6,
    P5 : 5..5,
    P4 : 4..4,
    P3 : 3..3,
    P2 : 2..2,
    P1 : 1..1,
    P0 : 0..0
  }

register PMOVSSET_EL0 : PMOVSSET_EL0_Type

val IncrementInstructionCounter : forall 'increment_name.
  int('increment_name) -> unit

function IncrementInstructionCounter increment_name = {
    if CountPMUEvents(INSTRUCTION_COUNTER_ID) then {
        let 'old_value = UInt(PMICNTR_EL0.bits);
        let 'new_value = old_value + increment_name;
        PMICNTR_EL0 = Mk_PMICNTR_EL0_Type(new_value[63 .. 0]);
        if [old_value[64]] != [new_value[64]] then {
            PMOVSSET_EL0[F0] = 0b1;
            PMOVSCLR_EL0[F0] = 0b1
        };
        ()
    };
    ()
}

val HaveStatisticalProfilingv1p1 : unit -> bool

function HaveStatisticalProfilingv1p1 () = {
    return(IsFeatureImplemented(FEAT_SPEv1p1))
}

val HaveStatisticalProfilingv1p4 : unit -> bool

function HaveStatisticalProfilingv1p4 () = {
    return(IsFeatureImplemented(FEAT_SPEv1p4))
}

val SPEEvent : bits(16) -> unit

function SPEEvent pmuevent = {
    match pmuevent {
      ? if ? == PMU_EVENT_DSNP_HIT_RD => {
          if HaveStatisticalProfilingv1p4() then {
              SPESampleEvents[23] = Bit(0b1)
          };
          ()
      },
      ? if ? == PMU_EVENT_L1D_LFB_HIT_RD => {
          if HaveStatisticalProfilingv1p4() then {
              SPESampleEvents[22] = Bit(0b1)
          };
          ()
      },
      ? if ? == PMU_EVENT_L2D_LFB_HIT_RD => {
          if HaveStatisticalProfilingv1p4() then {
              SPESampleEvents[22] = Bit(0b1)
          };
          ()
      },
      ? if ? == PMU_EVENT_L3D_LFB_HIT_RD => {
          if HaveStatisticalProfilingv1p4() then {
              SPESampleEvents[22] = Bit(0b1)
          };
          ()
      },
      ? if ? == PMU_EVENT_LL_LFB_HIT_RD => {
          if HaveStatisticalProfilingv1p4() then {
              SPESampleEvents[22] = Bit(0b1)
          };
          ()
      },
      ? if ? == PMU_EVENT_L1D_CACHE_HITM_RD => {
          if HaveStatisticalProfilingv1p4() then {
              SPESampleEvents[21] = Bit(0b1)
          };
          ()
      },
      ? if ? == PMU_EVENT_L2D_CACHE_HITM_RD => {
          if HaveStatisticalProfilingv1p4() then {
              SPESampleEvents[21] = Bit(0b1)
          };
          ()
      },
      ? if ? == PMU_EVENT_L3D_CACHE_HITM_RD => {
          if HaveStatisticalProfilingv1p4() then {
              SPESampleEvents[21] = Bit(0b1)
          };
          ()
      },
      ? if ? == PMU_EVENT_LL_CACHE_HITM_RD => {
          if HaveStatisticalProfilingv1p4() then {
              SPESampleEvents[21] = Bit(0b1)
          };
          ()
      },
      ? if ? == PMU_EVENT_L2D_CACHE_LMISS_RD => {
          if HaveStatisticalProfilingv1p4() then {
              SPESampleEvents[20] = Bit(0b1)
          };
          ()
      },
      ? if ? == PMU_EVENT_L2D_CACHE_RD => {
          if HaveStatisticalProfilingv1p4() then {
              SPESampleEvents[19] = Bit(0b1)
          };
          ()
      },
      ? if ? == PMU_EVENT_SVE_PRED_EMPTY_SPEC => {
          if HaveStatisticalProfilingv1p1() then {
              SPESampleEvents[18] = Bit(0b1)
          };
          ()
      },
      ? if ? == PMU_EVENT_SVE_PRED_PARTIAL_SPEC => {
          if HaveStatisticalProfilingv1p1() then {
              SPESampleEvents[17] = Bit(0b1)
          };
          ()
      },
      ? if ? == PMU_EVENT_LDST_ALIGN_LAT => {
          if HaveStatisticalProfilingv1p1() then {
              SPESampleEvents[11] = Bit(0b1)
          };
          ()
      },
      ? if ? == PMU_EVENT_REMOTE_ACCESS => {
          SPESampleEvents[10] = Bit(0b1)
      },
      ? if ? == PMU_EVENT_LL_CACHE_MISS => {
          SPESampleEvents[9] = Bit(0b1)
      },
      ? if ? == PMU_EVENT_LL_CACHE => {
          SPESampleEvents[8] = Bit(0b1)
      },
      ? if ? == PMU_EVENT_BR_MIS_PRED => {
          SPESampleEvents[7] = Bit(0b1)
      },
      ? if ? == PMU_EVENT_BR_MIS_PRED_RETIRED => {
          SPESampleEvents[7] = Bit(0b1)
      },
      ? if ? == PMU_EVENT_DTLB_WALK => {
          SPESampleEvents[5] = Bit(0b1)
      },
      ? if ? == PMU_EVENT_L1D_TLB => {
          SPESampleEvents[4] = Bit(0b1)
      },
      ? if ? == PMU_EVENT_L1D_CACHE_REFILL => {
          if not_bool(HaveStatisticalProfilingv1p4()) then {
              SPESampleEvents[3] = Bit(0b1)
          };
          ()
      },
      ? if ? == PMU_EVENT_L1D_CACHE_LMISS_RD => {
          if HaveStatisticalProfilingv1p4() then {
              SPESampleEvents[3] = Bit(0b1)
          };
          ()
      },
      ? if ? == PMU_EVENT_L1D_CACHE => {
          SPESampleEvents[2] = Bit(0b1)
      },
      ? if ? == PMU_EVENT_INST_RETIRED => {
          SPESampleEvents[1] = Bit(0b1)
      },
      ? if ? == PMU_EVENT_EXC_TAKEN => {
          SPESampleEvents[0] = Bit(0b1)
      },
      _ => {
          return()
      }
    };
    return()
}

val PMUEvent : bits(16) -> unit

val PMUEvent__1 : forall 'increment_name.
  (bits(16), int('increment_name)) -> unit

val PMUEvent__2 : forall 'idx 'increment_name.
  (bits(16), int('increment_name), int('idx)) -> unit

function PMUEvent pmuevent = {
    PMUEvent__1(pmuevent, 1)
}

function PMUEvent__1 (pmuevent, increment_name) = {
    if SPESampleInFlight then {
        SPEEvent(pmuevent)
    };
    if PMCR_EL0[E] == 0b0 & MDCR_EL2[HPME] == 0b0 then {
        return()
    };
    let 'counters = GetNumEventCounters();
    if counters != 0 then {
        foreach (idx from 0 to (counters - 1) by 1 in inc) {
            PMUEvent__2(pmuevent, increment_name, idx)
        }
    };
    if (HaveAArch64() & HavePMUv3ICNTR()) & pmuevent == PMU_EVENT_INST_RETIRED then {
        IncrementInstructionCounter(increment_name)
    };
    ()
}

function PMUEvent__2 (pmuevent, increment_name, idx) = {
    if not_bool(HavePMUv3()) then {
        return()
    };
    if UsingAArch32() then {
        assert(constraint((0 <= 'idx & 'idx < 31)));
        if PMEVTYPER_read(idx)[evtCount] == pmuevent then {
            PMUEventAccumulator[idx] = PMUEventAccumulator[idx] + increment_name
        };
        ()
    } else {
        assert(constraint((0 <= 'idx & 'idx < 32)));
        if PMEVTYPER_EL0[idx][evtCount] == pmuevent then {
            assert(constraint((0 <= 'idx & 'idx < 31)));
            PMUEventAccumulator[idx] = PMUEventAccumulator[idx] + increment_name
        };
        ()
    }
}

val HasElapsed64Cycles : unit -> bool

function HasElapsed64Cycles () = {
    if __clock_divider == 63 then {
        __clock_divider = 0;
        return(true)
    } else {
        __clock_divider = __clock_divider + 1;
        return(false)
    }
}

val ConstrainUnpredictableBits : forall 'width, 'width >= 0.
  (Unpredictable, int('width)) -> (Constraint, bits('width))

val HavePMUv3EDGE : unit -> bool

function HavePMUv3EDGE () = {
    return(IsFeatureImplemented(FEAT_PMUv3_EDGE))
}

val HavePMUv3TH : unit -> bool

function HavePMUv3TH () = {
    return(IsFeatureImplemented(FEAT_PMUv3_TH))
}

val PMUCountValue : forall 'Vb 'n, (0 <= 'n & 'n < 31).
  (int('n), int('Vb)) -> int

function PMUCountValue (n, Vb) = {
    Vp : bool = undefined;
    tc : bits(2) = undefined;
    if not_bool(HavePMUv3TH()) | not_bool(HaveAArch64()) then {
        return(Vb)
    };
    let 'T = UInt(PMEVTYPER_EL0[n][TH]);
    Vc : bool = undefined;
    match PMEVTYPER_EL0[n][TC][2 .. 1] {
      0b00 => {
          Vc = Vb != T
      },
      0b01 => {
          Vc = Vb == T
      },
      0b10 => {
          Vc = Vb >= T
      },
      0b11 => {
          Vc = Vb < T
      },
      _ => ()
    };
    Vt : int = undefined;
    if [PMEVTYPER_EL0[n][TC][0]] == 0b0 then {
        Vt = if Vc then Vb else 0
    } else {
        Vt = if Vc then 1 else 0
    };
    let 'Vt = Vt;
    v : int = undefined;
    if HavePMUv3EDGE() & PMEVTYPER_EL0[n][TE] == 0b1 then {
        assert(constraint((0 <= 'n & 'n < 31)));
        let Vp : bool = PMULastThresholdValue[n];
        tc : bits(2) = PMEVTYPER_EL0[n][TC][1 .. 0];
        if tc == 0b00 then {
            c : Constraint = undefined;
            (c, tc) = ConstrainUnpredictableBits(Unpredictable_RESTC, 2);
            if c == Constraint_DISABLED then {
                tc = 0b00
            };
            ()
        };
        match tc {
          0b00 => {
              v = Vt
          },
          0b10 => {
              v = if Vp != Vc then 1 else 0
          },
          [_, bitone] => {
              v = if not_bool(Vp) & Vc then 1 else 0
          }
        }
    } else {
        v = Vt
    };
    let 'v = v;
    PMULastThresholdValue[n] = Vc;
    return(v)
}

bitfield BRBCR_EL1_Type : bits(64) =
  {
    EXCEPTION : 23..23,
    ERTN : 22..22,
    FZPSS : 9..9,
    FZP : 8..8,
    TS : 6..5,
    MPRED : 4..4,
    CC : 3..3,
    E1BRE : 1..1,
    E0BRE : 0..0
  }

register BRBCR_EL1 : BRBCR_EL1_Type

bitfield BRBCR_EL2_Type : bits(64) =
  {
    EXCEPTION : 23..23,
    ERTN : 22..22,
    FZPSS : 9..9,
    FZP : 8..8,
    TS : 6..5,
    MPRED : 4..4,
    CC : 3..3,
    E2BRE : 1..1,
    E0HBRE : 0..0
  }

register BRBCR_EL2 : BRBCR_EL2_Type

val HaveECVExt : unit -> bool

function HaveECVExt () = {
    return(IsFeatureImplemented(FEAT_ECV))
}

val BRBETimeStamp : unit -> TimeStamp

function BRBETimeStamp () = {
    TS_el2 : bits(2) = undefined;
    if HaveEL(EL2) then {
        TS_el2 : bits(2) = BRBCR_EL2[TS];
        if not_bool(HaveECVExt()) & TS_el2 == 0b10 then {
            let (_, __tup_1 : bits(2)) = ConstrainUnpredictableBits(Unpredictable_EL2TIMESTAMP, 2);
            TS_el2 = __tup_1
        };
        match TS_el2 {
          0b00 => (),
          0b01 => {
              return(TimeStamp_Virtual)
          },
          0b10 => {
              assert(HaveECVExt());
              return(TimeStamp_OffsetPhysical)
          },
          0b11 => {
              return(TimeStamp_Physical)
          }
        }
    };
    let TS_el2 = TS_el2;
    TS_el1 : bits(2) = BRBCR_EL1[TS];
    if TS_el1 == 0b00 | not_bool(HaveECVExt()) & TS_el1 == 0b10 then {
        let (_, __tup_1 : bits(2)) = ConstrainUnpredictableBits(Unpredictable_EL1TIMESTAMP, 2);
        TS_el1 = __tup_1
    };
    match TS_el1 {
      0b01 => {
          return(TimeStamp_Virtual)
      },
      0b10 => {
          return(TimeStamp_OffsetPhysical)
      },
      0b11 => {
          return(TimeStamp_Physical)
      },
      _ => {
          Unreachable();
          return(undefined : TimeStamp)
      }
    }
}

bitfield BRBFCR_EL1_Type : bits(64) =
  {
    BANK : 29..28,
    CONDDIR : 22..22,
    DIRCALL : 21..21,
    INDCALL : 20..20,
    RTN : 19..19,
    INDIRECT : 18..18,
    DIRECT : 17..17,
    EnI : 16..16,
    PAUSED : 7..7,
    LASTFAILED : 6..6
  }

register BRBFCR_EL1 : BRBFCR_EL1_Type

bitfield BRBTS_EL1_Type : bits(64) = {TS : 63..0}

register BRBTS_EL1 : BRBTS_EL1_Type

type CNTPOFF_EL2_Type = bits(64)

register CNTPOFF_EL2 : CNTPOFF_EL2_Type

type CNTVOFF_EL2_Type = bits(64)

register CNTVOFF_EL2 : CNTVOFF_EL2_Type

val PhysicalCountInt : unit -> bits(64)

function PhysicalCountInt () = {
    return(PhysicalCount[87 .. 24])
}

bitfield CNTHCTL_EL2_Type : bits(64) =
  {
    CNTPMASK : 19..19,
    CNTVMASK : 18..18,
    EVNTIS : 17..17,
    EL1NVVCT : 16..16,
    EL1NVPCT : 15..15,
    EL1TVCT : 14..14,
    EL1TVT : 13..13,
    ECV : 12..12,
    EL1PTEN : 11..11,
    EL0PTEN : 9..9,
    EL0VTEN : 8..8,
    EVNTI : 7..4,
    EVNTDIR : 3..3,
    EVNTEN : 2..2,
    EL1PCEN : 1..1,
    EL0VCTEN : 1..1,
    EL0PCTEN : 0..0
  }

register CNTHCTL_EL2 : CNTHCTL_EL2_Type

val EffectiveSCR_EL3_RW : unit -> bits(1)

function EffectiveSCR_EL3_RW () = {
    if not_bool(HaveAArch64()) then {
        return(0b0)
    };
    if not_bool(HaveAArch32EL(EL2)) & not_bool(HaveAArch32EL(EL1)) then {
        return(0b1)
    };
    if HaveAArch32EL(EL1) then {
        if not_bool(HaveAArch32EL(EL2)) & SCR_EL3[NS] == 0b1 then {
            return(0b1)
        };
        if (HaveSecureEL2Ext() & SCR_EL3[EEL2] == 0b1) & SCR_EL3[NS] == 0b0 then {
            return(0b1)
        };
        ()
    };
    return(SCR_EL3[RW])
}

val PhysicalOffsetIsValid : unit -> bool

function PhysicalOffsetIsValid () = {
    if not_bool(HaveAArch64()) then {
        return(false)
    } else if not_bool(HaveEL(EL2)) | not_bool(HaveECVExt()) then {
        return(false)
    } else if (HaveEL(EL3) & SCR_EL3[NS] == 0b1) & EffectiveSCR_EL3_RW() == 0b0 then {
        return(false)
    } else if HaveEL(EL3) & SCR_EL3[ECVEn] == 0b0 then {
        return(false)
    } else if CNTHCTL_EL2[ECV] == 0b0 then {
        return(false)
    } else {
        return(true)
    }
}

register CFG_RVBAR : bits(64) = ZeroExtend(0x0, 64)

register __impdef_TG0 : bits(2) = 0b00

register __impdef_TG1 : bits(2) = 0b10

register __mpam_has_hcr : bool = true

register __mpam_partid_max : bits(16) = Zeros(16)

register __mpam_pmg_max : bits(8) = Zeros(8)

register __mpam_vpmr_max : bits(3) = Zeros(3)

val __IMPDEF_bits : forall 'N, 'N >= 0. (int('N), string) -> bits('N)

val GetTimestamp : TimeStamp -> bits(64)

function GetTimestamp timeStampType = {
    match timeStampType {
      TimeStamp_Physical => {
          return(PhysicalCountInt())
      },
      TimeStamp_Virtual => {
          return(PhysicalCountInt() - CNTVOFF_EL2)
      },
      TimeStamp_OffsetPhysical => {
          let physoff : bits(64) = if PhysicalOffsetIsValid() then CNTPOFF_EL2
          else
            Zeros(64);
          return(PhysicalCountInt() - physoff)
      },
      TimeStamp_None => {
          return(Zeros(64))
      },
      TimeStamp_CoreSight => {
          return(__IMPDEF_bits(64, "CoreSight timestamp"))
      },
      _ => {
          Unreachable();
          return(undefined : bits(64))
      }
    }
}

val BRBEFreeze : unit -> unit

function BRBEFreeze () = {
    BRBFCR_EL1[PAUSED] = 0b1;
    BRBTS_EL1 = Mk_BRBTS_EL1_Type(GetTimestamp(BRBETimeStamp()))
}

val CTI_SetEventLevel : (CrossTriggerIn, Signal) -> unit

bitfield EDECR_Type : bits(32) =
  {PME : 4..4, SS : 2..2, RCE : 1..1, OSUCE : 0..0}

register EDECR : EDECR_Type

val CTI_SignalEvent : CrossTriggerIn -> unit

type DLR_EL0_Type = bits(64)

register DLR_EL0 : DLR_EL0_Type

type DLR_Type = bits(32)

register _DLR : DLR_Type

val DLR_write : DLR_Type -> unit

function DLR_write value_name = {
    let r : DLR_Type = value_name;
    DLR_EL0[31 .. 0] = Slice(r, 0, 32);
    _DLR = r;
    return()
}

bitfield DSPSR_EL0_Type : bits(64) =
  {
    EXLOCK : 34..34,
    PPEND : 33..33,
    PM : 32..32,
    N : 31..31,
    Z : 30..30,
    C : 29..29,
    V : 28..28,
    Q : 27..27,
    TCO : 25..25,
    DIT : 24..24,
    UAO : 23..23,
    PAN : 22..22,
    SS : 21..21,
    IL : 20..20,
    GE : 19..16,
    ALLINT : 13..13,
    BTYPE : 11..10,
    IT : (15..10 @ 26..25),
    D : 9..9,
    E : 9..9,
    A : 8..8,
    I : 7..7,
    F : 6..6,
    T : 5..5
  }

register DSPSR_EL0 : DSPSR_EL0_Type

bitfield DSPSR_Type : bits(32) =
  {
    N : 31..31,
    Z : 30..30,
    C : 29..29,
    V : 28..28,
    Q : 27..27,
    DIT : 24..24,
    SSBS : 23..23,
    PAN : 22..22,
    SS : 21..21,
    IL : 20..20,
    GE : 19..16,
    IT : (15..10 @ 26..25),
    E : 9..9,
    A : 8..8,
    I : 7..7,
    F : 6..6,
    T : 5..5,
    M : 4..0
  }

register _DSPSR : DSPSR_Type

val DSPSR_write : DSPSR_Type -> unit

function DSPSR_write value_name = {
    let r : DSPSR_Type = value_name;
    DSPSR_EL0.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _DSPSR = r;
    return()
}

bitfield DSPSR2_Type : bits(32) = {PPEND : 1..1}

register _DSPSR2 : DSPSR2_Type

val DSPSR2_write : DSPSR2_Type -> unit

function DSPSR2_write value_name = {
    let r : DSPSR2_Type = value_name;
    DSPSR_EL0.bits[63 .. 32] = Slice(r.bits, 0, 32);
    _DSPSR2 = r;
    return()
}

val EDSCR_write : EDSCR_Type -> unit

function EDSCR_write value_name = {
    let r : EDSCR_Type = value_name;
    MDCCSR_EL0.bits[30 .. 29] = Slice(r.bits, 29, 2);
    _EDSCR = r;
    return()
}

val ExternalRealmInvasiveDebugEnabled : unit -> bool

function ExternalRealmInvasiveDebugEnabled () = {
    if not_bool(HaveRME()) then {
        return(false)
    };
    return(ExternalInvasiveDebugEnabled() & RLPIDEN == Signal_High)
}

val ExternalRootInvasiveDebugEnabled : unit -> bool

function ExternalRootInvasiveDebugEnabled () = {
    if not_bool(HaveRME()) then {
        return(false)
    };
    return(((ExternalInvasiveDebugEnabled() & (not_bool(HaveSecureEL2Ext()) | ExternalSecureInvasiveDebugEnabled())) & ExternalRealmInvasiveDebugEnabled()) & RTPIDEN == Signal_High)
}

val HaveBRBEv1p1 : unit -> bool

function HaveBRBEv1p1 () = {
    return(IsFeatureImplemented(FEAT_BRBEv1p1))
}

val BranchRecordAllowed : bits(2) -> bool

function BranchRecordAllowed el = {
    if ELUsingAArch32(el) then {
        return(false)
    };
    if BRBFCR_EL1[PAUSED] == 0b1 then {
        return(false)
    };
    if el == EL3 & HaveBRBEv1p1() then {
        return(MDCR_EL3[E3BREC] != MDCR_EL3[E3BREW])
    };
    if HaveEL(EL3) & (MDCR_EL3[SBRBE] == 0b00 | CurrentSecurityState() == SS_Secure & MDCR_EL3[SBRBE] == 0b01) then {
        return(false)
    };
    match el {
      ? if ? == EL3 => {
          return(false)
      },
      ? if ? == EL2 => {
          return(BRBCR_EL2[E2BRE] == 0b1)
      },
      ? if ? == EL1 => {
          return(BRBCR_EL1[E1BRE] == 0b1)
      },
      ? if ? == EL0 => {
          if EL2Enabled() & HCR_EL2[TGE] == 0b1 then {
              return(BRBCR_EL2[E0HBRE] == 0b1)
          } else {
              return(BRBCR_EL1[E0BRE] == 0b1)
          }
      },
      _ => {
          return(undefined : bool)
      }
    }
}

val ELIsInHost : bits(2) -> bool

function ELIsInHost el = {
    if not_bool(HaveVirtHostExt()) | ELUsingAArch32(EL2) then {
        return(false)
    };
    match el {
      ? if ? == EL3 => {
          return(false)
      },
      ? if ? == EL2 => {
          return(EL2Enabled() & HCR_EL2[E2H] == 0b1)
      },
      ? if ? == EL1 => {
          return(false)
      },
      ? if ? == EL0 => {
          return(EL2Enabled() & (HCR_EL2[E2H] @ HCR_EL2[TGE]) == 0b11)
      },
      _ => {
          Unreachable();
          return(undefined : bool)
      }
    }
}

val HavePACExt : unit -> bool

function HavePACExt () = {
    return(IsFeatureImplemented(FEAT_PAuth))
}

val S1TranslationRegime : bits(2) -> bits(2)

val S1TranslationRegime__1 : unit -> bits(2)

function S1TranslationRegime el = {
    if el != EL0 then {
        return(el)
    } else if (HaveEL(EL3) & ELUsingAArch32(EL3)) & SCR[NS] == 0b0 then {
        return(EL3)
    } else if HaveVirtHostExt() & ELIsInHost(el) then {
        return(EL2)
    } else {
        return(EL1)
    }
}

function S1TranslationRegime__1 () = {
    return(S1TranslationRegime(PSTATE.EL))
}

bitfield TCR_EL1_Type : bits(64) =
  {
    MTX1 : 61..61,
    MTX0 : 60..60,
    DS : 59..59,
    TCMA1 : 58..58,
    TCMA0 : 57..57,
    E0PD1 : 56..56,
    E0PD0 : 55..55,
    NFD1 : 54..54,
    NFD0 : 53..53,
    TBID1 : 52..52,
    TBID0 : 51..51,
    HWU162 : 50..50,
    HWU161 : 49..49,
    HWU160 : 48..48,
    HWU159 : 47..47,
    HWU062 : 46..46,
    HWU061 : 45..45,
    HWU060 : 44..44,
    HWU059 : 43..43,
    HPD1 : 42..42,
    HPD0 : 41..41,
    HD : 40..40,
    HA : 39..39,
    TBI1 : 38..38,
    TBI0 : 37..37,
    AS : 36..36,
    IPS : 34..32,
    TG1 : 31..30,
    SH1 : 29..28,
    ORGN1 : 27..26,
    IRGN1 : 25..24,
    EPD1 : 23..23,
    A1 : 22..22,
    T1SZ : 21..16,
    TG0 : 15..14,
    SH0 : 13..12,
    ORGN0 : 11..10,
    IRGN0 : 9..8,
    EPD0 : 7..7,
    T0SZ : 5..0
  }

register TCR_EL1 : TCR_EL1_Type

bitfield TCR_EL2_Type : bits(64) =
  {
    MTX1 : 61..61,
    MTX0 : 60..60,
    TCMA1 : 58..58,
    TCMA0 : 57..57,
    E0PD1 : 56..56,
    E0PD0 : 55..55,
    NFD1 : 54..54,
    NFD0 : 53..53,
    TBID1 : 52..52,
    TBID0 : 51..51,
    HWU162 : 50..50,
    HWU161 : 49..49,
    HWU160 : 48..48,
    HWU159 : 47..47,
    HWU062 : 46..46,
    HWU061 : 45..45,
    HWU060 : 44..44,
    HWU059 : 43..43,
    HPD1 : 42..42,
    HPD0 : 41..41,
    TBI1 : 38..38,
    TBI0 : 37..37,
    AS : 36..36,
    MTX : 33..33,
    IPS : 34..32,
    TG1 : 31..30,
    TCMA : 30..30,
    TBID : 29..29,
    SH1 : 29..28,
    HWU62 : 28..28,
    HWU61 : 27..27,
    ORGN1 : 27..26,
    HWU60 : 26..26,
    HWU59 : 25..25,
    IRGN1 : 25..24,
    HPD : 24..24,
    EPD1 : 23..23,
    A1 : 22..22,
    TBI : 20..20,
    T1SZ : 21..16,
    PS : 18..16,
    TG0 : 15..14,
    SH0 : 13..12,
    ORGN0 : 11..10,
    IRGN0 : 9..8,
    EPD0 : 7..7,
    T0SZ : 5..0
  }

register TCR_EL2 : TCR_EL2_Type

bitfield TCR_EL3_Type : bits(64) =
  {
    DisCH0 : 43..43,
    HAFT : 42..42,
    PTTWI : 41..41,
    D128 : 38..38,
    AIE : 37..37,
    POE : 36..36,
    PIE : 35..35,
    PnCH : 34..34,
    MTX : 33..33,
    DS : 32..32,
    TCMA : 30..30,
    TBID : 29..29,
    HWU62 : 28..28,
    HWU61 : 27..27,
    HWU60 : 26..26,
    HWU59 : 25..25,
    HPD : 24..24,
    HD : 22..22,
    HA : 21..21,
    TBI : 20..20,
    PS : 18..16,
    TG0 : 15..14,
    SH0 : 13..12,
    ORGN0 : 11..10,
    IRGN0 : 9..8,
    T0SZ : 5..0
  }

register TCR_EL3 : TCR_EL3_Type

val EffectiveTBI : forall ('IsInstr : Bool).
  (bits(64), bool('IsInstr), bits(2)) -> bits(1)

function EffectiveTBI (address, IsInstr, el) = {
    tbi : bits(1) = undefined;
    tbid : bits(1) = undefined;
    assert(HaveEL(el));
    let regime : bits(2) = S1TranslationRegime(el);
    assert(not_bool(ELUsingAArch32(regime)));
    match regime {
      ? if ? == EL1 => {
          tbi = if [address[55]] == 0b1 then TCR_EL1[TBI1] else TCR_EL1[TBI0];
          if HavePACExt() then {
              tbid = if [address[55]] == 0b1 then TCR_EL1[TBID1] else
                TCR_EL1[TBID0]
          };
          ()
      },
      ? if ? == EL2 => {
          if HaveVirtHostExt() & ELIsInHost(el) then {
              tbi = if [address[55]] == 0b1 then TCR_EL2[TBI1] else
                TCR_EL2[TBI0];
              if HavePACExt() then {
                  tbid = if [address[55]] == 0b1 then TCR_EL2[TBID1] else
                    TCR_EL2[TBID0]
              };
              ()
          } else {
              tbi = TCR_EL2[TBI];
              if HavePACExt() then {
                  tbid = TCR_EL2[TBID]
              };
              ()
          }
      },
      ? if ? == EL3 => {
          tbi = TCR_EL3[TBI];
          if HavePACExt() then {
              tbid = TCR_EL3[TBID]
          };
          ()
      },
      _ => ()
    };
    return(if tbi == 0b1 & ((not_bool(HavePACExt()) | tbid == 0b0) | not_bool(IsInstr)) then
      0b1
    else
      0b0)
}

val AddrTop : forall ('IsInstr : Bool).
  (bits(64), bool('IsInstr), bits(2)) -> int

function AddrTop (address, IsInstr, el) = {
    assert(HaveEL(el));
    let regime : bits(2) = S1TranslationRegime(el);
    if ELUsingAArch32(regime) then {
        return(31)
    } else {
        if EffectiveTBI(address, IsInstr, el) == 0b1 then {
            return(55)
        } else {
            return(63)
        }
    }
}

val IsInHost : unit -> bool

function IsInHost () = {
    return(ELIsInHost(PSTATE.EL))
}

val AArch64_BranchAddr : (bits(64), bits(2)) -> bits(64)

function AArch64_BranchAddr (vaddress, el) = {
    assert(not_bool(UsingAArch32()));
    let 'msbit = AddrTop(vaddress, true, el);
    if msbit == 63 then {
        return(vaddress)
    } else {
        assert(constraint((0 <= 'msbit & 'msbit < 64)));
        if ((el == EL0 | el == EL1) | IsInHost()) & [vaddress[msbit]] == 0b1 then {
            return(SignExtend(vaddress[msbit .. 0], 64))
        } else {
            return(ZeroExtend(vaddress[msbit .. 0], 64))
        }
    }
}

val BRBEMispredictAllowed : unit -> bool

function BRBEMispredictAllowed () = {
    if HaveEL(EL2) & BRBCR_EL2[MPRED] == 0b0 then {
        return(false)
    };
    if BRBCR_EL1[MPRED] == 0b0 then {
        return(false)
    };
    return(true)
}

val BRBCycleCountingEnabled : unit -> bool

function BRBCycleCountingEnabled () = {
    if HaveEL(EL2) & BRBCR_EL2[CC] == 0b0 then {
        return(false)
    };
    if BRBCR_EL1[CC] == 0b0 then {
        return(false)
    };
    return(true)
}

val BranchRawCycleCount : unit -> int

function BranchRawCycleCount () = {
    let 'diff = __cycle_count - __last_cycle_count;
    __last_cycle_count = __cycle_count;
    return(diff)
}

val FirstBranchAfterProhibited : unit -> bool

function FirstBranchAfterProhibited () = {
    return(not_bool(__last_branch_valid))
}

val BranchEncCycleCount : unit -> (bits(1), bits(14))

function BranchEncCycleCount () = {
    cc : int = BranchRawCycleCount();
    if not_bool(BRBCycleCountingEnabled()) | FirstBranchAfterProhibited() then {
        return((0b1, Zeros(14)))
    };
    E : bits(6) = undefined;
    M : bits(8) = undefined;
    if cc < pow2(8) then {
        E = Zeros(6);
        M = cc[7 .. 0]
    } else if cc >= pow2(20) then {
        E = Ones(6);
        M = Ones(8)
    } else {
        E = 1[5 .. 0];
        while cc >= pow2(9) do {
            E = E + 1;
            cc = DIV(cc, 2)
        };
        let 'cc = cc;
        M = cc[7 .. 0]
    };
    return((0b0, E @ M))
}

val BranchMispredict : unit -> bool

function BranchMispredict () = {
    return(false)
}

val FilterBranchRecord : forall ('cond : Bool).
  (BranchType, bool('cond)) -> bool

function FilterBranchRecord (br, cond) = {
    match br {
      BranchType_DIRCALL => {
          return(BRBFCR_EL1[DIRCALL] != BRBFCR_EL1[EnI])
      },
      BranchType_INDCALL => {
          return(BRBFCR_EL1[INDCALL] != BRBFCR_EL1[EnI])
      },
      BranchType_RET => {
          return(BRBFCR_EL1[RTN] != BRBFCR_EL1[EnI])
      },
      BranchType_DIR => {
          if cond then {
              return(BRBFCR_EL1[CONDDIR] != BRBFCR_EL1[EnI])
          } else {
              return(BRBFCR_EL1[DIRECT] != BRBFCR_EL1[EnI])
          }
      },
      BranchType_INDIR => {
          return(BRBFCR_EL1[INDIRECT] != BRBFCR_EL1[EnI])
      },
      _ => {
          Unreachable()
      }
    };
    return(false)
}

val HaveTME : unit -> bool

function HaveTME () = {
    return(IsFeatureImplemented(FEAT_TME))
}

val CurrentInstrSet : unit -> InstrSet

function CurrentInstrSet () = {
    result : InstrSet = undefined;
    if UsingAArch32() then {
        result = if PSTATE.T == 0b0 then InstrSet_A32 else InstrSet_T32
    } else {
        result = InstrSet_A64
    };
    return(result)
}

val BadMode : bits(5) -> bool

function BadMode mode = {
    valid_name : bool = undefined;
    match mode {
      ? if ? == M32_Monitor => {
          valid_name = HaveAArch32EL(EL3)
      },
      ? if ? == M32_Hyp => {
          valid_name = HaveAArch32EL(EL2)
      },
      ? if ? == M32_FIQ => {
          valid_name = HaveAArch32EL(EL1)
      },
      ? if ? == M32_IRQ => {
          valid_name = HaveAArch32EL(EL1)
      },
      ? if ? == M32_Svc => {
          valid_name = HaveAArch32EL(EL1)
      },
      ? if ? == M32_Abort => {
          valid_name = HaveAArch32EL(EL1)
      },
      ? if ? == M32_Undef => {
          valid_name = HaveAArch32EL(EL1)
      },
      ? if ? == M32_System => {
          valid_name = HaveAArch32EL(EL1)
      },
      ? if ? == M32_User => {
          valid_name = HaveAArch32EL(EL0)
      },
      _ => {
          valid_name = false
      }
    };
    let valid_name = valid_name;
    return(not_bool(valid_name))
}

val RBankSelect : forall 'usr 'fiq 'irq 'svc 'abt 'und 'hyp.
  (bits(5), int('usr), int('fiq), int('irq), int('svc), int('abt), int('und), int('hyp)) -> {'n, ('n == 'usr | 'n == 'fiq | 'n == 'irq | 'n == 'svc | 'n == 'abt | 'n == 'und | 'n == 'hyp). int('n)}

function RBankSelect (mode, usr, fiq, irq, svc, abt, und, hyp) = {
    match mode {
      ? if ? == M32_User => usr,
      ? if ? == M32_FIQ => fiq,
      ? if ? == M32_IRQ => irq,
      ? if ? == M32_Svc => svc,
      ? if ? == M32_Abort => abt,
      ? if ? == M32_Hyp => hyp,
      ? if ? == M32_Undef => und,
      ? if ? == M32_System => usr
    }
}

val LookUpRIndex : forall 'n, ('n >= 0 & 'n <= 15).
  (int('n), bits(5)) -> {'m, (0 <= 'm & 'm <= 30). int('m)}

function LookUpRIndex (n, mode) = {
    assert(n >= 0 & n <= 14);
    match n {
      8 => {
          return(RBankSelect(mode, 8, 24, 8, 8, 8, 8, 8))
      },
      9 => {
          return(RBankSelect(mode, 9, 25, 9, 9, 9, 9, 9))
      },
      10 => {
          return(RBankSelect(mode, 10, 26, 10, 10, 10, 10, 10))
      },
      11 => {
          return(RBankSelect(mode, 11, 27, 11, 11, 11, 11, 11))
      },
      12 => {
          return(RBankSelect(mode, 12, 28, 12, 12, 12, 12, 12))
      },
      13 => {
          return(RBankSelect(mode, 13, 29, 17, 19, 21, 23, 15))
      },
      14 => {
          return(RBankSelect(mode, 14, 30, 16, 18, 20, 22, 14))
      },
      _ => {
          return(n)
      }
    }
}

val Rmode_read : forall 'n. (int('n), bits(5)) -> bits(32)

function Rmode_read (n, mode) = {
    assert(n >= 0 & n <= 14);
    if CurrentSecurityState() != SS_Secure then {
        assert(mode != M32_Monitor)
    };
    assert(not_bool(BadMode(mode)));
    if mode == M32_Monitor then {
        if n == 13 then {
            return(SP_mon)
        } else if n == 14 then {
            return(LR_mon)
        } else {
            return(_R(n)[31 .. 0])
        }
    } else {
        return(_R(LookUpRIndex(n, mode))[31 .. 0])
    }
}

val R_read : forall 'n. int('n) -> bits(32)

function R_read n = {
    offset : int = undefined;
    if n == 15 then {
        let 'offset = if CurrentInstrSet() == InstrSet_A32 then 8 else 4;
        return(_PC[31 .. 0] + offset)
    } else {
        return(Rmode_read(n, PSTATE.M))
    }
}

val PC_read : unit -> bits(64)

val PC_read__1 : unit -> bits(32)

function PC_read () = {
    return(_PC)
}

function PC_read__1 () = {
    return(R_read(15))
}

bitfield BRBIDR0_EL1_Type : bits(64) =
  {CC : 15..12, FORMAT : 11..8, NUMREC : 7..0}

register BRBIDR0_EL1 : BRBIDR0_EL1_Type

val GetBRBENumRecords : unit -> int

function GetBRBENumRecords () = {
    assert(UInt(BRBIDR0_EL1[NUMREC]) == UInt(0x08) | UInt(BRBIDR0_EL1[NUMREC]) == UInt(0x10) | UInt(BRBIDR0_EL1[NUMREC]) == UInt(0x20) | UInt(BRBIDR0_EL1[NUMREC]) == UInt(0x40));
    return(__IMPDEF_integer("Number of BRB records"))
}

register Records_INF : vector(64, BRBINFType)

register Records_SRC : vector(64, BRBSRCType)

register Records_TGT : vector(64, BRBTGTType)

val UpdateBranchRecordBuffer : (bits(1), bits(14), bits(1), bits(1), bits(6), bits(2), bits(1), bits(2), bits(64), bits(64)) -> unit

function UpdateBranchRecordBuffer (ccu, cc, lastfailed, transactional, branch_type, el, mispredict, valid_name, source_address, target_address) = {
    foreach (i from (GetBRBENumRecords() - 1) to 1 by 1 in dec) {
        assert(constraint('loop_i < 64));
        Records_SRC[i] = Records_SRC[i - 1];
        Records_TGT[i] = Records_TGT[i - 1];
        Records_INF[i] = Records_INF[i - 1]
    };
    Records_INF[0][CCU] = ccu;
    Records_INF[0][CC] = cc;
    Records_INF[0][EL] = el;
    Records_INF[0][VALID] = valid_name;
    Records_INF[0][T] = transactional;
    Records_INF[0][LASTFAILED] = lastfailed;
    Records_INF[0][MPRED] = mispredict;
    Records_INF[0][TYPE] = branch_type;
    Records_SRC[0] = Mk_BRBSRCType(source_address);
    Records_TGT[0] = Mk_BRBTGTType(target_address);
    return()
}

val BRBEBranch : forall ('cond : Bool).
  (BranchType, bool('cond), bits(64)) -> unit

function BRBEBranch (br_type, cond, target_address) = {
    let branch_valid : bool = BranchRecordAllowed(PSTATE.EL);
    if branch_valid & FilterBranchRecord(br_type, cond) then {
        branch_type : bits(6) = undefined;
        match br_type {
          BranchType_DIR => {
              branch_type = if cond then 0b001000 else 0b000000
          },
          BranchType_INDIR => {
              branch_type = 0b000001
          },
          BranchType_DIRCALL => {
              branch_type = 0b000010
          },
          BranchType_INDCALL => {
              branch_type = 0b000011
          },
          BranchType_RET => {
              branch_type = 0b000101
          },
          _ => {
              Unreachable()
          }
        };
        ccu : bits(1) = undefined;
        cc : bits(14) = undefined;
        (ccu, cc) = BranchEncCycleCount();
        let lastfailed : bits(1) = if HaveTME() then BRBFCR_EL1[LASTFAILED] else
          0b0;
        let transactional : bits(1) = if HaveTME() & TSTATE.depth > 0 then 0b1
        else
          0b0;
        let el : bits(2) = PSTATE.EL;
        let mispredict : bits(1) = if BRBEMispredictAllowed() & BranchMispredict() then
          0b1
        else
          0b0;
        UpdateBranchRecordBuffer(ccu, cc, lastfailed, transactional, branch_type, el, mispredict, 0b11, PC_read(), target_address);
        BRBFCR_EL1[LASTFAILED] = 0b0;
        PMUEvent(PMU_EVENT_BRB_FILTRATE)
    };
    __last_branch_valid = branch_valid;
    return()
}

val HaveBRBExt : unit -> bool

function HaveBRBExt () = {
    return(IsFeatureImplemented(FEAT_BRBE))
}

val HaveStatisticalProfiling : unit -> bool

function HaveStatisticalProfiling () = {
    return(IsFeatureImplemented(FEAT_SPE))
}

val Hint_Branch : BranchType -> unit

bitfield PMSIDR_EL1_Type : bits(64) =
  {
    CRR : 25..25,
    PBT : 24..24,
    Format : 23..20,
    CountSize : 19..16,
    MaxSize : 15..12,
    Interval : 11..8,
    FDS : 7..7,
    FnE : 6..6,
    ERnd : 5..5,
    LDS : 4..4,
    ArchInst : 3..3,
    FL : 2..2,
    FT : 1..1,
    FE : 0..0
  }

register PMSIDR_EL1 : PMSIDR_EL1_Type

register SPESampleAddress : vector(32, bits(64))

register SPESampleAddressValid : vector(32, bool)

bitfield PMSCR_EL1_Type : bits(64) =
  {PCT : 7..6, TS : 5..5, PA : 4..4, CX : 3..3, E1SPE : 1..1, E0SPE : 0..0}

register PMSCR_EL1 : PMSCR_EL1_Type

bitfield PMSCR_EL2_Type : bits(64) =
  {PCT : 7..6, TS : 5..5, PA : 4..4, CX : 3..3, E2SPE : 1..1, E0HSPE : 0..0}

register PMSCR_EL2 : PMSCR_EL2_Type

bitfield PMBLIMITR_EL1_Type : bits(64) =
  {LIMIT : 63..12, PMFZ : 5..5, FM : 2..1, E : 0..0}

register PMBLIMITR_EL1 : PMBLIMITR_EL1_Type

bitfield PMBSR_EL1_Type : bits(64) =
  {
    AssuredOnly : 39..39,
    Overlay : 38..38,
    DirtyBit : 37..37,
    EC : 31..26,
    DL : 19..19,
    EA : 18..18,
    S : 17..17,
    COLL : 16..16,
    MSS : 15..0
  }

register PMBSR_EL1 : PMBSR_EL1_Type

val ProfilingBufferOwner : unit -> (SecurityState, bits(2))

function ProfilingBufferOwner () = {
    owning_ss : SecurityState = undefined;
    if HaveEL(EL3) then {
        state_bits : bits(3) = undefined;
        if HaveRME() then {
            state_bits = MDCR_EL3[NSPBE] @ MDCR_EL3[NSPB];
            if (match state_bits {
              [bitone, bitzero, _] => true,
              _ => false
            }) : bool | not_bool(HaveSecureEL2Ext()) & (match state_bits {
              [bitzero, bitzero, _] => true,
              _ => false
            }) : bool then {
                let (_, __tup_1 : bits(3)) = ConstrainUnpredictableBits(Unpredictable_RESERVEDNSxB, 3);
                state_bits = __tup_1
            };
            ()
        } else {
            state_bits = 0b0 @ MDCR_EL3[NSPB]
        };
        match state_bits {
          [bitzero, bitzero, _] => {
              owning_ss = SS_Secure
          },
          [bitzero, bitone, _] => {
              owning_ss = SS_NonSecure
          },
          [bitone, bitone, _] => {
              owning_ss = SS_Realm
          },
          _ => ()
        }
    } else {
        owning_ss = if SecureOnlyImplementation() then SS_Secure else
          SS_NonSecure
    };
    owning_el : bits(2) = undefined;
    if HaveEL(EL2) & (owning_ss != SS_Secure | IsSecureEL2Enabled()) then {
        owning_el = if MDCR_EL2[E2PB] == 0b00 then EL2 else EL1
    } else {
        owning_el = EL1
    };
    return((owning_ss, owning_el))
}

val ProfilingBufferEnabled : unit -> bool

function ProfilingBufferEnabled () = {
    owning_el : bits(2) = undefined;
    owning_ss : SecurityState = undefined;
    if not_bool(HaveStatisticalProfiling()) then {
        return(false)
    };
    (owning_ss, owning_el) = ProfilingBufferOwner();
    state_bits : bits(2) = undefined;
    if HaveRME() then {
        state_bits = SCR_EL3[NSE] @ EffectiveSCR_EL3_NS()
    } else {
        state_bits = 0b0 @ SCR_EL3[NS]
    };
    state_match : bool = undefined;
    match owning_ss {
      SS_Secure => {
          state_match = state_bits == 0b00
      },
      SS_NonSecure => {
          state_match = state_bits == 0b01
      },
      SS_Realm => {
          state_match = state_bits == 0b11
      },
      _ => ()
    };
    return(((not_bool(ELUsingAArch32(owning_el)) & state_match) & PMBLIMITR_EL1[E] == 0b1) & PMBSR_EL1[S] == 0b0)
}

val StatisticalProfilingEnabled : unit -> bool

val StatisticalProfilingEnabled__1 : bits(2) -> bool

function StatisticalProfilingEnabled () = {
    return(StatisticalProfilingEnabled__1(PSTATE.EL))
}

function StatisticalProfilingEnabled__1 el = {
    owning_el : bits(2) = undefined;
    owning_ss : SecurityState = undefined;
    if (not_bool(HaveStatisticalProfiling()) | UsingAArch32()) | not_bool(ProfilingBufferEnabled()) then {
        return(false)
    };
    let tge_set : bool = EL2Enabled() & HCR_EL2[TGE] == 0b1;
    (owning_ss, owning_el) = ProfilingBufferOwner();
    if (UInt(owning_el) < UInt(el) | tge_set & owning_el == EL1) | owning_ss != SecurityStateAtEL(el) then {
        return(false)
    };
    spe_bit : bits(1) = undefined;
    match el {
      ? if ? == EL3 => {
          Unreachable()
      },
      ? if ? == EL2 => {
          spe_bit = PMSCR_EL2[E2SPE]
      },
      ? if ? == EL1 => {
          spe_bit = PMSCR_EL1[E1SPE]
      },
      ? if ? == EL0 => {
          spe_bit = if tge_set then PMSCR_EL2[E0HSPE] else PMSCR_EL1[E0SPE]
      },
      _ => ()
    };
    return(spe_bit == 0b1)
}

val SPEBranch : forall 'N ('conditional : Bool) ('taken_flag : Bool),
  'N >= 0.
  (bits('N), BranchType, bool('conditional), bool('taken_flag)) -> unit

val SPEBranch__1 : forall 'N ('conditional : Bool) ('is_isb : Bool) ('taken_flag : Bool),
  'N >= 0.
  (bits('N), BranchType, bool('conditional), bool('taken_flag), bool('is_isb)) -> unit

function SPEBranch (target, branch_type, conditional, taken_flag) = {
    let is_isb : bool = false;
    SPEBranch__1(target, branch_type, conditional, taken_flag, is_isb)
}

function SPEBranch__1 (target, branch_type, conditional, taken_flag, is_isb) = {
    is_direct : bool = undefined;
    collect_prev_br : bool = undefined;
    let collect_prev_br_eret : bool = __IMPDEF_boolean("SPE prev br on eret");
    let collect_prev_br_exception : bool = __IMPDEF_boolean("SPE prev br on exception");
    let collect_prev_br_isb : bool = __IMPDEF_boolean("SPE prev br on isb");
    match branch_type {
      BranchType_EXCEPTION => {
          collect_prev_br = collect_prev_br_exception
      },
      BranchType_ERET => {
          collect_prev_br = collect_prev_br_eret
      },
      _ => {
          collect_prev_br = not_bool(is_isb) | collect_prev_br_isb
      }
    };
    let collect_prev_br = collect_prev_br;
    if ((taken_flag & not_bool(IsZero(PMSIDR_EL1[PBT]))) & StatisticalProfilingEnabled()) & collect_prev_br then {
        if SPESampleInFlight then {
            let previous_target : bits(64) = SPESamplePreviousBranchAddress;
            SPESampleAddress[SPEAddrPosPrevBranchTarget][63 .. 0] = previous_target[63 .. 0];
            let previous_branch_valid : bool = SPESamplePreviousBranchAddressValid;
            SPESampleAddressValid[SPEAddrPosPrevBranchTarget] = previous_branch_valid
        };
        assert(constraint(55 < 'N));
        SPESamplePreviousBranchAddress[55 .. 0] = target[55 .. 0];
        ns : bits(1) = undefined;
        nse : bits(1) = undefined;
        match CurrentSecurityState() {
          SS_Secure => {
              ns = 0b0;
              nse = 0b0
          },
          SS_NonSecure => {
              ns = 0b1;
              nse = 0b0
          },
          SS_Realm => {
              ns = 0b1;
              nse = 0b1
          },
          _ => {
              Unreachable()
          }
        };
        SPESamplePreviousBranchAddress[63] = Bit(ns);
        SPESamplePreviousBranchAddress[60] = Bit(nse);
        SPESamplePreviousBranchAddress[62 .. 61] = PSTATE.EL;
        SPESamplePreviousBranchAddressValid = true
    };
    if not_bool(StatisticalProfilingEnabled()) then {
        if taken_flag then {
            SPESamplePreviousBranchAddressValid = false
        };
        return()
    };
    if SPESampleInFlight then {
        let is_direct : bool = branch_type == BranchType_DIR | branch_type == BranchType_DIRCALL;
        SPESampleClass = 0b10;
        SPESampleSubclass[1] = Bit(if is_direct then 0b0 else 0b1);
        SPESampleSubclass[0] = Bit(if conditional then 0b1 else 0b0);
        SPESampleOpType = OpType_Branch;
        if taken_flag then {
            assert(constraint(55 < 'N));
            SPESampleAddress[SPEAddrPosBranchTarget][55 .. 0] = target[55 .. 0];
            ns : bits(1) = undefined;
            nse : bits(1) = undefined;
            match CurrentSecurityState() {
              SS_Secure => {
                  ns = 0b0;
                  nse = 0b0
              },
              SS_NonSecure => {
                  ns = 0b1;
                  nse = 0b0
              },
              SS_Realm => {
                  ns = 0b1;
                  nse = 0b1
              },
              _ => {
                  Unreachable()
              }
            };
            SPESampleAddress[SPEAddrPosBranchTarget][63] = Bit(ns);
            SPESampleAddress[SPEAddrPosBranchTarget][60] = Bit(nse);
            SPESampleAddress[SPEAddrPosBranchTarget][62 .. 61] = PSTATE.EL;
            SPESampleAddressValid[SPEAddrPosBranchTarget] = true
        };
        SPESampleEvents[6] = Bit(if not_bool(taken_flag) then 0b1 else 0b0)
    };
    ()
}

val BranchTo : forall 'N ('branch_conditional : Bool), 'N >= 0.
  (bits('N), BranchType, bool('branch_conditional)) -> unit

function BranchTo (target, branch_type, branch_conditional) = {
    Hint_Branch(branch_type);
    if 'N == 32 then {
        assert(UsingAArch32());
        sail_branch_announce(64, ZeroExtend(target, 64));
        _PC = ZeroExtend(target, 64)
    } else {
        assert('N == 64 & not_bool(UsingAArch32()));
        let target_vaddress : bits(64) = AArch64_BranchAddr(target[63 .. 0], PSTATE.EL);
        if HaveBRBExt() & (branch_type == BranchType_DIR | branch_type == BranchType_INDIR | branch_type == BranchType_DIRCALL | branch_type == BranchType_INDCALL | branch_type == BranchType_RET) then {
            BRBEBranch(branch_type, branch_conditional, target_vaddress)
        };
        let branch_taken : bool = true;
        if HaveStatisticalProfiling() then {
            SPEBranch(target, branch_type, branch_conditional, branch_taken)
        };
        sail_branch_announce(64, target_vaddress);
        _PC = target_vaddress
    };
    __BranchTaken = true;
    return()
}

val ClearExclusiveLocal : forall 'processorid. int('processorid) -> unit

val DiscardTransactionalWrites : unit -> unit

val ProcessorID : unit -> int

val FloorPow2 : forall 'x. int('x) -> nat

function FloorPow2 x = {
    assert(x >= 0);
    n : {'n, 'n >= 0. int('n)} = 1;
    if x == 0 then {
        return(0)
    };
    while x >= pow2(n) do {
        n = n + 1
    };
    let 'n = n;
    let r = 2 ^ (n - 1);
    assert(r >= 0);
    return(r)
}

val CeilPow2 : forall 'x. int('x) -> nat

function CeilPow2 x = {
    if x == 0 then {
        return(0)
    };
    if x == 1 then {
        return(2)
    };
    return(FloorPow2(x - 1) * 2)
}

val IsPow2 : forall 'x. int('x) -> bool

function IsPow2 x = {
    if x <= 0 then {
        return(false)
    };
    return(FloorPow2(x) == CeilPow2(x))
}

val MaxImplementedVL : unit -> int

val ImplementedSVEVectorLength : int -> vector_length

function ImplementedSVEVectorLength nbits_in = {
    let 'maxbits = MaxImplementedVL();
    assert((128 <= maxbits & maxbits <= 2048) & IsPow2(maxbits));
    nbits : int = Min(nbits_in, maxbits);
    assert((128 <= nbits & nbits <= 2048) & Align(nbits, 128) == nbits);
    while nbits > 128 do {
        if IsPow2(nbits) then {
            let 'nbits = nbits;
            assert(constraint(is_VL('nbits)));
            return(nbits)
        };
        nbits = nbits - 128
    };
    let 'nbits = nbits;
    assert(constraint(is_VL('nbits)));
    return(nbits)
}

bitfield ZCR_EL1_Type : bits(64) = {LEN : 3..0}

register ZCR_EL1 : ZCR_EL1_Type

bitfield ZCR_EL2_Type : bits(64) = {LEN : 3..0}

register ZCR_EL2 : ZCR_EL2_Type

bitfield ZCR_EL3_Type : bits(64) = {LEN : 3..0}

register ZCR_EL3 : ZCR_EL3_Type

val CurrentNSVL_read : unit -> vector_length

function CurrentNSVL_read () = {
    vl : int = undefined;
    if PSTATE.EL == EL1 | PSTATE.EL == EL0 & not_bool(IsInHost()) then {
        vl = UInt(ZCR_EL1[LEN])
    };
    if PSTATE.EL == EL2 | PSTATE.EL == EL0 & IsInHost() then {
        vl = UInt(ZCR_EL2[LEN])
    } else if (PSTATE.EL == EL0 | PSTATE.EL == EL1) & EL2Enabled() then {
        vl = Min(vl, UInt(ZCR_EL2[LEN]))
    } else ();
    if PSTATE.EL == EL3 then {
        vl = UInt(ZCR_EL3[LEN])
    } else if HaveEL(EL3) then {
        vl = Min(vl, UInt(ZCR_EL3[LEN]))
    } else ();
    vl : int = (vl + 1) * 128;
    let 'vl = ImplementedSVEVectorLength(vl);
    return(vl)
}

val MaxImplementedSVL : unit -> int

val SupportedPowerTwoSVL : forall 'nbits. int('nbits) -> bool

val ImplementedSMEVectorLength : forall 'nbits_in.
  int('nbits_in) -> vector_length

function ImplementedSMEVectorLength nbits_in = {
    let 'maxbits = MaxImplementedSVL();
    assert(constraint(is_VL('maxbits)));
    nbits : int = Min(nbits_in, maxbits);
    assert((128 <= nbits & nbits <= 2048) & Align(nbits, 128) == nbits);
    while nbits > 128 do {
        if IsPow2(nbits) & SupportedPowerTwoSVL(nbits) then {
            let 'nbits = nbits;
            assert(constraint(is_VL('nbits)));
            return(nbits)
        };
        nbits = nbits - 128
    };
    nbits : int = 128;
    while nbits < maxbits do {
        if SupportedPowerTwoSVL(nbits) then {
            let 'nbits = nbits;
            assert(constraint(is_VL('nbits)));
            return(nbits)
        };
        nbits = nbits * 2
    };
    return(maxbits)
}

bitfield SMCR_EL1_Type : bits(64) = {FA64 : 31..31, EZT0 : 30..30, LEN : 3..0}

register SMCR_EL1 : SMCR_EL1_Type

bitfield SMCR_EL2_Type : bits(64) = {FA64 : 31..31, EZT0 : 30..30, LEN : 3..0}

register SMCR_EL2 : SMCR_EL2_Type

bitfield SMCR_EL3_Type : bits(64) = {FA64 : 31..31, EZT0 : 30..30, LEN : 3..0}

register SMCR_EL3 : SMCR_EL3_Type

val CurrentSVL_read : unit -> vector_length

function CurrentSVL_read () = {
    vl : int = undefined;
    if PSTATE.EL == EL1 | PSTATE.EL == EL0 & not_bool(IsInHost()) then {
        vl = UInt(SMCR_EL1[LEN])
    };
    if PSTATE.EL == EL2 | PSTATE.EL == EL0 & IsInHost() then {
        vl = UInt(SMCR_EL2[LEN])
    } else if (PSTATE.EL == EL0 | PSTATE.EL == EL1) & EL2Enabled() then {
        vl = Min(vl, UInt(SMCR_EL2[LEN]))
    } else ();
    if PSTATE.EL == EL3 then {
        vl = UInt(SMCR_EL3[LEN])
    } else if HaveEL(EL3) then {
        vl = Min(vl, UInt(SMCR_EL3[LEN]))
    } else ();
    vl : int = (vl + 1) * 128;
    let 'vl = ImplementedSMEVectorLength(vl);
    return(vl)
}

val HaveSME : unit -> bool

function HaveSME () = {
    return(IsFeatureImplemented(FEAT_SME))
}

val CurrentVL_read : unit -> vector_length

function CurrentVL_read () = {
    let 'SVL = CurrentSVL_read();
    return(if HaveSME() & PSTATE.SM == 0b1 then SVL else CurrentNSVL_read())
}

val FFR_set : forall 'width, 'width >= 0. (int('width), bits('width)) -> unit

function FFR_set (width, value_name) = {
    let 'VL = CurrentVL_read();
    assert(width == DIV(VL, 8));
    if ConstrainUnpredictableBool(Unpredictable_SVEZEROUPPER) then {
        _FFR = ZeroExtend(value_name, MAX_PL)
    } else {
        _FFR[width - 1 .. 0] = value_name
    }
}

bitfield GCSPR_EL0_Type : bits(64) = {PTR : 63..3}

register GCSPR_EL0 : GCSPR_EL0_Type

bitfield GCSPR_EL1_Type : bits(64) = {PTR : 63..3}

register GCSPR_EL1 : GCSPR_EL1_Type

bitfield GCSPR_EL2_Type : bits(64) = {PTR : 63..3}

register GCSPR_EL2 : GCSPR_EL2_Type

bitfield GCSPR_EL3_Type : bits(64) = {PTR : 63..3}

register GCSPR_EL3 : GCSPR_EL3_Type

val HaveGCS : unit -> bool

function HaveGCS () = {
    return(IsFeatureImplemented(FEAT_GCS))
}

bitfield CPACR_EL1_Type : bits(64) =
  {E0POE : 29..29, TTA : 28..28, SMEN : 25..24, FPEN : 21..20, ZEN : 17..16}

register CPACR_EL1 : CPACR_EL1_Type

bitfield CPTR_EL2_Type : bits(64) =
  {
    TCPAC : 31..31,
    TAM : 30..30,
    E0POE : 29..29,
    SMEN : 25..24,
    FPEN : 21..20,
    ZEN : 17..16,
    TSM : 12..12,
    TFP : 10..10,
    TZ : 8..8
  }

register CPTR_EL2 : CPTR_EL2_Type

bitfield CPTR_EL3_Type : bits(64) =
  {
    TCPAC : 31..31,
    TAM : 30..30,
    TTA : 20..20,
    ESM : 12..12,
    TFP : 10..10,
    EZ : 8..8
  }

register CPTR_EL3 : CPTR_EL3_Type

val AArch64_IsFPEnabled : bits(2) -> bool

function AArch64_IsFPEnabled el = {
    if (el == EL0 | el == EL1) & not_bool(IsInHost()) then {
        disabled : bool = undefined;
        match CPACR_EL1[FPEN] {
          [_, bitzero] => {
              disabled = true
          },
          0b01 => {
              disabled = el == EL0
          },
          0b11 => {
              disabled = false
          }
        };
        let disabled = disabled;
        if disabled then {
            return(false)
        };
        ()
    };
    if (el == EL0 | el == EL1 | el == EL2) & EL2Enabled() then {
        if HaveVirtHostExt() & HCR_EL2[E2H] == 0b1 then {
            disabled : bool = undefined;
            match CPTR_EL2[FPEN] {
              [_, bitzero] => {
                  disabled = true
              },
              0b01 => {
                  disabled = el == EL0 & HCR_EL2[TGE] == 0b1
              },
              0b11 => {
                  disabled = false
              }
            };
            let disabled = disabled;
            if disabled then {
                return(false)
            };
            ()
        } else {
            if CPTR_EL2[TFP] == 0b1 then {
                return(false)
            };
            ()
        }
    };
    if HaveEL(EL3) then {
        if CPTR_EL3[TFP] == 0b1 then {
            return(false)
        };
        ()
    };
    return(true)
}

bitfield CPACR_Type : bits(32) =
  {ASEDIS : 31..31, TRCDIS : 28..28, cp11 : 23..22, cp10 : 21..20}

register _CPACR : CPACR_Type

val CPACR_read__1 : unit -> CPACR_Type

function CPACR_read__1 () = {
    r : CPACR_Type = _CPACR;
    r.bits[31 .. 0] = Slice(CPACR_EL1.bits, 0, 32);
    return(r)
}

bitfield HCPTR_Type : bits(32) =
  {
    TCPAC : 31..31,
    TAM : 30..30,
    TTA : 20..20,
    TASE : 15..15,
    TCP11 : 11..11,
    TCP10 : 10..10
  }

register _HCPTR : HCPTR_Type

val HCPTR_read : unit -> HCPTR_Type

function HCPTR_read () = {
    r : HCPTR_Type = _HCPTR;
    r.bits[31 .. 0] = Slice(CPTR_EL2.bits, 0, 32);
    return(r)
}

bitfield NSACR_Type : bits(32) =
  {NSTRCDIS : 20..20, NSASEDIS : 15..15, cp11 : 11..11, cp10 : 10..10}

register NSACR : NSACR_Type

val AArch32_IsFPEnabled : bits(2) -> bool

function AArch32_IsFPEnabled el = {
    if el == EL0 & not_bool(ELUsingAArch32(EL1)) then {
        return(AArch64_IsFPEnabled(el))
    };
    if (HaveEL(EL3) & ELUsingAArch32(EL3)) & CurrentSecurityState() == SS_NonSecure then {
        if NSACR[cp10] == 0b0 then {
            return(false)
        };
        ()
    };
    if el == EL0 | el == EL1 then {
        disabled : bool = undefined;
        match CPACR_read__1()[cp10] {
          0b00 => {
              disabled = true
          },
          0b01 => {
              disabled = el == EL0
          },
          0b10 => {
              disabled = ConstrainUnpredictableBool(Unpredictable_RESCPACR)
          },
          0b11 => {
              disabled = false
          }
        };
        let disabled = disabled;
        if disabled then {
            return(false)
        };
        ()
    };
    if (el == EL0 | el == EL1 | el == EL2) & EL2Enabled() then {
        if not_bool(ELUsingAArch32(EL2)) then {
            return(AArch64_IsFPEnabled(EL2))
        };
        if HCPTR_read()[TCP10] == 0b1 then {
            return(false)
        };
        ()
    };
    if HaveEL(EL3) & not_bool(ELUsingAArch32(EL3)) then {
        if CPTR_EL3[TFP] == 0b1 then {
            return(false)
        };
        ()
    };
    return(true)
}

val IsFPEnabled : bits(2) -> bool

function IsFPEnabled el = {
    if ELUsingAArch32(el) then {
        return(AArch32_IsFPEnabled(el))
    } else {
        return(AArch64_IsFPEnabled(el))
    }
}

val HaveSVE : unit -> bool

function HaveSVE () = {
    return(IsFeatureImplemented(FEAT_SVE))
}

val IsOriginalSVEEnabled : bits(2) -> bool

function IsOriginalSVEEnabled el = {
    disabled : bool = undefined;
    if ELUsingAArch32(el) then {
        return(false)
    };
    if (el == EL0 | el == EL1) & not_bool(IsInHost()) then {
        match CPACR_EL1[ZEN] {
          [_, bitzero] => {
              disabled = true
          },
          0b01 => {
              disabled = el == EL0
          },
          0b11 => {
              disabled = false
          }
        };
        if disabled then {
            return(false)
        };
        ()
    };
    if (el == EL0 | el == EL1 | el == EL2) & EL2Enabled() then {
        if HaveVirtHostExt() & HCR_EL2[E2H] == 0b1 then {
            match CPTR_EL2[ZEN] {
              [_, bitzero] => {
                  disabled = true
              },
              0b01 => {
                  disabled = el == EL0 & HCR_EL2[TGE] == 0b1
              },
              0b11 => {
                  disabled = false
              }
            };
            if disabled then {
                return(false)
            };
            ()
        } else {
            if CPTR_EL2[TZ] == 0b1 then {
                return(false)
            };
            ()
        }
    };
    if HaveEL(EL3) then {
        if CPTR_EL3[EZ] == 0b0 then {
            return(false)
        };
        ()
    };
    return(true)
}

val IsSMEEnabled : bits(2) -> bool

function IsSMEEnabled el = {
    disabled : bool = undefined;
    if ELUsingAArch32(el) then {
        return(false)
    };
    if (el == EL0 | el == EL1) & not_bool(IsInHost()) then {
        match CPACR_EL1[SMEN] {
          [_, bitzero] => {
              disabled = true
          },
          0b01 => {
              disabled = el == EL0
          },
          0b11 => {
              disabled = false
          }
        };
        if disabled then {
            return(false)
        };
        ()
    };
    if (el == EL0 | el == EL1 | el == EL2) & EL2Enabled() then {
        if HaveVirtHostExt() & HCR_EL2[E2H] == 0b1 then {
            match CPTR_EL2[SMEN] {
              [_, bitzero] => {
                  disabled = true
              },
              0b01 => {
                  disabled = el == EL0 & HCR_EL2[TGE] == 0b1
              },
              0b11 => {
                  disabled = false
              }
            };
            if disabled then {
                return(false)
            };
            ()
        } else {
            if CPTR_EL2[TSM] == 0b1 then {
                return(false)
            };
            ()
        }
    };
    if HaveEL(EL3) then {
        if CPTR_EL3[ESM] == 0b0 then {
            return(false)
        };
        ()
    };
    return(true)
}

val IsSVEEnabled : bits(2) -> bool

function IsSVEEnabled el = {
    if HaveSME() & PSTATE.SM == 0b1 then {
        return(IsSMEEnabled(el))
    } else if HaveSVE() then {
        return(IsOriginalSVEEnabled(el))
    } else {
        return(false)
    }
}

val P_set : forall 'n 'width, 'width >= 0.
  (int('n), int('width), bits('width)) -> unit

function P_set (n, width, value_name) = {
    let 'VL = CurrentVL_read();
    assert(n >= 0 & n <= 31);
    assert(width == DIV(VL, 8));
    if ConstrainUnpredictableBool(Unpredictable_SVEZEROUPPER) then {
        assert(constraint((0 <= 'n & 'n < 16)));
        _P[n] = ZeroExtend(value_name, MAX_PL)
    } else {
        assert(constraint((0 <= 'n & 'n < 16)));
        _P[n][width - 1 .. 0] = value_name
    }
}

type SP_EL0_Type = bits(64)

register SP_EL0 : SP_EL0_Type

type SP_EL1_Type = bits(64)

register SP_EL1 : SP_EL1_Type

type SP_EL2_Type = bits(64)

register SP_EL2 : SP_EL2_Type

type SP_EL3_Type = bits(64)

register SP_EL3 : SP_EL3_Type

val SP_set : bits(64) -> unit

function SP_set value_name = {
    if PSTATE.SP == 0b0 then {
        SP_EL0 = value_name
    } else {
        match PSTATE.EL {
          ? if ? == EL0 => {
              SP_EL0 = value_name
          },
          ? if ? == EL1 => {
              SP_EL1 = value_name
          },
          ? if ? == EL2 => {
              SP_EL2 = value_name
          },
          ? if ? == EL3 => {
              SP_EL3 = value_name
          },
          _ => ()
        }
    };
    return()
}

val V_set : forall 'n 'width,
  'width in {8, 16, 32, 64, 128}.
  (int('n), int('width), bits('width)) -> unit

function V_set (n, width, value_name) = {
    let 'VL = CurrentVL_read();
    assert(n >= 0 & n <= 31);
    assert(width == 8 | width == 16 | width == 32 | width == 64 | width == 128);
    let 'vlen = if IsSVEEnabled(PSTATE.EL) then VL else 128;
    if ConstrainUnpredictableBool(Unpredictable_SVEZEROUPPER) then {
        _Z[n] = ZeroExtend(value_name, MAX_VL)
    } else {
        _Z[n][vlen - 1 .. 0] = ZeroExtend(value_name, vlen)
    }
}

val X_set : forall 'n 'width,
  'width in {32, 64}.
  (int('n), int('width), bits('width)) -> unit

function X_set (n, width, value_name) = {
    assert(n >= 0 & n <= 31);
    assert(width == 32 | width == 64);
    if n != 31 then {
        _R(n) = ZeroExtend(value_name, 64)
    };
    return()
}

val Z_set : forall 'n 'width, 'width >= 0.
  (int('n), int('width), bits('width)) -> unit

function Z_set (n, width, value_name) = {
    let 'VL = CurrentVL_read();
    assert(n >= 0 & n <= 31);
    assert(width == VL);
    if ConstrainUnpredictableBool(Unpredictable_SVEZEROUPPER) then {
        _Z[n] = ZeroExtend(value_name, MAX_VL)
    } else {
        _Z[n][width - 1 .. 0] = value_name
    }
}

val RestoreTransactionCheckpointParameterised : forall 'pl 'vl, (is_VL('vl) & is_PL('pl)).
  (int('vl), int('pl)) -> unit

function RestoreTransactionCheckpointParameterised (vl, pl) = {
    assert(((((((((((((((vl == 128 | vl == 256) | vl == 384) | vl == 512) | vl == 640) | vl == 768) | vl == 896) | vl == 1024) | vl == 1152) | vl == 1280) | vl == 1408) | vl == 1536) | vl == 1664) | vl == 1792) | vl == 1920) | vl == 2048);
    SP_set() = TSTATE.SP;
    ICC_PMR_EL1 = Mk_ICC_PMR_EL1_Type(TSTATE.ICC_PMR_EL1);
    (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V) = TSTATE.nzcv;
    (PSTATE.D @ PSTATE.A @ PSTATE.I @ PSTATE.F) = TSTATE.D @ (TSTATE.A @ (TSTATE.I @ TSTATE.F));
    foreach (n from 0 to 30 by 1 in inc) {
        X_set(n, 64) = TSTATE.X[n]
    };
    if IsFPEnabled(PSTATE.EL) then {
        if IsSVEEnabled(PSTATE.EL) then {
            foreach (n from 0 to 31 by 1 in inc) {
                Z_set(n, vl) = TSTATE.Z[n][vl - 1 .. 0]
            };
            foreach (n from 0 to 15 by 1 in inc) {
                P_set(n, pl) = TSTATE.P[n][pl - 1 .. 0]
            };
            FFR_set(pl) = TSTATE.FFR[pl - 1 .. 0]
        } else {
            foreach (n from 0 to 31 by 1 in inc) {
                V_set(n, 128) = TSTATE.Z[n][127 .. 0]
            }
        };
        FPCR = Mk_FPCR_Type(TSTATE.FPCR);
        FPSR = Mk_FPSR_Type(TSTATE.FPSR)
    };
    if HaveGCS() then {
        match PSTATE.EL {
          ? if ? == EL0 => {
              GCSPR_EL0 = Mk_GCSPR_EL0_Type(TSTATE.GCSPR_ELx)
          },
          ? if ? == EL1 => {
              GCSPR_EL1 = Mk_GCSPR_EL1_Type(TSTATE.GCSPR_ELx)
          },
          ? if ? == EL2 => {
              GCSPR_EL2 = Mk_GCSPR_EL2_Type(TSTATE.GCSPR_ELx)
          },
          ? if ? == EL3 => {
              GCSPR_EL3 = Mk_GCSPR_EL3_Type(TSTATE.GCSPR_ELx)
          },
          _ => ()
        }
    };
    return()
}

val RestoreTransactionCheckpoint : unit -> unit

function RestoreTransactionCheckpoint () = {
    let 'VL = CurrentVL_read();
    let 'VL = VL;
    match VL {
      128 => {
          RestoreTransactionCheckpointParameterised(VL, DIV(VL, 8))
      },
      256 => {
          RestoreTransactionCheckpointParameterised(VL, DIV(VL, 8))
      },
      384 => {
          RestoreTransactionCheckpointParameterised(VL, DIV(VL, 8))
      },
      512 => {
          RestoreTransactionCheckpointParameterised(VL, DIV(VL, 8))
      },
      640 => {
          RestoreTransactionCheckpointParameterised(VL, DIV(VL, 8))
      },
      768 => {
          RestoreTransactionCheckpointParameterised(VL, DIV(VL, 8))
      },
      896 => {
          RestoreTransactionCheckpointParameterised(VL, DIV(VL, 8))
      },
      1024 => {
          RestoreTransactionCheckpointParameterised(VL, DIV(VL, 8))
      },
      1152 => {
          RestoreTransactionCheckpointParameterised(VL, DIV(VL, 8))
      },
      1280 => {
          RestoreTransactionCheckpointParameterised(VL, DIV(VL, 8))
      },
      1408 => {
          RestoreTransactionCheckpointParameterised(VL, DIV(VL, 8))
      },
      1536 => {
          RestoreTransactionCheckpointParameterised(VL, DIV(VL, 8))
      },
      1664 => {
          RestoreTransactionCheckpointParameterised(VL, DIV(VL, 8))
      },
      1792 => {
          RestoreTransactionCheckpointParameterised(VL, DIV(VL, 8))
      },
      1920 => {
          RestoreTransactionCheckpointParameterised(VL, DIV(VL, 8))
      },
      2048 => {
          RestoreTransactionCheckpointParameterised(VL, DIV(VL, 8))
      },
      _ => {
          assert(false)
      }
    }
}

val FailTransaction : forall ('retry : Bool). (TMFailure, bool('retry)) -> unit

val FailTransaction__1 : forall ('interrupt : Bool) ('retry : Bool).
  (TMFailure, bool('retry), bool('interrupt), bits(15)) -> unit

function FailTransaction (cause, retry) = {
    FailTransaction__1(cause, retry, false, Zeros(15));
    return()
}

function FailTransaction__1 (cause, retry, interrupt, reason) = {
    assert(not_bool(retry) | not_bool(interrupt));
    if HaveBRBExt() & BranchRecordAllowed(PSTATE.EL) then {
        BRBFCR_EL1[LASTFAILED] = 0b1
    };
    DiscardTransactionalWrites();
    if cause != TMFailure_TRIVIAL then {
        RestoreTransactionCheckpoint()
    };
    ClearExclusiveLocal(ProcessorID());
    result : bits(64) = Zeros(64);
    result[23] = Bit(if interrupt then 0b1 else 0b0);
    result[15] = Bit(if retry & not_bool(interrupt) then 0b1 else 0b0);
    match cause {
      TMFailure_TRIVIAL => {
          result[24] = Bit(0b1)
      },
      TMFailure_DBG => {
          result[22] = Bit(0b1)
      },
      TMFailure_NEST => {
          result[21] = Bit(0b1)
      },
      TMFailure_SIZE => {
          result[20] = Bit(0b1)
      },
      TMFailure_ERR => {
          result[19] = Bit(0b1)
      },
      TMFailure_IMP => {
          result[18] = Bit(0b1)
      },
      TMFailure_MEM => {
          result[17] = Bit(0b1)
      },
      TMFailure_CNCL => {
          result[16] = Bit(0b1);
          result[14 .. 0] = reason
      }
    };
    TSTATE.depth = 0;
    X_set(TSTATE.Rt, 64) = result;
    let branch_conditional : bool = false;
    BranchTo(TSTATE.nPC, BranchType_TMFAIL, branch_conditional);
    EndOfInstruction();
    return()
}

val HaveBTIExt : unit -> bool

function HaveBTIExt () = {
    return(IsFeatureImplemented(FEAT_BTI))
}

val HaveDITExt : unit -> bool

function HaveDITExt () = {
    return(IsFeatureImplemented(FEAT_DIT))
}

val HaveFeatNMI : unit -> bool

function HaveFeatNMI () = {
    return(IsFeatureImplemented(FEAT_NMI))
}

val HaveMTEExt : unit -> bool

function HaveMTEExt () = {
    return(IsFeatureImplemented(FEAT_MTE))
}

val HavePANExt : unit -> bool

function HavePANExt () = {
    return(IsFeatureImplemented(FEAT_PAN))
}

val HaveSSBSExt : unit -> bool

function HaveSSBSExt () = {
    return(IsFeatureImplemented(FEAT_SSBS))
}

val HaveUAOExt : unit -> bool

function HaveUAOExt () = {
    return(IsFeatureImplemented(FEAT_UAO))
}

val GetPSRFromPSTATE : forall 'N, 'N in {32, 64}.
  (ExceptionalOccurrenceTargetState, int('N)) -> bits('N)

function GetPSRFromPSTATE (targetELState, N) = {
    if UsingAArch32() & targetELState == AArch32_NonDebugState then {
        assert(N == 32)
    } else {
        assert(N == 64)
    };
    spsr : bits('N) = Zeros(N);
    spsr[31 .. 28] = PSTATE.N @ (PSTATE.Z @ (PSTATE.C @ PSTATE.V));
    if HavePANExt() then {
        spsr[22] = Bit(PSTATE.PAN)
    };
    spsr[20] = Bit(PSTATE.IL);
    if PSTATE.nRW == 0b1 then {
        spsr[27] = Bit(PSTATE.Q);
        spsr[26 .. 25] = PSTATE.IT[1 .. 0];
        if HaveSSBSExt() then {
            spsr[23] = Bit(PSTATE.SSBS)
        };
        if HaveDITExt() then {
            if targetELState == AArch32_NonDebugState then {
                spsr[21] = Bit(PSTATE.DIT)
            } else {
                spsr[24] = Bit(PSTATE.DIT)
            }
        };
        if targetELState == AArch64_NonDebugState | targetELState == DebugState then {
            spsr[21] = Bit(PSTATE.SS)
        };
        spsr[19 .. 16] = PSTATE.GE;
        spsr[15 .. 10] = PSTATE.IT[7 .. 2];
        spsr[9] = Bit(PSTATE.E);
        spsr[8 .. 6] = PSTATE.A @ (PSTATE.I @ PSTATE.F);
        spsr[5] = Bit(PSTATE.T);
        assert([PSTATE.M[4]] == PSTATE.nRW);
        spsr[4 .. 0] = PSTATE.M
    } else {
        if HaveMTEExt() then {
            spsr[25] = Bit(PSTATE.TCO)
        };
        if HaveGCS() then {
            assert(constraint(34 < 'N));
            spsr[34] = Bit(PSTATE.EXLOCK)
        };
        if HaveDITExt() then {
            spsr[24] = Bit(PSTATE.DIT)
        };
        if HaveUAOExt() then {
            spsr[23] = Bit(PSTATE.UAO)
        };
        spsr[21] = Bit(PSTATE.SS);
        if HaveFeatNMI() then {
            spsr[13] = Bit(PSTATE.ALLINT)
        };
        if HaveSSBSExt() then {
            spsr[12] = Bit(PSTATE.SSBS)
        };
        if HaveBTIExt() then {
            spsr[11 .. 10] = PSTATE.BTYPE
        };
        spsr[9 .. 6] = PSTATE.D @ (PSTATE.A @ (PSTATE.I @ PSTATE.F));
        spsr[4] = Bit(PSTATE.nRW);
        spsr[3 .. 2] = PSTATE.EL;
        spsr[0] = Bit(PSTATE.SP)
    };
    return(spsr)
}

val Havev8p9Debug : unit -> bool

function Havev8p9Debug () = {
    return(IsFeatureImplemented(FEAT_Debugv8p9))
}

val StopInstructionPrefetchAndEnableITR : unit -> unit

val ThisInstrAddr : forall 'N, 'N >= 0. int('N) -> bits('N)

function ThisInstrAddr N = {
    assert(N == 64 | N == 32 & UsingAArch32());
    return(_PC[N - 1 .. 0])
}

val UpdateEDSCRFields : unit -> unit

function UpdateEDSCRFields () = {
    ss : SecurityState = undefined;
    if not_bool(Halted()) then {
        EDSCR_write() = [EDSCR_read() with EL = 0b00];
        if HaveRME() then {
            EDSCR_write() = [EDSCR_read() with SDD = if ExternalRootInvasiveDebugEnabled() then
              0b0
            else
              0b1];
            {
                __tmp : EDSCR_Type = EDSCR_read();
                (__tmp[NSE] @ __tmp[NS]) = __UNKNOWN_bits(2);
                EDSCR_write() = __tmp
            }
        } else {
            EDSCR_write() = [EDSCR_read() with SDD = if ExternalSecureInvasiveDebugEnabled() then
              0b0
            else
              0b1];
            EDSCR_write() = [EDSCR_read() with NS = __UNKNOWN_bit()]
        };
        EDSCR_write() = [EDSCR_read() with RW = 0b1111]
    } else {
        EDSCR_write() = [EDSCR_read() with EL = PSTATE.EL];
        let ss : SecurityState = CurrentSecurityState();
        if HaveRME() then {
            match ss {
              SS_Secure => {
                  {
                      __tmp : EDSCR_Type = EDSCR_read();
                      (__tmp[NSE] @ __tmp[NS]) = 0b00;
                      EDSCR_write() = __tmp
                  }
              },
              SS_NonSecure => {
                  {
                      __tmp : EDSCR_Type = EDSCR_read();
                      (__tmp[NSE] @ __tmp[NS]) = 0b01;
                      EDSCR_write() = __tmp
                  }
              },
              SS_Root => {
                  {
                      __tmp : EDSCR_Type = EDSCR_read();
                      (__tmp[NSE] @ __tmp[NS]) = 0b10;
                      EDSCR_write() = __tmp
                  }
              },
              SS_Realm => {
                  {
                      __tmp : EDSCR_Type = EDSCR_read();
                      (__tmp[NSE] @ __tmp[NS]) = 0b11;
                      EDSCR_write() = __tmp
                  }
              }
            }
        } else {
            EDSCR_write() = [EDSCR_read() with NS = if ss == SS_Secure then 0b0
            else
              0b1]
        };
        RW : bits(4) = undefined;
        RW[1] = Bit(if ELUsingAArch32(EL1) then 0b0 else 0b1);
        if PSTATE.EL != EL0 then {
            RW[0] = Bit([RW[1]])
        } else {
            RW[0] = Bit(if UsingAArch32() then 0b0 else 0b1)
        };
        if not_bool(HaveEL(EL2)) | (HaveEL(EL3) & SCR_GEN_read()[NS] == 0b0) & not_bool(IsSecureEL2Enabled()) then {
            RW[2] = Bit([RW[1]])
        } else {
            RW[2] = Bit(if ELUsingAArch32(EL2) then 0b0 else 0b1)
        };
        if not_bool(HaveEL(EL3)) then {
            RW[3] = Bit([RW[2]])
        } else {
            RW[3] = Bit(if ELUsingAArch32(EL3) then 0b0 else 0b1)
        };
        if [RW[3]] == 0b0 then {
            RW[2 .. 0] = __UNKNOWN_bits(3)
        } else if [RW[2]] == 0b0 then {
            RW[1 .. 0] = __UNKNOWN_bits(2)
        } else if [RW[1]] == 0b0 then {
            RW[0] = Bit(__UNKNOWN_bit())
        } else ();
        EDSCR_write() = [EDSCR_read() with RW]
    };
    return()
}

val Halt : bits(6) -> unit

val Halt__1 : forall ('is_async : Bool). (bits(6), bool('is_async)) -> unit

function Halt reason = {
    let is_async : bool = false;
    Halt__1(reason, is_async)
}

function Halt__1 (reason, is_async) = {
    if HaveTME() & TSTATE.depth > 0 then {
        FailTransaction(TMFailure_DBG, false)
    };
    CTI_SignalEvent(CrossTriggerIn_CrossHalt);
    let preferred_restart_address : bits(64) = ThisInstrAddr(64);
    spsr : bits(64) = GetPSRFromPSTATE(DebugState, 64);
    if ((HaveBTIExt() & not_bool(is_async)) & not_bool(reason == DebugHalt_Step_Normal | reason == DebugHalt_Step_Exclusive | reason == DebugHalt_Step_NoSyndrome | reason == DebugHalt_Breakpoint | reason == DebugHalt_HaltInstruction)) & ConstrainUnpredictableBool(Unpredictable_ZEROBTYPE) then {
        spsr[11 .. 10] = 0b00
    };
    if UsingAArch32() then {
        DLR_write() = preferred_restart_address[31 .. 0];
        DSPSR_write() = Mk_DSPSR_Type(spsr[31 .. 0]);
        if Havev8p9Debug() then {
            DSPSR2_write() = Mk_DSPSR2_Type(spsr[63 .. 32])
        };
        ()
    } else {
        DLR_EL0 = preferred_restart_address;
        DSPSR_EL0 = Mk_DSPSR_EL0_Type(spsr)
    };
    EDSCR_write() = [EDSCR_read() with ITE = 0b1];
    EDSCR_write() = [EDSCR_read() with ITO = 0b0];
    if HaveRME() then {
        if PSTATE.EL == EL3 then {
            EDSCR_write() = [EDSCR_read() with SDD = 0b0]
        } else {
            EDSCR_write() = [EDSCR_read() with SDD = if ExternalRootInvasiveDebugEnabled() then
              0b0
            else
              0b1]
        }
    } else if CurrentSecurityState() == SS_Secure then {
        EDSCR_write() = [EDSCR_read() with SDD = 0b0]
    } else if HaveEL(EL3) then {
        EDSCR_write() = [EDSCR_read() with SDD = if ExternalSecureInvasiveDebugEnabled() then
          0b0
        else
          0b1]
    } else {
        EDSCR_write() = [EDSCR_read() with SDD = 0b1]
    };
    EDSCR_write() = [EDSCR_read() with MA = 0b0];
    if UsingAArch32() then {
        (PSTATE.IT @ PSTATE.SS @ PSTATE.SSBS @ PSTATE.A @ PSTATE.I @ PSTATE.F @ PSTATE.T) = __UNKNOWN_bits(14)
    } else {
        (PSTATE.SS @ PSTATE.SSBS @ PSTATE.D @ PSTATE.A @ PSTATE.I @ PSTATE.F) = __UNKNOWN_bits(6);
        PSTATE.TCO = 0b1;
        PSTATE.BTYPE = 0b00
    };
    PSTATE.IL = 0b0;
    StopInstructionPrefetchAndEnableITR();
    EDSCR_write() = [EDSCR_read() with STATUS = reason];
    UpdateEDSCRFields();
    if not_bool(is_async) then {
        EndOfInstruction()
    };
    return()
}

bitfield DBGOSDLR_Type : bits(32) = {DLK : 0..0}

bitfield OSDLR_EL1_Type : bits(64) = {DLK : 0..0}

register OSDLR_EL1 : OSDLR_EL1_Type

register _DBGOSDLR : DBGOSDLR_Type

val DBGOSDLR_read : unit -> DBGOSDLR_Type

function DBGOSDLR_read () = {
    r : DBGOSDLR_Type = _DBGOSDLR;
    r.bits[31 .. 0] = Slice(OSDLR_EL1.bits, 0, 32);
    return(r)
}

bitfield DBGPRCR_EL1_Type : bits(64) = {CORENPDRQ : 0..0}

register DBGPRCR_EL1 : DBGPRCR_EL1_Type

bitfield DBGPRCR_Type : bits(32) = {CORENPDRQ : 0..0}

register _DBGPRCR : DBGPRCR_Type

val DBGPRCR_read : unit -> DBGPRCR_Type

function DBGPRCR_read () = {
    r : DBGPRCR_Type = _DBGPRCR;
    r.bits[31 .. 0] = Slice(DBGPRCR_EL1.bits, 0, 32);
    return(r)
}

val HaveDoubleLock : unit -> bool

function HaveDoubleLock () = {
    return(IsFeatureImplemented(FEAT_DoubleLock))
}

val DoubleLockStatus : unit -> bool

function DoubleLockStatus () = {
    if not_bool(HaveDoubleLock()) then {
        return(false)
    } else if ELUsingAArch32(EL1) then {
        return((DBGOSDLR_read()[DLK] == 0b1 & DBGPRCR_read()[CORENPDRQ] == 0b0) & not_bool(Halted()))
    } else {
        return((OSDLR_EL1[DLK] == 0b1 & DBGPRCR_EL1[CORENPDRQ] == 0b0) & not_bool(Halted()))
    }
}

val HaltingAllowed : unit -> bool

function HaltingAllowed () = {
    if Halted() | DoubleLockStatus() then {
        return(false)
    };
    let ss : SecurityState = CurrentSecurityState();
    match ss {
      SS_NonSecure => {
          return(ExternalInvasiveDebugEnabled())
      },
      SS_Secure => {
          return(ExternalSecureInvasiveDebugEnabled())
      },
      SS_Root => {
          return(ExternalRootInvasiveDebugEnabled())
      },
      SS_Realm => {
          return(ExternalRealmInvasiveDebugEnabled())
      },
      _ => {
          return(undefined : bool)
      }
    }
}

val HavePMUv3p9 : unit -> bool

function HavePMUv3p9 () = {
    return(IsFeatureImplemented(FEAT_PMUv3p9))
}

val SetInterruptRequestLevel : (InterruptID, Signal) -> unit

val ShouldBRBEFreeze : unit -> bool

function ShouldBRBEFreeze () = {
    if not_bool(BranchRecordAllowed(PSTATE.EL)) then {
        return(false)
    };
    let check_e : bool = false;
    let check_cnten : bool = false;
    let check_inten : bool = false;
    let exclude_sync : bool = false;
    let exclude_cyc : bool = true;
    include_lo_name : bool = undefined;
    include_hi_name : bool = undefined;
    if HaveEL(EL2) then {
        include_lo_name = BRBCR_EL1[FZP] == 0b1;
        include_hi_name = BRBCR_EL2[FZP] == 0b1
    } else {
        include_lo_name = true;
        include_hi_name = true
    };
    return(PMUOverflowCondition(check_e, check_cnten, check_inten, include_hi_name, include_lo_name, exclude_cyc, exclude_sync))
}

val CheckForPMUOverflow : unit -> unit

function CheckForPMUOverflow () = {
    let check_cnten : bool = false;
    let check_e : bool = true;
    let check_inten : bool = true;
    let include_lo_name : bool = true;
    let include_hi_name : bool = true;
    let exclude_cyc : bool = false;
    let exclude_sync : bool = false;
    let pmuirq : bool = PMUOverflowCondition(check_e, check_cnten, check_inten, include_hi_name, include_lo_name, exclude_cyc, exclude_sync);
    SetInterruptRequestLevel(InterruptID_PMUIRQ, if pmuirq then Signal_High else
      Signal_Low);
    CTI_SetEventLevel(CrossTriggerIn_PMUOverflow, if pmuirq then Signal_High
    else
      Signal_Low);
    if HavePMUv3p9() & Havev8p9Debug() then {
        if (pmuirq & HaltingAllowed()) & EDECR[PME] == 0b1 then {
            Halt(DebugHalt_EDBGRQ)
        };
        ()
    };
    if ShouldBRBEFreeze() then {
        BRBEFreeze()
    };
    return()
}

val IsAligned__1 : forall 'N 'y, 'N >= 0. (bits('N), int('y)) -> bool

function IsAligned__1 (x, y) = {
    return(x == Align(x, y))
}

val Split : forall 'M 'N,
  'M > 'N & 'M >= 0 & 0 <= 'N - 1.
  (bits('M), int('N)) -> (bits('M - 'N), bits('N))

function Split (value_name, N) = {
    assert('M > N);
    return((value_name['M - 1 .. N], value_name[N - 1 .. 0]))
}

val RShr : forall ('round : Bool) 'shift 'value_name.
  (int('value_name), int('shift), bool('round)) -> int

function RShr (value_name, shift, round) = {
    assert(shift > 0);
    if round then {
        return(((value_name + (1 << (shift - 1))) >> shift))
    } else {
        return((value_name >> shift))
    }
}

val IsHighestEL : bits(2) -> bool

function IsHighestEL el = {
    return(HighestEL() == el)
}

val HaveFP16Ext : unit -> bool

val EffectiveSCR_EL3_NSE : unit -> bits(1)

function EffectiveSCR_EL3_NSE () = {
    return(if not_bool(HaveRME()) then 0b0 else SCR_EL3[NSE])
}

val ELFromM32 : bits(5) -> (bool, bits(2))

function ELFromM32 mode = {
    el : bits(2) = undefined;
    valid_name : bool = not_bool(BadMode(mode));
    let effective_nse_ns : bits(2) = EffectiveSCR_EL3_NSE() @ EffectiveSCR_EL3_NS();
    match mode {
      ? if ? == M32_Monitor => {
          el = EL3
      },
      ? if ? == M32_Hyp => {
          el = EL2
      },
      ? if ? == M32_FIQ => {
          el = if (HaveEL(EL3) & not_bool(HaveAArch64())) & SCR[NS] == 0b0 then
            EL3
          else
            EL1
      },
      ? if ? == M32_IRQ => {
          el = if (HaveEL(EL3) & not_bool(HaveAArch64())) & SCR[NS] == 0b0 then
            EL3
          else
            EL1
      },
      ? if ? == M32_Svc => {
          el = if (HaveEL(EL3) & not_bool(HaveAArch64())) & SCR[NS] == 0b0 then
            EL3
          else
            EL1
      },
      ? if ? == M32_Abort => {
          el = if (HaveEL(EL3) & not_bool(HaveAArch64())) & SCR[NS] == 0b0 then
            EL3
          else
            EL1
      },
      ? if ? == M32_Undef => {
          el = if (HaveEL(EL3) & not_bool(HaveAArch64())) & SCR[NS] == 0b0 then
            EL3
          else
            EL1
      },
      ? if ? == M32_System => {
          el = if (HaveEL(EL3) & not_bool(HaveAArch64())) & SCR[NS] == 0b0 then
            EL3
          else
            EL1
      },
      ? if ? == M32_User => {
          el = EL0
      },
      _ => {
          valid_name = false
      }
    };
    if ((valid_name & el == EL2) & HaveEL(EL3)) & SCR_GEN_read()[NS] == 0b0 then {
        valid_name = false
    } else if (valid_name & HaveRME()) & effective_nse_ns == 0b10 then {
        valid_name = false
    } else ();
    if not_bool(valid_name) then {
        el = __UNKNOWN_bits(2)
    };
    let el = el;
    return((valid_name, el))
}

val ELFromSPSR : forall 'N, 4 < 'N. bits('N) -> (bool, bits(2))

function ELFromSPSR spsr = {
    el : bits(2) = undefined;
    valid_name : bool = undefined;
    effective_nse_ns : bits(2) = undefined;
    if [spsr[4]] == 0b0 then {
        el = spsr[3 .. 2];
        let effective_nse_ns : bits(2) = EffectiveSCR_EL3_NSE() @ EffectiveSCR_EL3_NS();
        if not_bool(HaveAArch64()) then {
            valid_name = false
        } else if not_bool(HaveEL(el)) then {
            valid_name = false
        } else if [spsr[1]] == 0b1 then {
            valid_name = false
        } else if el == EL0 & [spsr[0]] == 0b1 then {
            valid_name = false
        } else if (HaveRME() & el != EL3) & effective_nse_ns == 0b10 then {
            valid_name = false
        } else if ((el == EL2 & HaveEL(EL3)) & not_bool(IsSecureEL2Enabled())) & SCR_EL3[NS] == 0b0 then {
            valid_name = false
        } else {
            valid_name = true
        }
    } else if HaveAArch32() then {
        (valid_name, el) = ELFromM32(spsr[4 .. 0])
    } else {
        valid_name = false
    };
    if not_bool(valid_name) then {
        el = __UNKNOWN_bits(2)
    };
    let el = el;
    return((valid_name, el))
}

val ELUsingAArch32K : bits(2) -> (bool, bool)

function ELUsingAArch32K el = {
    return(ELStateUsingAArch32K(el, IsSecureBelowEL3()))
}

bitfield GCSCR_EL1_Type : bits(64) =
  {STREn : 9..9, PUSHMEn : 8..8, EXLOCKEN : 6..6, RVCHKEN : 5..5, PCRSEL : 0..0}

register GCSCR_EL1 : GCSCR_EL1_Type

bitfield GCSCR_EL2_Type : bits(64) =
  {STREn : 9..9, PUSHMEn : 8..8, EXLOCKEN : 6..6, RVCHKEN : 5..5, PCRSEL : 0..0}

register GCSCR_EL2 : GCSCR_EL2_Type

bitfield GCSCR_EL3_Type : bits(64) =
  {STREn : 9..9, PUSHMEn : 8..8, EXLOCKEN : 6..6, RVCHKEN : 5..5, PCRSEL : 0..0}

register GCSCR_EL3 : GCSCR_EL3_Type

val GetCurrentEXLOCKEN : unit -> bool

function GetCurrentEXLOCKEN () = {
    match PSTATE.EL {
      ? if ? == EL0 => {
          Unreachable();
          return(undefined : bool)
      },
      ? if ? == EL1 => {
          return(GCSCR_EL1[EXLOCKEN] == 0b1)
      },
      ? if ? == EL2 => {
          return(GCSCR_EL2[EXLOCKEN] == 0b1)
      },
      ? if ? == EL3 => {
          return(GCSCR_EL3[EXLOCKEN] == 0b1)
      },
      _ => {
          return(undefined : bool)
      }
    }
}

val IllegalExceptionReturn : forall 'N, 4 < 'N. bits('N) -> bool

function IllegalExceptionReturn spsr = {
    known : bool = undefined;
    target : bits(2) = undefined;
    target_el_is_aarch32 : bool = undefined;
    valid_name : bool = undefined;
    (valid_name, target) = ELFromSPSR(spsr);
    if not_bool(valid_name) then {
        return(true)
    };
    if UInt(target) > UInt(PSTATE.EL) then {
        return(true)
    };
    let spsr_mode_is_aarch32 : bool = [spsr[4]] == 0b1;
    (known, target_el_is_aarch32) = ELUsingAArch32K(target);
    assert(known | target == EL0 & not_bool(ELUsingAArch32(EL1)));
    if known & spsr_mode_is_aarch32 != target_el_is_aarch32 then {
        return(true)
    };
    if UsingAArch32() & not_bool(spsr_mode_is_aarch32) then {
        return(true)
    };
    if (HaveEL(EL2) & target == EL1) & HCR_EL2[TGE] == 0b1 then {
        if not_bool(IsSecureBelowEL3()) | IsSecureEL2Enabled() then {
            return(true)
        };
        ()
    };
    if (((HaveGCS() & PSTATE.EXLOCK == 0b0) & PSTATE.EL == target) & GetCurrentEXLOCKEN()) & not_bool(Halted()) then {
        return(true)
    };
    return(false)
}

val AArch32_WriteMode : bits(5) -> unit

function AArch32_WriteMode mode = {
    el : bits(2) = undefined;
    valid_name : bool = undefined;
    (valid_name, el) = ELFromM32(mode);
    assert(valid_name);
    PSTATE.M = mode;
    PSTATE.EL = el;
    PSTATE.nRW = 0b1;
    PSTATE.SP = if mode == M32_User | mode == M32_System then 0b0 else 0b1;
    return()
}

val NonSecureOnlyImplementation : unit -> bool

function NonSecureOnlyImplementation () = {
    return(__IMPDEF_boolean("Non-secure only implementation"))
}

val AArch32_SelfHostedSecurePrivilegedInvasiveDebugEnabled : unit -> bool

function AArch32_SelfHostedSecurePrivilegedInvasiveDebugEnabled () = {
    if not_bool(HaveEL(EL3)) & NonSecureOnlyImplementation() then {
        return(false)
    };
    return(DBGEN == Signal_High & SPIDEN == Signal_High)
}

bitfield MDSCR_EL1_Type : bits(64) =
  {
    EHBWE : 35..35,
    EnSPM : 34..34,
    EMBWE : 32..32,
    TFO : 31..31,
    RXfull : 30..30,
    TXfull : 29..29,
    RXO : 27..27,
    TXU : 26..26,
    INTdis : 23..22,
    TDA : 21..21,
    SC2 : 19..19,
    MDE : 15..15,
    HDE : 14..14,
    KDE : 13..13,
    TDCC : 12..12,
    ERR : 6..6,
    SS : 0..0
  }

register MDSCR_EL1 : MDSCR_EL1_Type

bitfield OSLSR_EL1_Type : bits(64) =
  {OSLM : (3..3 @ 0..0), nTT : 2..2, OSLK : 1..1}

register OSLSR_EL1 : OSLSR_EL1_Type

val AArch64_GenerateDebugExceptionsFrom : (bits(2), SecurityState, bits(1)) -> bool

function AArch64_GenerateDebugExceptionsFrom (from_el, from_state, mask) = {
    if (OSLSR_EL1[OSLK] == 0b1 | DoubleLockStatus()) | Halted() then {
        return(false)
    };
    let route_to_el2 : bool = (HaveEL(EL2) & (from_state != SS_Secure | IsSecureEL2Enabled())) & (HCR_EL2[TGE] == 0b1 | MDCR_EL2[TDE] == 0b1);
    let target : bits(2) = if route_to_el2 then EL2 else EL1;
    enabled : bool = undefined;
    if HaveEL(EL3) & from_state == SS_Secure then {
        enabled = MDCR_EL3[SDD] == 0b0;
        if from_el == EL0 & ELUsingAArch32(EL1) then {
            enabled = enabled | SDER32_EL3_read()[SUIDEN] == 0b1
        };
        ()
    } else {
        enabled = true
    };
    if from_el == target then {
        enabled = (enabled & MDSCR_EL1[KDE] == 0b1) & mask == 0b0
    } else {
        enabled = enabled & UInt(target) > UInt(from_el)
    };
    return(enabled)
}

bitfield DBGOSLSR_Type : bits(32) =
  {OSLM : (3..3 @ 0..0), nTT : 2..2, OSLK : 1..1}

register _DBGOSLSR : DBGOSLSR_Type

val DBGOSLSR_read : unit -> DBGOSLSR_Type

function DBGOSLSR_read () = {
    r : DBGOSLSR_Type = _DBGOSLSR;
    r.bits[31 .. 0] = Slice(OSLSR_EL1.bits, 0, 32);
    return(r)
}

bitfield HCR_Type : bits(32) =
  {
    TRVM : 30..30,
    HCD : 29..29,
    TGE : 27..27,
    TVM : 26..26,
    TTLB : 25..25,
    TPU : 24..24,
    TPC : 23..23,
    TSW : 22..22,
    TAC : 21..21,
    TIDCP : 20..20,
    TSC : 19..19,
    TID3 : 18..18,
    TID2 : 17..17,
    TID1 : 16..16,
    TID0 : 15..15,
    TWE : 14..14,
    TWI : 13..13,
    DC : 12..12,
    BSU : 11..10,
    FB : 9..9,
    VA : 8..8,
    VI : 7..7,
    VF : 6..6,
    AMO : 5..5,
    IMO : 4..4,
    FMO : 3..3,
    PTW : 2..2,
    SWIO : 1..1,
    VM : 0..0
  }

register _HCR : HCR_Type

val HCR_read : unit -> HCR_Type

function HCR_read () = {
    r : HCR_Type = _HCR;
    r.bits[31 .. 0] = Slice(HCR_EL2.bits, 0, 32);
    return(r)
}

val DebugTargetFrom : SecurityState -> bits(2)

function DebugTargetFrom from_state = {
    route_to_el2 : bool = undefined;
    if HaveEL(EL2) & (from_state != SS_Secure | HaveSecureEL2Ext() & (not_bool(HaveEL(EL3)) | SCR_EL3[EEL2] == 0b1)) then {
        if ELUsingAArch32(EL2) then {
            route_to_el2 = HDCR_read()[TDE] == 0b1 | HCR_read()[TGE] == 0b1
        } else {
            route_to_el2 = MDCR_EL2[TDE] == 0b1 | HCR_EL2[TGE] == 0b1
        }
    } else {
        route_to_el2 = false
    };
    target : bits(2) = undefined;
    if route_to_el2 then {
        target = EL2
    } else if (HaveEL(EL3) & not_bool(HaveAArch64())) & from_state == SS_Secure then {
        target = EL3
    } else {
        target = EL1
    };
    return(target)
}

val AArch32_GenerateDebugExceptionsFrom : (bits(2), SecurityState) -> bool

function AArch32_GenerateDebugExceptionsFrom (from_el, from_state) = {
    mask : bits(1) = undefined;
    spd : bits(2) = undefined;
    if not_bool(ELUsingAArch32(DebugTargetFrom(from_state))) then {
        let mask : bits(1) = 0b0;
        return(AArch64_GenerateDebugExceptionsFrom(from_el, from_state, mask))
    };
    if (DBGOSLSR_read()[OSLK] == 0b1 | DoubleLockStatus()) | Halted() then {
        return(false)
    };
    enabled : bool = undefined;
    if HaveEL(EL3) & from_state == SS_Secure then {
        assert(from_el != EL2);
        if IsSecureEL2Enabled() then {
            enabled = MDCR_EL3[SDD] == 0b0
        } else {
            let spd : bits(2) = if ELUsingAArch32(EL3) then SDCR[SPD] else
              MDCR_EL3[SPD32];
            if [spd[1]] == 0b1 then {
                enabled = [spd[0]] == 0b1
            } else {
                enabled = AArch32_SelfHostedSecurePrivilegedInvasiveDebugEnabled()
            }
        };
        if from_el == EL0 then {
            enabled = enabled | SDER_read()[SUIDEN] == 0b1
        };
        ()
    } else {
        enabled = from_el != EL2
    };
    return(enabled)
}

val AArch32_GenerateDebugExceptions : unit -> bool

function AArch32_GenerateDebugExceptions () = {
    let ss : SecurityState = CurrentSecurityState();
    return(AArch32_GenerateDebugExceptionsFrom(PSTATE.EL, ss))
}

val AArch64_GenerateDebugExceptions : unit -> bool

function AArch64_GenerateDebugExceptions () = {
    let ss : SecurityState = CurrentSecurityState();
    return(AArch64_GenerateDebugExceptionsFrom(PSTATE.EL, ss, PSTATE.D))
}

val Restarting : unit -> bool

function Restarting () = {
    return(EDSCR_read()[STATUS] == 0b000001)
}

val DebugExceptionReturnSS : forall 'N, 4 < 'N. bits('N) -> bits(1)

function DebugExceptionReturnSS spsr = {
    assert((Halted() | Restarting()) | PSTATE.EL != EL0);
    enabled_at_source : bool = undefined;
    if Restarting() then {
        enabled_at_source = false
    } else if UsingAArch32() then {
        enabled_at_source = AArch32_GenerateDebugExceptions()
    } else {
        enabled_at_source = AArch64_GenerateDebugExceptions()
    };
    valid_name : bool = undefined;
    dest_el : bits(2) = undefined;
    if IllegalExceptionReturn(spsr) then {
        dest_el = PSTATE.EL
    } else {
        (valid_name, dest_el) = ELFromSPSR(spsr);
        assert(valid_name)
    };
    let dest_ss : SecurityState = SecurityStateAtEL(dest_el);
    mask : bits(1) = undefined;
    enabled_at_dest : bool = undefined;
    let dest_using_32 : bool = if dest_el == EL0 then [spsr[4]] == 0b1 else
      ELUsingAArch32(dest_el);
    if dest_using_32 then {
        enabled_at_dest = AArch32_GenerateDebugExceptionsFrom(dest_el, dest_ss)
    } else {
        assert(constraint(9 < 'N));
        let mask : bits(1) = [spsr[9]];
        enabled_at_dest = AArch64_GenerateDebugExceptionsFrom(dest_el, dest_ss, mask)
    };
    let ELd : bits(2) = DebugTargetFrom(dest_ss);
    SS_bit : bits(1) = undefined;
    if ((not_bool(ELUsingAArch32(ELd)) & MDSCR_EL1[SS] == 0b1) & not_bool(enabled_at_source)) & enabled_at_dest then {
        assert(constraint(21 < 'N));
        SS_bit = [spsr[21]]
    } else {
        SS_bit = 0b0
    };
    return(SS_bit)
}

bitfield HSCTLR_Type : bits(32) =
  {
    DSSBS : 31..31,
    TE : 30..30,
    EE : 25..25,
    WXN : 19..19,
    I : 12..12,
    SED : 8..8,
    ITD : 7..7,
    CP15BEN : 5..5,
    LSMAOE : 4..4,
    nTLSMD : 3..3,
    C : 2..2,
    A : 1..1,
    M : 0..0
  }

bitfield SCTLR_EL2_Type : bits(64) =
  {
    TIDCP : 63..63,
    SPINTMASK : 62..62,
    NMI : 61..61,
    EnTP2 : 60..60,
    TCSO : 59..59,
    TCSO0 : 58..58,
    EPAN : 57..57,
    EnALS : 56..56,
    EnAS0 : 55..55,
    EnASR : 54..54,
    TME : 53..53,
    TME0 : 52..52,
    TMT : 51..51,
    TMT0 : 50..50,
    TWEDEL : 49..46,
    TWEDEn : 45..45,
    DSSBS : 44..44,
    ATA : 43..43,
    ATA0 : 42..42,
    TCF : 41..40,
    TCF0 : 39..38,
    ITFSB : 37..37,
    BT : 36..36,
    BT0 : 35..35,
    MSCEn : 33..33,
    CMOW : 32..32,
    EnIA : 31..31,
    EnIB : 30..30,
    LSMAOE : 29..29,
    nTLSMD : 28..28,
    EnDA : 27..27,
    UCI : 26..26,
    EE : 25..25,
    E0E : 24..24,
    SPAN : 23..23,
    EIS : 22..22,
    IESB : 21..21,
    TSCXT : 20..20,
    WXN : 19..19,
    nTWE : 18..18,
    nTWI : 16..16,
    UCT : 15..15,
    DZE : 14..14,
    EnDB : 13..13,
    I : 12..12,
    EOS : 11..11,
    EnRCTX : 10..10,
    SED : 8..8,
    ITD : 7..7,
    nAA : 6..6,
    CP15BEN : 5..5,
    SA0 : 4..4,
    SA : 3..3,
    C : 2..2,
    A : 1..1,
    M : 0..0
  }

register SCTLR_EL2 : SCTLR_EL2_Type

register _HSCTLR : HSCTLR_Type

val HSCTLR_read : unit -> HSCTLR_Type

function HSCTLR_read () = {
    r : HSCTLR_Type = _HSCTLR;
    r.bits[31 .. 0] = Slice(SCTLR_EL2.bits, 0, 32);
    return(r)
}

bitfield SCTLR_EL1_Type : bits(64) =
  {
    TIDCP : 63..63,
    SPINTMASK : 62..62,
    NMI : 61..61,
    EnTP2 : 60..60,
    TCSO : 59..59,
    TCSO0 : 58..58,
    EPAN : 57..57,
    EnALS : 56..56,
    EnAS0 : 55..55,
    EnASR : 54..54,
    TME : 53..53,
    TME0 : 52..52,
    TMT : 51..51,
    TMT0 : 50..50,
    TWEDEL : 49..46,
    TWEDEn : 45..45,
    DSSBS : 44..44,
    ATA : 43..43,
    ATA0 : 42..42,
    TCF : 41..40,
    TCF0 : 39..38,
    ITFSB : 37..37,
    BT1 : 36..36,
    BT0 : 35..35,
    MSCEn : 33..33,
    CMOW : 32..32,
    EnIA : 31..31,
    EnIB : 30..30,
    LSMAOE : 29..29,
    nTLSMD : 28..28,
    EnDA : 27..27,
    UCI : 26..26,
    EE : 25..25,
    E0E : 24..24,
    SPAN : 23..23,
    EIS : 22..22,
    IESB : 21..21,
    TSCXT : 20..20,
    WXN : 19..19,
    nTWE : 18..18,
    nTWI : 16..16,
    UCT : 15..15,
    DZE : 14..14,
    EnDB : 13..13,
    I : 12..12,
    EOS : 11..11,
    EnRCTX : 10..10,
    UMA : 9..9,
    SED : 8..8,
    ITD : 7..7,
    nAA : 6..6,
    CP15BEN : 5..5,
    SA0 : 4..4,
    SA : 3..3,
    C : 2..2,
    A : 1..1,
    M : 0..0
  }

register SCTLR_EL1 : SCTLR_EL1_Type

bitfield SCTLR_EL3_Type : bits(64) =
  {
    SPINTMASK : 62..62,
    NMI : 61..61,
    TCSO : 59..59,
    TME : 53..53,
    TMT : 51..51,
    DSSBS : 44..44,
    ATA : 43..43,
    TCF : 41..40,
    ITFSB : 37..37,
    BT : 36..36,
    EnIA : 31..31,
    EnIB : 30..30,
    EnDA : 27..27,
    EE : 25..25,
    EIS : 22..22,
    IESB : 21..21,
    WXN : 19..19,
    EnDB : 13..13,
    I : 12..12,
    EOS : 11..11,
    nAA : 6..6,
    SA : 3..3,
    C : 2..2,
    A : 1..1,
    M : 0..0
  }

register SCTLR_EL3 : SCTLR_EL3_Type

bitfield SCTLR_Type : bits(32) =
  {
    DSSBS : 31..31,
    TE : 30..30,
    AFE : 29..29,
    TRE : 28..28,
    EE : 25..25,
    SPAN : 23..23,
    UWXN : 20..20,
    WXN : 19..19,
    nTWE : 18..18,
    nTWI : 16..16,
    V : 13..13,
    I : 12..12,
    EnRCTX : 10..10,
    SED : 8..8,
    ITD : 7..7,
    UNK : 6..6,
    CP15BEN : 5..5,
    LSMAOE : 4..4,
    nTLSMD : 3..3,
    C : 2..2,
    A : 1..1,
    M : 0..0
  }

register _SCTLR_NS : SCTLR_Type

val SCTLR_NS_read : unit -> SCTLR_Type

function SCTLR_NS_read () = {
    r : SCTLR_Type = _SCTLR_NS;
    r.bits[31 .. 0] = Slice(SCTLR_EL1.bits, 0, 32);
    return(r)
}

register SCTLR_S : SCTLR_Type

val SCTLR_read : bits(2) -> SCTLRType

val SCTLR_read__1 : unit -> SCTLRType

val SCTLR_read__2 : unit -> SCTLR_Type

function SCTLR_read__2 () = {
    r : SCTLR_Type = undefined;
    if ELUsingAArch32(EL3) & CurrentSecurityState() == SS_Secure then {
        r = SCTLR_S;
        r.bits[11] = Bit(0b1);
        r.bits[22] = Bit(0b1)
    } else {
        r = SCTLR_NS_read();
        r.bits[11] = Bit(0b1);
        r.bits[22] = Bit(0b1)
    };
    return(r)
}

function SCTLR_read regime = {
    r : bits(64) = undefined;
    match regime {
      ? if ? == EL1 => {
          r = SCTLR_EL1.bits
      },
      ? if ? == EL2 => {
          r = SCTLR_EL2.bits
      },
      ? if ? == EL3 => {
          r = SCTLR_EL3.bits
      },
      _ => {
          Unreachable()
      }
    };
    return(Mk_SCTLRType(r))
}

function SCTLR_read__1 () = {
    return(SCTLR_read(S1TranslationRegime__1()))
}

val RestoredITBits : forall 'N, 26 < 'N. bits('N) -> bits(8)

function RestoredITBits spsr = {
    let it : bits(8) = spsr[15 .. 10] @ spsr[26 .. 25];
    if PSTATE.IL == 0b1 then {
        if ConstrainUnpredictableBool(Unpredictable_ILZEROIT) then {
            return(0b00000000)
        } else {
            return(it)
        }
    };
    if not_bool(IsZero(it[7 .. 4])) & IsZero(it[3 .. 0]) then {
        return(0b00000000)
    };
    let itd : bits(1) = if PSTATE.EL == EL2 then HSCTLR_read()[ITD] else
      SCTLR_read__2()[ITD];
    if [spsr[5]] == 0b0 & not_bool(IsZero(it)) | itd == 0b1 & not_bool(IsZero(it[2 .. 0])) then {
        return(0b00000000)
    } else {
        return(it)
    }
}

val SetPSTATEFromPSR : forall 'N, 31 < 'N. bits('N) -> unit

val SetPSTATEFromPSR__1 : forall 'N ('illegal_psr_state : Bool), 31 < 'N.
  (bits('N), bool('illegal_psr_state)) -> unit

function SetPSTATEFromPSR spsr = {
    let illegal_psr_state : bool = IllegalExceptionReturn(spsr);
    SetPSTATEFromPSR__1(spsr, illegal_psr_state)
}

function SetPSTATEFromPSR__1 (spsr_in, illegal_psr_state) = {
    spsr : bits('N) = spsr_in;
    let from_aarch64 : bool = not_bool(UsingAArch32());
    PSTATE.SS = DebugExceptionReturnSS(spsr);
    ShouldAdvanceSS = false;
    if illegal_psr_state then {
        PSTATE.IL = 0b1;
        if HaveSSBSExt() then {
            PSTATE.SSBS = __UNKNOWN_bit()
        };
        if HaveBTIExt() then {
            PSTATE.BTYPE = __UNKNOWN_bits(2)
        };
        if HaveUAOExt() then {
            PSTATE.UAO = __UNKNOWN_bit()
        };
        if HaveDITExt() then {
            PSTATE.DIT = __UNKNOWN_bit()
        };
        if HaveMTEExt() then {
            PSTATE.TCO = __UNKNOWN_bit()
        };
        ()
    } else {
        assert(constraint(20 < 'N));
        PSTATE.IL = [spsr[20]];
        if [spsr[4]] == 0b1 then {
            AArch32_WriteMode(spsr[4 .. 0]);
            if HaveSSBSExt() then {
                assert(constraint(23 < 'N));
                PSTATE.SSBS = [spsr[23]]
            };
            ()
        } else {
            PSTATE.nRW = 0b0;
            PSTATE.EL = spsr[3 .. 2];
            PSTATE.SP = [spsr[0]];
            if HaveBTIExt() then {
                PSTATE.BTYPE = spsr[11 .. 10]
            };
            if HaveSSBSExt() then {
                PSTATE.SSBS = [spsr[12]]
            };
            if HaveUAOExt() then {
                assert(constraint(23 < 'N));
                PSTATE.UAO = [spsr[23]]
            };
            if HaveDITExt() then {
                assert(constraint(24 < 'N));
                PSTATE.DIT = [spsr[24]]
            };
            if HaveMTEExt() then {
                assert(constraint(25 < 'N));
                PSTATE.TCO = [spsr[25]]
            };
            if HaveGCS() then {
                assert(constraint(34 < 'N));
                PSTATE.EXLOCK = [spsr[34]]
            };
            ()
        }
    };
    if PSTATE.IL == 0b1 & PSTATE.nRW == 0b1 then {
        if ConstrainUnpredictableBool(Unpredictable_ILZEROT) then {
            assert(constraint(5 < 'N));
            spsr[5] = Bit(0b0)
        };
        ()
    };
    (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V) = spsr[31 .. 28];
    if HavePANExt() then {
        PSTATE.PAN = [spsr[22]]
    };
    if PSTATE.nRW == 0b1 then {
        PSTATE.Q = [spsr[27]];
        PSTATE.IT = RestoredITBits(spsr);
        ShouldAdvanceIT = false;
        if HaveDITExt() then {
            PSTATE.DIT = if Restarting() | from_aarch64 then [spsr[24]] else
              [spsr[21]]
        };
        PSTATE.GE = spsr[19 .. 16];
        PSTATE.E = [spsr[9]];
        (PSTATE.A @ PSTATE.I @ PSTATE.F) = spsr[8 .. 6];
        PSTATE.T = [spsr[5]]
    } else {
        if HaveFeatNMI() then {
            PSTATE.ALLINT = [spsr[13]]
        };
        (PSTATE.D @ PSTATE.A @ PSTATE.I @ PSTATE.F) = spsr[9 .. 6]
    };
    return()
}

val PLOfEL : bits(2) -> PrivilegeLevel

function PLOfEL el = {
    match el {
      ? if ? == EL3 => {
          return(if not_bool(HaveAArch64()) then PL1 else PL3)
      },
      ? if ? == EL2 => {
          return(PL2)
      },
      ? if ? == EL1 => {
          return(PL1)
      },
      ? if ? == EL0 => {
          return(PL0)
      },
      _ => {
          return(undefined : PrivilegeLevel)
      }
    }
}

val IsCurrentSecurityState : SecurityState -> bool

function IsCurrentSecurityState ss = {
    return(CurrentSecurityState() == ss)
}

val ConditionHolds : bits(4) -> bool

function ConditionHolds cond = {
    result : bool = undefined;
    match cond[3 .. 1] {
      0b000 => {
          result = PSTATE.Z == 0b1
      },
      0b001 => {
          result = PSTATE.C == 0b1
      },
      0b010 => {
          result = PSTATE.N == 0b1
      },
      0b011 => {
          result = PSTATE.V == 0b1
      },
      0b100 => {
          result = PSTATE.C == 0b1 & PSTATE.Z == 0b0
      },
      0b101 => {
          result = PSTATE.N == PSTATE.V
      },
      0b110 => {
          result = PSTATE.N == PSTATE.V & PSTATE.Z == 0b0
      },
      0b111 => {
          result = true
      }
    };
    if [cond[0]] == 0b1 & cond != 0b1111 then {
        result = not_bool(result)
    };
    return(result)
}

val AArch64_MaybeZeroRegisterUppers : unit -> unit

function AArch64_MaybeZeroRegisterUppers () = {
    assert(UsingAArch32());
    first : {'first, 'first == 0. int('first)} = 0;
    last : {14, 30} = 14;
    include_R15_name : bool = undefined;
    if PSTATE.EL == EL0 & not_bool(ELUsingAArch32(EL1)) then {
        first = 0;
        last = 14;
        include_R15_name = false
    } else if ((PSTATE.EL == EL0 | PSTATE.EL == EL1) & EL2Enabled()) & not_bool(ELUsingAArch32(EL2)) then {
        first = 0;
        last = 30;
        include_R15_name = false
    } else {
        first = 0;
        last = 30;
        include_R15_name = true
    };
    let 'last = last;
    let 'first = first;
    foreach (n from first to last by 1 in inc) {
        if (n != 15 | include_R15_name) & ConstrainUnpredictableBool(Unpredictable_ZEROUPPER) then {
            _R(n, 63, 32) = Zeros(32)
        };
        ()
    };
    return()
}

val ThisInstrLength : unit -> int

val AArch64_ExceptionClass : (Exception, bits(2)) -> (int, bits(1))

function AArch64_ExceptionClass (exceptype, target_el) = {
    il_is_valid : bool = true;
    let from_32 : bool = UsingAArch32();
    ec : int = undefined;
    match exceptype {
      Exception_Uncategorized => {
          ec = UInt(0x00);
          il_is_valid = false
      },
      Exception_WFxTrap => {
          ec = UInt(0x01)
      },
      Exception_CP15RTTrap => {
          ec = UInt(0x03);
          assert(from_32)
      },
      Exception_CP15RRTTrap => {
          ec = UInt(0x04);
          assert(from_32)
      },
      Exception_CP14RTTrap => {
          ec = UInt(0x05);
          assert(from_32)
      },
      Exception_CP14DTTrap => {
          ec = UInt(0x06);
          assert(from_32)
      },
      Exception_AdvSIMDFPAccessTrap => {
          ec = UInt(0x07)
      },
      Exception_FPIDTrap => {
          ec = UInt(0x08)
      },
      Exception_PACTrap => {
          ec = UInt(0x09)
      },
      Exception_LDST64BTrap => {
          ec = UInt(0x0A)
      },
      Exception_TSTARTAccessTrap => {
          ec = UInt(0x1B)
      },
      Exception_GPC => {
          ec = UInt(0x1E)
      },
      Exception_CP14RRTTrap => {
          ec = UInt(0x0C);
          assert(from_32)
      },
      Exception_BranchTarget => {
          ec = UInt(0x0D)
      },
      Exception_IllegalState => {
          ec = UInt(0x0E);
          il_is_valid = false
      },
      Exception_SupervisorCall => {
          ec = UInt(0x11)
      },
      Exception_HypervisorCall => {
          ec = UInt(0x12)
      },
      Exception_MonitorCall => {
          ec = UInt(0x13)
      },
      Exception_SystemRegisterTrap => {
          ec = UInt(0x18);
          assert(not_bool(from_32))
      },
      Exception_SystemRegister128Trap => {
          ec = UInt(0x14);
          assert(not_bool(from_32))
      },
      Exception_SVEAccessTrap => {
          ec = UInt(0x19);
          assert(not_bool(from_32))
      },
      Exception_ERetTrap => {
          ec = UInt(0x1A);
          assert(not_bool(from_32))
      },
      Exception_PACFail => {
          ec = UInt(0x1C);
          assert(not_bool(from_32))
      },
      Exception_SMEAccessTrap => {
          ec = UInt(0x1D);
          assert(not_bool(from_32))
      },
      Exception_InstructionAbort => {
          ec = UInt(0x20);
          il_is_valid = false
      },
      Exception_PCAlignment => {
          ec = UInt(0x22);
          il_is_valid = false
      },
      Exception_DataAbort => {
          ec = UInt(0x24)
      },
      Exception_NV2DataAbort => {
          ec = UInt(0x25)
      },
      Exception_SPAlignment => {
          ec = UInt(0x26);
          il_is_valid = false;
          assert(not_bool(from_32))
      },
      Exception_MemCpyMemSet => {
          ec = UInt(0x27)
      },
      Exception_GCSFail => {
          ec = UInt(0x2D);
          assert(not_bool(from_32))
      },
      Exception_FPTrappedException => {
          ec = UInt(0x28)
      },
      Exception_SError => {
          ec = UInt(0x2F);
          il_is_valid = false
      },
      Exception_Breakpoint => {
          ec = UInt(0x30);
          il_is_valid = false
      },
      Exception_SoftwareStep => {
          ec = UInt(0x32);
          il_is_valid = false
      },
      Exception_Watchpoint => {
          ec = UInt(0x34);
          il_is_valid = false
      },
      Exception_NV2Watchpoint => {
          ec = UInt(0x35);
          il_is_valid = false
      },
      Exception_SoftwareBreakpoint => {
          ec = UInt(0x38)
      },
      Exception_VectorCatch => {
          ec = UInt(0x3A);
          il_is_valid = false;
          assert(from_32)
      },
      _ => {
          Unreachable()
      }
    };
    if (ec == UInt(0x20) | ec == UInt(0x24) | ec == UInt(0x30) | ec == UInt(0x32) | ec == UInt(0x34)) & target_el == PSTATE.EL then {
        ec = ec + 1
    };
    if (ec == UInt(0x11) | ec == UInt(0x12) | ec == UInt(0x13) | ec == UInt(0x28) | ec == UInt(0x38)) & not_bool(from_32) then {
        ec = ec + 4
    };
    let 'ec = ec;
    il : bits(1) = undefined;
    if il_is_valid then {
        il = if ThisInstrLength() == 32 then 0b1 else 0b0
    } else {
        il = 0b1
    };
    assert(from_32 | il == 0b1);
    return((ec, il))
}

bitfield ESR_EL1_Type : bits(64) =
  {ISS2 : 55..32, EC : 31..26, IL : 25..25, ISS : 24..0}

register ESR_EL1 : ESR_EL1_Type

bitfield ESR_EL2_Type : bits(64) =
  {ISS2 : 55..32, EC : 31..26, IL : 25..25, ISS : 24..0}

register ESR_EL2 : ESR_EL2_Type

bitfield ESR_EL3_Type : bits(64) =
  {ISS2 : 55..32, EC : 31..26, IL : 25..25, ISS : 24..0}

register ESR_EL3 : ESR_EL3_Type

val ESR_set : (bits(2), ESRType) -> unit

val ESR_set__1 : ESRType -> unit

function ESR_set (regime, value_name) = {
    let r : bits(64) = value_name.bits;
    match regime {
      ? if ? == EL1 => {
          ESR_EL1 = Mk_ESR_EL1_Type(r)
      },
      ? if ? == EL2 => {
          ESR_EL2 = Mk_ESR_EL2_Type(r)
      },
      ? if ? == EL3 => {
          ESR_EL3 = Mk_ESR_EL3_Type(r)
      },
      _ => {
          Unreachable()
      }
    };
    return()
}

function ESR_set__1 value_name = {
    ESR_set(S1TranslationRegime__1()) = value_name
}

type FAR_EL1_Type = bits(64)

register FAR_EL1 : FAR_EL1_Type

type FAR_EL2_Type = bits(64)

register FAR_EL2 : FAR_EL2_Type

type FAR_EL3_Type = bits(64)

register FAR_EL3 : FAR_EL3_Type

val FAR_set : (bits(2), bits(64)) -> unit

function FAR_set (regime, value_name) = {
    let r : bits(64) = value_name;
    match regime {
      ? if ? == EL1 => {
          FAR_EL1 = r
      },
      ? if ? == EL2 => {
          FAR_EL2 = r
      },
      ? if ? == EL3 => {
          FAR_EL3 = r
      },
      _ => {
          Unreachable()
      }
    };
    return()
}

bitfield HPFAR_EL2_Type : bits(64) = {NS : 63..63, FIPA : 47..4}

register HPFAR_EL2 : HPFAR_EL2_Type

val HavePFAR : unit -> bool

function HavePFAR () = {
    return(IsFeatureImplemented(FEAT_PFAR))
}

bitfield MFAR_EL3_Type : bits(64) =
  {
    NS : 63..63,
    NSE : 62..62,
    PA : (55..52 @ (51..48 @ 47..0)),
    FPA : (55..52 @ (51..48 @ 47..12))
  }

register MFAR_EL3 : MFAR_EL3_Type

bitfield PFAR_EL1_Type : bits(64) =
  {NS : 63..63, NSE : 62..62, PA : (55..52 @ (51..48 @ 47..0))}

register PFAR_EL1 : PFAR_EL1_Type

bitfield PFAR_EL2_Type : bits(64) =
  {NS : 63..63, NSE : 62..62, PA : (55..52 @ (51..48 @ 47..0))}

register PFAR_EL2 : PFAR_EL2_Type

val PFAR_set : (bits(2), bits(64)) -> unit

function PFAR_set (regime, value_name) = {
    let r : bits(64) = value_name;
    assert(HavePFAR() | HaveRME() & regime == EL3);
    match regime {
      ? if ? == EL1 => {
          PFAR_EL1 = Mk_PFAR_EL1_Type(r)
      },
      ? if ? == EL2 => {
          PFAR_EL2 = Mk_PFAR_EL2_Type(r)
      },
      ? if ? == EL3 => {
          MFAR_EL3 = Mk_MFAR_EL3_Type(r)
      },
      _ => {
          Unreachable()
      }
    };
    return()
}

val AArch64_ReportException : (ExceptionRecord, bits(2)) -> unit

function AArch64_ReportException (except, target_el) = {
    ec : int = undefined;
    il : bits(1) = undefined;
    let exceptype : Exception = except.exceptype;
    (ec, il) = AArch64_ExceptionClass(exceptype, target_el);
    let 'ec = ec;
    let iss : bits(25) = except.syndrome;
    let iss2 : bits(24) = except.syndrome2;
    if (ec == UInt(0x24) | ec == UInt(0x25)) & [iss[24]] == 0b0 then {
        il = 0b1
    };
    let il = il;
    ESR_set(target_el) = Mk_ESRType((((Zeros(8) @ iss2) @ ec[5 .. 0]) @ il) @ iss);
    if exceptype == Exception_InstructionAbort | exceptype == Exception_PCAlignment | exceptype == Exception_DataAbort | exceptype == Exception_NV2DataAbort | exceptype == Exception_NV2Watchpoint | exceptype == Exception_GPC | exceptype == Exception_Watchpoint then {
        FAR_set(target_el) = except.vaddress
    } else {
        FAR_set(target_el) = __UNKNOWN_bits(64)
    };
    if except.ipavalid then {
        HPFAR_EL2.bits[47 .. 4] = except.ipaddress[55 .. 12];
        if IsSecureEL2Enabled() & CurrentSecurityState() == SS_Secure then {
            HPFAR_EL2[NS] = except.NS
        } else {
            HPFAR_EL2[NS] = 0b0
        }
    } else if target_el == EL2 then {
        HPFAR_EL2.bits[47 .. 4] = __UNKNOWN_bits(44)
    } else ();
    if except.pavalid then {
        faultaddr : bits(64) = ZeroExtend(except.paddress.address, 64);
        if HaveRME() then {
            match except.paddress.paspace {
              PAS_Secure => {
                  faultaddr[63 .. 62] = 0b00
              },
              PAS_NonSecure => {
                  faultaddr[63 .. 62] = 0b10
              },
              PAS_Root => {
                  faultaddr[63 .. 62] = 0b01
              },
              PAS_Realm => {
                  faultaddr[63 .. 62] = 0b11
              }
            };
            if exceptype == Exception_GPC then {
                faultaddr[11 .. 0] = Zeros(12)
            };
            ()
        } else {
            faultaddr[63] = Bit(if except.paddress.paspace == PAS_NonSecure then
              0b1
            else
              0b0)
        };
        PFAR_set(target_el) = faultaddr
    } else if HavePFAR() | HaveRME() & target_el == EL3 then {
        PFAR_set(target_el) = __UNKNOWN_bits(64)
    } else ();
    return()
}

type ELR_EL1_Type = bits(64)

register ELR_EL1 : ELR_EL1_Type

type ELR_EL2_Type = bits(64)

register ELR_EL2 : ELR_EL2_Type

type ELR_EL3_Type = bits(64)

register ELR_EL3 : ELR_EL3_Type

val ELR_set : (bits(2), bits(64)) -> unit

val ELR_set__1 : bits(64) -> unit

function ELR_set (el, value_name) = {
    let r : bits(64) = value_name;
    match el {
      ? if ? == EL1 => {
          ELR_EL1 = r
      },
      ? if ? == EL2 => {
          ELR_EL2 = r
      },
      ? if ? == EL3 => {
          ELR_EL3 = r
      },
      _ => {
          Unreachable()
      }
    };
    return()
}

function ELR_set__1 value_name = {
    assert(PSTATE.EL != EL0);
    ELR_set(PSTATE.EL) = value_name;
    return()
}

val HaveDoubleFaultExt : unit -> bool

function HaveDoubleFaultExt () = {
    return(IsFeatureImplemented(FEAT_DoubleFault))
}

val HaveIESB : unit -> bool

function HaveIESB () = {
    return(IsFeatureImplemented(FEAT_IESB))
}

val MaybeZeroSVEUppers : bits(2) -> unit

function MaybeZeroSVEUppers target_el = {
    let 'SVL = CurrentSVL_read();
    let 'VL = CurrentVL_read();
    lower_enabled : bool = undefined;
    if UInt(target_el) <= UInt(PSTATE.EL) | not_bool(IsSVEEnabled(target_el)) then {
        return()
    };
    if target_el == EL3 then {
        if EL2Enabled() then {
            lower_enabled = IsFPEnabled(EL2)
        } else {
            lower_enabled = IsFPEnabled(EL1)
        }
    } else if target_el == EL2 then {
        assert(not_bool(ELUsingAArch32(EL2)));
        if HCR_EL2[TGE] == 0b0 then {
            lower_enabled = IsFPEnabled(EL1)
        } else {
            lower_enabled = IsFPEnabled(EL0)
        }
    } else {
        assert(target_el == EL1 & not_bool(ELUsingAArch32(EL1)));
        lower_enabled = IsFPEnabled(EL0)
    };
    if lower_enabled then {
        let 'VL = if IsSVEEnabled(PSTATE.EL) then VL else 128;
        let 'PL = DIV(VL, 8);
        foreach (n from 0 to 31 by 1 in inc) {
            if ConstrainUnpredictableBool(Unpredictable_SVEZEROUPPER) then {
                _Z[n] = ZeroExtend(_Z[n][VL - 1 .. 0], MAX_VL)
            };
            ()
        };
        foreach (n from 0 to 15 by 1 in inc) {
            if ConstrainUnpredictableBool(Unpredictable_SVEZEROUPPER) then {
                _P[n] = ZeroExtend(_P[n][PL - 1 .. 0], MAX_PL)
            };
            ()
        };
        if ConstrainUnpredictableBool(Unpredictable_SVEZEROUPPER) then {
            _FFR = ZeroExtend(_FFR[PL - 1 .. 0], MAX_PL)
        };
        if HaveSME() & PSTATE.ZA == 0b1 then {
            let 'SVL = SVL;
            let 'accessiblevecs = DIV(SVL, 8);
            let 'allvecs = DIV(MaxImplementedSVL(), 8);
            foreach (n from 0 to (accessiblevecs - 1) by 1 in inc) {
                if ConstrainUnpredictableBool(Unpredictable_SMEZEROUPPER) then {
                    _ZA[n] = ZeroExtend(_ZA[n][SVL - 1 .. 0], MAX_VL)
                };
                ()
            };
            foreach (n from accessiblevecs to (allvecs - 1) by 1 in inc) {
                if ConstrainUnpredictableBool(Unpredictable_SMEZEROUPPER) then {
                    assert(constraint((0 <= 'loop_n & 'loop_n < 256)));
                    _ZA[n] = Zeros(MAX_VL)
                };
                ()
            }
        };
        ()
    };
    ()
}

val ResetSVEState : unit -> unit

function ResetSVEState () = {
    foreach (n from 0 to 31 by 1 in inc) {
        _Z[n] = Zeros(MAX_VL)
    };
    foreach (n from 0 to 15 by 1 in inc) {
        _P[n] = Zeros(MAX_PL)
    };
    _FFR = Zeros(MAX_PL);
    FPSR = Mk_FPSR_Type(ZeroExtend(0x0800009f, 64))
}

bitfield SPSR_EL1_Type : bits(64) =
  {
    EXLOCK : 34..34,
    PPEND : 33..33,
    PM : 32..32,
    N : 31..31,
    Z : 30..30,
    C : 29..29,
    V : 28..28,
    Q : 27..27,
    TCO : 25..25,
    DIT : 24..24,
    UAO : 23..23,
    PAN : 22..22,
    SS : 21..21,
    IL : 20..20,
    GE : 19..16,
    ALLINT : 13..13,
    BTYPE : 11..10,
    IT : (15..10 @ 26..25),
    D : 9..9,
    E : 9..9,
    A : 8..8,
    I : 7..7,
    F : 6..6,
    T : 5..5
  }

register SPSR_EL1 : SPSR_EL1_Type

bitfield SPSR_EL2_Type : bits(64) =
  {
    EXLOCK : 34..34,
    PPEND : 33..33,
    PM : 32..32,
    N : 31..31,
    Z : 30..30,
    C : 29..29,
    V : 28..28,
    Q : 27..27,
    TCO : 25..25,
    DIT : 24..24,
    UAO : 23..23,
    PAN : 22..22,
    SS : 21..21,
    IL : 20..20,
    GE : 19..16,
    ALLINT : 13..13,
    BTYPE : 11..10,
    IT : (15..10 @ 26..25),
    D : 9..9,
    E : 9..9,
    A : 8..8,
    I : 7..7,
    F : 6..6,
    T : 5..5
  }

register SPSR_EL2 : SPSR_EL2_Type

bitfield SPSR_EL3_Type : bits(64) =
  {
    EXLOCK : 34..34,
    PPEND : 33..33,
    PM : 32..32,
    N : 31..31,
    Z : 30..30,
    C : 29..29,
    V : 28..28,
    Q : 27..27,
    TCO : 25..25,
    DIT : 24..24,
    UAO : 23..23,
    PAN : 22..22,
    SS : 21..21,
    IL : 20..20,
    GE : 19..16,
    ALLINT : 13..13,
    BTYPE : 11..10,
    IT : (15..10 @ 26..25),
    D : 9..9,
    E : 9..9,
    A : 8..8,
    I : 7..7,
    F : 6..6,
    T : 5..5
  }

register SPSR_EL3 : SPSR_EL3_Type

bitfield SPSR_abt_Type : bits(64) =
  {
    N : 31..31,
    Z : 30..30,
    C : 29..29,
    V : 28..28,
    Q : 27..27,
    J : 24..24,
    SSBS : 23..23,
    PAN : 22..22,
    DIT : 21..21,
    IL : 20..20,
    GE : 19..16,
    IT : (15..10 @ 26..25),
    E : 9..9,
    A : 8..8,
    I : 7..7,
    F : 6..6,
    T : 5..5,
    M : 4..0
  }

register SPSR_abt : SPSR_abt_Type

bitfield SPSR_fiq_Type : bits(64) =
  {
    N : 31..31,
    Z : 30..30,
    C : 29..29,
    V : 28..28,
    Q : 27..27,
    J : 24..24,
    SSBS : 23..23,
    PAN : 22..22,
    DIT : 21..21,
    IL : 20..20,
    GE : 19..16,
    IT : (15..10 @ 26..25),
    E : 9..9,
    A : 8..8,
    I : 7..7,
    F : 6..6,
    T : 5..5,
    M : 4..0
  }

register SPSR_fiq : SPSR_fiq_Type

bitfield SPSR_hyp_Type : bits(32) =
  {
    N : 31..31,
    Z : 30..30,
    C : 29..29,
    V : 28..28,
    Q : 27..27,
    J : 24..24,
    SSBS : 23..23,
    PAN : 22..22,
    DIT : 21..21,
    IL : 20..20,
    GE : 19..16,
    IT : (15..10 @ 26..25),
    E : 9..9,
    A : 8..8,
    I : 7..7,
    F : 6..6,
    T : 5..5,
    M : 4..0
  }

register _SPSR_hyp : SPSR_hyp_Type

val SPSR_hyp_read : unit -> SPSR_hyp_Type

function SPSR_hyp_read () = {
    r : SPSR_hyp_Type = _SPSR_hyp;
    r.bits[31 .. 0] = Slice(SPSR_EL2.bits, 0, 32);
    return(r)
}

val SPSR_hyp_write : SPSR_hyp_Type -> unit

function SPSR_hyp_write value_name = {
    let r : SPSR_hyp_Type = value_name;
    SPSR_EL2.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _SPSR_hyp = r;
    return()
}

bitfield SPSR_irq_Type : bits(64) =
  {
    N : 31..31,
    Z : 30..30,
    C : 29..29,
    V : 28..28,
    Q : 27..27,
    J : 24..24,
    SSBS : 23..23,
    PAN : 22..22,
    DIT : 21..21,
    IL : 20..20,
    GE : 19..16,
    IT : (15..10 @ 26..25),
    E : 9..9,
    A : 8..8,
    I : 7..7,
    F : 6..6,
    T : 5..5,
    M : 4..0
  }

register SPSR_irq : SPSR_irq_Type

bitfield SPSR_mon_Type : bits(32) =
  {
    N : 31..31,
    Z : 30..30,
    C : 29..29,
    V : 28..28,
    Q : 27..27,
    J : 24..24,
    SSBS : 23..23,
    PAN : 22..22,
    DIT : 21..21,
    IL : 20..20,
    GE : 19..16,
    IT : (15..10 @ 26..25),
    E : 9..9,
    A : 8..8,
    I : 7..7,
    F : 6..6,
    T : 5..5,
    M : 4..0
  }

register SPSR_mon : SPSR_mon_Type

bitfield SPSR_svc_Type : bits(32) =
  {
    N : 31..31,
    Z : 30..30,
    C : 29..29,
    V : 28..28,
    Q : 27..27,
    J : 24..24,
    SSBS : 23..23,
    PAN : 22..22,
    DIT : 21..21,
    IL : 20..20,
    GE : 19..16,
    IT : (15..10 @ 26..25),
    E : 9..9,
    A : 8..8,
    I : 7..7,
    F : 6..6,
    T : 5..5,
    M : 4..0
  }

register _SPSR_svc : SPSR_svc_Type

val SPSR_svc_read : unit -> SPSR_svc_Type

function SPSR_svc_read () = {
    r : SPSR_svc_Type = _SPSR_svc;
    r.bits[31 .. 0] = Slice(SPSR_EL1.bits, 0, 32);
    return(r)
}

val SPSR_svc_write : SPSR_svc_Type -> unit

function SPSR_svc_write value_name = {
    let r : SPSR_svc_Type = value_name;
    SPSR_EL1.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _SPSR_svc = r;
    return()
}

bitfield SPSR_und_Type : bits(64) =
  {
    N : 31..31,
    Z : 30..30,
    C : 29..29,
    V : 28..28,
    Q : 27..27,
    J : 24..24,
    SSBS : 23..23,
    PAN : 22..22,
    DIT : 21..21,
    IL : 20..20,
    GE : 19..16,
    IT : (15..10 @ 26..25),
    E : 9..9,
    A : 8..8,
    I : 7..7,
    F : 6..6,
    T : 5..5,
    M : 4..0
  }

register SPSR_und : SPSR_und_Type

val SPSR_set : forall 'N, 'N >= 0. (implicit('N), bits('N)) -> unit

function SPSR_set (N, value_name) = {
    if UsingAArch32() then {
        assert(N == 32);
        match PSTATE.M {
          ? if ? == M32_FIQ => {
              SPSR_fiq.bits[N - 1 .. 0] = value_name[N - 1 .. 0]
          },
          ? if ? == M32_IRQ => {
              SPSR_irq.bits[N - 1 .. 0] = value_name[N - 1 .. 0]
          },
          ? if ? == M32_Svc => {
              SPSR_svc_write() = Mk_SPSR_svc_Type([SPSR_svc_read().bits with (N - 1) .. 0 = value_name[N - 1 .. 0]])
          },
          ? if ? == M32_Monitor => {
              SPSR_mon.bits[N - 1 .. 0] = value_name[N - 1 .. 0]
          },
          ? if ? == M32_Abort => {
              SPSR_abt.bits[N - 1 .. 0] = value_name[N - 1 .. 0]
          },
          ? if ? == M32_Hyp => {
              SPSR_hyp_write() = Mk_SPSR_hyp_Type([SPSR_hyp_read().bits with (N - 1) .. 0 = value_name[N - 1 .. 0]])
          },
          ? if ? == M32_Undef => {
              SPSR_und.bits[N - 1 .. 0] = value_name[N - 1 .. 0]
          },
          _ => {
              Unreachable()
          }
        }
    } else {
        assert(N == 64);
        match PSTATE.EL {
          ? if ? == EL1 => {
              SPSR_EL1.bits[N - 1 .. 0] = value_name[N - 1 .. 0]
          },
          ? if ? == EL2 => {
              SPSR_EL2.bits[N - 1 .. 0] = value_name[N - 1 .. 0]
          },
          ? if ? == EL3 => {
              SPSR_EL3.bits[N - 1 .. 0] = value_name[N - 1 .. 0]
          },
          _ => {
              Unreachable()
          }
        }
    };
    return()
}

val SynchronizeContext : unit -> unit

val SynchronizeErrors : unit -> unit

val AArch64_TakeExceptionInDebugState : (bits(2), ExceptionRecord) -> unit

function AArch64_TakeExceptionInDebugState (target_el, exception_in) = {
    assert((HaveEL(target_el) & not_bool(ELUsingAArch32(target_el))) & UInt(target_el) >= UInt(PSTATE.EL));
    assert(target_el != EL3 | EDSCR_read()[SDD] == 0b0);
    let except : ExceptionRecord = exception_in;
    sync_errors : bool = undefined;
    if HaveIESB() then {
        sync_errors = SCTLR_read(target_el)[IESB] == 0b1;
        if HaveDoubleFaultExt() then {
            sync_errors = sync_errors | (SCR_EL3[EA] @ SCR_EL3[NMEA]) == 0b11 & target_el == EL3
        };
        if not_bool(ConstrainUnpredictableBool(Unpredictable_IESBinDebug)) then {
            sync_errors = false
        };
        ()
    } else {
        sync_errors = false
    };
    if HaveTME() & TSTATE.depth > 0 then {
        cause : TMFailure = undefined;
        match except.exceptype {
          Exception_SoftwareBreakpoint => {
              cause = TMFailure_DBG
          },
          Exception_Breakpoint => {
              cause = TMFailure_DBG
          },
          Exception_Watchpoint => {
              cause = TMFailure_DBG
          },
          Exception_SoftwareStep => {
              cause = TMFailure_DBG
          },
          _ => {
              cause = TMFailure_ERR
          }
        };
        let cause = cause;
        FailTransaction(cause, false)
    };
    SynchronizeContext();
    let from_32 : bool = UsingAArch32();
    if from_32 then {
        AArch64_MaybeZeroRegisterUppers()
    };
    if (from_32 & HaveSME()) & PSTATE.SM == 0b1 then {
        ResetSVEState()
    } else {
        MaybeZeroSVEUppers(target_el)
    };
    AArch64_ReportException(except, target_el);
    if HaveGCS() then {
        PSTATE.EXLOCK = 0b0
    };
    PSTATE.EL = target_el;
    PSTATE.nRW = 0b0;
    PSTATE.SP = 0b1;
    SPSR_set(64) = __UNKNOWN_bits(64);
    ELR_set__1() = __UNKNOWN_bits(64);
    (PSTATE.SS @ PSTATE.D @ PSTATE.A @ PSTATE.I @ PSTATE.F) = __UNKNOWN_bits(5);
    PSTATE.IL = 0b0;
    if from_32 then {
        PSTATE.IT = 0b00000000;
        PSTATE.T = 0b0
    };
    if (HavePANExt() & (PSTATE.EL == EL1 | PSTATE.EL == EL2 & ELIsInHost(EL0))) & SCTLR_read__1()[SPAN] == 0b0 then {
        PSTATE.PAN = 0b1
    };
    if HaveUAOExt() then {
        PSTATE.UAO = 0b0
    };
    if HaveBTIExt() then {
        PSTATE.BTYPE = 0b00
    };
    if HaveSSBSExt() then {
        PSTATE.SSBS = __UNKNOWN_bit()
    };
    if HaveMTEExt() then {
        PSTATE.TCO = 0b1
    };
    DLR_EL0 = __UNKNOWN_bits(64);
    DSPSR_EL0 = Mk_DSPSR_EL0_Type(__UNKNOWN_bits(64));
    EDSCR_write() = [EDSCR_read() with ERR = 0b1];
    UpdateEDSCRFields();
    if sync_errors then {
        SynchronizeErrors()
    };
    EndOfInstruction()
}

val BRBEException : forall ('trappedsyscallinst : Bool).
  (ExceptionRecord, bits(64), bits(64), bits(2), bool('trappedsyscallinst)) -> unit

function BRBEException (erec, preferred_exception_return, target_address_in, target_el, trappedsyscallinst) = {
    target_address : bits(64) = target_address_in;
    let except : Exception = erec.exceptype;
    let iss : bits(25) = erec.syndrome;
    match target_el {
      ? if ? == EL3 => {
          if not_bool(HaveBRBEv1p1()) | MDCR_EL3[E3BREC] == MDCR_EL3[E3BREW] then {
              return()
          };
          ()
      },
      ? if ? == EL2 => {
          if BRBCR_EL2[EXCEPTION] == 0b0 then {
              return()
          };
          ()
      },
      ? if ? == EL1 => {
          if BRBCR_EL1[EXCEPTION] == 0b0 then {
              return()
          };
          ()
      },
      _ => ()
    };
    let source_valid : bool = BranchRecordAllowed(PSTATE.EL);
    let target_valid : bool = BranchRecordAllowed(target_el);
    let branch_valid : bool = source_valid | target_valid;
    if branch_valid then {
        branch_type : bits(6) = undefined;
        match except {
          Exception_Uncategorized => {
              branch_type = 0b100011
          },
          Exception_WFxTrap => {
              branch_type = 0b100011
          },
          Exception_CP15RTTrap => {
              branch_type = 0b100011
          },
          Exception_CP15RRTTrap => {
              branch_type = 0b100011
          },
          Exception_CP14RTTrap => {
              branch_type = 0b100011
          },
          Exception_CP14DTTrap => {
              branch_type = 0b100011
          },
          Exception_AdvSIMDFPAccessTrap => {
              branch_type = 0b100011
          },
          Exception_FPIDTrap => {
              branch_type = 0b100011
          },
          Exception_PACTrap => {
              branch_type = 0b100011
          },
          Exception_TSTARTAccessTrap => {
              branch_type = 0b100011
          },
          Exception_CP14RRTTrap => {
              branch_type = 0b100011
          },
          Exception_BranchTarget => {
              branch_type = 0b101011
          },
          Exception_IllegalState => {
              branch_type = 0b100011
          },
          Exception_SupervisorCall => {
              if not_bool(trappedsyscallinst) then {
                  branch_type = 0b100010
              } else {
                  branch_type = 0b100011
              }
          },
          Exception_HypervisorCall => {
              branch_type = 0b100010
          },
          Exception_MonitorCall => {
              if not_bool(trappedsyscallinst) then {
                  branch_type = 0b100010
              } else {
                  branch_type = 0b100011
              }
          },
          Exception_SystemRegisterTrap => {
              branch_type = 0b100011
          },
          Exception_SystemRegister128Trap => {
              branch_type = 0b100011
          },
          Exception_SVEAccessTrap => {
              branch_type = 0b100011
          },
          Exception_SMEAccessTrap => {
              branch_type = 0b100011
          },
          Exception_ERetTrap => {
              branch_type = 0b100011
          },
          Exception_PACFail => {
              branch_type = 0b101100
          },
          Exception_InstructionAbort => {
              branch_type = 0b101011
          },
          Exception_PCAlignment => {
              branch_type = 0b101010
          },
          Exception_DataAbort => {
              branch_type = 0b101100
          },
          Exception_NV2DataAbort => {
              branch_type = 0b101100
          },
          Exception_SPAlignment => {
              branch_type = 0b101010
          },
          Exception_FPTrappedException => {
              branch_type = 0b100011
          },
          Exception_SError => {
              branch_type = 0b100100
          },
          Exception_Breakpoint => {
              branch_type = 0b100110
          },
          Exception_SoftwareStep => {
              branch_type = 0b100110
          },
          Exception_Watchpoint => {
              branch_type = 0b100111
          },
          Exception_NV2Watchpoint => {
              branch_type = 0b100111
          },
          Exception_SoftwareBreakpoint => {
              branch_type = 0b100110
          },
          Exception_IRQ => {
              branch_type = 0b101110
          },
          Exception_FIQ => {
              branch_type = 0b101111
          },
          Exception_MemCpyMemSet => {
              branch_type = 0b100011
          },
          Exception_GCSFail => {
              if iss[23 .. 20] == 0b0000 then {
                  branch_type = 0b101100
              } else if iss[23 .. 20] == 0b0001 then {
                  branch_type = 0b101011
              } else if iss[23 .. 20] == 0b0010 then {
                  branch_type = 0b100011
              } else {
                  Unreachable()
              }
          },
          _ => {
              Unreachable()
          }
        };
        ccu : bits(1) = undefined;
        cc : bits(14) = undefined;
        (ccu, cc) = BranchEncCycleCount();
        let lastfailed : bits(1) = if HaveTME() then BRBFCR_EL1[LASTFAILED] else
          0b0;
        let transactional : bits(1) = if (source_valid & HaveTME()) & TSTATE.depth > 0 then
          0b1
        else
          0b0;
        let el : bits(2) = if target_valid then target_el else 0b00;
        let mispredict : bits(1) = 0b0;
        let sv : bits(1) = if source_valid then 0b1 else 0b0;
        let tv : bits(1) = if target_valid then 0b1 else 0b0;
        let source_address : bits(64) = if source_valid then
          preferred_exception_return
        else
          Zeros(64);
        if not_bool(target_valid) then {
            target_address = Zeros(64)
        } else {
            target_address = AArch64_BranchAddr(target_address, target_el)
        };
        UpdateBranchRecordBuffer(ccu, cc, lastfailed, transactional, branch_type, el, mispredict, sv @ tv, source_address, target_address);
        BRBFCR_EL1[LASTFAILED] = 0b0;
        PMUEvent(PMU_EVENT_BRB_FILTRATE)
    };
    __last_branch_valid = branch_valid;
    return()
}

bitfield EDECCR_Type : bits(32) =
  {
    RLR2 : 22..22,
    RLR1 : 21..21,
    RLR0 : 20..20,
    RLE2 : 18..18,
    RLE1 : 17..17,
    RLE0 : 16..16,
    NSR3 : 15..15,
    NSR2 : 14..14,
    NSR1 : 13..13,
    NSR0 : 12..12,
    SR3 : 11..11,
    SR2 : 10..10,
    SR1 : 9..9,
    SR0 : 8..8,
    NSE3 : 7..7,
    NSE2 : 6..6,
    NSE1 : 5..5,
    NSE0 : 4..4,
    SE3 : 3..3,
    SE2 : 2..2,
    SE1 : 1..1,
    SE0 : 0..0
  }

bitfield OSECCR_EL1_Type : bits(64) = {EDECCR : 31..0}

register OSECCR_EL1 : OSECCR_EL1_Type

register _EDECCR : EDECCR_Type

val EDECCR_read : unit -> EDECCR_Type

function EDECCR_read () = {
    r : EDECCR_Type = _EDECCR;
    r.bits[31 .. 0] = Slice(OSECCR_EL1.bits, 0, 32);
    return(r)
}

bitfield EDESR_Type : bits(32) = {EC : 3..3, SS : 2..2, RC : 1..1, OSUC : 0..0}

register EDESR : EDESR_Type

val HaveExtendedECDebugEvents : unit -> bool

function HaveExtendedECDebugEvents () = {
    return(IsFeatureImplemented(FEAT_Debugv8p2))
}

val Havev8p8Debug : unit -> bool

function Havev8p8Debug () = {
    return(IsFeatureImplemented(FEAT_Debugv8p8))
}

val CheckExceptionCatch : forall ('exception_entry : Bool).
  bool('exception_entry) -> unit

function CheckExceptionCatch exception_entry = {
    ctrl : bits(2) = undefined;
    exception_exit : bool = undefined;
    increment_name : int = undefined;
    let ss : SecurityState = SecurityStateAtEL(PSTATE.EL);
    base : {0, 4, 16} = 0;
    match ss {
      SS_Secure => {
          base = 0
      },
      SS_NonSecure => {
          base = 4
      },
      SS_Realm => {
          base = 16
      },
      SS_Root => {
          base = 0
      }
    };
    let 'base = base;
    if HaltingAllowed() then {
        halt : bool = undefined;
        if HaveExtendedECDebugEvents() then {
            let exception_exit : bool = not_bool(exception_entry);
            let 'increment_name = if ss == SS_Realm then 4 else 8;
            let ctrl : bits(2) = [EDECCR_read().bits[UInt(PSTATE.EL) + base + increment_name]] @ [EDECCR_read().bits[UInt(PSTATE.EL) + base]];
            match ctrl {
              0b00 => {
                  halt = false
              },
              0b01 => {
                  halt = true
              },
              0b10 => {
                  halt = exception_exit == true
              },
              0b11 => {
                  halt = exception_entry == true
              }
            }
        } else {
            halt = [EDECCR_read().bits[UInt(PSTATE.EL) + base]] == 0b1
        };
        if halt then {
            if Havev8p8Debug() & exception_entry then {
                EDESR[EC] = 0b1
            } else {
                Halt(DebugHalt_ExceptionCatch)
            }
        };
        ()
    };
    ()
}

val HaveNV2Ext : unit -> bool

function HaveNV2Ext () = {
    return(IsFeatureImplemented(FEAT_NV2))
}

val HaveNVExt : unit -> bool

function HaveNVExt () = {
    return(IsFeatureImplemented(FEAT_NV))
}

val InsertIESBBeforeException : bits(2) -> bool

function InsertIESBBeforeException el = {
    return(HaveIESB() & __IMPDEF_boolean("Has Implicit Error Synchronization Barrier before Exception"))
}

val TakeUnmaskedPhysicalSErrorInterrupts : forall ('iesb_req : Bool).
  bool('iesb_req) -> unit

type VBAR_EL1_Type = bits(64)

register VBAR_EL1 : VBAR_EL1_Type

type VBAR_EL2_Type = bits(64)

register VBAR_EL2 : VBAR_EL2_Type

type VBAR_EL3_Type = bits(64)

register VBAR_EL3 : VBAR_EL3_Type

type VBAR_Type = bits(32)

register _VBAR_NS : VBAR_Type

val VBAR_NS_read : unit -> VBAR_Type

function VBAR_NS_read () = {
    r : VBAR_Type = _VBAR_NS;
    r[31 .. 0] = Slice(VBAR_EL1, 0, 32);
    return(r)
}

register VBAR_S : VBAR_Type

val VBAR_read : bits(2) -> bits(64)

val VBAR_read__1 : unit -> bits(64)

val VBAR_read__2 : unit -> VBAR_Type

function VBAR_read__2 () = {
    r : VBAR_Type = undefined;
    if ELUsingAArch32(EL3) & CurrentSecurityState() == SS_Secure then {
        r = VBAR_S
    } else {
        r = VBAR_NS_read()
    };
    return(r)
}

function VBAR_read regime = {
    r : bits(64) = undefined;
    match regime {
      ? if ? == EL1 => {
          r = VBAR_EL1
      },
      ? if ? == EL2 => {
          r = VBAR_EL2
      },
      ? if ? == EL3 => {
          r = VBAR_EL3
      },
      _ => {
          Unreachable()
      }
    };
    return(r)
}

function VBAR_read__1 () = {
    return(VBAR_read(S1TranslationRegime__1()))
}

val AArch64_TakeException : forall 'vect_offset_in.
  (bits(2), ExceptionRecord, bits(64), int('vect_offset_in)) -> unit

function AArch64_TakeException (target_el, exception_in, preferred_exception_return, vect_offset_in) = {
    assert((HaveEL(target_el) & not_bool(ELUsingAArch32(target_el))) & UInt(target_el) >= UInt(PSTATE.EL));
    if Halted() then {
        AArch64_TakeExceptionInDebugState(target_el, exception_in);
        return()
    };
    except : ExceptionRecord = exception_in;
    sync_errors : bool = undefined;
    iesb_req : bool = undefined;
    if HaveIESB() then {
        sync_errors = SCTLR_read(target_el)[IESB] == 0b1;
        if HaveDoubleFaultExt() then {
            sync_errors = sync_errors | (SCR_EL3[EA] @ SCR_EL3[NMEA]) == 0b11 & target_el == EL3
        };
        if sync_errors & InsertIESBBeforeException(target_el) then {
            SynchronizeErrors();
            iesb_req = false;
            sync_errors = false;
            TakeUnmaskedPhysicalSErrorInterrupts(iesb_req)
        };
        ()
    } else {
        sync_errors = false
    };
    if HaveTME() & TSTATE.depth > 0 then {
        cause : TMFailure = undefined;
        match except.exceptype {
          Exception_SoftwareBreakpoint => {
              cause = TMFailure_DBG
          },
          Exception_Breakpoint => {
              cause = TMFailure_DBG
          },
          Exception_Watchpoint => {
              cause = TMFailure_DBG
          },
          Exception_SoftwareStep => {
              cause = TMFailure_DBG
          },
          _ => {
              cause = TMFailure_ERR
          }
        };
        let cause = cause;
        FailTransaction(cause, false)
    };
    SynchronizeContext();
    let from_32 : bool = UsingAArch32();
    if from_32 then {
        AArch64_MaybeZeroRegisterUppers()
    };
    if (from_32 & HaveSME()) & PSTATE.SM == 0b1 then {
        ResetSVEState()
    } else {
        MaybeZeroSVEUppers(target_el)
    };
    vect_offset : int = vect_offset_in;
    if UInt(target_el) > UInt(PSTATE.EL) then {
        lower_32 : bool = undefined;
        if target_el == EL3 then {
            if EL2Enabled() then {
                lower_32 = ELUsingAArch32(EL2)
            } else {
                lower_32 = ELUsingAArch32(EL1)
            }
        } else if (IsInHost() & PSTATE.EL == EL0) & target_el == EL2 then {
            lower_32 = ELUsingAArch32(EL0)
        } else {
            lower_32 = ELUsingAArch32(target_el - 1)
        };
        vect_offset = vect_offset + (if lower_32 then UInt(0x600) else
          UInt(0x400))
    } else if PSTATE.SP == 0b1 then {
        vect_offset = vect_offset + UInt(0x200)
    } else ();
    let 'vect_offset = vect_offset;
    spsr : bits(64) = GetPSRFromPSTATE(AArch64_NonDebugState, 64);
    if (PSTATE.EL == EL1 & target_el == EL1) & EL2Enabled() then {
        if HaveNV2Ext() & ((HCR_EL2[NV] @ (HCR_EL2[NV1] @ HCR_EL2[NV2])) == 0b100 | (HCR_EL2[NV] @ (HCR_EL2[NV1] @ HCR_EL2[NV2])) == 0b111) then {
            spsr[3 .. 2] = 0b10
        } else {
            if HaveNVExt() & (HCR_EL2[NV] @ HCR_EL2[NV1]) == 0b10 then {
                spsr[3 .. 2] = 0b10
            };
            ()
        }
    };
    if HaveBTIExt() & not_bool(UsingAArch32()) then {
        zero_btype : bool = undefined;
        if except.exceptype == Exception_SError | except.exceptype == Exception_IRQ | except.exceptype == Exception_FIQ | except.exceptype == Exception_SoftwareStep | except.exceptype == Exception_PCAlignment | except.exceptype == Exception_InstructionAbort | except.exceptype == Exception_Breakpoint | except.exceptype == Exception_VectorCatch | except.exceptype == Exception_SoftwareBreakpoint | except.exceptype == Exception_IllegalState | except.exceptype == Exception_BranchTarget then {
            zero_btype = false
        } else {
            zero_btype = ConstrainUnpredictableBool(Unpredictable_ZEROBTYPE)
        };
        if zero_btype then {
            spsr[11 .. 10] = 0b00
        };
        ()
    };
    if (HaveNV2Ext() & except.exceptype == Exception_NV2DataAbort) & target_el == EL3 then {
        except.exceptype = Exception_DataAbort
    };
    if not_bool(except.exceptype == Exception_IRQ | except.exceptype == Exception_FIQ) then {
        AArch64_ReportException(except, target_el)
    };
    if HaveBRBExt() then {
        BRBEException(except, preferred_exception_return, VBAR_read(target_el)[63 .. 11] @ vect_offset[10 .. 0], target_el, except.trappedsyscallinst)
    };
    if HaveGCS() then {
        if PSTATE.EL == target_el then {
            if GetCurrentEXLOCKEN() then {
                PSTATE.EXLOCK = 0b1
            } else {
                PSTATE.EXLOCK = 0b0
            }
        } else {
            PSTATE.EXLOCK = 0b0
        }
    };
    PSTATE.EL = target_el;
    PSTATE.nRW = 0b0;
    PSTATE.SP = 0b1;
    SPSR_set(64) = spsr;
    ELR_set__1() = preferred_exception_return;
    PSTATE.SS = 0b0;
    if HaveFeatNMI() & not_bool(ELUsingAArch32(target_el)) then {
        PSTATE.ALLINT = not_vec(SCTLR_read__1()[SPINTMASK])
    };
    (PSTATE.D @ PSTATE.A @ PSTATE.I @ PSTATE.F) = 0b1111;
    PSTATE.IL = 0b0;
    if from_32 then {
        PSTATE.IT = 0b00000000;
        PSTATE.T = 0b0
    };
    if (HavePANExt() & (PSTATE.EL == EL1 | PSTATE.EL == EL2 & ELIsInHost(EL0))) & SCTLR_read__1()[SPAN] == 0b0 then {
        PSTATE.PAN = 0b1
    };
    if HaveUAOExt() then {
        PSTATE.UAO = 0b0
    };
    if HaveBTIExt() then {
        PSTATE.BTYPE = 0b00
    };
    if HaveSSBSExt() then {
        PSTATE.SSBS = SCTLR_read__1()[DSSBS]
    };
    if HaveMTEExt() then {
        PSTATE.TCO = 0b1
    };
    let branch_conditional : bool = false;
    BranchTo(VBAR_read__1()[63 .. 11] @ vect_offset[10 .. 0], BranchType_EXCEPTION, branch_conditional);
    CheckExceptionCatch(true);
    if sync_errors then {
        SynchronizeErrors();
        let iesb_req : bool = true;
        TakeUnmaskedPhysicalSErrorInterrupts(iesb_req)
    };
    EndOfInstruction()
}

val ExceptionSyndrome : Exception -> ExceptionRecord

function ExceptionSyndrome exceptype = {
    r : ExceptionRecord = undefined;
    r.exceptype = exceptype;
    r.syndrome = Zeros(25);
    r.syndrome2 = Zeros(24);
    r.vaddress = Zeros(64);
    r.ipavalid = false;
    r.NS = 0b0;
    r.ipaddress = Zeros(56);
    r.paddress.paspace = __UNKNOWN_PASpace();
    r.paddress.address = __UNKNOWN_bits(56);
    r.trappedsyscallinst = false;
    return(r)
}

val AArch64_BranchTargetException : bits(52) -> unit

function AArch64_BranchTargetException vaddress = {
    let preferred_exception_return : bits(64) = ThisInstrAddr(64);
    let 'vect_offset = UInt(0x0);
    except : ExceptionRecord = ExceptionSyndrome(Exception_BranchTarget);
    except.syndrome[1 .. 0] = PSTATE.BTYPE;
    except.syndrome[24 .. 2] = Zeros(23);
    target_el : bits(2) = EL1;
    if UInt(PSTATE.EL) > UInt(EL1) then {
        target_el = PSTATE.EL
    } else if (PSTATE.EL == EL0 & EL2Enabled()) & HCR_EL2[TGE] == 0b1 then {
        target_el = EL2
    } else ();
    sail_take_exception(None());
    AArch64_TakeException(target_el, except, preferred_exception_return, vect_offset)
}

val ThisInstr : unit -> bits(32)

val AArch64_ExecutingBROrBLROrRetInstr : unit -> bool

function AArch64_ExecutingBROrBLROrRetInstr () = {
    opc : bits(4) = undefined;
    if not_bool(HaveBTIExt()) then {
        return(false)
    };
    let instr : bits(32) = ThisInstr();
    if instr[31 .. 25] == 0b1101011 & instr[20 .. 16] == 0b11111 then {
        let opc : bits(4) = instr[24 .. 21];
        return(opc != 0b0101)
    } else {
        return(false)
    }
}

val AArch64_ExecutingBTIInstr : unit -> bool

function AArch64_ExecutingBTIInstr () = {
    CRm : bits(4) = undefined;
    op2 : bits(3) = undefined;
    if not_bool(HaveBTIExt()) then {
        return(false)
    };
    let instr : bits(32) = ThisInstr();
    if (instr[31 .. 22] == 0b1101010100 & instr[21 .. 12] == 0b0000110010) & instr[4 .. 0] == 0b11111 then {
        let CRm : bits(4) = instr[11 .. 8];
        let op2 : bits(3) = instr[7 .. 5];
        return(CRm == 0b0100 & [op2[0]] == 0b0)
    } else {
        return(false)
    }
}

val BranchTargetCheck : unit -> unit

function BranchTargetCheck () = {
    assert(HaveBTIExt() & not_bool(UsingAArch32()));
    if ((InGuardedPage & PSTATE.BTYPE != 0b00) & not_bool(BTypeCompatible)) & not_bool(Halted()) then {
        let pc : bits(64) = ThisInstrAddr(64);
        AArch64_BranchTargetException(pc[51 .. 0])
    };
    let branch_instr : bool = AArch64_ExecutingBROrBLROrRetInstr();
    let bti_instr : bool = AArch64_ExecutingBTIInstr();
    if not_bool(branch_instr | bti_instr) then {
        BTypeNext = 0b00
    };
    ()
}

val Hint_Yield : unit -> unit

val Hint_DGH : unit -> unit

val Hint_CLRBHB : unit -> unit

val AArch32_CurrentCond : unit -> bits(4)

val ConditionSyndrome : unit -> bits(5)

function ConditionSyndrome () = {
    cond : bits(4) = undefined;
    syndrome : bits(5) = undefined;
    if UsingAArch32() then {
        let cond : bits(4) = AArch32_CurrentCond();
        if PSTATE.T == 0b0 then {
            syndrome[4] = Bit(0b1);
            if ConditionHolds(cond) & ConstrainUnpredictableBool(Unpredictable_ESRCONDPASS) then {
                syndrome[3 .. 0] = 0b1110
            } else {
                syndrome[3 .. 0] = cond
            }
        } else {
            if __IMPDEF_boolean("Condition valid for trapped T32") then {
                syndrome[4] = Bit(0b1);
                syndrome[3 .. 0] = cond
            } else {
                syndrome[4] = Bit(0b0);
                syndrome[3 .. 0] = __UNKNOWN_bits(4)
            }
        }
    } else {
        syndrome[4] = Bit(0b1);
        syndrome[3 .. 0] = 0b1110
    };
    return(syndrome)
}

val AArch64_WFxTrap : (WFxType, bits(2)) -> unit

function AArch64_WFxTrap (wfxtype, target_el) = {
    assert(UInt(target_el) > UInt(PSTATE.EL));
    let preferred_exception_return : bits(64) = ThisInstrAddr(64);
    let 'vect_offset = UInt(0x0);
    except : ExceptionRecord = ExceptionSyndrome(Exception_WFxTrap);
    except.syndrome[24 .. 20] = ConditionSyndrome();
    match wfxtype {
      WFxType_WFI => {
          except.syndrome[1 .. 0] = 0b00
      },
      WFxType_WFE => {
          except.syndrome[1 .. 0] = 0b01
      },
      WFxType_WFIT => {
          except.syndrome[1 .. 0] = 0b10;
          except.syndrome[2] = Bit(0b1);
          except.syndrome[9 .. 5] = ThisInstr()[4 .. 0]
      },
      WFxType_WFET => {
          except.syndrome[1 .. 0] = 0b11;
          except.syndrome[2] = Bit(0b1);
          except.syndrome[9 .. 5] = ThisInstr()[4 .. 0]
      }
    };
    sail_take_exception(None());
    if (target_el == EL1 & EL2Enabled()) & HCR_EL2[TGE] == 0b1 then {
        AArch64_TakeException(EL2, except, preferred_exception_return, vect_offset)
    } else {
        AArch64_TakeException(target_el, except, preferred_exception_return, vect_offset)
    }
}

val AArch64_CheckForWFxTrap : (bits(2), WFxType) -> unit

function AArch64_CheckForWFxTrap (target_el, wfxtype) = {
    assert(HaveEL(target_el));
    let is_wfe : bool = wfxtype == WFxType_WFE | wfxtype == WFxType_WFET;
    trap : bool = undefined;
    match target_el {
      ? if ? == EL1 => {
          trap = (if is_wfe then SCTLR_read__1()[nTWE] else
            SCTLR_read__1()[nTWI]) == 0b0
      },
      ? if ? == EL2 => {
          trap = (if is_wfe then HCR_EL2[TWE] else HCR_EL2[TWI]) == 0b1
      },
      ? if ? == EL3 => {
          trap = (if is_wfe then SCR_EL3[TWE] else SCR_EL3[TWI]) == 0b1
      },
      _ => ()
    };
    if trap then {
        AArch64_WFxTrap(wfxtype, target_el)
    };
    ()
}

val ClearEventRegister : unit -> unit

function ClearEventRegister () = {
    EventRegister = 0b0;
    return()
}

val HaveFeatWFxT : unit -> bool

function HaveFeatWFxT () = {
    return(IsFeatureImplemented(FEAT_WFxT))
}

val HaveTWEDExt : unit -> bool

function HaveTWEDExt () = {
    return(IsFeatureImplemented(FEAT_TWED))
}

val IsEventRegisterSet : unit -> bool

function IsEventRegisterSet () = {
    return(EventRegister == 0b1)
}

val LocalTimeoutEvent : forall 'localtimeout. int('localtimeout) -> bool

val WFETrapDelay : bits(2) -> (bool, int)

function WFETrapDelay target_el = {
    delay_enabled : bool = undefined;
    delay : int = undefined;
    match target_el {
      ? if ? == EL1 => {
          if not_bool(IsInHost()) then {
              delay_enabled = SCTLR_EL1[TWEDEn] == 0b1;
              delay = (1 << (UInt(SCTLR_EL1[TWEDEL]) + 8))
          } else {
              delay_enabled = SCTLR_EL2[TWEDEn] == 0b1;
              delay = (1 << (UInt(SCTLR_EL2[TWEDEL]) + 8))
          }
      },
      ? if ? == EL2 => {
          assert(EL2Enabled());
          delay_enabled = HCR_EL2[TWEDEn] == 0b1;
          delay = (1 << (UInt(HCR_EL2[TWEDEL]) + 8))
      },
      ? if ? == EL3 => {
          delay_enabled = SCR_EL3[TWEDEn] == 0b1;
          delay = (1 << (UInt(SCR_EL3[TWEDEL]) + 8))
      },
      _ => ()
    };
    let 'delay = delay;
    return((delay_enabled, delay))
}

val EnterLowPowerState : unit -> unit

val WaitForEvent : forall 'localtimeout. int('localtimeout) -> unit

function WaitForEvent localtimeout = {
    if not_bool(IsEventRegisterSet() | HaveFeatWFxT() & LocalTimeoutEvent(localtimeout)) then {
        IsWFEsleep = true;
        _DormantCtlReg[standbywfe] = 0b1;
        EnterLowPowerState()
    };
    return()
}

val WaitForEventUntilDelay : forall 'delay ('delay_enabled : Bool).
  (bool('delay_enabled), int('delay)) -> bool

val Hint_WFE : forall 'localtimeout. (int('localtimeout), WFxType) -> unit

function Hint_WFE (localtimeout, wfxtype) = {
    delay : int = undefined;
    delay_enabled : bool = undefined;
    sctlr : SCTLRType = undefined;
    trap : bool = undefined;
    if IsEventRegisterSet() then {
        ClearEventRegister()
    } else if HaveFeatWFxT() & LocalTimeoutEvent(localtimeout) then {
        EndOfInstruction()
    } else {
        target_el : bits(2) = undefined;
        trap : bool = false;
        if PSTATE.EL == EL0 then {
            if HaveTWEDExt() then {
                let sctlr : SCTLRType = SCTLR_read__1();
                trap = sctlr[nTWE] == 0b0;
                target_el = EL1
            } else {
                AArch64_CheckForWFxTrap(EL1, wfxtype)
            }
        };
        if ((not_bool(trap) & (PSTATE.EL == EL0 | PSTATE.EL == EL1)) & EL2Enabled()) & not_bool(IsInHost()) then {
            if HaveTWEDExt() then {
                trap = HCR_EL2[TWE] == 0b1;
                target_el = EL2
            } else {
                AArch64_CheckForWFxTrap(EL2, wfxtype)
            }
        };
        if (not_bool(trap) & HaveEL(EL3)) & PSTATE.EL != EL3 then {
            if HaveTWEDExt() then {
                trap = SCR_EL3[TWE] == 0b1;
                target_el = EL3
            } else {
                AArch64_CheckForWFxTrap(EL3, wfxtype)
            }
        };
        if trap & PSTATE.EL != EL3 then {
            (delay_enabled, delay) = WFETrapDelay(target_el);
            let 'delay = delay;
            if not_bool(WaitForEventUntilDelay(delay_enabled, delay)) then {
                AArch64_WFxTrap(wfxtype, target_el)
            };
            ()
        } else {
            WaitForEvent(localtimeout)
        }
    }
}

val IsVirtualSErrorPending : unit -> bool

function IsVirtualSErrorPending () = {
    if ELUsingAArch32(EL2) then {
        return(HCR_read()[VA] == 0b1)
    } else {
        return(HCR_EL2[VSE] == 0b1)
    }
}

val InterruptPending : unit -> bool

function InterruptPending () = {
    fiq_pending : bool = undefined;
    irq_pending : bool = undefined;
    pending_virtual_interrupt : bool = false;
    let (__tup_0 : bool, _) = IRQPending() in
      {
          irq_pending = __tup_0
      };
    let (__tup_0 : bool, _) = FIQPending() in
      {
          fiq_pending = __tup_0
      };
    let pending_physical_interrupt : bool = (irq_pending | fiq_pending) | IsPhysicalSErrorPending();
    if (EL2Enabled() & (PSTATE.EL == EL0 | PSTATE.EL == EL1)) & HCR_EL2[TGE] == 0b0 then {
        let virq_pending : bool = HCR_EL2[IMO] == 0b1 & (VirtualIRQPending() | HCR_EL2[VI] == 0b1);
        let vfiq_pending : bool = HCR_EL2[FMO] == 0b1 & (VirtualFIQPending() | HCR_EL2[VF] == 0b1);
        let vsei_pending : bool = HCR_EL2[AMO] == 0b1 & (IsVirtualSErrorPending() | HCR_EL2[VSE] == 0b1);
        pending_virtual_interrupt = (vsei_pending | virq_pending) | vfiq_pending
    };
    return(pending_physical_interrupt | pending_virtual_interrupt)
}

val WaitForInterrupt : forall 'localtimeout. int('localtimeout) -> unit

function WaitForInterrupt localtimeout = {
    if not_bool(HaveFeatWFxT() & LocalTimeoutEvent(localtimeout)) then {
        IsWFIsleep = true;
        _DormantCtlReg[standbywfi] = 0b1;
        EnterLowPowerState()
    };
    return()
}

val Hint_WFI : forall 'localtimeout. (int('localtimeout), WFxType) -> unit

function Hint_WFI (localtimeout, wfxtype) = {
    if HaveTME() & TSTATE.depth > 0 then {
        FailTransaction(TMFailure_ERR, false)
    };
    if InterruptPending() | HaveFeatWFxT() & LocalTimeoutEvent(localtimeout) then {
        EndOfInstruction()
    } else {
        if PSTATE.EL == EL0 then {
            AArch64_CheckForWFxTrap(EL1, wfxtype)
        };
        if ((PSTATE.EL == EL0 | PSTATE.EL == EL1) & EL2Enabled()) & not_bool(IsInHost()) then {
            AArch64_CheckForWFxTrap(EL2, wfxtype)
        };
        if HaveEL(EL3) & PSTATE.EL != EL3 then {
            AArch64_CheckForWFxTrap(EL3, wfxtype)
        };
        WaitForInterrupt(localtimeout)
    }
}

val SendEvent : unit -> unit

val SendEventLocal : unit -> unit

function SendEventLocal () = {
    EventRegister = 0b1;
    return()
}

val InstructionSynchronizationBarrier : unit -> unit

val SpeculationBarrier : unit -> unit

val ConsumptionOfSpeculativeDataBarrier : unit -> unit

val TakeUnmaskedSErrorInterrupts : unit -> unit

val IsASEInstruction : unit -> bool

val GetAccumulatedFPExceptions : unit -> bits(8)

val SetAccumulatedFPExceptions : bits(8) -> unit

val EffectiveEA : unit -> bits(1)

function EffectiveEA () = {
    if Halted() & EDSCR_read()[SDD] == 0b0 then {
        return(0b0)
    } else {
        return(if HaveAArch64() then SCR_EL3[EA] else SCR[EA])
    }
}

val EL3SDDUndefPriority : unit -> bool

function EL3SDDUndefPriority () = {
    return((Halted() & EDSCR_read()[SDD] == 0b1) & __IMPDEF_boolean("EL3 trap priority when SDD == '1'"))
}

val EL3SDDUndef : unit -> bool

function EL3SDDUndef () = {
    return(Halted() & EDSCR_read()[SDD] == 0b1)
}

val GetLoadStoreType : unit -> bits(2)

bitfield GCSCRE0_EL1_Type : bits(64) =
  {nTR : 10..10, STREn : 9..9, PUSHMEn : 8..8, RVCHKEN : 5..5, PCRSEL : 0..0}

register GCSCRE0_EL1 : GCSCRE0_EL1_Type

val GCSPCRSelected : bits(2) -> bool

function GCSPCRSelected el = {
    match el {
      ? if ? == EL0 => {
          return(GCSCRE0_EL1[PCRSEL] == 0b1)
      },
      ? if ? == EL1 => {
          return(GCSCR_EL1[PCRSEL] == 0b1)
      },
      ? if ? == EL2 => {
          return(GCSCR_EL2[PCRSEL] == 0b1)
      },
      ? if ? == EL3 => {
          return(GCSCR_EL3[PCRSEL] == 0b1)
      },
      _ => ()
    };
    Unreachable();
    return(true)
}

bitfield HCRX_EL2_Type : bits(64) =
  {
    GCSEn : 22..22,
    EnIDCP128 : 21..21,
    EnSDERR : 20..20,
    TMEA : 19..19,
    EnSNERR : 18..18,
    D128En : 17..17,
    PTTWI : 16..16,
    SCTLR2En : 15..15,
    TCR2En : 14..14,
    MSCEn : 11..11,
    MCE2 : 10..10,
    CMOW : 9..9,
    VFNMI : 8..8,
    VINMI : 7..7,
    TALLINT : 6..6,
    SMPME : 5..5,
    FGTnXS : 4..4,
    FnXS : 3..3,
    EnASR : 2..2,
    EnALS : 1..1,
    EnAS0 : 0..0
  }

register HCRX_EL2 : HCRX_EL2_Type

val HaveFeatHCX : unit -> bool

function HaveFeatHCX () = {
    return(IsFeatureImplemented(FEAT_HCX))
}

val IsHCRXEL2Enabled : unit -> bool

function IsHCRXEL2Enabled () = {
    if not_bool(HaveFeatHCX()) then {
        return(false)
    };
    if HaveEL(EL3) & SCR_EL3[HXEn] == 0b0 then {
        return(false)
    };
    return(EL2Enabled())
}

val GCSEnabled : bits(2) -> bool

function GCSEnabled el = {
    if UsingAArch32() then {
        return(false)
    };
    if (HaveEL(EL3) & el != EL3) & SCR_EL3[GCSEn] == 0b0 then {
        return(false)
    };
    if (((el == EL0 | el == EL1) & EL2Enabled()) & (HCR_EL2[TGE] == 0b0 | HCR_EL2[E2H] == 0b0)) & (not_bool(IsHCRXEL2Enabled()) | HCRX_EL2[GCSEn] == 0b0) then {
        return(false)
    };
    return(GCSPCRSelected(el))
}

val AArch64_ChkFeat : bits(64) -> bits(64)

function AArch64_ChkFeat feat_select = {
    feat_en : bits(64) = Zeros(64);
    feat_en[0] = Bit(if HaveGCS() & GCSEnabled(PSTATE.EL) then 0b1 else 0b0);
    return(feat_select & not_vec(feat_en))
}

let TAG_GRANULE : int(16) = 16

val DataSynchronizationBarrier : forall ('nXS : Bool).
  (MBReqDomain, MBReqTypes, bool('nXS)) -> unit

val DataMemoryBarrier : (MBReqDomain, MBReqTypes) -> unit

val SpeculativeStoreBypassBarrierToVA : unit -> unit

val SpeculativeStoreBypassBarrierToPA : unit -> unit

val Hint_Prefetch : forall ('stream : Bool) 'target.
  (bits(64), PrefetchHint, int('target), bool('stream)) -> unit

val Hint_RangePrefetch : forall 'count 'length 'reuse 'stride.
  (bits(64), int('length), int('stride), int('count), int('reuse), bits(6)) -> unit

val BigEndian : AccessType -> bool

function BigEndian acctype = {
    bigend : bool = undefined;
    if HaveNV2Ext() & acctype == AccessType_NV2 then {
        return(SCTLR_EL2[EE] == 0b1)
    };
    if UsingAArch32() then {
        bigend = PSTATE.E != 0b0
    } else if PSTATE.EL == EL0 then {
        bigend = SCTLR_read__1()[E0E] != 0b0
    } else {
        bigend = SCTLR_read__1()[EE] != 0b0
    };
    return(bigend)
}

val IsDataAccess : AccessType -> bool

function IsDataAccess acctype = {
    return(not_bool(acctype == AccessType_IFETCH | acctype == AccessType_TTW | acctype == AccessType_DC | acctype == AccessType_IC | acctype == AccessType_AT))
}

val EffectiveTCMA : (bits(64), bits(2)) -> bits(1)

function EffectiveTCMA (address, el) = {
    tcma : bits(1) = undefined;
    assert(HaveEL(el));
    let regime : bits(2) = S1TranslationRegime(el);
    assert(not_bool(ELUsingAArch32(regime)));
    match regime {
      ? if ? == EL1 => {
          tcma = if [address[55]] == 0b1 then TCR_EL1[TCMA1] else TCR_EL1[TCMA0]
      },
      ? if ? == EL2 => {
          if HaveVirtHostExt() & ELIsInHost(el) then {
              tcma = if [address[55]] == 0b1 then TCR_EL2[TCMA1] else
                TCR_EL2[TCMA0]
          } else {
              tcma = TCR_EL2[TCMA]
          }
      },
      ? if ? == EL3 => {
          tcma = TCR_EL3[TCMA]
      },
      _ => ()
    };
    return(tcma)
}

val HaveMTE4Ext : unit -> bool

function HaveMTE4Ext () = {
    return(IsFeatureImplemented(FEAT_MTE4))
}

val EffectiveMTX : forall ('is_instr : Bool).
  (bits(64), bool('is_instr), bits(2)) -> bits(1)

function EffectiveMTX (address, is_instr, el) = {
    mtx : bits(1) = undefined;
    assert(HaveEL(el));
    let regime : bits(2) = S1TranslationRegime(el);
    assert(not_bool(ELUsingAArch32(regime)));
    if not_bool(HaveMTE4Ext()) | is_instr then {
        mtx = 0b0
    } else {
        match regime {
          ? if ? == EL1 => {
              mtx = if [address[55]] == 0b1 then TCR_EL1[MTX1] else
                TCR_EL1[MTX0]
          },
          ? if ? == EL2 => {
              if HaveVirtHostExt() & ELIsInHost(el) then {
                  mtx = if [address[55]] == 0b1 then TCR_EL2[MTX1] else
                    TCR_EL2[MTX0]
              } else {
                  mtx = TCR_EL2[MTX]
              }
          },
          ? if ? == EL3 => {
              mtx = TCR_EL3[MTX]
          },
          _ => ()
        }
    };
    return(mtx)
}

val PhysMemRead : forall 'size, 'size > 0.
  (AddressDescriptor, int('size), AccessDescriptor, option(TranslationInfo)) -> (PhysMemRetStatus, bits(8 * 'size))

val PhysMemWrite : forall 'size, 'size > 0.
  (AddressDescriptor, int('size), AccessDescriptor, option(TranslationInfo), bits(8 * 'size)) -> PhysMemRetStatus

overload BigEndianReverse = {reverse_endianness}

bitfield MPAM2_EL2_Type : bits(64) =
  {
    MPAMEN : 63..63,
    TIDR : 58..58,
    ALTSP_HFC : 56..56,
    ALTSP_EL2 : 55..55,
    ALTSP_FRCD : 54..54,
    EnMPAMSM : 50..50,
    TRAPMPAM0EL1 : 49..49,
    TRAPMPAM1EL1 : 48..48,
    PMG_D : 47..40,
    PMG_I : 39..32,
    PARTID_D : 31..16,
    PARTID_I : 15..0
  }

register MPAM2_EL2 : MPAM2_EL2_Type

bitfield MPAM3_EL3_Type : bits(64) =
  {
    MPAMEN : 63..63,
    TRAPLOWER : 62..62,
    SDEFLT : 61..61,
    FORCE_NS : 60..60,
    ALTSP_HEN : 57..57,
    ALTSP_HFC : 56..56,
    ALTSP_EL3 : 55..55,
    RT_ALTSP_NS : 52..52,
    PMG_D : 47..40,
    PMG_I : 39..32,
    PARTID_D : 31..16,
    PARTID_I : 15..0
  }

register _MPAM3_EL3 : MPAM3_EL3_Type

val MPAM3_EL3_read : unit -> MPAM3_EL3_Type

function MPAM3_EL3_read () = {
    r : MPAM3_EL3_Type = _MPAM3_EL3;
    r.bits[63] = Bit(Slice(MPAM2_EL2.bits, 63, 1));
    return(r)
}

bitfield MPAM1_EL1_Type : bits(64) =
  {
    MPAMEN : 63..63,
    FORCED_NS : 60..60,
    ALTSP_FRCD : 54..54,
    PMG_D : 47..40,
    PMG_I : 39..32,
    PARTID_D : 31..16,
    PARTID_I : 15..0
  }

register _MPAM1_EL1 : MPAM1_EL1_Type

val MPAM1_EL1_read : unit -> MPAM1_EL1_Type

function MPAM1_EL1_read () = {
    r : MPAM1_EL1_Type = _MPAM1_EL1;
    if HaveEL(EL3) then {
        r.bits[63] = Bit(Slice(MPAM3_EL3_read().bits, 63, 1))
    } else {
        r.bits[63] = Bit(Slice(MPAM2_EL2.bits, 63, 1))
    };
    return(r)
}

val MPAMisEnabled : unit -> bool

function MPAMisEnabled () = {
    let el : bits(2) = HighestEL();
    match el {
      ? if ? == EL3 => {
          return(MPAM3_EL3_read()[MPAMEN] == 0b1)
      },
      ? if ? == EL2 => {
          return(MPAM2_EL2[MPAMEN] == 0b1)
      },
      ? if ? == EL1 => {
          return(MPAM1_EL1_read()[MPAMEN] == 0b1)
      },
      _ => {
          return(undefined : bool)
      }
    }
}

val UsePrimarySpaceEL10 : unit -> bool

function UsePrimarySpaceEL10 () = {
    if MPAM3_EL3_read()[ALTSP_HEN] == 0b0 then {
        return(MPAM3_EL3_read()[ALTSP_HFC] == 0b0)
    };
    return((not_bool(MPAMisEnabled()) | not_bool(EL2Enabled())) | MPAM2_EL2[ALTSP_HFC] == 0b0)
}

val UsePrimarySpaceEL2 : unit -> bool

function UsePrimarySpaceEL2 () = {
    if MPAM3_EL3_read()[ALTSP_HEN] == 0b0 then {
        return(MPAM3_EL3_read()[ALTSP_HFC] == 0b0)
    };
    return(not_bool(MPAMisEnabled()) | MPAM2_EL2[ALTSP_EL2] == 0b0)
}

val AltPIdRealm : (bits(2), PARTIDspaceType) -> PARTIDspaceType

function AltPIdRealm (el, primaryPIdSpace) = {
    PIdSpace : PARTIDspaceType = primaryPIdSpace;
    match el {
      ? if ? == EL0 => {
          if ELIsInHost(EL0) then {
              if not_bool(UsePrimarySpaceEL2()) then {
                  PIdSpace = PIdSpace_NonSecure
              };
              ()
          } else if not_bool(UsePrimarySpaceEL10()) then {
              PIdSpace = PIdSpace_NonSecure
          } else ()
      },
      ? if ? == EL1 => {
          if not_bool(UsePrimarySpaceEL10()) then {
              PIdSpace = PIdSpace_NonSecure
          };
          ()
      },
      ? if ? == EL2 => {
          if not_bool(UsePrimarySpaceEL2()) then {
              PIdSpace = PIdSpace_NonSecure
          };
          ()
      },
      _ => {
          Unreachable()
      }
    };
    return(PIdSpace)
}

val AltPIdSecure : (bits(2), PARTIDspaceType) -> PARTIDspaceType

function AltPIdSecure (el, primaryPIdSpace) = {
    PIdSpace : PARTIDspaceType = primaryPIdSpace;
    let el2en : bool = EL2Enabled();
    match el {
      ? if ? == EL0 => {
          if el2en then {
              if ELIsInHost(EL0) then {
                  if not_bool(UsePrimarySpaceEL2()) then {
                      PIdSpace = PIdSpace_NonSecure
                  };
                  ()
              } else if not_bool(UsePrimarySpaceEL10()) then {
                  PIdSpace = PIdSpace_NonSecure
              } else ()
          } else if MPAM3_EL3_read()[ALTSP_HEN] == 0b0 & MPAM3_EL3_read()[ALTSP_HFC] == 0b1 then {
              PIdSpace = PIdSpace_NonSecure
          } else ()
      },
      ? if ? == EL1 => {
          if el2en then {
              if not_bool(UsePrimarySpaceEL10()) then {
                  PIdSpace = PIdSpace_NonSecure
              };
              ()
          } else if MPAM3_EL3_read()[ALTSP_HEN] == 0b0 & MPAM3_EL3_read()[ALTSP_HFC] == 0b1 then {
              PIdSpace = PIdSpace_NonSecure
          } else ()
      },
      ? if ? == EL2 => {
          if not_bool(UsePrimarySpaceEL2()) then {
              PIdSpace = PIdSpace_NonSecure
          };
          ()
      },
      _ => {
          Unreachable()
      }
    };
    return(PIdSpace)
}

val AltPARTIDspace : (bits(2), SecurityState, PARTIDspaceType) -> PARTIDspaceType

function AltPARTIDspace (el, security, primaryPIdSpace) = {
    match security {
      SS_NonSecure => {
          assert(el != EL3);
          return(primaryPIdSpace)
      },
      SS_Secure => {
          assert(el != EL3);
          if primaryPIdSpace == PIdSpace_NonSecure then {
              return(primaryPIdSpace)
          };
          return(AltPIdSecure(el, primaryPIdSpace))
      },
      SS_Root => {
          assert(el == EL3);
          if MPAM3_EL3_read()[ALTSP_EL3] == 0b1 then {
              if MPAM3_EL3_read()[RT_ALTSP_NS] == 0b1 then {
                  return(PIdSpace_NonSecure)
              } else {
                  return(PIdSpace_Secure)
              }
          } else {
              return(primaryPIdSpace)
          }
      },
      SS_Realm => {
          assert(el != EL3);
          return(AltPIdRealm(el, primaryPIdSpace))
      },
      _ => {
          Unreachable();
          return(undefined : PARTIDspaceType)
      }
    }
}

val DefaultMPAMinfo : PARTIDspaceType -> MPAMinfo

function DefaultMPAMinfo partidspace = {
    DefaultInfo : MPAMinfo = undefined;
    DefaultInfo.mpam_sp = partidspace;
    DefaultInfo.partid = DefaultPARTID;
    DefaultInfo.pmg = DefaultPMG;
    return(DefaultInfo)
}

val HaveMPAMv0p1Ext : unit -> bool

function HaveMPAMv0p1Ext () = {
    return(IsFeatureImplemented(FEAT_MPAMv0p1))
}

val HaveMPAMv1p1Ext : unit -> bool

function HaveMPAMv1p1Ext () = {
    return(IsFeatureImplemented(FEAT_MPAMv1p1))
}

bitfield MPAMIDR_EL1_Type : bits(64) =
  {
    HAS_SDEFLT : 61..61,
    HAS_FORCE_NS : 60..60,
    SP4 : 59..59,
    HAS_TIDR : 58..58,
    HAS_ALTSP : 57..57,
    PMG_MAX : 39..32,
    VPMR_MAX : 20..18,
    HAS_HCR : 17..17,
    PARTID_MAX : 15..0
  }

register MPAMIDR_EL1 : MPAMIDR_EL1_Type

val PARTIDspaceFromSS : SecurityState -> PARTIDspaceType

function PARTIDspaceFromSS security = {
    match security {
      SS_NonSecure => {
          return(PIdSpace_NonSecure)
      },
      SS_Root => {
          return(PIdSpace_Root)
      },
      SS_Realm => {
          return(PIdSpace_Realm)
      },
      SS_Secure => {
          return(PIdSpace_Secure)
      },
      _ => {
          Unreachable();
          return(undefined : PARTIDspaceType)
      }
    }
}

bitfield MPAMHCR_EL2_Type : bits(64) =
  {
    TRAP_MPAMIDR_EL1 : 31..31,
    GSTAPP_PLK : 8..8,
    EL1_VPMEN : 1..1,
    EL0_VPMEN : 0..0
  }

register MPAMHCR_EL2 : MPAMHCR_EL2_Type

bitfield MPAMVPM0_EL2_Type : bits(64) =
  {
    PhyPARTID3 : 63..48,
    PhyPARTID2 : 47..32,
    PhyPARTID1 : 31..16,
    PhyPARTID0 : 15..0
  }

register MPAMVPM0_EL2 : MPAMVPM0_EL2_Type

bitfield MPAMVPMV_EL2_Type : bits(64) =
  {
    VPM_V31 : 31..31,
    VPM_V30 : 30..30,
    VPM_V29 : 29..29,
    VPM_V28 : 28..28,
    VPM_V27 : 27..27,
    VPM_V26 : 26..26,
    VPM_V25 : 25..25,
    VPM_V24 : 24..24,
    VPM_V23 : 23..23,
    VPM_V22 : 22..22,
    VPM_V21 : 21..21,
    VPM_V20 : 20..20,
    VPM_V19 : 19..19,
    VPM_V18 : 18..18,
    VPM_V17 : 17..17,
    VPM_V16 : 16..16,
    VPM_V15 : 15..15,
    VPM_V14 : 14..14,
    VPM_V13 : 13..13,
    VPM_V12 : 12..12,
    VPM_V11 : 11..11,
    VPM_V10 : 10..10,
    VPM_V9 : 9..9,
    VPM_V8 : 8..8,
    VPM_V7 : 7..7,
    VPM_V6 : 6..6,
    VPM_V5 : 5..5,
    VPM_V4 : 4..4,
    VPM_V3 : 3..3,
    VPM_V2 : 2..2,
    VPM_V1 : 1..1,
    VPM_V0 : 0..0
  }

register MPAMVPMV_EL2 : MPAMVPMV_EL2_Type

bitfield MPAMVPM1_EL2_Type : bits(64) =
  {
    PhyPARTID7 : 63..48,
    PhyPARTID6 : 47..32,
    PhyPARTID5 : 31..16,
    PhyPARTID4 : 15..0
  }

register MPAMVPM1_EL2 : MPAMVPM1_EL2_Type

bitfield MPAMVPM2_EL2_Type : bits(64) =
  {
    PhyPARTID11 : 63..48,
    PhyPARTID10 : 47..32,
    PhyPARTID9 : 31..16,
    PhyPARTID8 : 15..0
  }

register MPAMVPM2_EL2 : MPAMVPM2_EL2_Type

bitfield MPAMVPM3_EL2_Type : bits(64) =
  {
    PhyPARTID15 : 63..48,
    PhyPARTID14 : 47..32,
    PhyPARTID13 : 31..16,
    PhyPARTID12 : 15..0
  }

register MPAMVPM3_EL2 : MPAMVPM3_EL2_Type

bitfield MPAMVPM4_EL2_Type : bits(64) =
  {
    PhyPARTID19 : 63..48,
    PhyPARTID18 : 47..32,
    PhyPARTID17 : 31..16,
    PhyPARTID16 : 15..0
  }

register MPAMVPM4_EL2 : MPAMVPM4_EL2_Type

bitfield MPAMVPM5_EL2_Type : bits(64) =
  {
    PhyPARTID23 : 63..48,
    PhyPARTID22 : 47..32,
    PhyPARTID21 : 31..16,
    PhyPARTID20 : 15..0
  }

register MPAMVPM5_EL2 : MPAMVPM5_EL2_Type

bitfield MPAMVPM6_EL2_Type : bits(64) =
  {
    PhyPARTID27 : 63..48,
    PhyPARTID26 : 47..32,
    PhyPARTID25 : 31..16,
    PhyPARTID24 : 15..0
  }

register MPAMVPM6_EL2 : MPAMVPM6_EL2_Type

bitfield MPAMVPM7_EL2_Type : bits(64) =
  {
    PhyPARTID31 : 63..48,
    PhyPARTID30 : 47..32,
    PhyPARTID29 : 31..16,
    PhyPARTID28 : 15..0
  }

register MPAMVPM7_EL2 : MPAMVPM7_EL2_Type

val mapvpmw : forall 'vpartid. int('vpartid) -> PARTIDtype

function mapvpmw vpartid = {
    vpmw : bits(64) = undefined;
    let 'wd = DIV(vpartid, 4);
    match wd {
      0 => {
          vpmw = MPAMVPM0_EL2.bits
      },
      1 => {
          vpmw = MPAMVPM1_EL2.bits
      },
      2 => {
          vpmw = MPAMVPM2_EL2.bits
      },
      3 => {
          vpmw = MPAMVPM3_EL2.bits
      },
      4 => {
          vpmw = MPAMVPM4_EL2.bits
      },
      5 => {
          vpmw = MPAMVPM5_EL2.bits
      },
      6 => {
          vpmw = MPAMVPM6_EL2.bits
      },
      7 => {
          vpmw = MPAMVPM7_EL2.bits
      },
      _ => {
          vpmw = Zeros(64)
      }
    };
    let vpmw = vpmw;
    let 'vpme_lsb = MOD(vpartid, 4) * 16;
    return(Slice(vpmw, vpme_lsb, 16))
}

val MAP_vPARTID : PARTIDtype -> (PARTIDtype, bool)

function MAP_vPARTID vpartid = {
    ret : PARTIDtype = undefined;
    err : bool = undefined;
    virt : int = UInt(vpartid);
    let 'vpmrmax = UInt(MPAMIDR_EL1[VPMR_MAX]);
    let 'vpartid_max = (vpmrmax << 2) + 3;
    if UInt(vpartid) > vpartid_max then {
        virt = MOD(virt, vpartid_max + 1)
    };
    let 'virt = virt;
    assert(constraint((0 <= 'virt & 'virt < 64)));
    if [MPAMVPMV_EL2.bits[virt]] == 0b1 then {
        ret = mapvpmw(virt);
        err = false
    } else if [MPAMVPMV_EL2.bits[0]] == 0b1 then {
        ret = Slice(MPAMVPM0_EL2.bits, 0, 16);
        err = false
    } else {
        ret = DefaultPARTID;
        err = true
    };
    let 'partid_max = UInt(MPAMIDR_EL1[PARTID_MAX]);
    if UInt(ret) > partid_max then {
        ret = DefaultPARTID;
        err = true
    };
    let err = err;
    let ret = ret;
    return((ret, err))
}

val MPAMisVirtual : bits(2) -> bool

function MPAMisVirtual el = {
    return((MPAMIDR_EL1[HAS_HCR] == 0b1 & EL2Enabled()) & ((el == EL0 & MPAMHCR_EL2[EL0_VPMEN] == 0b1) & (HCR_EL2[E2H] == 0b0 | HCR_EL2[TGE] == 0b0) | el == EL1 & MPAMHCR_EL2[EL1_VPMEN] == 0b1))
}

bitfield MPAM0_EL1_Type : bits(64) =
  {PMG_D : 47..40, PMG_I : 39..32, PARTID_D : 31..16, PARTID_I : 15..0}

register MPAM0_EL1 : MPAM0_EL1_Type

bitfield MPAMSM_EL1_Type : bits(64) = {PMG_D : 47..40, PARTID_D : 31..16}

register MPAMSM_EL1 : MPAMSM_EL1_Type

val getMPAM_PARTID : forall ('InD : Bool) ('InSM : Bool).
  (bits(2), bool('InD), bool('InSM)) -> PARTIDtype

function getMPAM_PARTID (MPAMn, InD, InSM) = {
    partid : PARTIDtype = undefined;
    let el2avail : bool = EL2Enabled();
    if InSM then {
        partid = MPAMSM_EL1[PARTID_D];
        return(partid)
    };
    if InD then {
        match MPAMn {
          0b11 => {
              partid = MPAM3_EL3_read()[PARTID_I]
          },
          0b10 => {
              partid = if el2avail then MPAM2_EL2[PARTID_I] else Zeros(16)
          },
          0b01 => {
              partid = MPAM1_EL1_read()[PARTID_I]
          },
          0b00 => {
              partid = MPAM0_EL1[PARTID_I]
          },
          _ => {
              partid = __UNKNOWN_PARTIDtype()
          }
        }
    } else {
        match MPAMn {
          0b11 => {
              partid = MPAM3_EL3_read()[PARTID_D]
          },
          0b10 => {
              partid = if el2avail then MPAM2_EL2[PARTID_D] else Zeros(16)
          },
          0b01 => {
              partid = MPAM1_EL1_read()[PARTID_D]
          },
          0b00 => {
              partid = MPAM0_EL1[PARTID_D]
          },
          _ => {
              partid = __UNKNOWN_PARTIDtype()
          }
        }
    };
    return(partid)
}

val genPARTID : forall ('InD : Bool) ('InSM : Bool).
  (bits(2), bool('InD), bool('InSM)) -> (PARTIDtype, bool)

function genPARTID (el, InD, InSM) = {
    let partidel : PARTIDtype = getMPAM_PARTID(el, InD, InSM);
    let partid_max : PARTIDtype = MPAMIDR_EL1[PARTID_MAX];
    if UInt(partidel) > UInt(partid_max) then {
        return((DefaultPARTID, true))
    };
    if MPAMisVirtual(el) then {
        return(MAP_vPARTID(partidel))
    } else {
        return((partidel, false))
    }
}

val getMPAM_PMG : forall ('InD : Bool) ('InSM : Bool).
  (bits(2), bool('InD), bool('InSM)) -> PMGtype

function getMPAM_PMG (MPAMn, InD, InSM) = {
    pmg : PMGtype = undefined;
    let el2avail : bool = EL2Enabled();
    if InSM then {
        pmg = MPAMSM_EL1[PMG_D];
        return(pmg)
    };
    if InD then {
        match MPAMn {
          0b11 => {
              pmg = MPAM3_EL3_read()[PMG_I]
          },
          0b10 => {
              pmg = if el2avail then MPAM2_EL2[PMG_I] else Zeros(8)
          },
          0b01 => {
              pmg = MPAM1_EL1_read()[PMG_I]
          },
          0b00 => {
              pmg = MPAM0_EL1[PMG_I]
          },
          _ => {
              pmg = __UNKNOWN_PMGtype()
          }
        }
    } else {
        match MPAMn {
          0b11 => {
              pmg = MPAM3_EL3_read()[PMG_D]
          },
          0b10 => {
              pmg = if el2avail then MPAM2_EL2[PMG_D] else Zeros(8)
          },
          0b01 => {
              pmg = MPAM1_EL1_read()[PMG_D]
          },
          0b00 => {
              pmg = MPAM0_EL1[PMG_D]
          },
          _ => {
              pmg = __UNKNOWN_PMGtype()
          }
        }
    };
    return(pmg)
}

val genPMG : forall ('InD : Bool) ('InSM : Bool) ('partid_err : Bool).
  (bits(2), bool('InD), bool('InSM), bool('partid_err)) -> PMGtype

function genPMG (el, InD, InSM, partid_err) = {
    let 'pmg_max = UInt(MPAMIDR_EL1[PMG_MAX]);
    if partid_err then {
        return(DefaultPMG)
    };
    let groupel : PMGtype = getMPAM_PMG(el, InD, InSM);
    if UInt(groupel) <= pmg_max then {
        return(groupel)
    };
    return(DefaultPMG)
}

val genMPAM : forall ('InD : Bool) ('InSM : Bool).
  (bits(2), bool('InD), bool('InSM), PARTIDspaceType) -> MPAMinfo

function genMPAM (el, InD, InSM, pspace) = {
    returninfo : MPAMinfo = undefined;
    partidel : PARTIDtype = undefined;
    perr : bool = undefined;
    let gstplk : bool = ((el == EL0 & EL2Enabled()) & MPAMHCR_EL2[GSTAPP_PLK] == 0b1) & HCR_EL2[TGE] == 0b0;
    let eff_el : bits(2) = if gstplk then EL1 else el;
    (partidel, perr) = genPARTID(eff_el, InD, InSM);
    let groupel : PMGtype = genPMG(eff_el, InD, InSM, perr);
    returninfo.mpam_sp = pspace;
    returninfo.partid = partidel;
    returninfo.pmg = groupel;
    return(returninfo)
}

val GenMPAMatEL : (AccessType, bits(2)) -> MPAMinfo

function GenMPAMatEL (acctype, el) = {
    mpamEL : bits(2) = undefined;
    validEL_name : bool = false;
    let security : SecurityState = SecurityStateAtEL(el);
    InD : bool = false;
    InSM : bool = false;
    pspace : PARTIDspaceType = PARTIDspaceFromSS(security);
    if pspace == PIdSpace_NonSecure & not_bool(MPAMisEnabled()) then {
        return(DefaultMPAMinfo(pspace))
    };
    if UsingAArch32() then {
        (validEL_name, mpamEL) = ELFromM32(PSTATE.M)
    } else {
        mpamEL = if acctype == AccessType_NV2 then EL2 else el;
        validEL_name = true
    };
    match acctype {
      AccessType_IFETCH => {
          InD = true
      },
      AccessType_IC => {
          InD = true
      },
      AccessType_SME => {
          InSM = __IMPDEF_boolean("Shared SMCU") | __IMPDEF_boolean("MPAMSM_EL1 label precedence")
      },
      AccessType_ASIMD => {
          InSM = (HaveSME() & PSTATE.SM == 0b1) & (__IMPDEF_boolean("Shared SMCU") | __IMPDEF_boolean("MPAMSM_EL1 label precedence"))
      },
      AccessType_SVE => {
          InSM = (HaveSME() & PSTATE.SM == 0b1) & (__IMPDEF_boolean("Shared SMCU") | __IMPDEF_boolean("MPAMSM_EL1 label precedence"))
      },
      _ => {
          InD = false
      }
    };
    if not_bool(validEL_name) then {
        return(DefaultMPAMinfo(pspace))
    } else if HaveRME() & MPAMIDR_EL1[HAS_ALTSP] == 0b1 then {
        pspace = AltPARTIDspace(mpamEL, security, pspace)
    } else ();
    if HaveMPAMv0p1Ext() & MPAMIDR_EL1[HAS_FORCE_NS] == 0b1 then {
        if MPAM3_EL3_read()[FORCE_NS] == 0b1 & security == SS_Secure then {
            pspace = PIdSpace_NonSecure
        };
        ()
    };
    if (HaveMPAMv0p1Ext() | HaveMPAMv1p1Ext()) & MPAMIDR_EL1[HAS_SDEFLT] == 0b1 then {
        if MPAM3_EL3_read()[SDEFLT] == 0b1 & security == SS_Secure then {
            return(DefaultMPAMinfo(pspace))
        };
        ()
    };
    if not_bool(MPAMisEnabled()) then {
        return(DefaultMPAMinfo(pspace))
    } else {
        return(genMPAM(mpamEL, InD, InSM, pspace))
    }
}

val GenMPAMcurEL : AccessType -> MPAMinfo

function GenMPAMcurEL acctype = {
    return(GenMPAMatEL(acctype, PSTATE.EL))
}

val NewAccDesc : AccessType -> AccessDescriptor

function NewAccDesc acctype = {
    accdesc : AccessDescriptor = undefined;
    accdesc.acctype = acctype;
    accdesc.el = PSTATE.EL;
    accdesc.ss = SecurityStateAtEL(PSTATE.EL);
    accdesc.acqsc = false;
    accdesc.acqpc = false;
    accdesc.relsc = false;
    accdesc.limitedordered = false;
    accdesc.exclusive = false;
    accdesc.rcw = false;
    accdesc.rcws = false;
    accdesc.atomicop = false;
    accdesc.nontemporal = false;
    accdesc.read = false;
    accdesc.write = false;
    accdesc.pan = false;
    accdesc.nonfault = false;
    accdesc.firstfault = false;
    accdesc.first = false;
    accdesc.contiguous = false;
    accdesc.streamingsve = false;
    accdesc.ls64 = false;
    accdesc.mops = false;
    accdesc.a32lsmd = false;
    accdesc.tagchecked = false;
    accdesc.tagaccess = false;
    accdesc.transactional = false;
    accdesc.mpam = GenMPAMcurEL(acctype);
    return(accdesc)
}

val CreateAccDescIFetch : unit -> AccessDescriptor

function CreateAccDescIFetch () = {
    let accdesc : AccessDescriptor = NewAccDesc(AccessType_IFETCH);
    return(accdesc)
}

val CreateAccDescGPR : forall ('nontemporal : Bool) ('privileged : Bool) ('tagchecked : Bool).
  (MemOp, bool('nontemporal), bool('privileged), bool('tagchecked)) -> AccessDescriptor

function CreateAccDescGPR (memop, nontemporal, privileged, tagchecked) = {
    accdesc : AccessDescriptor = NewAccDesc(AccessType_GPR);
    accdesc.el = if not_bool(privileged) then EL0 else PSTATE.EL;
    accdesc.nontemporal = nontemporal;
    accdesc.read = memop == MemOp_LOAD;
    accdesc.write = memop == MemOp_STORE;
    accdesc.pan = true;
    accdesc.tagchecked = tagchecked;
    accdesc.transactional = HaveTME() & TSTATE.depth > 0;
    return(accdesc)
}

val CreateAccDescExLDST : forall ('acqrel : Bool) ('tagchecked : Bool).
  (MemOp, bool('acqrel), bool('tagchecked)) -> AccessDescriptor

function CreateAccDescExLDST (memop, acqrel, tagchecked) = {
    accdesc : AccessDescriptor = NewAccDesc(AccessType_GPR);
    accdesc.acqsc = acqrel & memop == MemOp_LOAD;
    accdesc.relsc = acqrel & memop == MemOp_STORE;
    accdesc.exclusive = true;
    accdesc.read = memop == MemOp_LOAD;
    accdesc.write = memop == MemOp_STORE;
    accdesc.pan = true;
    accdesc.tagchecked = tagchecked;
    accdesc.transactional = HaveTME() & TSTATE.depth > 0;
    return(accdesc)
}

val CreateAccDescLDGSTG : MemOp -> AccessDescriptor

function CreateAccDescLDGSTG memop = {
    accdesc : AccessDescriptor = NewAccDesc(AccessType_GPR);
    accdesc.read = memop == MemOp_LOAD;
    accdesc.write = memop == MemOp_STORE;
    accdesc.pan = true;
    accdesc.tagaccess = true;
    accdesc.transactional = HaveTME() & TSTATE.depth > 0;
    return(accdesc)
}

val CreateAccDescMOPS : forall ('nontemporal : Bool) ('privileged : Bool).
  (MemOp, bool('privileged), bool('nontemporal)) -> AccessDescriptor

function CreateAccDescMOPS (memop, privileged, nontemporal) = {
    accdesc : AccessDescriptor = NewAccDesc(AccessType_GPR);
    accdesc.el = if not_bool(privileged) then EL0 else PSTATE.EL;
    accdesc.nontemporal = nontemporal;
    accdesc.read = memop == MemOp_LOAD;
    accdesc.write = memop == MemOp_STORE;
    accdesc.pan = true;
    accdesc.mops = true;
    accdesc.tagchecked = true;
    accdesc.transactional = HaveTME() & TSTATE.depth > 0;
    return(accdesc)
}

val CreateAccDescSTGMOPS : forall ('nontemporal : Bool) ('privileged : Bool).
  (bool('privileged), bool('nontemporal)) -> AccessDescriptor

function CreateAccDescSTGMOPS (privileged, nontemporal) = {
    accdesc : AccessDescriptor = NewAccDesc(AccessType_GPR);
    accdesc.el = if not_bool(privileged) then EL0 else PSTATE.EL;
    accdesc.nontemporal = nontemporal;
    accdesc.write = true;
    accdesc.pan = true;
    accdesc.mops = true;
    accdesc.tagaccess = true;
    accdesc.transactional = HaveTME() & TSTATE.depth > 0;
    return(accdesc)
}

val CreateAccDescAtomicOp : forall ('acquire : Bool) ('release : Bool) ('tagchecked : Bool).
  (MemAtomicOp, bool('acquire), bool('release), bool('tagchecked)) -> AccessDescriptor

function CreateAccDescAtomicOp (modop, acquire, release, tagchecked) = {
    accdesc : AccessDescriptor = NewAccDesc(AccessType_GPR);
    accdesc.acqsc = acquire;
    accdesc.relsc = release;
    accdesc.atomicop = true;
    accdesc.modop = modop;
    accdesc.read = true;
    accdesc.write = true;
    accdesc.pan = true;
    accdesc.tagchecked = tagchecked;
    accdesc.transactional = HaveTME() & TSTATE.depth > 0;
    return(accdesc)
}

val CreateAccDescRCW : forall ('acquire : Bool) ('release : Bool) ('soft : Bool) ('tagchecked : Bool).
  (MemAtomicOp, bool('soft), bool('acquire), bool('release), bool('tagchecked)) -> AccessDescriptor

function CreateAccDescRCW (modop, soft, acquire, release, tagchecked) = {
    accdesc : AccessDescriptor = NewAccDesc(AccessType_GPR);
    accdesc.acqsc = acquire;
    accdesc.relsc = release;
    accdesc.rcw = true;
    accdesc.rcws = soft;
    accdesc.atomicop = true;
    accdesc.modop = modop;
    accdesc.read = true;
    accdesc.write = true;
    accdesc.pan = true;
    accdesc.tagchecked = tagchecked;
    accdesc.transactional = HaveTME() & TSTATE.depth > 0;
    return(accdesc)
}

val CreateAccDescAcqRel : forall ('tagchecked : Bool).
  (MemOp, bool('tagchecked)) -> AccessDescriptor

function CreateAccDescAcqRel (memop, tagchecked) = {
    accdesc : AccessDescriptor = NewAccDesc(AccessType_GPR);
    accdesc.acqsc = memop == MemOp_LOAD;
    accdesc.relsc = memop == MemOp_STORE;
    accdesc.read = memop == MemOp_LOAD;
    accdesc.write = memop == MemOp_STORE;
    accdesc.pan = true;
    accdesc.tagchecked = tagchecked;
    accdesc.transactional = HaveTME() & TSTATE.depth > 0;
    return(accdesc)
}

val CreateAccDescLOR : forall ('tagchecked : Bool).
  (MemOp, bool('tagchecked)) -> AccessDescriptor

function CreateAccDescLOR (memop, tagchecked) = {
    accdesc : AccessDescriptor = NewAccDesc(AccessType_GPR);
    accdesc.acqsc = memop == MemOp_LOAD;
    accdesc.relsc = memop == MemOp_STORE;
    accdesc.limitedordered = true;
    accdesc.read = memop == MemOp_LOAD;
    accdesc.write = memop == MemOp_STORE;
    accdesc.pan = true;
    accdesc.tagchecked = tagchecked;
    accdesc.transactional = HaveTME() & TSTATE.depth > 0;
    return(accdesc)
}

val CreateAccDescLDAcqPC : forall ('tagchecked : Bool).
  bool('tagchecked) -> AccessDescriptor

function CreateAccDescLDAcqPC tagchecked = {
    accdesc : AccessDescriptor = NewAccDesc(AccessType_GPR);
    accdesc.acqpc = true;
    accdesc.read = true;
    accdesc.pan = true;
    accdesc.tagchecked = tagchecked;
    accdesc.transactional = HaveTME() & TSTATE.depth > 0;
    return(accdesc)
}

val CreateAccDescA32LSMD : MemOp -> AccessDescriptor

function CreateAccDescA32LSMD memop = {
    accdesc : AccessDescriptor = NewAccDesc(AccessType_GPR);
    accdesc.read = memop == MemOp_LOAD;
    accdesc.write = memop == MemOp_STORE;
    accdesc.pan = true;
    accdesc.a32lsmd = true;
    accdesc.transactional = HaveTME() & TSTATE.depth > 0;
    return(accdesc)
}

val CreateAccDescLS64 : forall ('tagchecked : Bool).
  (MemOp, bool('tagchecked)) -> AccessDescriptor

function CreateAccDescLS64 (memop, tagchecked) = {
    accdesc : AccessDescriptor = NewAccDesc(AccessType_GPR);
    accdesc.read = memop == MemOp_LOAD;
    accdesc.write = memop == MemOp_STORE;
    accdesc.pan = true;
    accdesc.ls64 = true;
    accdesc.tagchecked = tagchecked;
    accdesc.transactional = HaveTME() & TSTATE.depth > 0;
    return(accdesc)
}

val InStreamingMode : unit -> bool

function InStreamingMode () = {
    return(HaveSME() & PSTATE.SM == 0b1)
}

val CreateAccDescASIMD : forall ('nontemporal : Bool) ('tagchecked : Bool).
  (MemOp, bool('nontemporal), bool('tagchecked)) -> AccessDescriptor

function CreateAccDescASIMD (memop, nontemporal, tagchecked) = {
    accdesc : AccessDescriptor = NewAccDesc(AccessType_ASIMD);
    accdesc.nontemporal = nontemporal;
    accdesc.read = memop == MemOp_LOAD;
    accdesc.write = memop == MemOp_STORE;
    accdesc.pan = true;
    accdesc.streamingsve = InStreamingMode();
    if accdesc.streamingsve & __IMPDEF_boolean("No tag checking of SIMD&FP loads and stores in Streaming SVE mode") then {
        accdesc.tagchecked = false
    } else {
        accdesc.tagchecked = tagchecked
    };
    accdesc.transactional = HaveTME() & TSTATE.depth > 0;
    return(accdesc)
}

val CreateAccDescASIMDAcqRel : forall ('tagchecked : Bool).
  (MemOp, bool('tagchecked)) -> AccessDescriptor

function CreateAccDescASIMDAcqRel (memop, tagchecked) = {
    accdesc : AccessDescriptor = NewAccDesc(AccessType_ASIMD);
    accdesc.acqpc = memop == MemOp_LOAD;
    accdesc.relsc = memop == MemOp_STORE;
    accdesc.read = memop == MemOp_LOAD;
    accdesc.write = memop == MemOp_STORE;
    accdesc.pan = true;
    accdesc.streamingsve = InStreamingMode();
    if accdesc.streamingsve & __IMPDEF_boolean("No tag checking of SIMD&FP loads and stores in Streaming SVE mode") then {
        accdesc.tagchecked = false
    } else {
        accdesc.tagchecked = tagchecked
    };
    accdesc.transactional = HaveTME() & TSTATE.depth > 0;
    return(accdesc)
}

val CreateAccDescIC : CacheRecord -> AccessDescriptor

function CreateAccDescIC cache = {
    accdesc : AccessDescriptor = NewAccDesc(AccessType_IC);
    accdesc.cacheop = cache.cacheop;
    accdesc.cachetype = cache.cachetype;
    accdesc.opscope = cache.opscope;
    return(accdesc)
}

val CreateAccDescDC : CacheRecord -> AccessDescriptor

function CreateAccDescDC cache = {
    accdesc : AccessDescriptor = NewAccDesc(AccessType_DC);
    accdesc.cacheop = cache.cacheop;
    accdesc.cachetype = cache.cachetype;
    accdesc.opscope = cache.opscope;
    return(accdesc)
}

val CreateAccDescDCZero : forall ('tagaccess : Bool) ('tagchecked : Bool).
  (bool('tagaccess), bool('tagchecked)) -> AccessDescriptor

function CreateAccDescDCZero (tagaccess, tagchecked) = {
    accdesc : AccessDescriptor = NewAccDesc(AccessType_DCZero);
    accdesc.write = true;
    accdesc.pan = true;
    accdesc.tagchecked = tagchecked;
    accdesc.tagaccess = tagaccess;
    accdesc.transactional = HaveTME() & TSTATE.depth > 0;
    return(accdesc)
}

val CreateAccDescAT : forall ('pan : Bool) ('write : Bool).
  (SecurityState, bits(2), bool('write), bool('pan)) -> AccessDescriptor

function CreateAccDescAT (ss, el, write, pan) = {
    accdesc : AccessDescriptor = NewAccDesc(AccessType_AT);
    accdesc.el = el;
    accdesc.ss = ss;
    accdesc.read = not_bool(write);
    accdesc.write = write;
    accdesc.pan = pan;
    return(accdesc)
}

val CreateAccDescTTEUpdate : AccessDescriptor -> AccessDescriptor

function CreateAccDescTTEUpdate accdesc_in = {
    accdesc : AccessDescriptor = NewAccDesc(AccessType_TTW);
    accdesc.el = accdesc_in.el;
    accdesc.ss = accdesc_in.ss;
    accdesc.atomicop = true;
    accdesc.modop = MemAtomicOp_CAS;
    accdesc.read = true;
    accdesc.write = true;
    accdesc.mpam = accdesc_in.mpam;
    return(accdesc)
}

val CreateAccDescS1TTW : forall ('toplevel : Bool).
  (bool('toplevel), VARange, AccessDescriptor) -> AccessDescriptor

function CreateAccDescS1TTW (toplevel, varange, accdesc_in) = {
    accdesc : AccessDescriptor = NewAccDesc(AccessType_TTW);
    accdesc.el = accdesc_in.el;
    accdesc.ss = accdesc_in.ss;
    accdesc.read = true;
    accdesc.toplevel = toplevel;
    accdesc.varange = varange;
    accdesc.mpam = accdesc_in.mpam;
    return(accdesc)
}

val CreateAccDescS2TTW : AccessDescriptor -> AccessDescriptor

function CreateAccDescS2TTW accdesc_in = {
    accdesc : AccessDescriptor = NewAccDesc(AccessType_TTW);
    accdesc.el = accdesc_in.el;
    accdesc.ss = accdesc_in.ss;
    accdesc.read = true;
    accdesc.mpam = accdesc_in.mpam;
    return(accdesc)
}

val CreateAccDescSVENF : forall ('contiguous : Bool) ('tagchecked : Bool).
  (bool('contiguous), bool('tagchecked)) -> AccessDescriptor

function CreateAccDescSVENF (contiguous, tagchecked) = {
    accdesc : AccessDescriptor = NewAccDesc(AccessType_SVE);
    accdesc.read = true;
    accdesc.pan = true;
    accdesc.nonfault = true;
    accdesc.contiguous = contiguous;
    accdesc.streamingsve = InStreamingMode();
    if accdesc.streamingsve & __IMPDEF_boolean("No tag checking of SIMD&FP loads and stores in Streaming SVE mode") then {
        accdesc.tagchecked = false
    } else {
        accdesc.tagchecked = tagchecked
    };
    accdesc.transactional = HaveTME() & TSTATE.depth > 0;
    return(accdesc)
}

val CreateAccDescSVEFF : forall ('contiguous : Bool) ('tagchecked : Bool).
  (bool('contiguous), bool('tagchecked)) -> AccessDescriptor

function CreateAccDescSVEFF (contiguous, tagchecked) = {
    accdesc : AccessDescriptor = NewAccDesc(AccessType_SVE);
    accdesc.read = true;
    accdesc.pan = true;
    accdesc.firstfault = true;
    accdesc.first = true;
    accdesc.contiguous = contiguous;
    accdesc.streamingsve = InStreamingMode();
    if accdesc.streamingsve & __IMPDEF_boolean("No tag checking of SIMD&FP loads and stores in Streaming SVE mode") then {
        accdesc.tagchecked = false
    } else {
        accdesc.tagchecked = tagchecked
    };
    accdesc.transactional = HaveTME() & TSTATE.depth > 0;
    return(accdesc)
}

val CreateAccDescSVE : forall ('contiguous : Bool) ('nontemporal : Bool) ('tagchecked : Bool).
  (MemOp, bool('nontemporal), bool('contiguous), bool('tagchecked)) -> AccessDescriptor

function CreateAccDescSVE (memop, nontemporal, contiguous, tagchecked) = {
    accdesc : AccessDescriptor = NewAccDesc(AccessType_SVE);
    accdesc.nontemporal = nontemporal;
    accdesc.read = memop == MemOp_LOAD;
    accdesc.write = memop == MemOp_STORE;
    accdesc.pan = true;
    accdesc.contiguous = contiguous;
    accdesc.streamingsve = InStreamingMode();
    if accdesc.streamingsve & __IMPDEF_boolean("No tag checking of SIMD&FP loads and stores in Streaming SVE mode") then {
        accdesc.tagchecked = false
    } else {
        accdesc.tagchecked = tagchecked
    };
    accdesc.transactional = HaveTME() & TSTATE.depth > 0;
    return(accdesc)
}

val CreateAccDescSME : forall ('contiguous : Bool) ('nontemporal : Bool) ('tagchecked : Bool).
  (MemOp, bool('nontemporal), bool('contiguous), bool('tagchecked)) -> AccessDescriptor

function CreateAccDescSME (memop, nontemporal, contiguous, tagchecked) = {
    accdesc : AccessDescriptor = NewAccDesc(AccessType_SME);
    accdesc.nontemporal = nontemporal;
    accdesc.read = memop == MemOp_LOAD;
    accdesc.write = memop == MemOp_STORE;
    accdesc.pan = true;
    accdesc.contiguous = contiguous;
    accdesc.streamingsve = true;
    if __IMPDEF_boolean("No tag checking of SME LDR & STR instructions") then {
        accdesc.tagchecked = false
    } else {
        accdesc.tagchecked = tagchecked
    };
    accdesc.transactional = HaveTME() & TSTATE.depth > 0;
    return(accdesc)
}

val CreateAccDescNV2 : MemOp -> AccessDescriptor

function CreateAccDescNV2 memop = {
    accdesc : AccessDescriptor = NewAccDesc(AccessType_NV2);
    accdesc.el = EL2;
    accdesc.ss = SecurityStateAtEL(EL2);
    accdesc.read = memop == MemOp_LOAD;
    accdesc.write = memop == MemOp_STORE;
    accdesc.transactional = HaveTME() & TSTATE.depth > 0;
    return(accdesc)
}

val CreateAccDescSPE : (SecurityState, bits(2)) -> AccessDescriptor

function CreateAccDescSPE (owning_ss, owning_el) = {
    accdesc : AccessDescriptor = NewAccDesc(AccessType_SPE);
    accdesc.el = owning_el;
    accdesc.ss = owning_ss;
    accdesc.write = true;
    accdesc.mpam = GenMPAMatEL(AccessType_SPE, owning_el);
    return(accdesc)
}

val CreateAccDescGPTW : AccessDescriptor -> AccessDescriptor

function CreateAccDescGPTW accdesc_in = {
    accdesc : AccessDescriptor = NewAccDesc(AccessType_GPTW);
    accdesc.el = accdesc_in.el;
    accdesc.ss = accdesc_in.ss;
    accdesc.read = true;
    accdesc.mpam = accdesc_in.mpam;
    return(accdesc)
}

val CreateAccDescGCS : (bits(2), MemOp) -> AccessDescriptor

function CreateAccDescGCS (el, memop) = {
    accdesc : AccessDescriptor = NewAccDesc(AccessType_GCS);
    accdesc.el = el;
    accdesc.read = memop == MemOp_LOAD;
    accdesc.write = memop == MemOp_STORE;
    return(accdesc)
}

val CreateAccDescGCSSS1 : bits(2) -> AccessDescriptor

function CreateAccDescGCSSS1 el = {
    accdesc : AccessDescriptor = NewAccDesc(AccessType_GCS);
    accdesc.el = el;
    accdesc.atomicop = true;
    accdesc.modop = MemAtomicOp_GCSSS1;
    accdesc.read = true;
    accdesc.write = true;
    return(accdesc)
}

val TranslationRegime : bits(2) -> Regime

function TranslationRegime el = {
    if el == EL3 then {
        return(if ELUsingAArch32(EL3) then Regime_EL30 else Regime_EL3)
    } else if el == EL2 then {
        return(if ELIsInHost(EL2) then Regime_EL20 else Regime_EL2)
    } else if el == EL1 then {
        return(Regime_EL10)
    } else if el == EL0 then {
        if CurrentSecurityState() == SS_Secure & ELUsingAArch32(EL3) then {
            return(Regime_EL30)
        } else if ELIsInHost(EL0) then {
            return(Regime_EL20)
        } else {
            return(Regime_EL10)
        }
    } else {
        Unreachable();
        return(undefined : Regime)
    }
}

val AlignmentEnforced : unit -> bool

function AlignmentEnforced () = {
    let regime : Regime = TranslationRegime(PSTATE.EL);
    A : bits(1) = undefined;
    match regime {
      Regime_EL3 => {
          A = SCTLR_EL3[A]
      },
      Regime_EL30 => {
          A = SCTLR_read__2()[A]
      },
      Regime_EL2 => {
          A = if ELUsingAArch32(EL2) then HSCTLR_read()[A] else SCTLR_EL2[A]
      },
      Regime_EL20 => {
          A = SCTLR_EL2[A]
      },
      Regime_EL10 => {
          A = if ELUsingAArch32(EL1) then SCTLR_read__2()[A] else SCTLR_EL1[A]
      },
      _ => {
          Unreachable()
      }
    };
    return(A == 0b1)
}

val IsExclusiveLocal : forall 'processorid 'size.
  (FullAddress, int('processorid), int('size)) -> bool

val IsExclusiveGlobal : forall 'processorid 'size.
  (FullAddress, int('processorid), int('size)) -> bool

val MarkExclusiveLocal : forall 'processorid 'size.
  (FullAddress, int('processorid), int('size)) -> unit

val MarkExclusiveGlobal : forall 'processorid 'size.
  (FullAddress, int('processorid), int('size)) -> unit

val ClearExclusiveByAddress : forall 'processorid 'size.
  (FullAddress, int('processorid), int('size)) -> unit

val ExclusiveMonitorsStatus : unit -> bits(1)

val ConstrainUnpredictable : Unpredictable -> Constraint

val ConstrainUnpredictableProcedure : Unpredictable -> unit

val CPASAtPAS : PASpace -> CachePASpace

function CPASAtPAS pas = {
    match pas {
      PAS_NonSecure => {
          return(CPAS_NonSecure)
      },
      PAS_Secure => {
          return(CPAS_Secure)
      },
      PAS_Root => {
          return(CPAS_Root)
      },
      PAS_Realm => {
          return(CPAS_Realm)
      },
      _ => {
          return(undefined : CachePASpace)
      }
    }
}

val CPASAtSecurityState : SecurityState -> CachePASpace

function CPASAtSecurityState ss = {
    match ss {
      SS_NonSecure => {
          return(CPAS_NonSecure)
      },
      SS_Secure => {
          return(CPAS_SecureNonSecure)
      },
      SS_Root => {
          return(CPAS_Any)
      },
      SS_Realm => {
          return(CPAS_RealmNonSecure)
      },
      _ => {
          return(undefined : CachePASpace)
      }
    }
}

val ICInstNeedsTranslation : CacheOpScope -> bool

function ICInstNeedsTranslation opscope = {
    return(__IMPDEF_boolean("Instruction Cache needs translation"))
}

bitfield CLIDR_EL1_Type : bits(64) =
  {
    Ttype7 : 46..45,
    Ttype6 : 44..43,
    Ttype5 : 42..41,
    Ttype4 : 40..39,
    Ttype3 : 38..37,
    Ttype2 : 36..35,
    Ttype1 : 34..33,
    ICB : 32..30,
    LoUU : 29..27,
    LoC : 26..24,
    LoUIS : 23..21,
    Ctype7 : 20..18,
    Ctype6 : 17..15,
    Ctype5 : 14..12,
    Ctype4 : 11..9,
    Ctype3 : 8..6,
    Ctype2 : 5..3,
    Ctype1 : 2..0
  }

register CLIDR_EL1 : CLIDR_EL1_Type

val DCInstNeedsTranslation : CacheOpScope -> bool

function DCInstNeedsTranslation opscope = {
    if opscope == CacheOpScope_PoE then {
        return(false)
    };
    if opscope == CacheOpScope_PoPA then {
        return(false)
    };
    if CLIDR_EL1[LoC] == 0b000 then {
        return(not_bool(__IMPDEF_boolean("No fault generated for DC operations if PoC is before any level of cache")))
    };
    if CLIDR_EL1[LoUU] == 0b000 & opscope == CacheOpScope_PoU then {
        return(not_bool(__IMPDEF_boolean("No fault generated for DC operations if PoU is before any level of cache")))
    };
    return(true)
}

val GetCacheInfo : forall 'level. (int('level), CacheType) -> (int, int, int)

val DecodeSW : (bits(64), CacheType) -> (int, int, int)

function DecodeSW (regval, cachetype) = {
    linesize : int = undefined;
    setnum : int = undefined;
    waynum : int = undefined;
    let 'level = UInt(regval[3 .. 1]);
    (setnum, waynum, linesize) = GetCacheInfo(level, cachetype);
    let 'waynum = waynum;
    let 'setnum = setnum;
    return((setnum, waynum, level))
}

val HaveCRCExt : unit -> bool

function HaveCRCExt () = {
    return(IsFeatureImplemented(FEAT_CRC32))
}

val BitReverse : forall 'N, 'N >= 0. bits('N) -> bits('N)

function BitReverse data = {
    result : bits('N) = undefined;
    foreach (i from 0 to ('N - 1) by 1 in inc) {
        result['N - i - 1] = Bit([data[i]])
    };
    return(result)
}

val Poly32Mod2 : forall 'N, 'N > 32. (bits('N), bits(32)) -> bits(32)

function Poly32Mod2 (data_in, poly) = {
    assert('N > 32);
    data : bits('N) = data_in;
    foreach (i from ('N - 1) to 32 by 1 in dec) {
        if [data[i]] == 0b1 then {
            data[i - 1 .. 0] = EOR(data[i - 1 .. 0], poly @ Zeros(i - 32))
        };
        ()
    };
    return(data[31 .. 0])
}

val HaveAESExt : unit -> bool

function HaveAESExt () = {
    return(IsFeatureImplemented(FEAT_AES))
}

val HaveBit128PMULLExt : unit -> bool

function HaveBit128PMULLExt () = {
    return(IsFeatureImplemented(FEAT_PMULL))
}

val HaveSHA1Ext : unit -> bool

function HaveSHA1Ext () = {
    return(IsFeatureImplemented(FEAT_SHA1))
}

val HaveSHA256Ext : unit -> bool

function HaveSHA256Ext () = {
    return(IsFeatureImplemented(FEAT_SHA256))
}

val HaveSHA512Ext : unit -> bool

function HaveSHA512Ext () = {
    return(IsFeatureImplemented(FEAT_SHA512))
}

val HaveSHA3Ext : unit -> bool

function HaveSHA3Ext () = {
    return(IsFeatureImplemented(FEAT_SHA3))
}

val HaveSM3Ext : unit -> bool

function HaveSM3Ext () = {
    return(IsFeatureImplemented(FEAT_SM3))
}

val HaveSM4Ext : unit -> bool

function HaveSM4Ext () = {
    return(IsFeatureImplemented(FEAT_SM4))
}

val ROL : forall 'N 'shift, 'N >= 0. (bits('N), int('shift)) -> bits('N)

function ROL (x, shift) = {
    assert(shift >= 0 & shift <= 'N);
    if shift == 0 then {
        return(x)
    };
    return(ROR(x, 'N - shift))
}

val AESShiftRows : bits(128) -> bits(128)

function AESShiftRows op = {
    return(((((((((((((((op[95 .. 88] @ op[55 .. 48]) @ op[15 .. 8]) @ op[103 .. 96]) @ op[63 .. 56]) @ op[23 .. 16]) @ op[111 .. 104]) @ op[71 .. 64]) @ op[31 .. 24]) @ op[119 .. 112]) @ op[79 .. 72]) @ op[39 .. 32]) @ op[127 .. 120]) @ op[87 .. 80]) @ op[47 .. 40]) @ op[7 .. 0])
}

val AESInvShiftRows : bits(128) -> bits(128)

function AESInvShiftRows op = {
    return(((((((((((((((op[31 .. 24] @ op[55 .. 48]) @ op[79 .. 72]) @ op[103 .. 96]) @ op[127 .. 120]) @ op[23 .. 16]) @ op[47 .. 40]) @ op[71 .. 64]) @ op[95 .. 88]) @ op[119 .. 112]) @ op[15 .. 8]) @ op[39 .. 32]) @ op[63 .. 56]) @ op[87 .. 80]) @ op[111 .. 104]) @ op[7 .. 0])
}

val AESSubBytes : bits(128) -> bits(128)

function AESSubBytes op = {
    let GF2 : bits(2048) = ((((((((((((((0x16bb54b00f2d99416842e6bf0d89a18c @ 0xdf2855cee9871e9b948ed9691198f8e1) @ 0x9e1dc186b95735610ef6034866b53e70) @ 0x8a8bbd4b1f74dde8c6b4a61c2e2578ba) @ 0x08ae7a65eaf4566ca94ed58d6d37c8e7) @ 0x79e4959162acd3c25c2406490a3a32e0) @ 0xdb0b5ede14b8ee4688902a22dc4f8160) @ 0x73195d643d7ea7c41744975fec130ccd) @ 0xd2f3ff1021dab6bcf5389d928f40a351) @ 0xa89f3c507f02f94585334d43fbaaefd0) @ 0xcf584c4a39becb6a5bb1fc20ed00d153) @ 0x842fe329b3d63b52a05a6e1b1a2c8309) @ 0x75b227ebe28012079a059618c323c704) @ 0x1531d871f1e5a534ccf73f362693fdb7) @ 0xc072a49cafa2d4adf04759fa7dc982ca) @ 0x76abd7fe2b670130c56f6bf27b777c63;
    out : bits(128) = undefined;
    foreach (i from 0 to 15 by 1 in inc) {
        out = SetSlice(8, out, i * 8, Slice(GF2, UInt(Slice(op, i * 8, 8)) * 8, 8))
    };
    return(out)
}

val AESInvSubBytes : bits(128) -> bits(128)

function AESInvSubBytes op = {
    let GF2_inv : bits(2048) = ((((((((((((((0x7d0c2155631469e126d677ba7e042b17 @ 0x619953833cbbebc8b0f52aae4d3be0a0) @ 0xef9cc9939f7ae52d0d4ab519a97f5160) @ 0x5fec8027591012b131c7078833a8dd1f) @ 0xf45acd78fec0db9a2079d2c64b3e56fc) @ 0x1bbe18aa0e62b76f89c5291d711af147) @ 0x6edf751ce837f9e28535ade72274ac96) @ 0x73e6b4f0cecff297eadc674f4111913a) @ 0x6b8a130103bdafc1020f3fca8f1e2cd0) @ 0x0645b3b80558e4f70ad3bc8c00abd890) @ 0x849d8da75746155edab9edfd5048706c) @ 0x92b6655dcc5ca4d41698688664f6f872) @ 0x25d18b6d49a25b76b224d92866a12e08) @ 0x4ec3fa420b954cee3d23c2a632947b54) @ 0xcbe9dec444438e3487ff2f9b8239e37c) @ 0xfbd7f3819ea340bf38a53630d56a0952;
    out : bits(128) = undefined;
    foreach (i from 0 to 15 by 1 in inc) {
        out = SetSlice(8, out, i * 8, Slice(GF2_inv, UInt(Slice(op, i * 8, 8)) * 8, 8))
    };
    return(out)
}

val FFmul02 : bits(8) -> bits(8)

function FFmul02 b = {
    let FFmul_02 : bits(2048) = ((((((((((((((0xE5E7E1E3EDEFE9EBF5F7F1F3FDFFF9FB @ 0xC5C7C1C3CDCFC9CBD5D7D1D3DDDFD9DB) @ 0xA5A7A1A3ADAFA9ABB5B7B1B3BDBFB9BB) @ 0x858781838D8F898B959791939D9F999B) @ 0x656761636D6F696B757771737D7F797B) @ 0x454741434D4F494B555751535D5F595B) @ 0x252721232D2F292B353731333D3F393B) @ 0x050701030D0F090B151711131D1F191B) @ 0xFEFCFAF8F6F4F2F0EEECEAE8E6E4E2E0) @ 0xDEDCDAD8D6D4D2D0CECCCAC8C6C4C2C0) @ 0xBEBCBAB8B6B4B2B0AEACAAA8A6A4A2A0) @ 0x9E9C9A98969492908E8C8A8886848280) @ 0x7E7C7A78767472706E6C6A6866646260) @ 0x5E5C5A58565452504E4C4A4846444240) @ 0x3E3C3A38363432302E2C2A2826242220) @ 0x1E1C1A18161412100E0C0A0806040200;
    return(Slice(FFmul_02, UInt(b) * 8, 8))
}

val FFmul03 : bits(8) -> bits(8)

function FFmul03 b = {
    let FFmul_03 : bits(2048) = ((((((((((((((0x1A191C1F16151013020104070E0D080B @ 0x2A292C2F26252023323134373E3D383B) @ 0x7A797C7F76757073626164676E6D686B) @ 0x4A494C4F46454043525154575E5D585B) @ 0xDAD9DCDFD6D5D0D3C2C1C4C7CECDC8CB) @ 0xEAE9ECEFE6E5E0E3F2F1F4F7FEFDF8FB) @ 0xBAB9BCBFB6B5B0B3A2A1A4A7AEADA8AB) @ 0x8A898C8F86858083929194979E9D989B) @ 0x818287848D8E8B88999A9F9C95969390) @ 0xB1B2B7B4BDBEBBB8A9AAAFACA5A6A3A0) @ 0xE1E2E7E4EDEEEBE8F9FAFFFCF5F6F3F0) @ 0xD1D2D7D4DDDEDBD8C9CACFCCC5C6C3C0) @ 0x414247444D4E4B48595A5F5C55565350) @ 0x717277747D7E7B78696A6F6C65666360) @ 0x212227242D2E2B28393A3F3C35363330) @ 0x111217141D1E1B18090A0F0C05060300;
    return(Slice(FFmul_03, UInt(b) * 8, 8))
}

val FFmul09 : bits(8) -> bits(8)

function FFmul09 b = {
    let FFmul_09 : bits(2048) = ((((((((((((((0x464F545D626B70790E071C152A233831 @ 0xD6DFC4CDF2FBE0E99E978C85BAB3A8A1) @ 0x7D746F6659504B42353C272E1118030A) @ 0xEDE4FFF6C9C0DBD2A5ACB7BE8188939A) @ 0x3039222B141D060F78716A635C554E47) @ 0xA0A9B2BB848D969FE8E1FAF3CCC5DED7) @ 0x0B0219102F263D34434A5158676E757C) @ 0x9B928980BFB6ADA4D3DAC1C8F7FEE5EC) @ 0xAAA3B8B18E879C95E2EBF0F9C6CFD4DD) @ 0x3A3328211E170C05727B6069565F444D) @ 0x9198838AB5BCA7AED9D0CBC2FDF4EFE6) @ 0x0108131A252C373E49405B526D647F76) @ 0xDCD5CEC7F8F1EAE3949D868FB0B9A2AB) @ 0x4C455E5768617A73040D161F2029323B) @ 0xE7EEF5FCC3CAD1D8AFA6BDB48B829990) @ 0x777E656C535A41483F362D241B120900;
    return(Slice(FFmul_09, UInt(b) * 8, 8))
}

val FFmul0B : bits(8) -> bits(8)

function FFmul0B b = {
    let FFmul_0B : bits(2048) = ((((((((((((((0xA3A8B5BE8F849992FBF0EDE6D7DCC1CA @ 0x1318050E3F3429224B405D56676C717A) @ 0xD8D3CEC5F4FFE2E9808B969DACA7BAB1) @ 0x68637E75444F5259303B262D1C170A01) @ 0x555E434879726F640D061B10212A373C) @ 0xE5EEF3F8C9C2DFD4BDB6ABA0919A878C) @ 0x2E2538330209141F767D606B5A514C47) @ 0x9E958883B2B9A4AFC6CDD0DBEAE1FCF7) @ 0x545F424978736E650C071A11202B363D) @ 0xE4EFF2F9C8C3DED5BCB7AAA1909B868D) @ 0x2F2439320308151E777C616A5B504D46) @ 0x9F948982B3B8A5AEC7CCD1DAEBE0FDF6) @ 0xA2A9B4BF8E859893FAF1ECE7D6DDC0CB) @ 0x1219040F3E3528234A415C57666D707B) @ 0xD9D2CFC4F5FEE3E8818A979CADA6BBB0) @ 0x69627F74454E5358313A272C1D160B00;
    return(Slice(FFmul_0B, UInt(b) * 8, 8))
}

val FFmul0D : bits(8) -> bits(8)

function FFmul0D b = {
    let FFmul_0D : bits(2048) = ((((((((((((((0x979A8D80A3AEB9B4FFF2E5E8CBC6D1DC @ 0x474A5D50737E69642F2235381B16010C) @ 0x2C21363B1815020F44495E53707D6A67) @ 0xFCF1E6EBC8C5D2DF94998E83A0ADBAB7) @ 0xFAF7E0EDCEC3D4D9929F8885A6ABBCB1) @ 0x2A27303D1E130409424F5855767B6C61) @ 0x414C5B5675786F622924333E1D10070A) @ 0x919C8B86A5A8BFB2F9F4E3EECDC0D7DA) @ 0x4D40575A7974636E25283F32111C0B06) @ 0x9D90878AA9A4B3BEF5F8EFE2C1CCDBD6) @ 0xF6FBECE1C2CFD8D59E938489AAA7B0BD) @ 0x262B3C31121F08054E4354597A77606D) @ 0x202D3A3714190E034845525F7C71666B) @ 0xF0FDEAE7C4C9DED39895828FACA1B6BB) @ 0x9B96818CAFA2B5B8F3FEE9E4C7CADDD0) @ 0x4B46515C7F726568232E3934171A0D00;
    return(Slice(FFmul_0D, UInt(b) * 8, 8))
}

val FFmul0E : bits(8) -> bits(8)

function FFmul0E b = {
    let FFmul_0E : bits(2048) = ((((((((((((((0x8D83919FB5BBA9A7FDF3E1EFC5CBD9D7 @ 0x6D63717F555B49471D13010F252B3937) @ 0x56584A446E60727C26283A341E10020C) @ 0xB6B8AAA48E80929CC6C8DAD4FEF0E2EC) @ 0x202E3C321816040A505E4C426866747A) @ 0xC0CEDCD2F8F6E4EAB0BEACA28886949A) @ 0xFBF5E7E9C3CDDFD18B859799B3BDAFA1) @ 0x1B150709232D3F316B657779535D4F41) @ 0xCCC2D0DEF4FAE8E6BCB2A0AE848A9896) @ 0x2C22303E141A08065C52404E646A7876) @ 0x17190B052F21333D67697B755F51434D) @ 0xF7F9EBE5CFC1D3DD87899B95BFB1A3AD) @ 0x616F7D735957454B111F0D032927353B) @ 0x818F9D93B9B7A5ABF1FFEDE3C9C7D5DB) @ 0xBAB4A6A8828C9E90CAC4D6D8F2FCEEE0) @ 0x5A544648626C7E702A243638121C0E00;
    return(Slice(FFmul_0E, UInt(b) * 8, 8))
}

val AESMixColumns : bits(128) -> bits(128)

function AESMixColumns op = {
    let in0 : bits(32) = ((Slice(op, 96, 8) @ Slice(op, 64, 8)) @ Slice(op, 32, 8)) @ Slice(op, 0, 8);
    let in1 : bits(32) = ((Slice(op, 104, 8) @ Slice(op, 72, 8)) @ Slice(op, 40, 8)) @ Slice(op, 8, 8);
    let in2 : bits(32) = ((Slice(op, 112, 8) @ Slice(op, 80, 8)) @ Slice(op, 48, 8)) @ Slice(op, 16, 8);
    let in3 : bits(32) = ((Slice(op, 120, 8) @ Slice(op, 88, 8)) @ Slice(op, 56, 8)) @ Slice(op, 24, 8);
    out0 : bits(32) = undefined;
    out1 : bits(32) = undefined;
    out2 : bits(32) = undefined;
    out3 : bits(32) = undefined;
    foreach (c from 0 to 3 by 1 in inc) {
        out0 = SetSlice(8, out0, c * 8, EOR(EOR(EOR(FFmul02(Slice(in0, c * 8, 8)), FFmul03(Slice(in1, c * 8, 8))), Slice(in2, c * 8, 8)), Slice(in3, c * 8, 8)));
        out1 = SetSlice(8, out1, c * 8, EOR(EOR(EOR(FFmul02(Slice(in1, c * 8, 8)), FFmul03(Slice(in2, c * 8, 8))), Slice(in3, c * 8, 8)), Slice(in0, c * 8, 8)));
        out2 = SetSlice(8, out2, c * 8, EOR(EOR(EOR(FFmul02(Slice(in2, c * 8, 8)), FFmul03(Slice(in3, c * 8, 8))), Slice(in0, c * 8, 8)), Slice(in1, c * 8, 8)));
        out3 = SetSlice(8, out3, c * 8, EOR(EOR(EOR(FFmul02(Slice(in3, c * 8, 8)), FFmul03(Slice(in0, c * 8, 8))), Slice(in1, c * 8, 8)), Slice(in2, c * 8, 8)))
    };
    return(((((((((((((((Slice(out3, 3 * 8, 8) @ Slice(out2, 3 * 8, 8)) @ Slice(out1, 3 * 8, 8)) @ Slice(out0, 3 * 8, 8)) @ Slice(out3, 2 * 8, 8)) @ Slice(out2, 2 * 8, 8)) @ Slice(out1, 2 * 8, 8)) @ Slice(out0, 2 * 8, 8)) @ Slice(out3, 1 * 8, 8)) @ Slice(out2, 1 * 8, 8)) @ Slice(out1, 1 * 8, 8)) @ Slice(out0, 1 * 8, 8)) @ Slice(out3, 0 * 8, 8)) @ Slice(out2, 0 * 8, 8)) @ Slice(out1, 0 * 8, 8)) @ Slice(out0, 0 * 8, 8))
}

val AESInvMixColumns : bits(128) -> bits(128)

function AESInvMixColumns op = {
    let in0 : bits(32) = ((Slice(op, 96, 8) @ Slice(op, 64, 8)) @ Slice(op, 32, 8)) @ Slice(op, 0, 8);
    let in1 : bits(32) = ((Slice(op, 104, 8) @ Slice(op, 72, 8)) @ Slice(op, 40, 8)) @ Slice(op, 8, 8);
    let in2 : bits(32) = ((Slice(op, 112, 8) @ Slice(op, 80, 8)) @ Slice(op, 48, 8)) @ Slice(op, 16, 8);
    let in3 : bits(32) = ((Slice(op, 120, 8) @ Slice(op, 88, 8)) @ Slice(op, 56, 8)) @ Slice(op, 24, 8);
    out0 : bits(32) = undefined;
    out1 : bits(32) = undefined;
    out2 : bits(32) = undefined;
    out3 : bits(32) = undefined;
    foreach (c from 0 to 3 by 1 in inc) {
        out0 = SetSlice(8, out0, c * 8, EOR(EOR(EOR(FFmul0E(Slice(in0, c * 8, 8)), FFmul0B(Slice(in1, c * 8, 8))), FFmul0D(Slice(in2, c * 8, 8))), FFmul09(Slice(in3, c * 8, 8))));
        out1 = SetSlice(8, out1, c * 8, EOR(EOR(EOR(FFmul09(Slice(in0, c * 8, 8)), FFmul0E(Slice(in1, c * 8, 8))), FFmul0B(Slice(in2, c * 8, 8))), FFmul0D(Slice(in3, c * 8, 8))));
        out2 = SetSlice(8, out2, c * 8, EOR(EOR(EOR(FFmul0D(Slice(in0, c * 8, 8)), FFmul09(Slice(in1, c * 8, 8))), FFmul0E(Slice(in2, c * 8, 8))), FFmul0B(Slice(in3, c * 8, 8))));
        out3 = SetSlice(8, out3, c * 8, EOR(EOR(EOR(FFmul0B(Slice(in0, c * 8, 8)), FFmul0D(Slice(in1, c * 8, 8))), FFmul09(Slice(in2, c * 8, 8))), FFmul0E(Slice(in3, c * 8, 8))))
    };
    return(((((((((((((((Slice(out3, 3 * 8, 8) @ Slice(out2, 3 * 8, 8)) @ Slice(out1, 3 * 8, 8)) @ Slice(out0, 3 * 8, 8)) @ Slice(out3, 2 * 8, 8)) @ Slice(out2, 2 * 8, 8)) @ Slice(out1, 2 * 8, 8)) @ Slice(out0, 2 * 8, 8)) @ Slice(out3, 1 * 8, 8)) @ Slice(out2, 1 * 8, 8)) @ Slice(out1, 1 * 8, 8)) @ Slice(out0, 1 * 8, 8)) @ Slice(out3, 0 * 8, 8)) @ Slice(out2, 0 * 8, 8)) @ Slice(out1, 0 * 8, 8)) @ Slice(out0, 0 * 8, 8))
}

val SHAchoose : (bits(32), bits(32), bits(32)) -> bits(32)

function SHAchoose (x, y, z) = {
    return(EOR(EOR(y, z) & x, z))
}

val SHAparity : (bits(32), bits(32), bits(32)) -> bits(32)

function SHAparity (x, y, z) = {
    return(EOR(EOR(x, y), z))
}

val SHAmajority : (bits(32), bits(32), bits(32)) -> bits(32)

function SHAmajority (x, y, z) = {
    return(x & y | (x | y) & z)
}

val SHAhashSIGMA0 : bits(32) -> bits(32)

function SHAhashSIGMA0 x = {
    return(EOR(EOR(ROR(x, 2), ROR(x, 13)), ROR(x, 22)))
}

val SHAhashSIGMA1 : bits(32) -> bits(32)

function SHAhashSIGMA1 x = {
    return(EOR(EOR(ROR(x, 6), ROR(x, 11)), ROR(x, 25)))
}

val SHA256hash : forall ('part1 : Bool).
  (bits(128), bits(128), bits(128), bool('part1)) -> bits(128)

function SHA256hash (x_in, y_in, w, part1) = {
    chs : bits(32) = undefined;
    maj : bits(32) = undefined;
    t : bits(32) = undefined;
    x : bits(128) = x_in;
    y : bits(128) = y_in;
    foreach (e from 0 to 3 by 1 in inc) {
        chs = SHAchoose(y[31 .. 0], y[63 .. 32], y[95 .. 64]);
        maj = SHAmajority(x[31 .. 0], x[63 .. 32], x[95 .. 64]);
        t = y[127 .. 96] + SHAhashSIGMA1(y[31 .. 0]) + chs + Elem_read(w, e, 32);
        x[127 .. 96] = t + x[127 .. 96];
        y[127 .. 96] = t + SHAhashSIGMA0(x[31 .. 0]) + maj;
        (y @ x) = ROL(y @ x, 32)
    };
    return(if part1 then x else y)
}

val Sbox : bits(8) -> bits(8)

function Sbox sboxin = {
    let sboxstring : bits(2048) = 0xd690e9fecce13db716b614c228fb2c052b679a762abe04c3aa441326498606999c4250f491ef987a33540b43edcfac62e4b31ca9c908e89580df94fa758f3fa64707a7fcf37317ba83593c19e6854fa8686b81b27164da8bf8eb0f4b70569d351e240e5e6358d1a225227c3b01217887d40046579fd327524c3602e7a0c4c89eeabf8ad240c738b5a3f7f2cef96115a1e0ae5da49b341a55ad933230f58cb1e31df6e22e8266ca60c02923ab0d534e6fd5db3745defd8e2f03ff6a726d6c5b518d1baf92bbddbc7f11d95c411f105ad80ac13188a5cd7bbd2d74d012b8e5b4b08969974a0c96777e65b9f109c56ec68418f07dec3adc4d2079ee5f3ed7cb3948;
    let sboxin = UInt(sboxin);
    let sboxout : bits(8) = sboxstring[(255 - sboxin) * 8 + 7 .. (255 - sboxin) * 8];
    return(sboxout)
}

val TargetSecurityState : (bits(1), bits(1)) -> SecurityState

function TargetSecurityState (NS, NSE) = {
    let curr_ss : SecurityState = SecurityStateAtEL(PSTATE.EL);
    if curr_ss == SS_NonSecure then {
        return(SS_NonSecure)
    } else if curr_ss == SS_Secure then {
        match NS {
          0b0 => {
              return(SS_Secure)
          },
          0b1 => {
              return(SS_NonSecure)
          },
          _ => {
              return(undefined : SecurityState)
          }
        }
    } else if HaveRME() then {
        if curr_ss == SS_Root then {
            match NSE @ NS {
              0b00 => {
                  return(SS_Secure)
              },
              0b01 => {
                  return(SS_NonSecure)
              },
              0b11 => {
                  return(SS_Realm)
              },
              0b10 => {
                  return(SS_Root)
              },
              _ => {
                  return(undefined : SecurityState)
              }
            }
        } else if curr_ss == SS_Realm then {
            return(SS_Realm)
        } else {
            return(undefined : SecurityState)
        }
    } else {
        return(undefined : SecurityState)
    }
}

val RESTRICT_PREDICTIONS : ExecutionCntxt -> unit

function RESTRICT_PREDICTIONS c = {
    return()
}

bitfield CONTEXTIDR_EL1_Type : bits(64) = {PROCID : 31..0}

register CONTEXTIDR_EL1 : CONTEXTIDR_EL1_Type

bitfield TTBCR_Type : bits(32) =
  {
    EAE : 31..31,
    SH1 : 29..28,
    ORGN1 : 27..26,
    IRGN1 : 25..24,
    EPD1 : 23..23,
    A1 : 22..22,
    T1SZ : 18..16,
    SH0 : 13..12,
    ORGN0 : 11..10,
    IRGN0 : 9..8,
    EPD0 : 7..7,
    T2E : 6..6,
    PD1 : 5..5,
    PD0 : 4..4,
    T0SZ : 2..0,
    N : 2..0
  }

register _TTBCR_NS : TTBCR_Type

val TTBCR_NS_read : unit -> TTBCR_Type

function TTBCR_NS_read () = {
    r : TTBCR_Type = _TTBCR_NS;
    r.bits[31 .. 0] = Slice(TCR_EL1.bits, 0, 32);
    return(r)
}

register TTBCR_S : TTBCR_Type

val TTBCR_read : unit -> TTBCR_Type

function TTBCR_read () = {
    r : TTBCR_Type = undefined;
    if ELUsingAArch32(EL3) & CurrentSecurityState() == SS_Secure then {
        r = TTBCR_S
    } else {
        r = TTBCR_NS_read()
    };
    return(r)
}

val EAEisOne : unit -> bool

function EAEisOne () = {
    return(TTBCR_read()[EAE] == 0b1)
}

bitfield CONTEXTIDR_Type : bits(32) = {ASID : 7..0}

register _CONTEXTIDR_NS : CONTEXTIDR_Type

val CONTEXTIDR_NS_read : unit -> CONTEXTIDR_Type

function CONTEXTIDR_NS_read () = {
    r : CONTEXTIDR_Type = _CONTEXTIDR_NS;
    r.bits[31 .. 0] = Slice(CONTEXTIDR_EL1.bits, 0, 32);
    return(r)
}

register CONTEXTIDR_S : CONTEXTIDR_Type

val CONTEXTIDR_read : unit -> CONTEXTIDR_Type

function CONTEXTIDR_read () = {
    r : CONTEXTIDR_Type = undefined;
    if ELUsingAArch32(EL3) & CurrentSecurityState() == SS_Secure then {
        r = CONTEXTIDR_S
    } else {
        r = CONTEXTIDR_NS_read()
    };
    return(r)
}

bitfield TTBR0_Type : bits(64) =
  {
    ASID : 55..48,
    TTB0 : 31..7,
    NOS : 5..5,
    RGN : 4..3,
    IMP : 2..2,
    BADDR : 47..1,
    S : 1..1,
    CnP : 0..0,
    IRGN : (0..0 @ 6..6)
  }

register TTBR0_NS : TTBR0_Type

register TTBR0_S : TTBR0_Type

val TTBR0_read : unit -> TTBR0_Type

function TTBR0_read () = {
    r : TTBR0_Type = undefined;
    if ELUsingAArch32(EL3) & CurrentSecurityState() == SS_Secure then {
        r = TTBR0_S
    } else {
        r = TTBR0_NS
    };
    return(r)
}

bitfield TTBR0_EL1_Type : bits(128) = {ASID : 63..48, SKL : 2..1, CnP : 0..0}

register _TTBR0_EL1 : TTBR0_EL1_Type

val TTBR0_EL1_read : unit -> TTBR0_EL1_Type

function TTBR0_EL1_read () = {
    r : TTBR0_EL1_Type = _TTBR0_EL1;
    r.bits[63 .. 0] = Slice(TTBR0_read().bits, 0, 64);
    return(r)
}

bitfield HTTBR_Type : bits(64) = {BADDR : 47..1, CnP : 0..0}

register HTTBR : HTTBR_Type

bitfield TTBR0_EL2_Type : bits(128) = {ASID : 63..48, SKL : 2..1, CnP : 0..0}

register _TTBR0_EL2 : TTBR0_EL2_Type

val TTBR0_EL2_read : unit -> TTBR0_EL2_Type

function TTBR0_EL2_read () = {
    r : TTBR0_EL2_Type = _TTBR0_EL2;
    r.bits[47 .. 1] = Slice(HTTBR.bits, 1, 47);
    return(r)
}

bitfield TTBR1_Type : bits(64) =
  {
    ASID : 55..48,
    TTB1 : 31..7,
    IRGN : (6..6 @ 0..0),
    NOS : 5..5,
    RGN : 4..3,
    IMP : 2..2,
    BADDR : 47..1,
    S : 1..1,
    CnP : 0..0
  }

register TTBR1_NS : TTBR1_Type

register TTBR1_S : TTBR1_Type

val TTBR1_read : unit -> TTBR1_Type

function TTBR1_read () = {
    r : TTBR1_Type = undefined;
    if ELUsingAArch32(EL3) & CurrentSecurityState() == SS_Secure then {
        r = TTBR1_S
    } else {
        r = TTBR1_NS
    };
    return(r)
}

bitfield TTBR1_EL1_Type : bits(128) = {ASID : 63..48, SKL : 2..1, CnP : 0..0}

register _TTBR1_EL1 : TTBR1_EL1_Type

val TTBR1_EL1_read : unit -> TTBR1_EL1_Type

function TTBR1_EL1_read () = {
    r : TTBR1_EL1_Type = _TTBR1_EL1;
    r.bits[63 .. 0] = Slice(TTBR1_read().bits, 0, 64);
    return(r)
}

bitfield TTBR1_EL2_Type : bits(128) = {ASID : 63..48, SKL : 2..1, CnP : 0..0}

register TTBR1_EL2 : TTBR1_EL2_Type

val ASID_read : unit -> bits(16)

function ASID_read () = {
    if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (HCR_EL2[E2H] @ HCR_EL2[TGE]) == 0b11 then {
        if TCR_EL2[A1] == 0b1 then {
            return(TTBR1_EL2[ASID])
        } else {
            return(TTBR0_EL2_read()[ASID])
        }
    } else if not_bool(ELUsingAArch32(EL1)) then {
        if TCR_EL1[A1] == 0b1 then {
            return(TTBR1_EL1_read()[ASID])
        } else {
            return(TTBR0_EL1_read()[ASID])
        }
    } else {
        if TTBCR_read()[EAE] == 0b0 then {
            return(ZeroExtend(CONTEXTIDR_read()[ASID], 16))
        } else {
            if TTBCR_read()[A1] == 0b1 then {
                return(ZeroExtend(TTBR1_read()[ASID], 16))
            } else {
                return(ZeroExtend(TTBR0_read()[ASID], 16))
            }
        }
    }
}

val RecipEstimate : forall 'a_in ('increasedprecision_name : Bool).
  (int('a_in), bool('increasedprecision_name)) -> int

function RecipEstimate (a_in, increasedprecision_name) = {
    a : int = a_in;
    r : int = undefined;
    if not_bool(increasedprecision_name) then {
        assert(256 <= a & a < 512);
        let 'a = a * 2 + 1;
        let 'b = DIV(2 ^ 19, a);
        r = DIV(b + 1, 2);
        assert(256 <= r & r < 512)
    } else {
        assert(2048 <= a & a < 4096);
        let 'a = a * 2 + 1;
        let real_val : real = Real(2 ^ 25) / Real(a);
        r = RoundDown(real_val);
        let error : real = real_val - Real(r);
        let round_up : bool = error > 0.5;
        if round_up then {
            r = r + 1
        };
        assert(4096 <= r & r < 8192)
    };
    let 'r = r;
    return(r)
}

val UnsignedRecipEstimate : forall 'N, 'N == 32. bits('N) -> bits('N)

function UnsignedRecipEstimate operand = {
    estimate : int = undefined;
    increasedprecision_name : bool = undefined;
    assert('N == 32);
    result : bits('N) = undefined;
    if [operand['N - 1]] == 0b0 then {
        result = Ones('N)
    } else {
        let increasedprecision_name : bool = false;
        let 'estimate = RecipEstimate(UInt(operand[31 .. 23]), increasedprecision_name);
        result = estimate[8 .. 0] @ Zeros('N - 9)
    };
    return(result)
}

val RecipSqrtEstimate : forall 'a_in ('increasedprecision_name : Bool).
  (int('a_in), bool('increasedprecision_name)) -> int

function RecipSqrtEstimate (a_in, increasedprecision_name) = {
    round_up : bool = undefined;
    a : int = a_in;
    r : int = undefined;
    if not_bool(increasedprecision_name) then {
        assert(128 <= a & a < 512);
        if a < 256 then {
            a = a * 2 + 1
        } else {
            a = (((a >> 1)) << 1);
            a = (a + 1) * 2
        };
        let 'a = a;
        b : int = 512;
        while a * (b + 1) * (b + 1) < pow2(28) do {
            b = b + 1
        };
        let 'b = b;
        r = DIV(b + 1, 2);
        assert(256 <= r & r < 512)
    } else {
        assert(1024 <= a & a < 4096);
        real_val : real = undefined;
        if a < 2048 then {
            let 'a = a * 2 + 1;
            real_val = Real(a) / 2.0
        } else {
            a : int = (((a >> 1)) << 1);
            let 'a = a + 1;
            real_val = Real(a)
        };
        real_val : real = sqrt(real_val);
        real_val : real = real_val * Real(2 ^ 47);
        int_val : int = RoundDown(real_val);
        error : real = real_val - Real(int_val);
        round_up : bool = error > 0.5;
        if round_up then {
            int_val = int_val + 1
        };
        let real_val : real = Real(2 ^ 65) / Real(int_val);
        int_val : int = RoundDown(real_val);
        let error : real = real_val - Real(int_val);
        let round_up : bool = error > 0.5 | error == 0.5 & [int_val[0]] == 0b1;
        if round_up then {
            int_val = int_val + 1
        };
        let 'int_val = int_val;
        r = int_val;
        assert(4096 <= r & r < 8192)
    };
    let 'r = r;
    return(r)
}

val UnsignedRSqrtEstimate : forall 'N, 'N == 32. bits('N) -> bits('N)

function UnsignedRSqrtEstimate operand = {
    estimate : int = undefined;
    increasedprecision_name : bool = undefined;
    assert('N == 32);
    result : bits('N) = undefined;
    if operand['N - 1 .. 'N - 2] == 0b00 then {
        result = Ones('N)
    } else {
        let increasedprecision_name : bool = false;
        let 'estimate = RecipSqrtEstimate(UInt(operand[31 .. 23]), increasedprecision_name);
        result = estimate[8 .. 0] @ Zeros('N - 9)
    };
    return(result)
}

val SignedSatQ : forall 'N 'i, 0 <= 'N - 1.
  (int('i), int('N)) -> (bits('N), bool)

function SignedSatQ (i, N) = {
    result : int = undefined;
    saturated : bool = undefined;
    if i > pow2(N - 1) - 1 then {
        result = pow2(N - 1) - 1;
        saturated = true
    } else if i < negate(2 ^ (N - 1)) then {
        result = negate(2 ^ (N - 1));
        saturated = true
    } else {
        result = i;
        saturated = false
    };
    let 'result = result;
    return((result[N - 1 .. 0], saturated))
}

val UnsignedSatQ : forall 'N 'i, 0 <= 'N - 1.
  (int('i), int('N)) -> (bits('N), bool)

function UnsignedSatQ (i, N) = {
    result : int = undefined;
    saturated : bool = undefined;
    if i > pow2(N) - 1 then {
        result = pow2(N) - 1;
        saturated = true
    } else if i < 0 then {
        result = 0;
        saturated = true
    } else {
        result = i;
        saturated = false
    };
    let 'result = result;
    return((result[N - 1 .. 0], saturated))
}

val SatQ : forall 'N 'i ('is_unsigned : Bool),
  'N >= 0.
  (int('i), int('N), bool('is_unsigned)) -> (bits('N), bool)

function SatQ (i, N, is_unsigned) = {
    result : bits('N) = undefined;
    sat : bool = undefined;
    (result, sat) = if is_unsigned then {
        assert(constraint(0 <= 'N - 1));
        UnsignedSatQ(i, N)
    } else {
        assert(constraint(0 <= 'N - 1));
        SignedSatQ(i, N)
    };
    return((result, sat))
}

val AdvSIMDExpandImm : (bits(1), bits(4), bits(8)) -> bits(64)

function AdvSIMDExpandImm (op, cmode, imm8) = {
    imm32 : bits(32) = undefined;
    imm8a : bits(8) = undefined;
    imm8b : bits(8) = undefined;
    imm8c : bits(8) = undefined;
    imm8d : bits(8) = undefined;
    imm8e : bits(8) = undefined;
    imm8f : bits(8) = undefined;
    imm8g : bits(8) = undefined;
    imm8h : bits(8) = undefined;
    imm64 : bits(64) = undefined;
    match cmode[3 .. 1] {
      0b000 => {
          imm64 = Replicate(Zeros(24) @ imm8, 2)
      },
      0b001 => {
          imm64 = Replicate((Zeros(16) @ imm8) @ Zeros(8), 2)
      },
      0b010 => {
          imm64 = Replicate((Zeros(8) @ imm8) @ Zeros(16), 2)
      },
      0b011 => {
          imm64 = Replicate(imm8 @ Zeros(24), 2)
      },
      0b100 => {
          imm64 = Replicate(Zeros(8) @ imm8, 4)
      },
      0b101 => {
          imm64 = Replicate(imm8 @ Zeros(8), 4)
      },
      0b110 => {
          if [cmode[0]] == 0b0 then {
              imm64 = Replicate((Zeros(16) @ imm8) @ Ones(8), 2)
          } else {
              imm64 = Replicate((Zeros(8) @ imm8) @ Ones(16), 2)
          }
      },
      0b111 => {
          if [cmode[0]] == 0b0 & op == 0b0 then {
              imm64 = Replicate(imm8, 8)
          };
          if [cmode[0]] == 0b0 & op == 0b1 then {
              let imm8a : bits(8) = Replicate([imm8[7]], 8);
              let imm8b : bits(8) = Replicate([imm8[6]], 8);
              let imm8c : bits(8) = Replicate([imm8[5]], 8);
              let imm8d : bits(8) = Replicate([imm8[4]], 8);
              let imm8e : bits(8) = Replicate([imm8[3]], 8);
              let imm8f : bits(8) = Replicate([imm8[2]], 8);
              let imm8g : bits(8) = Replicate([imm8[1]], 8);
              let imm8h : bits(8) = Replicate([imm8[0]], 8);
              imm64 = ((((((imm8a @ imm8b) @ imm8c) @ imm8d) @ imm8e) @ imm8f) @ imm8g) @ imm8h
          };
          if [cmode[0]] == 0b1 & op == 0b0 then {
              let imm32 : bits(32) = ((([imm8[7]] @ not_vec([imm8[6]])) @ Replicate([imm8[6]], 5)) @ imm8[5 .. 0]) @ Zeros(19);
              imm64 = Replicate(imm32, 2)
          };
          if [cmode[0]] == 0b1 & op == 0b1 then {
              if UsingAArch32() then {
                  ReservedEncoding()
              };
              imm64 = ((([imm8[7]] @ not_vec([imm8[6]])) @ Replicate([imm8[6]], 8)) @ imm8[5 .. 0]) @ Zeros(48)
          };
          ()
      }
    };
    return(imm64)
}

val PolynomialMult : forall 'M 'N, ('M >= 0 & 'N >= 0).
  (bits('M), bits('N)) -> bits('M + 'N)

function PolynomialMult (op1, op2) = {
    result : bits('M + 'N) = Zeros('M + 'N);
    let extended_op2 : bits('M + 'N) = ZeroExtend(op2, 'M + 'N);
    foreach (i from 0 to ('M - 1) by 1 in inc) {
        if [op1[i]] == 0b1 then {
            result = EOR(result, LSL(extended_op2, i))
        };
        ()
    };
    return(result)
}

val MatMulAdd : forall 'N ('op1_unsigned : Bool) ('op2_unsigned : Bool),
  'N == 128.
  (bits('N), bits('N), bits('N), bool('op1_unsigned), bool('op2_unsigned)) -> bits('N)

function MatMulAdd (addend, op1, op2, op1_unsigned, op2_unsigned) = {
    assert('N == 128);
    result : bits('N) = undefined;
    sum : bits(32) = undefined;
    prod : int = undefined;
    foreach (i from 0 to 1 by 1 in inc) {
        foreach (j from 0 to 1 by 1 in inc) {
            sum = Elem_read(addend, 2 * i + j, 32);
            foreach (k from 0 to 7 by 1 in inc) {
                prod = asl_Int(Elem_read(op1, 8 * i + k, 8), op1_unsigned) * asl_Int(Elem_read(op2, 8 * j + k, 8), op2_unsigned);
                sum = sum + prod
            };
            result = Elem_set(result, 2 * i + j, 32, sum)
        }
    };
    return(result)
}

val AddWithCarry : forall 'N, 'N > 0.
  (bits('N), bits('N), bits(1)) -> (bits('N), bits(4))

function AddWithCarry (x, y, carry_in) = {
    let 'unsigned_sum = UInt(x) + UInt(y) + UInt(carry_in);
    let 'signed_sum = SInt(x) + SInt(y) + UInt(carry_in);
    let result : bits('N) = unsigned_sum['N - 1 .. 0];
    let n : bits(1) = [result['N - 1]];
    let z : bits(1) = if IsZero(result) then 0b1 else 0b0;
    let c : bits(1) = if UInt(result) == unsigned_sum then 0b0 else 0b1;
    let v : bits(1) = if SInt(result) == signed_sum then 0b0 else 0b1;
    return((result, ((n @ z) @ c) @ v))
}

val HaveRASExt : unit -> bool

function HaveRASExt () = {
    return(IsFeatureImplemented(FEAT_RAS))
}

val IsExternalAbortTakenSynchronously : forall ('iswrite : Bool) 'size.
  (PhysMemRetStatus, bool('iswrite), AddressDescriptor, int('size), AccessDescriptor) -> bool

val IsExternalSyncAbort : Fault -> bool

val IsExternalSyncAbort__1 : FaultRecord -> bool

function IsExternalSyncAbort statuscode = {
    assert(statuscode != Fault_None);
    return(statuscode == Fault_SyncExternal | statuscode == Fault_SyncParity | statuscode == Fault_SyncExternalOnWalk | statuscode == Fault_SyncParityOnWalk)
}

function IsExternalSyncAbort__1 fault = {
    return(IsExternalSyncAbort(fault.statuscode) | fault.gpcf.gpf == GPCF_EABT)
}

val PendSErrorInterrupt : FaultRecord -> unit

val HandleExternalTTWAbort : forall ('iswrite : Bool) 'size.
  (PhysMemRetStatus, bool('iswrite), AddressDescriptor, AccessDescriptor, int('size), FaultRecord) -> FaultRecord

function HandleExternalTTWAbort (memretstatus, iswrite, memaddrdesc, accdesc, size, input_fault) = {
    output_fault : FaultRecord = input_fault;
    output_fault.extflag = memretstatus.extflag;
    output_fault.statuscode = memretstatus.statuscode;
    if IsExternalSyncAbort__1(output_fault) & not_bool(IsExternalAbortTakenSynchronously(memretstatus, iswrite, memaddrdesc, size, accdesc)) then {
        if output_fault.statuscode == Fault_SyncParity then {
            output_fault.statuscode = Fault_AsyncParity
        } else {
            output_fault.statuscode = Fault_AsyncExternal
        }
    };
    if IsExternalSyncAbort__1(output_fault) then {
        if output_fault.statuscode == Fault_SyncParity then {
            output_fault.statuscode = Fault_SyncParityOnWalk
        } else {
            output_fault.statuscode = Fault_SyncExternalOnWalk
        }
    };
    if HaveRASExt() then {
        output_fault.merrorstate = memretstatus.merrorstate
    };
    if not_bool(IsExternalSyncAbort__1(output_fault)) then {
        PendSErrorInterrupt(output_fault);
        output_fault.statuscode = Fault_None
    };
    return(output_fault)
}

val AArch32_EncodeAsyncErrorSyndrome : ErrorState -> bits(2)

function AArch32_EncodeAsyncErrorSyndrome errorstate = {
    match errorstate {
      ErrorState_UC => {
          return(0b00)
      },
      ErrorState_UEU => {
          return(0b01)
      },
      ErrorState_UEO => {
          return(0b10)
      },
      ErrorState_UER => {
          return(0b11)
      },
      _ => {
          Unreachable();
          return(undefined : bits(2))
      }
    }
}

val ActionRequired : unit -> bool

val ErrorIsContained : unit -> bool

val ErrorIsSynchronized : unit -> bool

val ReportErrorAsUC : unit -> bool

val ReportErrorAsUER : unit -> bool

val ReportErrorAsUEU : unit -> bool

val StateIsRecoverable : unit -> bool

val AArch32_PEErrorState : FaultRecord -> ErrorState

function AArch32_PEErrorState fault = {
    if (not_bool(ErrorIsContained()) | not_bool(ErrorIsSynchronized()) & not_bool(StateIsRecoverable())) | ReportErrorAsUC() then {
        return(ErrorState_UC)
    };
    if not_bool(StateIsRecoverable()) | ReportErrorAsUEU() then {
        return(ErrorState_UEU)
    };
    if ActionRequired() | ReportErrorAsUER() then {
        return(ErrorState_UER)
    };
    return(ErrorState_UEO)
}

val Have52BitIPAAndPASpaceExt : unit -> bool

function Have52BitIPAAndPASpaceExt () = {
    return(IsFeatureImplemented(FEAT_LPA2))
}

val Have56BitPAExt : unit -> bool

function Have56BitPAExt () = {
    return(IsFeatureImplemented(FEAT_D128))
}

val HaveMTE2Ext : unit -> bool

function HaveMTE2Ext () = {
    return(IsFeatureImplemented(FEAT_MTE2))
}

val EncodeLDFSC : forall 'level. (Fault, int('level)) -> bits(6)

function EncodeLDFSC (statuscode, level) = {
    result : bits(6) = undefined;
    if level == negate(2) then {
        assert(Have56BitPAExt());
        match statuscode {
          Fault_AddressSize => {
              result = 0b101100
          },
          Fault_Translation => {
              result = 0b101010
          },
          Fault_SyncExternalOnWalk => {
              result = 0b010010
          },
          Fault_SyncParityOnWalk => {
              result = 0b011010;
              assert(not_bool(HaveRASExt()))
          },
          Fault_GPCFOnWalk => {
              result = 0b100010
          },
          _ => {
              Unreachable()
          }
        };
        return(result)
    };
    if level == negate(1) then {
        assert(Have52BitIPAAndPASpaceExt());
        match statuscode {
          Fault_AddressSize => {
              result = 0b101001
          },
          Fault_Translation => {
              result = 0b101011
          },
          Fault_SyncExternalOnWalk => {
              result = 0b010011
          },
          Fault_SyncParityOnWalk => {
              result = 0b011011;
              assert(not_bool(HaveRASExt()))
          },
          Fault_GPCFOnWalk => {
              result = 0b100011
          },
          _ => {
              Unreachable()
          }
        };
        return(result)
    };
    match statuscode {
      Fault_AddressSize => {
          result = 0b0000 @ level[1 .. 0];
          assert(level == 0 | level == 1 | level == 2 | level == 3)
      },
      Fault_AccessFlag => {
          result = 0b0010 @ level[1 .. 0];
          assert(level == 0 | level == 1 | level == 2 | level == 3)
      },
      Fault_Permission => {
          result = 0b0011 @ level[1 .. 0];
          assert(level == 0 | level == 1 | level == 2 | level == 3)
      },
      Fault_Translation => {
          result = 0b0001 @ level[1 .. 0];
          assert(level == 0 | level == 1 | level == 2 | level == 3)
      },
      Fault_SyncExternal => {
          result = 0b010000
      },
      Fault_SyncExternalOnWalk => {
          result = 0b0101 @ level[1 .. 0];
          assert(level == 0 | level == 1 | level == 2 | level == 3)
      },
      Fault_SyncParity => {
          result = 0b011000
      },
      Fault_SyncParityOnWalk => {
          result = 0b0111 @ level[1 .. 0];
          assert(level == 0 | level == 1 | level == 2 | level == 3)
      },
      Fault_AsyncParity => {
          result = 0b011001
      },
      Fault_AsyncExternal => {
          result = 0b010001;
          assert(UsingAArch32())
      },
      Fault_TagCheck => {
          result = 0b010001;
          assert(HaveMTE2Ext())
      },
      Fault_Alignment => {
          result = 0b100001
      },
      Fault_Debug => {
          result = 0b100010
      },
      Fault_GPCFOnWalk => {
          result = 0b1001 @ level[1 .. 0];
          assert(level == 0 | level == 1 | level == 2 | level == 3)
      },
      Fault_GPCFOnOutput => {
          result = 0b101000
      },
      Fault_TLBConflict => {
          result = 0b110000
      },
      Fault_HWUpdateAccessFlag => {
          result = 0b110001
      },
      Fault_Lockdown => {
          result = 0b110100
      },
      Fault_Exclusive => {
          result = 0b110101
      },
      _ => {
          Unreachable()
      }
    };
    return(result)
}

val IsAsyncAbort : Fault -> bool

val IsAsyncAbort__1 : FaultRecord -> bool

function IsAsyncAbort statuscode = {
    assert(statuscode != Fault_None);
    return(statuscode == Fault_AsyncExternal | statuscode == Fault_AsyncParity)
}

function IsAsyncAbort__1 fault = {
    return(IsAsyncAbort(fault.statuscode))
}

val IsExternalAbort : Fault -> bool

val IsExternalAbort__1 : FaultRecord -> bool

function IsExternalAbort statuscode = {
    assert(statuscode != Fault_None);
    return(statuscode == Fault_SyncExternal | statuscode == Fault_SyncParity | statuscode == Fault_SyncExternalOnWalk | statuscode == Fault_SyncParityOnWalk | statuscode == Fault_AsyncExternal | statuscode == Fault_AsyncParity)
}

function IsExternalAbort__1 fault = {
    return(IsExternalAbort(fault.statuscode) | fault.gpcf.gpf == GPCF_EABT)
}

val IsSecondStage : FaultRecord -> bool

function IsSecondStage fault = {
    assert(fault.statuscode != Fault_None);
    return(fault.secondstage)
}

val LSInstructionSyndrome : unit -> bits(11)

val AArch32_FaultSyndrome : forall ('d_side : Bool).
  (bool('d_side), FaultRecord) -> bits(25)

function AArch32_FaultSyndrome (d_side, fault) = {
    assert(fault.statuscode != Fault_None);
    iss : bits(25) = Zeros(25);
    let iss2 : bits(24) = Zeros(24);
    if HaveRASExt() & IsAsyncAbort__1(fault) then {
        let errstate : ErrorState = AArch32_PEErrorState(fault);
        iss[11 .. 10] = AArch32_EncodeAsyncErrorSyndrome(errstate)
    };
    if d_side then {
        if (IsSecondStage(fault) & not_bool(fault.s2fs1walk)) & (not_bool(IsExternalSyncAbort__1(fault)) | (not_bool(HaveRASExt()) & fault.access.acctype == AccessType_TTW) & __IMPDEF_boolean("ISV on second stage translation table walk")) then {
            iss[24 .. 14] = LSInstructionSyndrome()
        };
        if fault.access.acctype == AccessType_DC | fault.access.acctype == AccessType_IC | fault.access.acctype == AccessType_AT then {
            iss[8] = Bit(0b1)
        };
        if fault.access.acctype == AccessType_DC | fault.access.acctype == AccessType_IC | fault.access.acctype == AccessType_AT then {
            iss[6] = Bit(0b1)
        } else if fault.statuscode == Fault_HWUpdateAccessFlag | fault.statuscode == Fault_Exclusive then {
            iss[6] = Bit(__UNKNOWN_bit())
        } else if fault.access.atomicop & IsExternalAbort__1(fault) then {
            iss[6] = Bit(__UNKNOWN_bit())
        } else {
            iss[6] = Bit(if fault.write then 0b1 else 0b0)
        }
    };
    if IsExternalAbort__1(fault) then {
        iss[9] = Bit(fault.extflag)
    };
    iss[7] = Bit(if fault.s2fs1walk then 0b1 else 0b0);
    iss[5 .. 0] = EncodeLDFSC(fault.statuscode, fault.level);
    return(iss)
}

val IPAValid : FaultRecord -> bool

function IPAValid fault = {
    assert(fault.statuscode != Fault_None);
    if fault.gpcf.gpf != GPCF_None then {
        return(fault.secondstage)
    } else if fault.s2fs1walk then {
        return(fault.statuscode == Fault_AccessFlag | fault.statuscode == Fault_Permission | fault.statuscode == Fault_Translation | fault.statuscode == Fault_AddressSize)
    } else if fault.secondstage then {
        return(fault.statuscode == Fault_AccessFlag | fault.statuscode == Fault_Translation | fault.statuscode == Fault_AddressSize)
    } else {
        return(false)
    }
}

val AArch32_AbortSyndrome : (Exception, FaultRecord, bits(32), bits(2)) -> ExceptionRecord

function AArch32_AbortSyndrome (exceptype, fault, vaddress, target_el) = {
    except : ExceptionRecord = ExceptionSyndrome(exceptype);
    let d_side : bool = exceptype == Exception_DataAbort;
    except.syndrome = AArch32_FaultSyndrome(d_side, fault);
    except.vaddress = ZeroExtend(vaddress, 64);
    if IPAValid(fault) then {
        except.ipavalid = true;
        except.NS = if fault.ipaddress.paspace == PAS_NonSecure then 0b1 else
          0b0;
        except.ipaddress = ZeroExtend(fault.ipaddress.address, 56)
    } else {
        except.ipavalid = false
    };
    return(except)
}

val AArch32_ExceptionClass : Exception -> (int, bits(1))

function AArch32_ExceptionClass exceptype = {
    il_is_valid : bool = true;
    ec : int = undefined;
    match exceptype {
      Exception_Uncategorized => {
          ec = UInt(0x00);
          il_is_valid = false
      },
      Exception_WFxTrap => {
          ec = UInt(0x01)
      },
      Exception_CP15RTTrap => {
          ec = UInt(0x03)
      },
      Exception_CP15RRTTrap => {
          ec = UInt(0x04)
      },
      Exception_CP14RTTrap => {
          ec = UInt(0x05)
      },
      Exception_CP14DTTrap => {
          ec = UInt(0x06)
      },
      Exception_AdvSIMDFPAccessTrap => {
          ec = UInt(0x07)
      },
      Exception_FPIDTrap => {
          ec = UInt(0x08)
      },
      Exception_PACTrap => {
          ec = UInt(0x09)
      },
      Exception_TSTARTAccessTrap => {
          ec = UInt(0x1B)
      },
      Exception_GPC => {
          ec = UInt(0x1E)
      },
      Exception_CP14RRTTrap => {
          ec = UInt(0x0C)
      },
      Exception_BranchTarget => {
          ec = UInt(0x0D)
      },
      Exception_IllegalState => {
          ec = UInt(0x0E);
          il_is_valid = false
      },
      Exception_SupervisorCall => {
          ec = UInt(0x11)
      },
      Exception_HypervisorCall => {
          ec = UInt(0x12)
      },
      Exception_MonitorCall => {
          ec = UInt(0x13)
      },
      Exception_InstructionAbort => {
          ec = UInt(0x20);
          il_is_valid = false
      },
      Exception_PCAlignment => {
          ec = UInt(0x22);
          il_is_valid = false
      },
      Exception_DataAbort => {
          ec = UInt(0x24)
      },
      Exception_NV2DataAbort => {
          ec = UInt(0x25)
      },
      Exception_FPTrappedException => {
          ec = UInt(0x28)
      },
      _ => {
          Unreachable()
      }
    };
    if (ec == UInt(0x20) | ec == UInt(0x24)) & PSTATE.EL == EL2 then {
        ec = ec + 1
    };
    let 'ec = ec;
    il : bits(1) = undefined;
    if il_is_valid then {
        il = if ThisInstrLength() == 32 then 0b1 else 0b0
    } else {
        il = 0b1
    };
    return((ec, il))
}

type HDFAR_Type = bits(32)

register _HDFAR : HDFAR_Type

val HDFAR_write : HDFAR_Type -> unit

function HDFAR_write value_name = {
    let r : HDFAR_Type = value_name;
    FAR_EL2[31 .. 0] = Slice(r, 0, 32);
    _HDFAR = r;
    return()
}

type HIFAR_Type = bits(32)

register _HIFAR : HIFAR_Type

val HIFAR_write : HIFAR_Type -> unit

function HIFAR_write value_name = {
    let r : HIFAR_Type = value_name;
    FAR_EL2[63 .. 32] = Slice(r, 0, 32);
    _HIFAR = r;
    return()
}

bitfield HPFAR_Type : bits(32) = {FIPA : 31..4}

register _HPFAR : HPFAR_Type

val HPFAR_read : unit -> HPFAR_Type

function HPFAR_read () = {
    r : HPFAR_Type = _HPFAR;
    r.bits[31 .. 0] = Slice(HPFAR_EL2.bits, 0, 32);
    return(r)
}

val HPFAR_write : HPFAR_Type -> unit

function HPFAR_write value_name = {
    let r : HPFAR_Type = value_name;
    HPFAR_EL2.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _HPFAR = r;
    return()
}

bitfield HSR_Type : bits(32) = {EC : 31..26, IL : 25..25, ISS : 24..0}

register _HSR : HSR_Type

val HSR_write : HSR_Type -> unit

function HSR_write value_name = {
    let r : HSR_Type = value_name;
    ESR_EL2.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _HSR = r;
    return()
}

val AArch32_ReportHypEntry : ExceptionRecord -> unit

function AArch32_ReportHypEntry except = {
    ec : int = undefined;
    il : bits(1) = undefined;
    let exceptype : Exception = except.exceptype;
    (ec, il) = AArch32_ExceptionClass(exceptype);
    let 'ec = ec;
    let iss : bits(25) = except.syndrome;
    let iss2 : bits(24) = except.syndrome2;
    if (ec == UInt(0x24) | ec == UInt(0x25)) & [iss[24]] == 0b0 then {
        il = 0b1
    };
    let il = il;
    HSR_write() = Mk_HSR_Type((ec[5 .. 0] @ il) @ iss);
    if exceptype == Exception_InstructionAbort | exceptype == Exception_PCAlignment then {
        HIFAR_write() = except.vaddress[31 .. 0];
        HDFAR_write() = __UNKNOWN_bits(32)
    } else if exceptype == Exception_DataAbort then {
        HIFAR_write() = __UNKNOWN_bits(32);
        HDFAR_write() = except.vaddress[31 .. 0]
    } else ();
    if except.ipavalid then {
        HPFAR_write() = Mk_HPFAR_Type([HPFAR_read().bits with 31 .. 4 = except.ipaddress[39 .. 12]])
    } else {
        HPFAR_write() = Mk_HPFAR_Type([HPFAR_read().bits with 31 .. 4 = __UNKNOWN_bits(28)])
    };
    return()
}

type ELR_hyp_Type = bits(32)

register _ELR_hyp : ELR_hyp_Type

val ELR_hyp_write : ELR_hyp_Type -> unit

function ELR_hyp_write value_name = {
    let r : ELR_hyp_Type = value_name;
    ELR_EL2[31 .. 0] = Slice(r, 0, 32);
    _ELR_hyp = r;
    return()
}

val AArch32_EnterHypModeInDebugState : ExceptionRecord -> unit

function AArch32_EnterHypModeInDebugState except = {
    SynchronizeContext();
    assert((HaveEL(EL2) & CurrentSecurityState() == SS_NonSecure) & ELUsingAArch32(EL2));
    AArch32_ReportHypEntry(except);
    AArch32_WriteMode(M32_Hyp);
    SPSR_set(32) = __UNKNOWN_bits(32);
    ELR_hyp_write() = __UNKNOWN_bits(32);
    PSTATE.T = 0b1;
    (PSTATE.SS @ PSTATE.A @ PSTATE.I @ PSTATE.F) = __UNKNOWN_bits(4);
    DLR_write() = __UNKNOWN_bits(32);
    DSPSR_write() = Mk_DSPSR_Type(__UNKNOWN_bits(32));
    PSTATE.E = HSCTLR_read()[EE];
    PSTATE.IL = 0b0;
    PSTATE.IT = 0b00000000;
    if HaveSSBSExt() then {
        PSTATE.SSBS = __UNKNOWN_bit()
    };
    EDSCR_write() = [EDSCR_read() with ERR = 0b1];
    UpdateEDSCRFields();
    EndOfInstruction()
}

type HVBAR_Type = bits(32)

register _HVBAR : HVBAR_Type

val HVBAR_read : unit -> HVBAR_Type

function HVBAR_read () = {
    r : HVBAR_Type = _HVBAR;
    r[31 .. 0] = Slice(VBAR_EL2, 0, 32);
    return(r)
}

val AArch32_EnterHypMode : forall 'vect_offset.
  (ExceptionRecord, bits(32), int('vect_offset)) -> unit

function AArch32_EnterHypMode (except, preferred_exception_return, vect_offset) = {
    SynchronizeContext();
    assert((HaveEL(EL2) & CurrentSecurityState() == SS_NonSecure) & ELUsingAArch32(EL2));
    if Halted() then {
        AArch32_EnterHypModeInDebugState(except);
        return()
    };
    let spsr : bits(32) = GetPSRFromPSTATE(AArch32_NonDebugState, 32);
    if not_bool(except.exceptype == Exception_IRQ | except.exceptype == Exception_FIQ) then {
        AArch32_ReportHypEntry(except)
    };
    AArch32_WriteMode(M32_Hyp);
    SPSR_set(32) = spsr;
    ELR_hyp_write() = preferred_exception_return;
    PSTATE.T = HSCTLR_read()[TE];
    PSTATE.SS = 0b0;
    if not_bool(HaveEL(EL3)) | SCR_GEN_read()[EA] == 0b0 then {
        PSTATE.A = 0b1
    };
    if not_bool(HaveEL(EL3)) | SCR_GEN_read()[IRQ] == 0b0 then {
        PSTATE.I = 0b1
    };
    if not_bool(HaveEL(EL3)) | SCR_GEN_read()[FIQ] == 0b0 then {
        PSTATE.F = 0b1
    };
    PSTATE.E = HSCTLR_read()[EE];
    PSTATE.IL = 0b0;
    PSTATE.IT = 0b00000000;
    if HaveSSBSExt() then {
        PSTATE.SSBS = HSCTLR_read()[DSSBS]
    };
    let branch_conditional : bool = false;
    BranchTo(HVBAR_read()[31 .. 5] @ vect_offset[4 .. 0], BranchType_EXCEPTION, branch_conditional);
    CheckExceptionCatch(true);
    EndOfInstruction()
}

val Rmode_set : forall 'n. (int('n), bits(5), bits(32)) -> unit

function Rmode_set (n, mode, value_name) = {
    assert(n >= 0 & n <= 14);
    if CurrentSecurityState() != SS_Secure then {
        assert(mode != M32_Monitor)
    };
    assert(not_bool(BadMode(mode)));
    if mode == M32_Monitor then {
        if n == 13 then {
            SP_mon = value_name
        } else if n == 14 then {
            LR_mon = value_name
        } else {
            _R(n, 31, 0) = value_name
        }
    } else {
        if HaveAArch64() & ConstrainUnpredictableBool(Unpredictable_ZEROUPPER) then {
            _R(LookUpRIndex(n, mode)) = ZeroExtend(value_name, 64)
        } else {
            _R(LookUpRIndex(n, mode), 31, 0) = value_name
        }
    };
    return()
}

val R_set : forall 'n. (int('n), bits(32)) -> unit

function R_set (n, value_name) = {
    Rmode_set(n, PSTATE.M) = value_name;
    return()
}

val AArch32_EnterModeInDebugState : bits(5) -> unit

function AArch32_EnterModeInDebugState target_mode = {
    SynchronizeContext();
    assert(ELUsingAArch32(EL1) & PSTATE.EL != EL2);
    if PSTATE.M == M32_Monitor then {
        SCR[NS] = 0b0
    };
    AArch32_WriteMode(target_mode);
    SPSR_set(32) = __UNKNOWN_bits(32);
    R_set(14) = __UNKNOWN_bits(32);
    PSTATE.T = 0b1;
    (PSTATE.SS @ PSTATE.A @ PSTATE.I @ PSTATE.F) = __UNKNOWN_bits(4);
    DLR_write() = __UNKNOWN_bits(32);
    DSPSR_write() = Mk_DSPSR_Type(__UNKNOWN_bits(32));
    PSTATE.E = SCTLR_read__2()[EE];
    PSTATE.IL = 0b0;
    PSTATE.IT = 0b00000000;
    if HavePANExt() & SCTLR_read__2()[SPAN] == 0b0 then {
        PSTATE.PAN = 0b1
    };
    if HaveSSBSExt() then {
        PSTATE.SSBS = __UNKNOWN_bit()
    };
    EDSCR_write() = [EDSCR_read() with ERR = 0b1];
    UpdateEDSCRFields();
    EndOfInstruction()
}

val ExcVectorBase : unit -> bits(32)

function ExcVectorBase () = {
    if SCTLR_read__2()[V] == 0b1 then {
        return(Ones(16) @ Zeros(16))
    } else {
        return(VBAR_read__2()[31 .. 5] @ Zeros(5))
    }
}

val AArch32_EnterMode : forall 'lr_offset 'vect_offset.
  (bits(5), bits(32), int('lr_offset), int('vect_offset)) -> unit

function AArch32_EnterMode (target_mode, preferred_exception_return, lr_offset, vect_offset) = {
    SynchronizeContext();
    assert(ELUsingAArch32(EL1) & PSTATE.EL != EL2);
    if Halted() then {
        AArch32_EnterModeInDebugState(target_mode);
        return()
    };
    let spsr : bits(32) = GetPSRFromPSTATE(AArch32_NonDebugState, 32);
    if PSTATE.M == M32_Monitor then {
        SCR[NS] = 0b0
    };
    AArch32_WriteMode(target_mode);
    SPSR_set(32) = spsr;
    R_set(14) = preferred_exception_return + lr_offset;
    PSTATE.T = SCTLR_read__2()[TE];
    PSTATE.SS = 0b0;
    if target_mode == M32_FIQ then {
        (PSTATE.A @ PSTATE.I @ PSTATE.F) = 0b111
    } else if target_mode == M32_Abort | target_mode == M32_IRQ then {
        (PSTATE.A @ PSTATE.I) = 0b11
    } else {
        PSTATE.I = 0b1
    };
    PSTATE.E = SCTLR_read__2()[EE];
    PSTATE.IL = 0b0;
    PSTATE.IT = 0b00000000;
    if HavePANExt() & SCTLR_read__2()[SPAN] == 0b0 then {
        PSTATE.PAN = 0b1
    };
    if HaveSSBSExt() then {
        PSTATE.SSBS = SCTLR_read__2()[DSSBS]
    };
    let branch_conditional : bool = false;
    BranchTo(ExcVectorBase()[31 .. 5] @ vect_offset[4 .. 0], BranchType_EXCEPTION, branch_conditional);
    CheckExceptionCatch(true);
    EndOfInstruction()
}

val AArch32_EnterMonitorModeInDebugState : unit -> unit

function AArch32_EnterMonitorModeInDebugState () = {
    SynchronizeContext();
    assert(HaveEL(EL3) & ELUsingAArch32(EL3));
    let from_secure : bool = CurrentSecurityState() == SS_Secure;
    if PSTATE.M == M32_Monitor then {
        SCR[NS] = 0b0
    };
    AArch32_WriteMode(M32_Monitor);
    SPSR_set(32) = __UNKNOWN_bits(32);
    R_set(14) = __UNKNOWN_bits(32);
    PSTATE.T = 0b1;
    (PSTATE.SS @ PSTATE.A @ PSTATE.I @ PSTATE.F) = __UNKNOWN_bits(4);
    PSTATE.E = SCTLR_read__2()[EE];
    PSTATE.IL = 0b0;
    PSTATE.IT = 0b00000000;
    if HavePANExt() then {
        if not_bool(from_secure) then {
            PSTATE.PAN = 0b0
        } else if SCTLR_read__2()[SPAN] == 0b0 then {
            PSTATE.PAN = 0b1
        } else ()
    };
    if HaveSSBSExt() then {
        PSTATE.SSBS = __UNKNOWN_bit()
    };
    DLR_write() = __UNKNOWN_bits(32);
    DSPSR_write() = Mk_DSPSR_Type(__UNKNOWN_bits(32));
    EDSCR_write() = [EDSCR_read() with ERR = 0b1];
    UpdateEDSCRFields();
    EndOfInstruction()
}

bitfield MVBAR_Type : bits(32) = {Reserved : 4..0}

register MVBAR : MVBAR_Type

val AArch32_EnterMonitorMode : forall 'lr_offset 'vect_offset.
  (bits(32), int('lr_offset), int('vect_offset)) -> unit

function AArch32_EnterMonitorMode (preferred_exception_return, lr_offset, vect_offset) = {
    SynchronizeContext();
    assert(HaveEL(EL3) & ELUsingAArch32(EL3));
    let from_secure : bool = CurrentSecurityState() == SS_Secure;
    if Halted() then {
        AArch32_EnterMonitorModeInDebugState();
        return()
    };
    let spsr : bits(32) = GetPSRFromPSTATE(AArch32_NonDebugState, 32);
    if PSTATE.M == M32_Monitor then {
        SCR[NS] = 0b0
    };
    AArch32_WriteMode(M32_Monitor);
    SPSR_set(32) = spsr;
    R_set(14) = preferred_exception_return + lr_offset;
    PSTATE.T = SCTLR_read__2()[TE];
    PSTATE.SS = 0b0;
    (PSTATE.A @ PSTATE.I @ PSTATE.F) = 0b111;
    PSTATE.E = SCTLR_read__2()[EE];
    PSTATE.IL = 0b0;
    PSTATE.IT = 0b00000000;
    if HavePANExt() then {
        if not_bool(from_secure) then {
            PSTATE.PAN = 0b0
        } else if SCTLR_read__2()[SPAN] == 0b0 then {
            PSTATE.PAN = 0b1
        } else ()
    };
    if HaveSSBSExt() then {
        PSTATE.SSBS = SCTLR_read__2()[DSSBS]
    };
    let branch_conditional : bool = false;
    BranchTo(MVBAR.bits[31 .. 5] @ vect_offset[4 .. 0], BranchType_EXCEPTION, branch_conditional);
    CheckExceptionCatch(true);
    EndOfInstruction()
}

val EncodeSDFSC : forall 'level. (Fault, int('level)) -> bits(5)

function EncodeSDFSC (statuscode, level) = {
    result : bits(5) = undefined;
    match statuscode {
      Fault_AccessFlag => {
          assert(level == 1 | level == 2);
          result = if level == 1 then 0b00011 else 0b00110
      },
      Fault_Alignment => {
          result = 0b00001
      },
      Fault_Permission => {
          assert(level == 1 | level == 2);
          result = if level == 1 then 0b01101 else 0b01111
      },
      Fault_Domain => {
          assert(level == 1 | level == 2);
          result = if level == 1 then 0b01001 else 0b01011
      },
      Fault_Translation => {
          assert(level == 1 | level == 2);
          result = if level == 1 then 0b00101 else 0b00111
      },
      Fault_SyncExternal => {
          result = 0b01000
      },
      Fault_SyncExternalOnWalk => {
          assert(level == 1 | level == 2);
          result = if level == 1 then 0b01100 else 0b01110
      },
      Fault_SyncParity => {
          result = 0b11001
      },
      Fault_SyncParityOnWalk => {
          assert(level == 1 | level == 2);
          result = if level == 1 then 0b11100 else 0b11110
      },
      Fault_AsyncParity => {
          result = 0b11000
      },
      Fault_AsyncExternal => {
          result = 0b10110
      },
      Fault_Debug => {
          result = 0b00010
      },
      Fault_TLBConflict => {
          result = 0b10000
      },
      Fault_Lockdown => {
          result = 0b10100
      },
      Fault_Exclusive => {
          result = 0b10101
      },
      Fault_ICacheMaint => {
          result = 0b00100
      },
      _ => {
          Unreachable()
      }
    };
    return(result)
}

val AArch32_CommonFaultStatus : forall ('long_format : Bool).
  (FaultRecord, bool('long_format)) -> bits(32)

function AArch32_CommonFaultStatus (fault, long_format) = {
    target : bits(32) = Zeros(32);
    if HaveRASExt() & IsAsyncAbort__1(fault) then {
        let errstate : ErrorState = AArch32_PEErrorState(fault);
        target[15 .. 14] = AArch32_EncodeAsyncErrorSyndrome(errstate)
    };
    if IsExternalAbort__1(fault) then {
        target[12] = Bit(fault.extflag)
    };
    target[9] = Bit(if long_format then 0b1 else 0b0);
    if long_format then {
        target[5 .. 0] = EncodeLDFSC(fault.statuscode, fault.level)
    } else {
        (target[10 .. 10] @ target[3 .. 0]) = EncodeSDFSC(fault.statuscode, fault.level)
    };
    return(target)
}

type DFAR_Type = bits(32)

register _DFAR_NS : DFAR_Type

val DFAR_NS_write : DFAR_Type -> unit

function DFAR_NS_write value_name = {
    let r : DFAR_Type = value_name;
    FAR_EL1[31 .. 0] = Slice(r, 0, 32);
    _DFAR_NS = r;
    return()
}

val HDFAR_read : unit -> HDFAR_Type

function HDFAR_read () = {
    r : HDFAR_Type = _HDFAR;
    r[31 .. 0] = Slice(FAR_EL2, 0, 32);
    return(r)
}

register _DFAR_S : DFAR_Type

val DFAR_S_write : DFAR_Type -> unit

function DFAR_S_write value_name = {
    let r : DFAR_Type = value_name;
    HDFAR_write() = SetSlice(32, HDFAR_read(), 0, Slice(r, 0, 32));
    _DFAR_S = r;
    return()
}

val DFAR_write : DFAR_Type -> unit

function DFAR_write value_name = {
    let r : DFAR_Type = value_name;
    if ELUsingAArch32(EL3) & CurrentSecurityState() == SS_Secure then {
        DFAR_S_write() = r
    } else {
        DFAR_NS_write() = r
    };
    return()
}

bitfield DFSR_Type : bits(32) =
  {
    FnV : 16..16,
    AET : 15..14,
    CM : 13..13,
    ExT : 12..12,
    WnR : 11..11,
    FS : (10..10 @ 3..0),
    LPAE : 9..9,
    Domain : 7..4,
    STATUS : 5..0
  }

register _DFSR_NS : DFSR_Type

val DFSR_NS_write : DFSR_Type -> unit

function DFSR_NS_write value_name = {
    let r : DFSR_Type = value_name;
    ESR_EL1.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _DFSR_NS = r;
    return()
}

register DFSR_S : DFSR_Type

val DFSR_write : DFSR_Type -> unit

function DFSR_write value_name = {
    let r : DFSR_Type = value_name;
    if ELUsingAArch32(EL3) & CurrentSecurityState() == SS_Secure then {
        DFSR_S = r
    } else {
        DFSR_NS_write() = r
    };
    return()
}

bitfield IFSR32_EL2_Type : bits(64) =
  {FnV : 16..16, ExT : 12..12, FS : (10..10 @ 3..0), LPAE : 9..9, STATUS : 5..0}

register IFSR32_EL2 : IFSR32_EL2_Type

bitfield IFSR_Type : bits(32) =
  {FnV : 16..16, ExT : 12..12, FS : (10..10 @ 3..0), LPAE : 9..9, STATUS : 5..0}

register _IFSR_NS : IFSR_Type

val IFSR_NS_write : IFSR_Type -> unit

function IFSR_NS_write value_name = {
    let r : IFSR_Type = value_name;
    IFSR32_EL2.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _IFSR_NS = r;
    return()
}

register IFSR_S : IFSR_Type

val IFSR_write : IFSR_Type -> unit

function IFSR_write value_name = {
    let r : IFSR_Type = value_name;
    if ELUsingAArch32(EL3) & CurrentSecurityState() == SS_Secure then {
        IFSR_S = r
    } else {
        IFSR_NS_write() = r
    };
    return()
}

val AArch32_ReportDataAbort : forall ('route_to_monitor : Bool).
  (bool('route_to_monitor), FaultRecord, bits(32)) -> unit

function AArch32_ReportDataAbort (route_to_monitor, fault, vaddress) = {
    long_format : bool = undefined;
    if route_to_monitor & CurrentSecurityState() != SS_Secure then {
        long_format = TTBCR_S[EAE] == 0b1 | IsExternalSyncAbort__1(fault) & ((PSTATE.EL == EL2 | TTBCR_read()[EAE] == 0b1) | fault.secondstage & __IMPDEF_boolean("Report abort using Long-descriptor format"))
    } else {
        long_format = TTBCR_read()[EAE] == 0b1
    };
    syndrome : bits(32) = AArch32_CommonFaultStatus(fault, long_format);
    if fault.access.acctype == AccessType_DC | fault.access.acctype == AccessType_IC | fault.access.acctype == AccessType_AT then {
        syndrome[13] = Bit(0b1);
        syndrome[11] = Bit(0b1)
    } else {
        syndrome[11] = Bit(if fault.write then 0b1 else 0b0)
    };
    if not_bool(long_format) then {
        syndrome[7 .. 4] = fault.domain
    };
    if fault.access.acctype == AccessType_IC then {
        i_syndrome : bits(32) = undefined;
        if not_bool(long_format) & __IMPDEF_boolean("Report I-cache maintenance fault in IFSR") then {
            i_syndrome = syndrome;
            (syndrome[10 .. 10] @ syndrome[3 .. 0]) = EncodeSDFSC(Fault_ICacheMaint, 1)
        } else {
            i_syndrome = __UNKNOWN_bits(32)
        };
        if route_to_monitor then {
            IFSR_S = Mk_IFSR_Type(i_syndrome)
        } else {
            IFSR_write() = Mk_IFSR_Type(i_syndrome)
        }
    };
    if route_to_monitor then {
        DFSR_S = Mk_DFSR_Type(syndrome);
        DFAR_S_write() = vaddress
    } else {
        DFSR_write() = Mk_DFSR_Type(syndrome);
        DFAR_write() = vaddress
    };
    return()
}

bitfield DBGDSCRext_Type : bits(32) =
  {
    TFO : 31..31,
    RXfull : 30..30,
    TXfull : 29..29,
    RXO : 27..27,
    TXU : 26..26,
    INTdis : 23..22,
    TDA : 21..21,
    SC2 : 19..19,
    NS : 18..18,
    SPNIDdis : 17..17,
    SPIDdis : 16..16,
    MDBGen : 15..15,
    HDE : 14..14,
    UDCCdis : 12..12,
    ERR : 6..6,
    MOE : 5..2
  }

bitfield DBGDSCRint_Type : bits(32) =
  {
    RXfull : 30..30,
    TXfull : 29..29,
    NS : 18..18,
    SPNIDdis : 17..17,
    SPIDdis : 16..16,
    MDBGen : 15..15,
    UDCCdis : 12..12,
    MOE : 5..2
  }

register _DBGDSCRint : DBGDSCRint_Type

val DBGDSCRint_read : unit -> DBGDSCRint_Type

function DBGDSCRint_read () = {
    r : DBGDSCRint_Type = _DBGDSCRint;
    r.bits[30 .. 29] = Slice(MDCCSR_EL0.bits, 29, 2);
    r.bits[15] = Bit(Slice(MDSCR_EL1.bits, 15, 1));
    r.bits[12] = Bit(Slice(MDSCR_EL1.bits, 12, 1));
    r.bits[5 .. 2] = Slice(MDSCR_EL1.bits, 2, 4);
    return(r)
}

register _DBGDSCRext : DBGDSCRext_Type

val DBGDSCRext_read : unit -> DBGDSCRext_Type

function DBGDSCRext_read () = {
    r : DBGDSCRext_Type = _DBGDSCRext;
    r.bits[31 .. 0] = Slice(MDSCR_EL1.bits, 0, 32);
    r.bits[15] = Bit(Slice(DBGDSCRint_read().bits, 15, 1));
    r.bits[12] = Bit(Slice(DBGDSCRint_read().bits, 12, 1));
    r.bits[5 .. 2] = Slice(DBGDSCRint_read().bits, 2, 4);
    return(r)
}

val DBGDSCRint_write : DBGDSCRint_Type -> unit

function DBGDSCRint_write value_name = {
    let r : DBGDSCRint_Type = value_name;
    MDCCSR_EL0.bits[30 .. 29] = Slice(r.bits, 29, 2);
    MDSCR_EL1.bits[15] = Bit(Slice(r.bits, 15, 1));
    MDSCR_EL1.bits[12] = Bit(Slice(r.bits, 12, 1));
    MDSCR_EL1.bits[5 .. 2] = Slice(r.bits, 2, 4);
    _DBGDSCRint = r;
    return()
}

val DBGDSCRext_write : DBGDSCRext_Type -> unit

function DBGDSCRext_write value_name = {
    let r : DBGDSCRext_Type = value_name;
    MDSCR_EL1.bits[31 .. 0] = Slice(r.bits, 0, 32);
    DBGDSCRint_write() = Mk_DBGDSCRint_Type(SetSlice(1, DBGDSCRint_read().bits, 15, Slice(r.bits, 15, 1)));
    DBGDSCRint_write() = Mk_DBGDSCRint_Type(SetSlice(1, DBGDSCRint_read().bits, 12, Slice(r.bits, 12, 1)));
    DBGDSCRint_write() = Mk_DBGDSCRint_Type(SetSlice(4, DBGDSCRint_read().bits, 2, Slice(r.bits, 2, 4)));
    _DBGDSCRext = r;
    return()
}

bitfield HCR2_Type : bits(32) =
  {
    TTLBIS : 22..22,
    TOCU : 20..20,
    TICAB : 18..18,
    TID4 : 17..17,
    MIOCNCE : 6..6,
    TEA : 5..5,
    TERR : 4..4,
    ID : 1..1,
    CD : 0..0
  }

register _HCR2 : HCR2_Type

val HCR2_read : unit -> HCR2_Type

function HCR2_read () = {
    r : HCR2_Type = _HCR2;
    r.bits[31 .. 0] = Slice(HCR_EL2.bits, 32, 32);
    return(r)
}

val IsDebugException : FaultRecord -> bool

function IsDebugException fault = {
    assert(fault.statuscode != Fault_None);
    return(fault.statuscode == Fault_Debug)
}

val AArch32_TakeDataAbortException : (bits(32), FaultRecord) -> unit

function AArch32_TakeDataAbortException (vaddress, fault) = {
    except : ExceptionRecord = undefined;
    let route_to_monitor : bool = (HaveEL(EL3) & EffectiveEA() == 0b1) & IsExternalAbort__1(fault);
    let route_to_hyp : bool = (EL2Enabled() & (PSTATE.EL == EL0 | PSTATE.EL == EL1)) & (((HCR_read()[TGE] == 0b1 | (HaveRASExt() & HCR2_read()[TEA] == 0b1) & IsExternalAbort__1(fault)) | IsDebugException(fault) & HDCR_read()[TDE] == 0b1) | IsSecondStage(fault));
    let preferred_exception_return : bits(32) = ThisInstrAddr(32);
    let 'vect_offset = UInt(0x10);
    let 'lr_offset = 8;
    if IsDebugException(fault) then {
        DBGDSCRext_write() = [DBGDSCRext_read() with MOE = fault.debugmoe]
    };
    if route_to_monitor then {
        AArch32_ReportDataAbort(route_to_monitor, fault, vaddress);
        AArch32_EnterMonitorMode(preferred_exception_return, lr_offset, vect_offset)
    } else if PSTATE.EL == EL2 | route_to_hyp then {
        let except : ExceptionRecord = AArch32_AbortSyndrome(Exception_DataAbort, fault, vaddress, EL2);
        if PSTATE.EL == EL2 then {
            AArch32_EnterHypMode(except, preferred_exception_return, vect_offset)
        } else {
            AArch32_EnterHypMode(except, preferred_exception_return, UInt(0x14))
        }
    } else {
        AArch32_ReportDataAbort(route_to_monitor, fault, vaddress);
        AArch32_EnterMode(M32_Abort, preferred_exception_return, lr_offset, vect_offset)
    }
}

type IFAR_Type = bits(32)

register _IFAR_NS : IFAR_Type

val IFAR_NS_write : IFAR_Type -> unit

function IFAR_NS_write value_name = {
    let r : IFAR_Type = value_name;
    FAR_EL1[63 .. 32] = Slice(r, 0, 32);
    _IFAR_NS = r;
    return()
}

val HIFAR_read : unit -> HIFAR_Type

function HIFAR_read () = {
    r : HIFAR_Type = _HIFAR;
    r[31 .. 0] = Slice(FAR_EL2, 32, 32);
    return(r)
}

register _IFAR_S : IFAR_Type

val IFAR_S_write : IFAR_Type -> unit

function IFAR_S_write value_name = {
    let r : IFAR_Type = value_name;
    if HaveEL(EL2) then {
        FAR_EL2[63 .. 32] = Slice(r, 0, 32)
    } else {
        HIFAR_write() = SetSlice(32, HIFAR_read(), 0, Slice(r, 0, 32))
    };
    _IFAR_S = r;
    return()
}

val IFAR_write : IFAR_Type -> unit

function IFAR_write value_name = {
    let r : IFAR_Type = value_name;
    if ELUsingAArch32(EL3) & CurrentSecurityState() == SS_Secure then {
        IFAR_S_write() = r
    } else {
        IFAR_NS_write() = r
    };
    return()
}

val AArch32_ReportPrefetchAbort : forall ('route_to_monitor : Bool).
  (bool('route_to_monitor), FaultRecord, bits(32)) -> unit

function AArch32_ReportPrefetchAbort (route_to_monitor, fault, vaddress) = {
    long_format : bool = false;
    if route_to_monitor & CurrentSecurityState() != SS_Secure then {
        long_format = (TTBCR_S[EAE] == 0b1 | PSTATE.EL == EL2) | TTBCR_read()[EAE] == 0b1
    } else {
        long_format = TTBCR_read()[EAE] == 0b1
    };
    let fsr : bits(32) = AArch32_CommonFaultStatus(fault, long_format);
    if route_to_monitor then {
        IFSR_S = Mk_IFSR_Type(fsr);
        IFAR_S_write() = vaddress
    } else {
        IFSR_write() = Mk_IFSR_Type(fsr);
        IFAR_write() = vaddress
    };
    return()
}

val AArch32_TakePrefetchAbortException : (bits(32), FaultRecord) -> unit

function AArch32_TakePrefetchAbortException (vaddress, fault) = {
    let route_to_monitor : bool = (HaveEL(EL3) & EffectiveEA() == 0b1) & IsExternalAbort__1(fault);
    let route_to_hyp : bool = (EL2Enabled() & (PSTATE.EL == EL0 | PSTATE.EL == EL1)) & (((HCR_read()[TGE] == 0b1 | (HaveRASExt() & HCR2_read()[TEA] == 0b1) & IsExternalAbort__1(fault)) | IsDebugException(fault) & HDCR_read()[TDE] == 0b1) | IsSecondStage(fault));
    except : ExceptionRecord = undefined;
    let preferred_exception_return : bits(32) = ThisInstrAddr(32);
    let 'vect_offset = UInt(0x0C);
    let 'lr_offset = 4;
    if IsDebugException(fault) then {
        DBGDSCRext_write() = [DBGDSCRext_read() with MOE = fault.debugmoe]
    };
    if route_to_monitor then {
        AArch32_ReportPrefetchAbort(route_to_monitor, fault, vaddress);
        AArch32_EnterMonitorMode(preferred_exception_return, lr_offset, vect_offset)
    } else if PSTATE.EL == EL2 | route_to_hyp then {
        if fault.statuscode == Fault_Alignment then {
            except = ExceptionSyndrome(Exception_PCAlignment);
            except.vaddress = ThisInstrAddr(64)
        } else {
            except = AArch32_AbortSyndrome(Exception_InstructionAbort, fault, vaddress, EL2)
        };
        if PSTATE.EL == EL2 then {
            AArch32_EnterHypMode(except, preferred_exception_return, vect_offset)
        } else {
            AArch32_EnterHypMode(except, preferred_exception_return, UInt(0x14))
        }
    } else {
        AArch32_ReportPrefetchAbort(route_to_monitor, fault, vaddress);
        AArch32_EnterMode(M32_Abort, preferred_exception_return, lr_offset, vect_offset)
    }
}

val AArch64_EncodeSyncErrorSyndrome : ErrorState -> bits(2)

function AArch64_EncodeSyncErrorSyndrome errorstate = {
    match errorstate {
      ErrorState_UC => {
          return(0b10)
      },
      ErrorState_UEO => {
          return(0b11)
      },
      ErrorState_UER => {
          return(0b00)
      },
      _ => {
          Unreachable();
          return(undefined : bits(2))
      }
    }
}

val ExtAbortToA64 : FaultRecord -> bool

function ExtAbortToA64 fault = {
    route_to_aarch64 : bool = PSTATE.EL == EL0 & not_bool(ELUsingAArch32(EL1));
    if (not_bool(route_to_aarch64) & EL2Enabled()) & not_bool(ELUsingAArch32(EL2)) then {
        route_to_aarch64 = ((HCR_EL2[TGE] == 0b1 | IsSecondStage(fault)) | (HaveRASExt() & HCR_EL2[TEA] == 0b1) & IsExternalAbort__1(fault)) | IsDebugException(fault) & MDCR_EL2[TDE] == 0b1
    };
    if (not_bool(route_to_aarch64) & HaveEL(EL3)) & not_bool(ELUsingAArch32(EL3)) then {
        route_to_aarch64 = SCR_GEN_read()[EA] == 0b1 & IsExternalAbort__1(fault)
    };
    return(route_to_aarch64 & IsExternalSyncAbort(fault.statuscode))
}

val FaultIsCorrected : unit -> bool

val ReportErrorAsIMPDEF : unit -> bool

val ReportErrorAsUncategorized : unit -> bool

val AArch64_PEErrorState : FaultRecord -> ErrorState

function AArch64_PEErrorState fault = {
    if not_bool(IsExternalSyncAbort__1(fault)) & ExtAbortToA64(fault) then {
        if ReportErrorAsUncategorized() then {
            return(ErrorState_Uncategorized)
        };
        if ReportErrorAsIMPDEF() then {
            return(ErrorState_IMPDEF)
        };
        ()
    };
    assert(not_bool(FaultIsCorrected()));
    if (not_bool(ErrorIsContained()) | not_bool(ErrorIsSynchronized()) & not_bool(StateIsRecoverable())) | ReportErrorAsUC() then {
        return(ErrorState_UC)
    };
    if not_bool(StateIsRecoverable()) | ReportErrorAsUEU() then {
        if IsExternalSyncAbort__1(fault) then {
            return(ErrorState_UC)
        } else {
            return(ErrorState_UEU)
        }
    };
    if ActionRequired() | ReportErrorAsUER() then {
        return(ErrorState_UER)
    };
    return(ErrorState_UEO)
}

val HaveFeatLS64 : unit -> bool

function HaveFeatLS64 () = {
    return(IsFeatureImplemented(FEAT_LS64))
}

val LS64InstructionSyndrome : unit -> (bits(24), bits(11))

val AArch64_FaultSyndrome : forall ('d_side : Bool) ('pavalid : Bool).
  (bool('d_side), FaultRecord, bool('pavalid)) -> (bits(25), bits(24))

function AArch64_FaultSyndrome (d_side, fault, pavalid) = {
    assert(fault.statuscode != Fault_None);
    iss : bits(25) = Zeros(25);
    iss2 : bits(24) = Zeros(24);
    if HaveRASExt() & fault.statuscode == Fault_SyncExternal then {
        let errstate : ErrorState = AArch64_PEErrorState(fault);
        iss[12 .. 11] = AArch64_EncodeSyncErrorSyndrome(errstate)
    };
    if d_side then {
        if fault.access.acctype == AccessType_GCS then {
            iss2[8] = Bit(0b1)
        };
        if HaveFeatLS64() & fault.access.ls64 then {
            if fault.statuscode == Fault_AccessFlag | fault.statuscode == Fault_Translation | fault.statuscode == Fault_Permission then {
                (iss2, iss[24 .. 14]) = LS64InstructionSyndrome()
            };
            ()
        } else if (IsSecondStage(fault) & not_bool(fault.s2fs1walk)) & (not_bool(IsExternalSyncAbort__1(fault)) | (not_bool(HaveRASExt()) & fault.access.acctype == AccessType_TTW) & __IMPDEF_boolean("ISV on second stage translation table walk")) then {
            iss[24 .. 14] = LSInstructionSyndrome()
        } else ();
        if HaveNV2Ext() & fault.access.acctype == AccessType_NV2 then {
            iss[13] = Bit(0b1)
        };
        if HaveFeatLS64() & (fault.statuscode == Fault_AccessFlag | fault.statuscode == Fault_Translation | fault.statuscode == Fault_Permission) then {
            iss[12 .. 11] = GetLoadStoreType()
        };
        if fault.access.acctype == AccessType_DC | fault.access.acctype == AccessType_IC | fault.access.acctype == AccessType_AT then {
            iss[8] = Bit(0b1)
        };
        if fault.access.acctype == AccessType_DC | fault.access.acctype == AccessType_IC | fault.access.acctype == AccessType_AT then {
            iss[6] = Bit(0b1)
        } else if fault.statuscode == Fault_HWUpdateAccessFlag | fault.statuscode == Fault_Exclusive then {
            iss[6] = Bit(__UNKNOWN_bit())
        } else if fault.access.atomicop & IsExternalAbort__1(fault) then {
            iss[6] = Bit(__UNKNOWN_bit())
        } else {
            iss[6] = Bit(if fault.write then 0b1 else 0b0)
        };
        if fault.statuscode == Fault_Permission then {
            iss2[5] = Bit(if fault.dirtybit then 0b1 else 0b0);
            iss2[6] = Bit(if fault.overlay then 0b1 else 0b0);
            if [iss[24]] == 0b0 then {
                iss[21] = Bit(if fault.toplevel then 0b1 else 0b0)
            };
            iss2[7] = Bit(if fault.assuredonly then 0b1 else 0b0);
            iss2[9] = Bit(if fault.tagaccess then 0b1 else 0b0);
            iss2[10] = Bit(if fault.s1tagnotdata then 0b1 else 0b0)
        };
        ()
    } else {
        if fault.access.acctype == AccessType_IFETCH & fault.statuscode == Fault_Permission then {
            iss2[5] = Bit(if fault.dirtybit then 0b1 else 0b0);
            iss[21] = Bit(if fault.toplevel then 0b1 else 0b0);
            iss2[7] = Bit(if fault.assuredonly then 0b1 else 0b0);
            iss2[6] = Bit(if fault.overlay then 0b1 else 0b0)
        };
        ()
    };
    if IsExternalAbort__1(fault) then {
        iss[9] = Bit(fault.extflag)
    };
    iss[7] = Bit(if fault.s2fs1walk then 0b1 else 0b0);
    iss[5 .. 0] = EncodeLDFSC(fault.statuscode, fault.level);
    return((iss, iss2))
}

val AArch64_AbortSyndrome : (Exception, FaultRecord, bits(64), bits(2)) -> ExceptionRecord

function AArch64_AbortSyndrome (exceptype, fault, vaddress, target_el) = {
    except : ExceptionRecord = ExceptionSyndrome(exceptype);
    let d_side : bool = exceptype == Exception_DataAbort | exceptype == Exception_NV2DataAbort | exceptype == Exception_Watchpoint | exceptype == Exception_NV2Watchpoint;
    if (not_bool(HavePFAR()) | not_bool(IsExternalSyncAbort__1(fault))) | (EL2Enabled() & HCR_EL2[VM] == 0b1) & target_el == EL1 then {
        except.pavalid = false
    } else {
        except.pavalid = __IMPDEF_boolean("PFAR_ELx is valid")
    };
    (except.syndrome, except.syndrome2) = AArch64_FaultSyndrome(d_side, fault, except.pavalid);
    if fault.statuscode == Fault_TagCheck then {
        if HaveMTE4Ext() then {
            except.vaddress = ZeroExtend(vaddress, 64)
        } else {
            except.vaddress = __UNKNOWN_bits(4) @ vaddress[59 .. 0]
        }
    } else {
        except.vaddress = ZeroExtend(vaddress, 64)
    };
    if IPAValid(fault) then {
        except.ipavalid = true;
        except.NS = if fault.ipaddress.paspace == PAS_NonSecure then 0b1 else
          0b0;
        except.ipaddress = fault.ipaddress.address
    } else {
        except.ipavalid = false
    };
    return(except)
}

val AArch64_BreakpointException : FaultRecord -> unit

function AArch64_BreakpointException fault = {
    assert(PSTATE.EL != EL3);
    let route_to_el2 : bool = ((PSTATE.EL == EL0 | PSTATE.EL == EL1) & EL2Enabled()) & (HCR_EL2[TGE] == 0b1 | MDCR_EL2[TDE] == 0b1);
    let preferred_exception_return : bits(64) = ThisInstrAddr(64);
    let 'vect_offset = UInt(0x0);
    let target_el : bits(2) = if PSTATE.EL == EL2 | route_to_el2 then EL2 else
      EL1;
    let vaddress : bits(64) = __UNKNOWN_bits(64);
    let except : ExceptionRecord = AArch64_AbortSyndrome(Exception_Breakpoint, fault, vaddress, target_el);
    sail_take_exception(None());
    AArch64_TakeException(target_el, except, preferred_exception_return, vect_offset)
}

val HaveDoubleFault2Ext : unit -> bool

function HaveDoubleFault2Ext () = {
    return(IsFeatureImplemented(FEAT_DoubleFault2))
}

val HaveFeatSCTLR2 : unit -> bool

function HaveFeatSCTLR2 () = {
    return(IsFeatureImplemented(FEAT_SCTLR2))
}

val IsSCTLR2EL1Enabled : unit -> bool

function IsSCTLR2EL1Enabled () = {
    if not_bool(HaveFeatSCTLR2()) then {
        return(false)
    };
    if HaveEL(EL3) & SCR_EL3[SCTLR2En] == 0b0 then {
        return(false)
    } else if EL2Enabled() & (not_bool(IsHCRXEL2Enabled()) | HCRX_EL2[SCTLR2En] == 0b0) then {
        return(false)
    } else {
        return(true)
    }
}

val IsSCTLR2EL2Enabled : unit -> bool

function IsSCTLR2EL2Enabled () = {
    if not_bool(HaveFeatSCTLR2()) then {
        return(false)
    };
    if HaveEL(EL3) & SCR_EL3[SCTLR2En] == 0b0 then {
        return(false)
    };
    return(EL2Enabled())
}

bitfield SCTLR2_EL1_Type : bits(64) =
  {EnIDCP128 : 6..6, EASE : 5..5, EnANERR : 4..4, EnADERR : 3..3, NMEA : 2..2}

register SCTLR2_EL1 : SCTLR2_EL1_Type

bitfield SCTLR2_EL2_Type : bits(64) =
  {
    EnIDCP128 : 6..6,
    EASE : 5..5,
    EnANERR : 4..4,
    EnADERR : 3..3,
    NMEA : 2..2,
    EMEC : 1..1
  }

register SCTLR2_EL2 : SCTLR2_EL2_Type

val AArch64_RouteToSErrorOffset : bits(2) -> bool

function AArch64_RouteToSErrorOffset target_el = {
    if not_bool(HaveDoubleFaultExt()) then {
        return(false)
    };
    ease_bit : bits(1) = undefined;
    match target_el {
      ? if ? == EL3 => {
          ease_bit = SCR_EL3[EASE]
      },
      ? if ? == EL2 => {
          if HaveDoubleFault2Ext() & IsSCTLR2EL2Enabled() then {
              ease_bit = SCTLR2_EL2[EASE]
          } else {
              ease_bit = 0b0
          }
      },
      ? if ? == EL1 => {
          if HaveDoubleFault2Ext() & IsSCTLR2EL1Enabled() then {
              ease_bit = SCTLR2_EL1[EASE]
          } else {
              ease_bit = 0b0
          }
      },
      _ => ()
    };
    return(ease_bit == 0b1)
}

val AArch64_SyncExternalAbortTarget : FaultRecord -> bits(2)

function AArch64_SyncExternalAbortTarget fault = {
    route_to_el3 : bool = undefined;
    if PSTATE.EL != EL3 then {
        route_to_el3 = HaveEL(EL3) & EffectiveEA() == 0b1
    } else {
        route_to_el3 = false
    };
    let tea_bit : bits(1) = if HaveRASExt() then HCR_EL2[TEA] else 0b0;
    route_to_el2 : bool = undefined;
    if (not_bool(route_to_el3) & EL2Enabled()) & PSTATE.EL == EL1 then {
        route_to_el2 = (tea_bit == 0b1 | fault.access.acctype == AccessType_NV2) | IsSecondStage(fault)
    } else if (not_bool(route_to_el3) & EL2Enabled()) & PSTATE.EL == EL0 then {
        route_to_el2 = not_bool(IsInHost()) & ((HCR_EL2[TGE] == 0b1 | tea_bit == 0b1) | IsSecondStage(fault))
    } else {
        route_to_el2 = false
    };
    route_masked_to_el3 : bool = undefined;
    route_masked_to_el2 : bool = undefined;
    if HaveDoubleFault2Ext() then {
        route_masked_to_el2 = (((EL2Enabled() & not_bool(route_to_el3)) & PSTATE.EL == EL1 & PSTATE.A == 0b1) & IsHCRXEL2Enabled()) & HCRX_EL2[TMEA] == 0b1;
        route_masked_to_el3 = ((HaveEL(EL3) & not_bool(route_to_el2 | route_masked_to_el2)) & (PSTATE.EL == EL2 | PSTATE.EL == EL1) & PSTATE.A == 0b1) & SCR_EL3[TMEA] == 0b1
    } else {
        route_masked_to_el2 = false;
        route_masked_to_el3 = false
    };
    let take_in_el3 : bool = PSTATE.EL == EL3;
    let take_in_el2_0 : bool = (PSTATE.EL == EL2 | IsInHost()) & not_bool(route_to_el3 | route_masked_to_el3);
    let take_in_el1_0 : bool = ((PSTATE.EL == EL1 | PSTATE.EL == EL0 & not_bool(IsInHost())) & not_bool(route_to_el2 | route_masked_to_el2)) & not_bool(route_to_el3 | route_masked_to_el3);
    target_el : bits(2) = undefined;
    if (take_in_el3 | route_to_el3) | route_masked_to_el3 then {
        target_el = EL3
    } else if (take_in_el2_0 | route_to_el2) | route_masked_to_el2 then {
        target_el = EL2
    } else if take_in_el1_0 then {
        target_el = EL1
    } else {
        assert(false)
    };
    return(target_el)
}

val AArch64_DataAbort : (bits(64), FaultRecord) -> unit

function AArch64_DataAbort (vaddress, fault) = {
    route_to_el2 : bool = undefined;
    target_el : bits(2) = undefined;
    if IsExternalAbort__1(fault) then {
        target_el = AArch64_SyncExternalAbortTarget(fault)
    } else {
        let route_to_el2 : bool = (EL2Enabled() & (PSTATE.EL == EL0 | PSTATE.EL == EL1)) & (((HCR_EL2[TGE] == 0b1 | (HaveRME() & fault.gpcf.gpf == GPCF_Fail) & HCR_EL2[GPF] == 0b1) | HaveNV2Ext() & fault.access.acctype == AccessType_NV2) | IsSecondStage(fault));
        if PSTATE.EL == EL3 then {
            target_el = EL3
        } else if PSTATE.EL == EL2 | route_to_el2 then {
            target_el = EL2
        } else {
            target_el = EL1
        }
    };
    let preferred_exception_return : bits(64) = ThisInstrAddr(64);
    vect_offset : int = undefined;
    if IsExternalAbort__1(fault) & AArch64_RouteToSErrorOffset(target_el) then {
        vect_offset = UInt(0x180)
    } else {
        vect_offset = UInt(0x0)
    };
    let 'vect_offset = vect_offset;
    except : ExceptionRecord = undefined;
    if HaveNV2Ext() & fault.access.acctype == AccessType_NV2 then {
        except = AArch64_AbortSyndrome(Exception_NV2DataAbort, fault, vaddress, target_el)
    } else {
        except = AArch64_AbortSyndrome(Exception_DataAbort, fault, vaddress, target_el)
    };
    sail_take_exception(Some(fault));
    AArch64_TakeException(target_el, except, preferred_exception_return, vect_offset)
}

val AArch64_InstructionAbort : (bits(64), FaultRecord) -> unit

function AArch64_InstructionAbort (vaddress, fault) = {
    route_to_el2 : bool = undefined;
    if HaveDoubleFaultExt() then {
        assert(fault.statuscode != Fault_AsyncExternal)
    };
    target_el : bits(2) = undefined;
    if IsExternalAbort__1(fault) then {
        target_el = AArch64_SyncExternalAbortTarget(fault)
    } else {
        let route_to_el2 : bool = (EL2Enabled() & (PSTATE.EL == EL0 | PSTATE.EL == EL1)) & ((HCR_EL2[TGE] == 0b1 | (HaveRME() & fault.gpcf.gpf == GPCF_Fail) & HCR_EL2[GPF] == 0b1) | IsSecondStage(fault));
        if PSTATE.EL == EL3 then {
            target_el = EL3
        } else if PSTATE.EL == EL2 | route_to_el2 then {
            target_el = EL2
        } else {
            target_el = EL1
        }
    };
    let preferred_exception_return : bits(64) = ThisInstrAddr(64);
    vect_offset : int = undefined;
    if IsExternalAbort__1(fault) & AArch64_RouteToSErrorOffset(target_el) then {
        vect_offset = UInt(0x180)
    } else {
        vect_offset = UInt(0x0)
    };
    let 'vect_offset = vect_offset;
    let except : ExceptionRecord = AArch64_AbortSyndrome(Exception_InstructionAbort, fault, vaddress, target_el);
    sail_take_exception(Some(fault));
    AArch64_TakeException(target_el, except, preferred_exception_return, vect_offset)
}

val AArch64_VectorCatchException : FaultRecord -> unit

function AArch64_VectorCatchException fault = {
    assert(PSTATE.EL != EL2);
    assert(EL2Enabled() & (HCR_EL2[TGE] == 0b1 | MDCR_EL2[TDE] == 0b1));
    let preferred_exception_return : bits(64) = ThisInstrAddr(64);
    let 'vect_offset = UInt(0x0);
    let vaddress : bits(64) = __UNKNOWN_bits(64);
    let except : ExceptionRecord = AArch64_AbortSyndrome(Exception_VectorCatch, fault, vaddress, EL2);
    sail_take_exception(None());
    AArch64_TakeException(EL2, except, preferred_exception_return, vect_offset)
}

val AArch64_WatchpointException : (bits(64), FaultRecord) -> unit

function AArch64_WatchpointException (vaddress, fault) = {
    assert(PSTATE.EL != EL3);
    let route_to_el2 : bool = ((PSTATE.EL == EL0 | PSTATE.EL == EL1) & EL2Enabled()) & (HCR_EL2[TGE] == 0b1 | MDCR_EL2[TDE] == 0b1);
    let preferred_exception_return : bits(64) = ThisInstrAddr(64);
    let 'vect_offset = UInt(0x0);
    let target_el : bits(2) = if PSTATE.EL == EL2 | route_to_el2 then EL2 else
      EL1;
    except : ExceptionRecord = undefined;
    if HaveNV2Ext() & fault.access.acctype == AccessType_NV2 then {
        except = AArch64_AbortSyndrome(Exception_NV2Watchpoint, fault, vaddress, target_el)
    } else {
        except = AArch64_AbortSyndrome(Exception_Watchpoint, fault, vaddress, target_el)
    };
    sail_take_exception(Some(fault));
    AArch64_TakeException(target_el, except, preferred_exception_return, vect_offset)
}

val ReportAsGPCException : FaultRecord -> bool

function ReportAsGPCException fault = {
    assert(HaveRME());
    assert(fault.statuscode == Fault_GPCFOnWalk | fault.statuscode == Fault_GPCFOnOutput);
    assert(fault.gpcf.gpf != GPCF_None);
    match fault.gpcf.gpf {
      GPCF_Walk => {
          return(true)
      },
      GPCF_AddressSize => {
          return(true)
      },
      GPCF_EABT => {
          return(true)
      },
      GPCF_Fail => {
          return(SCR_EL3[GPF] == 0b1 & PSTATE.EL != EL3)
      },
      _ => {
          return(undefined : bool)
      }
    }
}

val EncodeGPCSC : GPCFRecord -> bits(6)

function EncodeGPCSC gpcf = {
    assert(gpcf.level == 0 | gpcf.level == 1);
    match gpcf.gpf {
      GPCF_AddressSize => {
          return(0b00000 @ [gpcf.level[0]])
      },
      GPCF_Walk => {
          return(0b00010 @ [gpcf.level[0]])
      },
      GPCF_Fail => {
          return(0b00110 @ [gpcf.level[0]])
      },
      GPCF_EABT => {
          return(0b01010 @ [gpcf.level[0]])
      },
      _ => {
          return(undefined : bits(6))
      }
    }
}

val HaveAccessFlagUpdateExt : unit -> bool

function HaveAccessFlagUpdateExt () = {
    return(IsFeatureImplemented(FEAT_HAFDBS))
}

val HaveAtomicExt : unit -> bool

function HaveAtomicExt () = {
    return(IsFeatureImplemented(FEAT_LSE))
}

val HaveDirtyBitModifierExt : unit -> bool

function HaveDirtyBitModifierExt () = {
    return(IsFeatureImplemented(FEAT_HAFDBS))
}

val TakeGPCException : (bits(64), FaultRecord) -> unit

function TakeGPCException (vaddress, fault) = {
    assert(HaveRME());
    assert(HaveAtomicExt());
    assert(HaveAccessFlagUpdateExt());
    assert(HaveDirtyBitModifierExt());
    assert(HaveDoubleFaultExt());
    except : ExceptionRecord = undefined;
    except.exceptype = Exception_GPC;
    except.vaddress = ZeroExtend(vaddress, 64);
    except.paddress = fault.paddress;
    except.pavalid = true;
    if IPAValid(fault) then {
        except.ipavalid = true;
        except.NS = if fault.ipaddress.paspace == PAS_NonSecure then 0b1 else
          0b0;
        except.ipaddress = fault.ipaddress.address
    } else {
        except.ipavalid = false
    };
    if fault.access.acctype == AccessType_GCS then {
        except.syndrome2[8] = Bit(0b1)
    };
    except.syndrome[24 .. 22] = Zeros(3);
    except.syndrome[21] = Bit(if fault.gpcfs2walk then 0b1 else 0b0);
    if fault.access.acctype == AccessType_IFETCH then {
        except.syndrome[20] = Bit(0b1)
    } else {
        except.syndrome[20] = Bit(0b0)
    };
    except.syndrome[19 .. 14] = EncodeGPCSC(fault.gpcf);
    if HaveNV2Ext() & fault.access.acctype == AccessType_NV2 then {
        except.syndrome[13] = Bit(0b1)
    } else {
        except.syndrome[13] = Bit(0b0)
    };
    except.syndrome[12 .. 11] = 0b00;
    except.syndrome[10 .. 9] = 0b00;
    if fault.access.acctype == AccessType_DC | fault.access.acctype == AccessType_IC | fault.access.acctype == AccessType_AT then {
        except.syndrome[8] = Bit(0b1)
    } else {
        except.syndrome[8] = Bit(0b0)
    };
    except.syndrome[7] = Bit(if fault.s2fs1walk then 0b1 else 0b0);
    if fault.access.acctype == AccessType_DC | fault.access.acctype == AccessType_IC | fault.access.acctype == AccessType_AT then {
        except.syndrome[6] = Bit(0b1)
    } else if fault.statuscode == Fault_HWUpdateAccessFlag | fault.statuscode == Fault_Exclusive then {
        except.syndrome[6] = Bit(__UNKNOWN_bit())
    } else if fault.access.atomicop & IsExternalAbort__1(fault) then {
        except.syndrome[6] = Bit(__UNKNOWN_bit())
    } else {
        except.syndrome[6] = Bit(if fault.write then 0b1 else 0b0)
    };
    except.syndrome[5 .. 0] = EncodeLDFSC(fault.statuscode, fault.level);
    let preferred_exception_return : bits(64) = ThisInstrAddr(64);
    let target_el : bits(2) = EL3;
    vect_offset : int = undefined;
    if IsExternalAbort__1(fault) & AArch64_RouteToSErrorOffset(target_el) then {
        vect_offset = UInt(0x180)
    } else {
        vect_offset = UInt(0x0)
    };
    let 'vect_offset = vect_offset;
    sail_take_exception(Some(fault));
    AArch64_TakeException(target_el, except, preferred_exception_return, vect_offset)
}

val AArch64_Abort : (bits(64), FaultRecord) -> unit

function AArch64_Abort (vaddress, fault) = {
    if IsDebugException(fault) then {
        if fault.access.acctype == AccessType_IFETCH then {
            if UsingAArch32() & fault.debugmoe == DebugException_VectorCatch then {
                AArch64_VectorCatchException(fault)
            } else {
                AArch64_BreakpointException(fault)
            }
        } else {
            AArch64_WatchpointException(vaddress, fault)
        }
    } else if fault.gpcf.gpf != GPCF_None & ReportAsGPCException(fault) then {
        TakeGPCException(vaddress, fault)
    } else if fault.access.acctype == AccessType_IFETCH then {
        AArch64_InstructionAbort(vaddress, fault)
    } else {
        AArch64_DataAbort(vaddress, fault)
    }
}

val AArch32_Abort : (bits(32), FaultRecord) -> unit

function AArch32_Abort (vaddress, fault) = {
    route_to_aarch64 : bool = PSTATE.EL == EL0 & not_bool(ELUsingAArch32(EL1));
    if (not_bool(route_to_aarch64) & EL2Enabled()) & not_bool(ELUsingAArch32(EL2)) then {
        route_to_aarch64 = ((HCR_EL2[TGE] == 0b1 | IsSecondStage(fault)) | (HaveRASExt() & HCR_EL2[TEA] == 0b1) & IsExternalAbort__1(fault)) | IsDebugException(fault) & MDCR_EL2[TDE] == 0b1
    };
    if (not_bool(route_to_aarch64) & HaveEL(EL3)) & not_bool(ELUsingAArch32(EL3)) then {
        route_to_aarch64 = EffectiveEA() == 0b1 & IsExternalAbort__1(fault)
    };
    if route_to_aarch64 then {
        AArch64_Abort(ZeroExtend(vaddress, 64), fault)
    } else if fault.access.acctype == AccessType_IFETCH then {
        AArch32_TakePrefetchAbortException(vaddress, fault)
    } else {
        AArch32_TakeDataAbortException(vaddress, fault)
    }
}

val GPCNoFault : unit -> GPCFRecord

function GPCNoFault () = {
    result : GPCFRecord = undefined;
    result.gpf = GPCF_None;
    return(result)
}

val NoFault : unit -> FaultRecord

val NoFault__1 : AccessDescriptor -> FaultRecord

function NoFault () = {
    fault : FaultRecord = undefined;
    fault.statuscode = Fault_None;
    fault.access = __UNKNOWN_AccessDescriptor();
    fault.secondstage = false;
    fault.s2fs1walk = false;
    fault.dirtybit = false;
    fault.overlay = false;
    fault.toplevel = false;
    fault.assuredonly = false;
    fault.s1tagnotdata = false;
    fault.tagaccess = false;
    fault.gpcfs2walk = false;
    fault.gpcf = GPCNoFault();
    return(fault)
}

function NoFault__1 accdesc = {
    fault : FaultRecord = undefined;
    fault.statuscode = Fault_None;
    fault.access = accdesc;
    fault.secondstage = false;
    fault.s2fs1walk = false;
    fault.dirtybit = false;
    fault.overlay = false;
    fault.toplevel = false;
    fault.assuredonly = false;
    fault.s1tagnotdata = false;
    fault.tagaccess = false;
    fault.write = not_bool(accdesc.read) & accdesc.write;
    fault.gpcfs2walk = false;
    fault.gpcf = GPCNoFault();
    return(fault)
}

val HandleExternalAbort : forall ('iswrite : Bool) 'size.
  (PhysMemRetStatus, bool('iswrite), AddressDescriptor, int('size), AccessDescriptor) -> unit

function HandleExternalAbort (memretstatus, iswrite, memaddrdesc, size, accdesc) = {
    assert((memretstatus.statuscode == Fault_SyncExternal | memretstatus.statuscode == Fault_AsyncExternal) | not_bool(HaveRASExt()) & (memretstatus.statuscode == Fault_SyncParity | memretstatus.statuscode == Fault_AsyncParity));
    fault : FaultRecord = NoFault__1(accdesc);
    fault.statuscode = memretstatus.statuscode;
    fault.write = iswrite;
    fault.extflag = memretstatus.extflag;
    if IsExternalSyncAbort__1(fault) & not_bool(IsExternalAbortTakenSynchronously(memretstatus, iswrite, memaddrdesc, size, accdesc)) then {
        if fault.statuscode == Fault_SyncParity then {
            fault.statuscode = Fault_AsyncParity
        } else {
            fault.statuscode = Fault_AsyncExternal
        }
    };
    if HaveRASExt() then {
        fault.merrorstate = memretstatus.merrorstate
    };
    if IsExternalSyncAbort__1(fault) then {
        if UsingAArch32() then {
            AArch32_Abort(memaddrdesc.vaddress[31 .. 0], fault)
        } else {
            AArch64_Abort(memaddrdesc.vaddress, fault)
        }
    } else {
        PendSErrorInterrupt(fault)
    }
}

val HandleExternalReadAbort : forall 'size.
  (PhysMemRetStatus, AddressDescriptor, int('size), AccessDescriptor) -> unit

function HandleExternalReadAbort (memstatus, memaddrdesc, size, accdesc) = {
    let iswrite : bool = false;
    HandleExternalAbort(memstatus, iswrite, memaddrdesc, size, accdesc)
}

val HandleExternalWriteAbort : forall 'size.
  (PhysMemRetStatus, AddressDescriptor, int('size), AccessDescriptor) -> unit

function HandleExternalWriteAbort (memstatus, memaddrdesc, size, accdesc) = {
    let iswrite : bool = true;
    HandleExternalAbort(memstatus, iswrite, memaddrdesc, size, accdesc)
}

val IsSynchronizablePhysicalSErrorPending : unit -> bool

val GetPendingPhysicalSError : unit -> FaultRecord

val HCR_write : HCR_Type -> unit

function HCR_write value_name = {
    let r : HCR_Type = value_name;
    HCR_EL2.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _HCR = r;
    return()
}

val ClearPendingVirtualSError : unit -> unit

function ClearPendingVirtualSError () = {
    if ELUsingAArch32(EL2) then {
        HCR_write() = [HCR_read() with VA = 0b0]
    } else {
        HCR_EL2[VSE] = 0b0
    }
}

val IsSErrorEdgeTriggered : unit -> bool

function IsSErrorEdgeTriggered () = {
    if HaveDoubleFaultExt() then {
        return(true)
    } else {
        return(__IMPDEF_boolean("Edge-triggered SError"))
    }
}

val FPInfinity : forall 'N, 'N in {16, 32, 64}. (bits(1), int('N)) -> bits('N)

function FPInfinity (sign, N) = {
    assert(N == 16 | N == 32 | N == 64);
    let 'E = if N == 16 then 5 else if N == 32 then 8 else 11;
    let 'F = N - (E + 1);
    let exp : bits('E) = Ones(E);
    let frac : bits('F) = Zeros(F);
    return((sign @ exp) @ frac)
}

val FPMaxNormal : forall 'N, 'N in {16, 32, 64}. (bits(1), int('N)) -> bits('N)

function FPMaxNormal (sign, N) = {
    assert(N == 16 | N == 32 | N == 64);
    let 'E = if N == 16 then 5 else if N == 32 then 8 else 11;
    let 'F = N - (E + 1);
    let exp : bits('E) = Ones(E - 1) @ 0b0;
    let frac : bits('F) = Ones(F);
    return((sign @ exp) @ frac)
}

val AArch32_GeneralExceptionsToAArch64 : unit -> bool

function AArch32_GeneralExceptionsToAArch64 () = {
    return(PSTATE.EL == EL0 & not_bool(ELUsingAArch32(EL1)) | (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & HCR_EL2[TGE] == 0b1)
}

val AArch32_TakeUndefInstrException : unit -> unit

val AArch32_TakeUndefInstrException__1 : ExceptionRecord -> unit

function AArch32_TakeUndefInstrException () = {
    let except : ExceptionRecord = ExceptionSyndrome(Exception_Uncategorized);
    AArch32_TakeUndefInstrException__1(except)
}

function AArch32_TakeUndefInstrException__1 except = {
    let route_to_hyp : bool = (PSTATE.EL == EL0 & EL2Enabled()) & HCR_read()[TGE] == 0b1;
    let preferred_exception_return : bits(32) = ThisInstrAddr(32);
    let 'vect_offset = UInt(0x04);
    let 'lr_offset = if CurrentInstrSet() == InstrSet_A32 then 4 else 2;
    if PSTATE.EL == EL2 then {
        AArch32_EnterHypMode(except, preferred_exception_return, vect_offset)
    } else if route_to_hyp then {
        AArch32_EnterHypMode(except, preferred_exception_return, UInt(0x14))
    } else {
        AArch32_EnterMode(M32_Undef, preferred_exception_return, lr_offset, vect_offset)
    }
}

val AArch64_FPTrappedException : forall ('is_ase : Bool).
  (bool('is_ase), bits(8)) -> unit

function AArch64_FPTrappedException (is_ase, accumulated_exceptions) = {
    except : ExceptionRecord = ExceptionSyndrome(Exception_FPTrappedException);
    if is_ase then {
        if __IMPDEF_boolean("vector instructions set TFV to 1") then {
            except.syndrome[23] = Bit(0b1)
        } else {
            except.syndrome[23] = Bit(0b0)
        }
    } else {
        except.syndrome[23] = Bit(0b1)
    };
    except.syndrome[10 .. 8] = __UNKNOWN_bits(3);
    if [except.syndrome[23]] == 0b1 then {
        (except.syndrome[7 .. 7] @ except.syndrome[4 .. 0]) = [accumulated_exceptions[7]] @ accumulated_exceptions[4 .. 0]
    } else {
        (except.syndrome[7 .. 7] @ except.syndrome[4 .. 0]) = __UNKNOWN_bits(6)
    };
    let route_to_el2 : bool = EL2Enabled() & HCR_EL2[TGE] == 0b1;
    let preferred_exception_return : bits(64) = ThisInstrAddr(64);
    let 'vect_offset = UInt(0x0);
    sail_take_exception(None());
    if UInt(PSTATE.EL) > UInt(EL1) then {
        AArch64_TakeException(PSTATE.EL, except, preferred_exception_return, vect_offset)
    } else if route_to_el2 then {
        AArch64_TakeException(EL2, except, preferred_exception_return, vect_offset)
    } else {
        AArch64_TakeException(EL1, except, preferred_exception_return, vect_offset)
    }
}

bitfield FPEXC32_EL2_Type : bits(64) =
  {
    EX : 31..31,
    EN : 30..30,
    DEX : 29..29,
    FP2V : 28..28,
    VV : 27..27,
    TFV : 26..26,
    VECITR : 10..8,
    IDF : 7..7,
    IXF : 4..4,
    UFF : 3..3,
    OFF : 2..2,
    DZF : 1..1,
    IOF : 0..0
  }

register FPEXC32_EL2 : FPEXC32_EL2_Type

bitfield FPEXC_Type : bits(32) =
  {
    EX : 31..31,
    EN : 30..30,
    DEX : 29..29,
    FP2V : 28..28,
    VV : 27..27,
    TFV : 26..26,
    VECITR : 10..8,
    IDF : 7..7,
    IXF : 4..4,
    UFF : 3..3,
    OFF : 2..2,
    DZF : 1..1,
    IOF : 0..0
  }

register _FPEXC : FPEXC_Type

val FPEXC_read : unit -> FPEXC_Type

function FPEXC_read () = {
    r : FPEXC_Type = _FPEXC;
    r.bits[31 .. 0] = Slice(FPEXC32_EL2.bits, 0, 32);
    return(r)
}

val FPEXC_write : FPEXC_Type -> unit

function FPEXC_write value_name = {
    let r : FPEXC_Type = value_name;
    FPEXC32_EL2.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _FPEXC = r;
    return()
}

val AArch32_FPTrappedException : bits(8) -> unit

function AArch32_FPTrappedException accumulated_exceptions = {
    element : int = undefined;
    is_ase : bool = undefined;
    if AArch32_GeneralExceptionsToAArch64() then {
        let is_ase : bool = false;
        element = 0;
        AArch64_FPTrappedException(is_ase, accumulated_exceptions)
    };
    FPEXC_write() = [FPEXC_read() with DEX = 0b1];
    FPEXC_write() = [FPEXC_read() with TFV = 0b1];
    FPEXC_write() = Mk_FPEXC_Type([FPEXC_read().bits with 7 .. 7 = Slice([accumulated_exceptions[7]] @ accumulated_exceptions[4 .. 0], 5, 1)]);
    FPEXC_write() = Mk_FPEXC_Type([FPEXC_read().bits with 4 .. 0 = Slice([accumulated_exceptions[7]] @ accumulated_exceptions[4 .. 0], 0, 5)]);
    FPEXC_write() = Mk_FPEXC_Type([FPEXC_read().bits with 10 .. 8 = 0b111]);
    AArch32_TakeUndefInstrException()
}

val FPSCR_write : FPSCR_Type -> unit

function FPSCR_write value_name = {
    let r : FPSCR_Type = value_name;
    FPSR.bits[31 .. 27] = Slice(r.bits, 27, 5);
    FPSR.bits[7] = Bit(Slice(r.bits, 7, 1));
    FPSR.bits[4 .. 0] = Slice(r.bits, 0, 5);
    FPCR.bits[26 .. 15] = Slice(r.bits, 15, 12);
    FPCR.bits[12 .. 8] = Slice(r.bits, 8, 5);
    return()
}

val HaveSMEFullA64 : unit -> bool

function HaveSMEFullA64 () = {
    return(IsFeatureImplemented(FEAT_SME_FA64))
}

val IsFullA64Enabled : unit -> bool

function IsFullA64Enabled () = {
    if not_bool(HaveSMEFullA64()) then {
        return(false)
    };
    if (PSTATE.EL == EL0 | PSTATE.EL == EL1) & not_bool(IsInHost()) then {
        if SMCR_EL1[FA64] == 0b0 then {
            return(false)
        };
        ()
    };
    if (PSTATE.EL == EL0 | PSTATE.EL == EL1 | PSTATE.EL == EL2) & EL2Enabled() then {
        if SMCR_EL2[FA64] == 0b0 then {
            return(false)
        };
        ()
    };
    if HaveEL(EL3) then {
        if SMCR_EL3[FA64] == 0b0 then {
            return(false)
        };
        ()
    };
    return(true)
}

val FPProcessException : (FPExc, FPCRType) -> unit

function FPProcessException (except, fpcr) = {
    is_ase : bool = undefined;
    cumul : {0, 1, 2, 3, 4, 7} = 0;
    match except {
      FPExc_InvalidOp => {
          cumul = 0
      },
      FPExc_DivideByZero => {
          cumul = 1
      },
      FPExc_Overflow => {
          cumul = 2
      },
      FPExc_Underflow => {
          cumul = 3
      },
      FPExc_Inexact => {
          cumul = 4
      },
      FPExc_InputDenorm => {
          cumul = 7
      }
    };
    let 'cumul = cumul;
    let 'enable = cumul + 8;
    if [fpcr.bits[enable]] == 0b1 & ((not_bool(HaveSME()) | PSTATE.SM == 0b0) | IsFullA64Enabled()) then {
        accumulated_exceptions : bits(8) = GetAccumulatedFPExceptions();
        accumulated_exceptions[cumul] = Bit(0b1);
        if __IMPDEF_boolean("Support trapping of floating-point exceptions") then {
            if UsingAArch32() then {
                AArch32_FPTrappedException(accumulated_exceptions)
            } else {
                let is_ase : bool = IsASEInstruction();
                AArch64_FPTrappedException(is_ase, accumulated_exceptions)
            }
        } else {
            SetAccumulatedFPExceptions(accumulated_exceptions)
        }
    } else if UsingAArch32() then {
        FPSCR_write() = Mk_FPSCR_Type([FPSCR_read__1().bits with cumul .. cumul = 0b1])
    } else {
        FPSR.bits[cumul] = Bit(0b1)
    };
    return()
}

val FPZero : forall 'N, 'N in {16, 32, 64}. (bits(1), int('N)) -> bits('N)

function FPZero (sign, N) = {
    assert(N == 16 | N == 32 | N == 64);
    let 'E = if N == 16 then 5 else if N == 32 then 8 else 11;
    let 'F = N - (E + 1);
    let exp : bits('E) = Zeros(E);
    let frac : bits('F) = Zeros(F);
    let result : bits(1 + 'E + 'F) = (sign @ exp) @ frac;
    return(result)
}

val HaveAltFP : unit -> bool

function HaveAltFP () = {
    return(IsFeatureImplemented(FEAT_AFP))
}

val FPRoundBase__1 : forall 'N ('fpexc : Bool) ('isbfloat16 : Bool),
  'N in {16, 32, 64}.
  (real, FPCRType, FPRounding, bool('isbfloat16), bool('fpexc), int('N)) -> bits('N)

function FPRoundBase__1 (op, fpcr, rounding, isbfloat16, fpexc, N) = {
    assert(N == 16 | N == 32 | N == 64);
    assert(op != 0.0);
    assert(rounding != FPRounding_TIEAWAY);
    result : bits('N) = undefined;
    minimum_exp : int = undefined;
    F : {7, 10, 23, 52} = 7;
    E : {5, 8, 11} = 5;
    if N == 16 then {
        minimum_exp = negate(14);
        E = 5;
        F = 10
    } else if N == 32 & isbfloat16 then {
        minimum_exp = negate(126);
        E = 8;
        F = 7
    } else if N == 32 then {
        minimum_exp = negate(126);
        E = 8;
        F = 23
    } else {
        minimum_exp = negate(1022);
        E = 11;
        F = 52
    };
    let 'minimum_exp = minimum_exp;
    let 'F = F;
    let 'E = E;
    sign : bits(1) = undefined;
    mantissa : real = undefined;
    if op < 0.0 then {
        sign = 0b1;
        mantissa = neg_real(op)
    } else {
        sign = 0b0;
        mantissa = op
    };
    exponent : int = 0;
    while mantissa < 1.0 do {
        mantissa = mantissa * 2.0;
        exponent = exponent - 1
    };
    while mantissa >= 2.0 do {
        mantissa = mantissa / 2.0;
        exponent = exponent + 1
    };
    let 'exponent = exponent;
    let altfp : bool = (HaveAltFP() & not_bool(UsingAArch32())) & fpcr[AH] == 0b1;
    if (not_bool(altfp) & (fpcr[FZ] == 0b1 & N != 16 | fpcr[FZ16] == 0b1 & N == 16)) & exponent < minimum_exp then {
        if UsingAArch32() then {
            FPSCR_write() = [FPSCR_read__1() with UFC = 0b1]
        } else {
            if fpexc then {
                FPSR[UFC] = 0b1
            };
            ()
        };
        return(FPZero(sign, N))
    };
    biased_exp_unconstrained : int = exponent - minimum_exp + 1;
    int_mant_unconstrained : int = RoundDown(mantissa * 2.0 ^ F);
    let error_unconstrained : real = mantissa * 2.0 ^ F - Real(int_mant_unconstrained);
    biased_exp : int = Max(exponent - minimum_exp + 1, 0);
    if biased_exp == 0 then {
        mantissa = mantissa / 2.0 ^ (minimum_exp - exponent)
    };
    let mantissa = mantissa;
    int_mant : int = RoundDown(mantissa * 2.0 ^ F);
    error : real = mantissa * 2.0 ^ F - Real(int_mant);
    let trapped_UF : bool = fpcr[UFE] == 0b1 & (not_bool(InStreamingMode()) | IsFullA64Enabled());
    if (not_bool(altfp) & biased_exp == 0) & (error != 0.0 | trapped_UF) then {
        if fpexc then {
            FPProcessException(FPExc_Underflow, fpcr)
        };
        ()
    };
    round_up_unconstrained : bool = undefined;
    round_up : bool = undefined;
    overflow_to_inf : bool = undefined;
    if altfp then {
        match rounding {
          FPRounding_TIEEVEN => {
              round_up_unconstrained = error_unconstrained > 0.5 | error_unconstrained == 0.5 & [int_mant_unconstrained[0]] == 0b1;
              round_up = error > 0.5 | error == 0.5 & [int_mant[0]] == 0b1;
              overflow_to_inf = true
          },
          FPRounding_POSINF => {
              round_up_unconstrained = error_unconstrained != 0.0 & sign == 0b0;
              round_up = error != 0.0 & sign == 0b0;
              overflow_to_inf = sign == 0b0
          },
          FPRounding_NEGINF => {
              round_up_unconstrained = error_unconstrained != 0.0 & sign == 0b1;
              round_up = error != 0.0 & sign == 0b1;
              overflow_to_inf = sign == 0b1
          },
          FPRounding_ZERO => {
              round_up_unconstrained = false;
              round_up = false;
              overflow_to_inf = false
          },
          FPRounding_ODD => {
              round_up_unconstrained = false;
              round_up = false;
              overflow_to_inf = false
          },
          _ => ()
        };
        if round_up_unconstrained then {
            int_mant_unconstrained = int_mant_unconstrained + 1;
            if int_mant_unconstrained == pow2(F + 1) then {
                biased_exp_unconstrained = biased_exp_unconstrained + 1;
                int_mant_unconstrained = DIV(int_mant_unconstrained, 2)
            };
            ()
        };
        let 'int_mant_unconstrained = int_mant_unconstrained;
        let 'biased_exp_unconstrained = biased_exp_unconstrained;
        if biased_exp_unconstrained < 1 & int_mant_unconstrained != 0 then {
            if fpcr[FZ] == 0b1 & N != 16 | fpcr[FZ16] == 0b1 & N == 16 then {
                if fpexc then {
                    FPSR[UFC] = 0b1;
                    FPProcessException(FPExc_Inexact, fpcr)
                };
                return(FPZero(sign, N))
            } else if error != 0.0 | trapped_UF then {
                if fpexc then {
                    FPProcessException(FPExc_Underflow, fpcr)
                };
                ()
            } else ()
        };
        ()
    } else {
        match rounding {
          FPRounding_TIEEVEN => {
              round_up = error > 0.5 | error == 0.5 & [int_mant[0]] == 0b1;
              overflow_to_inf = true
          },
          FPRounding_POSINF => {
              round_up = error != 0.0 & sign == 0b0;
              overflow_to_inf = sign == 0b0
          },
          FPRounding_NEGINF => {
              round_up = error != 0.0 & sign == 0b1;
              overflow_to_inf = sign == 0b1
          },
          FPRounding_ZERO => {
              round_up = false;
              overflow_to_inf = false
          },
          FPRounding_ODD => {
              round_up = false;
              overflow_to_inf = false
          },
          _ => ()
        }
    };
    if round_up then {
        int_mant = int_mant + 1;
        if int_mant == pow2(F) then {
            biased_exp = 1
        };
        if int_mant == pow2(F + 1) then {
            biased_exp = biased_exp + 1;
            int_mant = DIV(int_mant, 2)
        };
        ()
    };
    let 'biased_exp = biased_exp;
    if error != 0.0 & rounding == FPRounding_ODD then {
        int_mant = [int_mant with 0 .. 0 = 0b1]
    };
    let 'int_mant = int_mant;
    if N != 16 | fpcr[AHP] == 0b0 then {
        if biased_exp >= pow2(E) - 1 then {
            result = if overflow_to_inf then FPInfinity(sign, N) else
              FPMaxNormal(sign, N);
            if fpexc then {
                FPProcessException(FPExc_Overflow, fpcr)
            };
            error = 1.0
        } else {
            assert(constraint('N - ('E + 'F + 1) >= 0));
            result = ((sign @ biased_exp[E - 1 .. 0]) @ int_mant[F - 1 .. 0]) @ Zeros(N - (E + F + 1))
        }
    } else {
        if biased_exp >= pow2(E) then {
            result = sign @ Ones(N - 1);
            if fpexc then {
                FPProcessException(FPExc_InvalidOp, fpcr)
            };
            error = 0.0
        } else {
            assert(constraint('N - ('E + 'F + 1) >= 0));
            result = ((sign @ biased_exp[E - 1 .. 0]) @ int_mant[F - 1 .. 0]) @ Zeros(N - (E + F + 1))
        }
    };
    if error != 0.0 then {
        if fpexc then {
            FPProcessException(FPExc_Inexact, fpcr)
        };
        ()
    };
    return(result)
}

val FPDecodeRounding : bits(2) -> FPRounding

function FPDecodeRounding rmode = {
    match rmode {
      0b00 => {
          return(FPRounding_TIEEVEN)
      },
      0b01 => {
          return(FPRounding_POSINF)
      },
      0b10 => {
          return(FPRounding_NEGINF)
      },
      0b11 => {
          return(FPRounding_ZERO)
      },
      _ => {
          return(undefined : FPRounding)
      }
    }
}

val FPRoundingMode : FPCRType -> FPRounding

function FPRoundingMode fpcr = {
    return(FPDecodeRounding(fpcr[RMode]))
}

val FPRound : forall 'N, 'N in {16, 32, 64}.
  (real, FPCRType, int('N)) -> bits('N)

val FPRound__1 : forall 'N, 'N in {16, 32, 64}.
  (real, FPCRType, FPRounding, int('N)) -> bits('N)

val FPRound__2 : forall 'N ('fpexc : Bool),
  'N in {16, 32, 64}.
  (real, FPCRType, FPRounding, bool('fpexc), int('N)) -> bits('N)

function FPRound (op, fpcr, N) = {
    return(FPRound__1(op, fpcr, FPRoundingMode(fpcr), N))
}

function FPRound__1 (op, fpcr_in, rounding, N) = {
    let fpexc : bool = true;
    return(FPRound__2(op, fpcr_in, rounding, fpexc, N))
}

function FPRound__2 (op, fpcr_in, rounding, fpexc, N) = {
    fpcr : FPCRType = fpcr_in;
    fpcr[AHP] = 0b0;
    let isbfloat16 : bool = false;
    return(FPRoundBase__1(op, fpcr, rounding, isbfloat16, fpexc, N))
}

val FixedToFP : forall 'M 'N 'fbits ('is_unsigned : Bool),
  ('N in {16, 32, 64} & 'M in {16, 32, 64}).
  (bits('M), int('fbits), bool('is_unsigned), FPCRType, FPRounding, int('N)) -> bits('N)

function FixedToFP (op, fbits, is_unsigned, fpcr, rounding, N) = {
    assert(N == 16 | N == 32 | N == 64);
    assert('M == 16 | 'M == 32 | 'M == 64);
    result : bits('N) = undefined;
    assert(fbits >= 0);
    assert(rounding != FPRounding_ODD);
    let 'int_operand = asl_Int(op, is_unsigned);
    let real_operand : real = Real(int_operand) / 2.0 ^ fbits;
    if real_operand == 0.0 then {
        result = FPZero(0b0, N)
    } else {
        result = FPRound__1(real_operand, fpcr, rounding, N)
    };
    return(result)
}

val FPUnpackBase : forall 'N ('fpexc : Bool),
  'N in {16, 32, 64}.
  (bits('N), FPCRType, bool('fpexc)) -> (FPType, bits(1), real)

val FPUnpackBase__1 : forall 'N ('fpexc : Bool) ('isbfloat16 : Bool),
  'N in {16, 32, 64}.
  (bits('N), FPCRType, bool('fpexc), bool('isbfloat16)) -> (FPType, bits(1), real)

function FPUnpackBase (fpval, fpcr, fpexc) = {
    fp_type : FPType = undefined;
    sign : bits(1) = undefined;
    value_name : real = undefined;
    let isbfloat16 : bool = false;
    (fp_type, sign, value_name) = FPUnpackBase__1(fpval, fpcr, fpexc, isbfloat16);
    return((fp_type, sign, value_name))
}

function FPUnpackBase__1 (fpval, fpcr_in, fpexc, isbfloat16) = {
    exp16 : bits(5) = undefined;
    exp64 : bits(11) = undefined;
    frac16 : bits(10) = undefined;
    frac64 : bits(52) = undefined;
    assert('N == 16 | 'N == 32 | 'N == 64);
    let fpcr : FPCRType = fpcr_in;
    let altfp : bool = HaveAltFP() & not_bool(UsingAArch32());
    let fiz : bool = altfp & fpcr[FIZ] == 0b1;
    let fz : bool = fpcr[FZ] == 0b1 & not_bool(altfp & fpcr[AH] == 0b1);
    value_name : real = undefined;
    sign : bits(1) = undefined;
    fptype : FPType = undefined;
    if 'N == 16 & not_bool(isbfloat16) then {
        sign = [fpval[15]];
        let exp16 : bits(5) = fpval[14 .. 10];
        let frac16 : bits(10) = fpval[9 .. 0];
        if IsZero(exp16) then {
            if IsZero(frac16) | fpcr[FZ16] == 0b1 then {
                fptype = FPType_Zero;
                value_name = 0.0
            } else {
                fptype = FPType_Denormal;
                value_name = 2.0 ^ negate(14) * (Real(UInt(frac16)) * 2.0 ^ negate(10))
            }
        } else if IsOnes(exp16) & fpcr[AHP] == 0b0 then {
            if IsZero(frac16) then {
                fptype = FPType_Infinity;
                value_name = 2.0 ^ 1000000
            } else {
                fptype = if [frac16[9]] == 0b1 then FPType_QNaN else FPType_SNaN;
                value_name = 0.0
            }
        } else {
            fptype = FPType_Nonzero;
            value_name = 2.0 ^ (UInt(exp16) - 15) * (1.0 + Real(UInt(frac16)) * 2.0 ^ negate(10))
        }
    } else if 'N == 32 | isbfloat16 then {
        exp32 : bits(8) = undefined;
        frac32 : bits(23) = undefined;
        if isbfloat16 then {
            sign = [fpval[15]];
            exp32 = fpval[14 .. 7];
            frac32 = fpval[6 .. 0] @ Zeros(16)
        } else {
            sign = [fpval[31]];
            exp32 = fpval[30 .. 23];
            frac32 = fpval[22 .. 0]
        };
        if IsZero(exp32) then {
            if IsZero(frac32) then {
                fptype = FPType_Zero;
                value_name = 0.0
            } else if fz | fiz then {
                fptype = FPType_Zero;
                value_name = 0.0;
                if fz then {
                    if fpexc then {
                        FPProcessException(FPExc_InputDenorm, fpcr)
                    };
                    ()
                };
                ()
            } else {
                fptype = FPType_Denormal;
                value_name = 2.0 ^ negate(126) * (Real(UInt(frac32)) * 2.0 ^ negate(23))
            }
        } else if IsOnes(exp32) then {
            if IsZero(frac32) then {
                fptype = FPType_Infinity;
                value_name = 2.0 ^ 1000000
            } else {
                fptype = if [frac32[22]] == 0b1 then FPType_QNaN else
                  FPType_SNaN;
                value_name = 0.0
            }
        } else {
            fptype = FPType_Nonzero;
            value_name = 2.0 ^ (UInt(exp32) - 127) * (1.0 + Real(UInt(frac32)) * 2.0 ^ negate(23))
        }
    } else {
        sign = [fpval[63]];
        let exp64 : bits(11) = fpval[62 .. 52];
        let frac64 : bits(52) = fpval[51 .. 0];
        if IsZero(exp64) then {
            if IsZero(frac64) then {
                fptype = FPType_Zero;
                value_name = 0.0
            } else if fz | fiz then {
                fptype = FPType_Zero;
                value_name = 0.0;
                if fz then {
                    if fpexc then {
                        FPProcessException(FPExc_InputDenorm, fpcr)
                    };
                    ()
                };
                ()
            } else {
                fptype = FPType_Denormal;
                value_name = 2.0 ^ negate(1022) * (Real(UInt(frac64)) * 2.0 ^ negate(52))
            }
        } else if IsOnes(exp64) then {
            if IsZero(frac64) then {
                fptype = FPType_Infinity;
                value_name = 2.0 ^ 1000000
            } else {
                fptype = if [frac64[51]] == 0b1 then FPType_QNaN else
                  FPType_SNaN;
                value_name = 0.0
            }
        } else {
            fptype = FPType_Nonzero;
            value_name = 2.0 ^ (UInt(exp64) - 1023) * (1.0 + Real(UInt(frac64)) * 2.0 ^ negate(52))
        }
    };
    if sign == 0b1 then {
        value_name = neg_real(value_name)
    };
    let value_name = value_name;
    return((fptype, sign, value_name))
}

val FPUnpack : forall 'N, 'N in {16, 32, 64}.
  (bits('N), FPCRType) -> (FPType, bits(1), real)

val FPUnpack__1 : forall 'N ('fpexc : Bool),
  'N in {16, 32, 64}.
  (bits('N), FPCRType, bool('fpexc)) -> (FPType, bits(1), real)

function FPUnpack (fpval, fpcr_in) = {
    fp_type : FPType = undefined;
    sign : bits(1) = undefined;
    value_name : real = undefined;
    fpcr : FPCRType = fpcr_in;
    fpcr[AHP] = 0b0;
    let fpexc : bool = true;
    (fp_type, sign, value_name) = FPUnpackBase(fpval, fpcr, fpexc);
    return((fp_type, sign, value_name))
}

function FPUnpack__1 (fpval, fpcr_in, fpexc) = {
    fp_type : FPType = undefined;
    sign : bits(1) = undefined;
    value_name : real = undefined;
    fpcr : FPCRType = fpcr_in;
    fpcr[AHP] = 0b0;
    (fp_type, sign, value_name) = FPUnpackBase(fpval, fpcr, fpexc);
    return((fp_type, sign, value_name))
}

val FPAbs : forall 'N, 'N in {16, 32, 64}. bits('N) -> bits('N)

function FPAbs op = {
    fptype : FPType = undefined;
    assert('N == 16 | 'N == 32 | 'N == 64);
    if not_bool(UsingAArch32()) & HaveAltFP() then {
        let fpcr : FPCRType = FPCR_read();
        if fpcr[AH] == 0b1 then {
            let (__tup_0 : FPType, _, _) = FPUnpack__1(op, fpcr, false) in
              {
                  fptype = __tup_0
              };
            if fptype == FPType_SNaN | fptype == FPType_QNaN then {
                return(op)
            };
            ()
        };
        ()
    };
    return(0b0 @ op['N - 2 .. 0])
}

val FPDefaultNaN : forall 'N, 'N in {16, 32, 64}. int('N) -> bits('N)

val FPDefaultNaN__1 : forall 'N, 'N in {16, 32, 64}.
  (FPCRType, int('N)) -> bits('N)

function FPDefaultNaN N = {
    let fpcr : FPCRType = FPCR_read();
    return(FPDefaultNaN__1(fpcr, N))
}

function FPDefaultNaN__1 (fpcr, N) = {
    assert(N == 16 | N == 32 | N == 64);
    let 'E = if N == 16 then 5 else if N == 32 then 8 else 11;
    let 'F = N - (E + 1);
    let sign : bits(1) = if HaveAltFP() & not_bool(UsingAArch32()) then fpcr[AH]
    else
      0b0;
    let exp : bits('E) = Ones(E);
    let frac : bits('F) = 0b1 @ Zeros(F - 1);
    return((sign @ exp) @ frac)
}

val FPProcessDenorms : forall 'N. (FPType, FPType, int('N), FPCRType) -> unit

function FPProcessDenorms (type1, type2, N, fpcr) = {
    let altfp : bool = (HaveAltFP() & not_bool(UsingAArch32())) & fpcr[AH] == 0b1;
    if (altfp & N != 16) & (type1 == FPType_Denormal | type2 == FPType_Denormal) then {
        FPProcessException(FPExc_InputDenorm, fpcr)
    };
    ()
}

val FPProcessNaN : forall 'N, 'N in {16, 32, 64}.
  (FPType, bits('N), FPCRType) -> bits('N)

val FPProcessNaN__1 : forall 'N ('fpexc : Bool),
  'N in {16, 32, 64}.
  (FPType, bits('N), FPCRType, bool('fpexc)) -> bits('N)

function FPProcessNaN (fptype, op, fpcr) = {
    let fpexc : bool = true;
    return(FPProcessNaN__1(fptype, op, fpcr, fpexc))
}

function FPProcessNaN__1 (fptype, op, fpcr, fpexc) = {
    assert('N == 16 | 'N == 32 | 'N == 64);
    assert(fptype == FPType_QNaN | fptype == FPType_SNaN);
    topfrac : {9, 22, 51} = 9;
    match 'N {
      16 => {
          topfrac = 9
      },
      32 => {
          topfrac = 22
      },
      64 => {
          topfrac = 51
      },
      _ => ()
    };
    let 'topfrac = topfrac;
    result : bits('N) = op;
    if fptype == FPType_SNaN then {
        assert(constraint((0 <= 'topfrac & 'topfrac < 'N)));
        result[topfrac] = Bit(0b1);
        if fpexc then {
            FPProcessException(FPExc_InvalidOp, fpcr)
        };
        ()
    };
    if fpcr[DN] == 0b1 then {
        result = FPDefaultNaN__1(fpcr, 'N)
    };
    return(result)
}

val FPProcessNaNs : forall 'N, 'N in {16, 32, 64}.
  (FPType, FPType, bits('N), bits('N), FPCRType) -> (bool, bits('N))

val FPProcessNaNs__1 : forall 'N ('fpexc : Bool),
  'N in {16, 32, 64}.
  (FPType, FPType, bits('N), bits('N), FPCRType, bool('fpexc)) -> (bool, bits('N))

function FPProcessNaNs (type1, type2, op1, op2, fpcr) = {
    let fpexc : bool = true;
    return(FPProcessNaNs__1(type1, type2, op1, op2, fpcr, fpexc))
}

function FPProcessNaNs__1 (type1, type2, op1, op2, fpcr, fpexc) = {
    assert('N == 16 | 'N == 32 | 'N == 64);
    done : bool = undefined;
    result : bits('N) = undefined;
    let altfp : bool = (HaveAltFP() & not_bool(UsingAArch32())) & fpcr[AH] == 0b1;
    let op1_nan : bool = type1 == FPType_SNaN | type1 == FPType_QNaN;
    let op2_nan : bool = type2 == FPType_SNaN | type2 == FPType_QNaN;
    let any_snan : bool = type1 == FPType_SNaN | type2 == FPType_SNaN;
    let type_nan : FPType = if any_snan then FPType_SNaN else FPType_QNaN;
    if (altfp & op1_nan) & op2_nan then {
        done = true;
        result = FPProcessNaN__1(type_nan, op1, fpcr, fpexc)
    } else if type1 == FPType_SNaN then {
        done = true;
        result = FPProcessNaN__1(type1, op1, fpcr, fpexc)
    } else if type2 == FPType_SNaN then {
        done = true;
        result = FPProcessNaN__1(type2, op2, fpcr, fpexc)
    } else if type1 == FPType_QNaN then {
        done = true;
        result = FPProcessNaN__1(type1, op1, fpcr, fpexc)
    } else if type2 == FPType_QNaN then {
        done = true;
        result = FPProcessNaN__1(type2, op2, fpcr, fpexc)
    } else {
        done = false;
        result = Zeros('N)
    };
    return((done, result))
}

val FPAdd : forall 'N, 'N in {16, 32, 64}.
  (bits('N), bits('N), FPCRType) -> bits('N)

val FPAdd__1 : forall 'N ('fpexc : Bool),
  'N in {16, 32, 64}.
  (bits('N), bits('N), FPCRType, bool('fpexc)) -> bits('N)

function FPAdd (op1, op2, fpcr) = {
    let fpexc : bool = true;
    return(FPAdd__1(op1, op2, fpcr, fpexc))
}

function FPAdd__1 (op1, op2, fpcr, fpexc) = {
    done : bool = undefined;
    inf1 : bool = undefined;
    inf2 : bool = undefined;
    result : bits('N) = undefined;
    result_sign : bits(1) = undefined;
    result_value : real = undefined;
    sign1 : bits(1) = undefined;
    sign2 : bits(1) = undefined;
    type1 : FPType = undefined;
    type2 : FPType = undefined;
    value1_name : real = undefined;
    value2_name : real = undefined;
    zero1 : bool = undefined;
    zero2 : bool = undefined;
    assert('N == 16 | 'N == 32 | 'N == 64);
    let rounding : FPRounding = FPRoundingMode(fpcr);
    (type1, sign1, value1_name) = FPUnpack__1(op1, fpcr, fpexc);
    (type2, sign2, value2_name) = FPUnpack__1(op2, fpcr, fpexc);
    (done, result) = FPProcessNaNs__1(type1, type2, op1, op2, fpcr, fpexc);
    if not_bool(done) then {
        let inf1 : bool = type1 == FPType_Infinity;
        let inf2 : bool = type2 == FPType_Infinity;
        let zero1 : bool = type1 == FPType_Zero;
        let zero2 : bool = type2 == FPType_Zero;
        if (inf1 & inf2) & sign1 == not_vec(sign2) then {
            result = FPDefaultNaN__1(fpcr, 'N);
            if fpexc then {
                FPProcessException(FPExc_InvalidOp, fpcr)
            };
            ()
        } else if inf1 & sign1 == 0b0 | inf2 & sign2 == 0b0 then {
            result = FPInfinity(0b0, 'N)
        } else if inf1 & sign1 == 0b1 | inf2 & sign2 == 0b1 then {
            result = FPInfinity(0b1, 'N)
        } else if (zero1 & zero2) & sign1 == sign2 then {
            result = FPZero(sign1, 'N)
        } else {
            let result_value : real = value1_name + value2_name;
            if result_value == 0.0 then {
                let result_sign : bits(1) = if rounding == FPRounding_NEGINF then
                  0b1
                else
                  0b0;
                result = FPZero(result_sign, 'N)
            } else {
                result = FPRound__2(result_value, fpcr, rounding, fpexc, 'N)
            }
        };
        if fpexc then {
            FPProcessDenorms(type1, type2, 'N, fpcr)
        };
        ()
    };
    return(result)
}

val FPAdd_ZA : forall 'N, 'N in {16, 32, 64}.
  (bits('N), bits('N), FPCRType) -> bits('N)

function FPAdd_ZA (op1, op2, fpcr_in) = {
    fpcr : FPCRType = fpcr_in;
    let fpexc : bool = false;
    fpcr[DN] = 0b1;
    return(FPAdd__1(op1, op2, fpcr, fpexc))
}

val FPCompare : forall 'N ('signal_nans : Bool),
  'N in {16, 32, 64}.
  (bits('N), bits('N), bool('signal_nans), FPCRType) -> bits(4)

function FPCompare (op1, op2, signal_nans, fpcr) = {
    sign1 : bits(1) = undefined;
    sign2 : bits(1) = undefined;
    type1 : FPType = undefined;
    type2 : FPType = undefined;
    value1_name : real = undefined;
    value2_name : real = undefined;
    assert('N == 16 | 'N == 32 | 'N == 64);
    (type1, sign1, value1_name) = FPUnpack(op1, fpcr);
    (type2, sign2, value2_name) = FPUnpack(op2, fpcr);
    result : bits(4) = undefined;
    if (type1 == FPType_SNaN | type1 == FPType_QNaN) | type2 == FPType_SNaN | type2 == FPType_QNaN then {
        result = 0b0011;
        if (type1 == FPType_SNaN | type2 == FPType_SNaN) | signal_nans then {
            FPProcessException(FPExc_InvalidOp, fpcr)
        };
        ()
    } else {
        if value1_name == value2_name then {
            result = 0b0110
        } else if value1_name < value2_name then {
            result = 0b1000
        } else {
            result = 0b0010
        };
        FPProcessDenorms(type1, type2, 'N, fpcr)
    };
    return(result)
}

val FPCompareEQ : forall 'N, 'N in {16, 32, 64}.
  (bits('N), bits('N), FPCRType) -> bool

function FPCompareEQ (op1, op2, fpcr) = {
    sign1 : bits(1) = undefined;
    sign2 : bits(1) = undefined;
    type1 : FPType = undefined;
    type2 : FPType = undefined;
    value1_name : real = undefined;
    value2_name : real = undefined;
    assert('N == 16 | 'N == 32 | 'N == 64);
    (type1, sign1, value1_name) = FPUnpack(op1, fpcr);
    (type2, sign2, value2_name) = FPUnpack(op2, fpcr);
    result : bool = undefined;
    if (type1 == FPType_SNaN | type1 == FPType_QNaN) | type2 == FPType_SNaN | type2 == FPType_QNaN then {
        result = false;
        if type1 == FPType_SNaN | type2 == FPType_SNaN then {
            FPProcessException(FPExc_InvalidOp, fpcr)
        };
        ()
    } else {
        result = value1_name == value2_name;
        FPProcessDenorms(type1, type2, 'N, fpcr)
    };
    return(result)
}

val FPCompareGE : forall 'N, 'N in {16, 32, 64}.
  (bits('N), bits('N), FPCRType) -> bool

function FPCompareGE (op1, op2, fpcr) = {
    sign1 : bits(1) = undefined;
    sign2 : bits(1) = undefined;
    type1 : FPType = undefined;
    type2 : FPType = undefined;
    value1_name : real = undefined;
    value2_name : real = undefined;
    assert('N == 16 | 'N == 32 | 'N == 64);
    (type1, sign1, value1_name) = FPUnpack(op1, fpcr);
    (type2, sign2, value2_name) = FPUnpack(op2, fpcr);
    result : bool = undefined;
    if (type1 == FPType_SNaN | type1 == FPType_QNaN) | type2 == FPType_SNaN | type2 == FPType_QNaN then {
        result = false;
        FPProcessException(FPExc_InvalidOp, fpcr)
    } else {
        result = value1_name >= value2_name;
        FPProcessDenorms(type1, type2, 'N, fpcr)
    };
    return(result)
}

val FPCompareGT : forall 'N, 'N in {16, 32, 64}.
  (bits('N), bits('N), FPCRType) -> bool

function FPCompareGT (op1, op2, fpcr) = {
    sign1 : bits(1) = undefined;
    sign2 : bits(1) = undefined;
    type1 : FPType = undefined;
    type2 : FPType = undefined;
    value1_name : real = undefined;
    value2_name : real = undefined;
    assert('N == 16 | 'N == 32 | 'N == 64);
    (type1, sign1, value1_name) = FPUnpack(op1, fpcr);
    (type2, sign2, value2_name) = FPUnpack(op2, fpcr);
    result : bool = undefined;
    if (type1 == FPType_SNaN | type1 == FPType_QNaN) | type2 == FPType_SNaN | type2 == FPType_QNaN then {
        result = false;
        FPProcessException(FPExc_InvalidOp, fpcr)
    } else {
        result = value1_name > value2_name;
        FPProcessDenorms(type1, type2, 'N, fpcr)
    };
    return(result)
}

val FPConvertNaN : forall 'M 'N,
  ('N in {16, 32, 64} & 'M in {16, 32, 64}).
  (bits('N), int('M)) -> bits('M)

function FPConvertNaN (op, M) = {
    assert('N == 16 | 'N == 32 | 'N == 64);
    assert(M == 16 | M == 32 | M == 64);
    result : bits('M) = undefined;
    frac : bits(51) = undefined;
    let sign : bits(1) = [op['N - 1]];
    match 'N {
      64 => {
          frac = op[50 .. 0]
      },
      32 => {
          frac = op[21 .. 0] @ Zeros(29)
      },
      16 => {
          frac = op[8 .. 0] @ Zeros(42)
      },
      _ => ()
    };
    match M {
      64 => {
          result = (sign @ Ones(M - 52)) @ frac
      },
      32 => {
          result = (sign @ Ones(M - 23)) @ frac[50 .. 29]
      },
      16 => {
          result = (sign @ Ones(M - 10)) @ frac[50 .. 42]
      },
      _ => ()
    };
    return(result)
}

val FPProcessDenorm : forall 'N. (FPType, int('N), FPCRType) -> unit

function FPProcessDenorm (fptype, N, fpcr) = {
    let altfp : bool = (HaveAltFP() & not_bool(UsingAArch32())) & fpcr[AH] == 0b1;
    if (altfp & N != 16) & fptype == FPType_Denormal then {
        FPProcessException(FPExc_InputDenorm, fpcr)
    };
    ()
}

val FPRoundCV : forall 'N, 'N in {16, 32, 64}.
  (real, FPCRType, FPRounding, int('N)) -> bits('N)

function FPRoundCV (op, fpcr_in, rounding, N) = {
    fpcr : FPCRType = fpcr_in;
    fpcr[FZ16] = 0b0;
    let fpexc : bool = true;
    let isbfloat16 : bool = false;
    return(FPRoundBase__1(op, fpcr, rounding, isbfloat16, fpexc, N))
}

val FPUnpackCV : forall 'N, 'N in {16, 32, 64}.
  (bits('N), FPCRType) -> (FPType, bits(1), real)

function FPUnpackCV (fpval, fpcr_in) = {
    fp_type : FPType = undefined;
    sign : bits(1) = undefined;
    value_name : real = undefined;
    fpcr : FPCRType = fpcr_in;
    fpcr[FZ16] = 0b0;
    let fpexc : bool = true;
    (fp_type, sign, value_name) = FPUnpackBase(fpval, fpcr, fpexc);
    return((fp_type, sign, value_name))
}

val FPConvert : forall 'M 'N,
  ('M in {16, 32, 64} & 'N in {16, 32, 64}).
  (bits('N), FPCRType, FPRounding, int('M)) -> bits('M)

val FPConvert__1 : forall 'M 'N,
  ('M in {16, 32, 64} & 'N in {16, 32, 64}).
  (bits('N), FPCRType, int('M)) -> bits('M)

function FPConvert (op, fpcr, rounding, M) = {
    fptype : FPType = undefined;
    sign : bits(1) = undefined;
    value_name : real = undefined;
    assert(M == 16 | M == 32 | M == 64);
    assert('N == 16 | 'N == 32 | 'N == 64);
    result : bits('M) = undefined;
    (fptype, sign, value_name) = FPUnpackCV(op, fpcr);
    let alt_hp : bool = M == 16 & fpcr[AHP] == 0b1;
    if fptype == FPType_SNaN | fptype == FPType_QNaN then {
        if alt_hp then {
            result = FPZero(sign, M)
        } else if fpcr[DN] == 0b1 then {
            result = FPDefaultNaN__1(fpcr, M)
        } else {
            result = FPConvertNaN(op, M)
        };
        if fptype == FPType_SNaN | alt_hp then {
            FPProcessException(FPExc_InvalidOp, fpcr)
        };
        ()
    } else if fptype == FPType_Infinity then {
        if alt_hp then {
            result = sign @ Ones(M - 1);
            FPProcessException(FPExc_InvalidOp, fpcr)
        } else {
            result = FPInfinity(sign, M)
        }
    } else if fptype == FPType_Zero then {
        result = FPZero(sign, M)
    } else {
        result = FPRoundCV(value_name, fpcr, rounding, M);
        FPProcessDenorm(fptype, 'N, fpcr)
    };
    return(result)
}

function FPConvert__1 (op, fpcr, M) = {
    return(FPConvert(op, fpcr, FPRoundingMode(fpcr), M))
}

val FPDecodeRM : bits(2) -> FPRounding

function FPDecodeRM rm = {
    result : FPRounding = undefined;
    match rm {
      0b00 => {
          result = FPRounding_TIEAWAY
      },
      0b01 => {
          result = FPRounding_TIEEVEN
      },
      0b10 => {
          result = FPRounding_POSINF
      },
      0b11 => {
          result = FPRounding_NEGINF
      }
    };
    let result = result;
    return(result)
}

val FPDiv : forall 'N, 'N in {16, 32, 64}.
  (bits('N), bits('N), FPCRType) -> bits('N)

function FPDiv (op1, op2, fpcr) = {
    done : bool = undefined;
    inf1 : bool = undefined;
    inf2 : bool = undefined;
    result : bits('N) = undefined;
    sign1 : bits(1) = undefined;
    sign2 : bits(1) = undefined;
    type1 : FPType = undefined;
    type2 : FPType = undefined;
    value1_name : real = undefined;
    value2_name : real = undefined;
    zero1 : bool = undefined;
    zero2 : bool = undefined;
    assert('N == 16 | 'N == 32 | 'N == 64);
    (type1, sign1, value1_name) = FPUnpack(op1, fpcr);
    (type2, sign2, value2_name) = FPUnpack(op2, fpcr);
    (done, result) = FPProcessNaNs(type1, type2, op1, op2, fpcr);
    if not_bool(done) then {
        let inf1 : bool = type1 == FPType_Infinity;
        let inf2 : bool = type2 == FPType_Infinity;
        let zero1 : bool = type1 == FPType_Zero;
        let zero2 : bool = type2 == FPType_Zero;
        if inf1 & inf2 | zero1 & zero2 then {
            result = FPDefaultNaN__1(fpcr, 'N);
            FPProcessException(FPExc_InvalidOp, fpcr)
        } else if inf1 | zero2 then {
            result = FPInfinity(EOR(sign1, sign2), 'N);
            if not_bool(inf1) then {
                FPProcessException(FPExc_DivideByZero, fpcr)
            };
            ()
        } else if zero1 | inf2 then {
            result = FPZero(EOR(sign1, sign2), 'N)
        } else {
            result = FPRound(value1_name / value2_name, fpcr, 'N)
        };
        if not_bool(zero2) then {
            FPProcessDenorms(type1, type2, 'N, fpcr)
        };
        ()
    };
    return(result)
}

val FPMax : forall 'N, 'N in {16, 32, 64}.
  (bits('N), bits('N), FPCRType) -> bits('N)

val FPMax__1 : forall 'N ('altfp : Bool),
  'N in {16, 32, 64}.
  (bits('N), bits('N), FPCRType, bool('altfp)) -> bits('N)

function FPMax (op1, op2, fpcr) = {
    let altfp : bool = (HaveAltFP() & not_bool(UsingAArch32())) & fpcr[AH] == 0b1;
    return(FPMax__1(op1, op2, fpcr, altfp))
}

function FPMax__1 (op1, op2, fpcr_in, altfp) = {
    rounding : FPRounding = undefined;
    sign1 : bits(1) = undefined;
    sign2 : bits(1) = undefined;
    type1 : FPType = undefined;
    type2 : FPType = undefined;
    value1_name : real = undefined;
    value2_name : real = undefined;
    assert('N == 16 | 'N == 32 | 'N == 64);
    done : bool = undefined;
    result : bits('N) = undefined;
    fpcr : FPCRType = fpcr_in;
    (type1, sign1, value1_name) = FPUnpack(op1, fpcr);
    (type2, sign2, value2_name) = FPUnpack(op2, fpcr);
    if ((altfp & type1 == FPType_Zero) & type2 == FPType_Zero) & sign1 != sign2 then {
        return(FPZero(sign2, 'N))
    } else if altfp & ((type1 == FPType_SNaN | type1 == FPType_QNaN) | type2 == FPType_SNaN | type2 == FPType_QNaN) then {
        FPProcessException(FPExc_InvalidOp, fpcr);
        return(if type2 == FPType_Zero then FPZero(sign2, 'N) else op2)
    } else ();
    (done, result) = FPProcessNaNs(type1, type2, op1, op2, fpcr);
    if not_bool(done) then {
        fptype : FPType = undefined;
        sign : bits(1) = undefined;
        value_name : real = undefined;
        if value1_name > value2_name then {
            (fptype, sign, value_name) = (type1, sign1, value1_name)
        } else {
            (fptype, sign, value_name) = (type2, sign2, value2_name)
        };
        if fptype == FPType_Infinity then {
            result = FPInfinity(sign, 'N)
        } else if fptype == FPType_Zero then {
            let sign : bits(1) = sign1 & sign2;
            result = FPZero(sign, 'N)
        } else {
            let rounding : FPRounding = FPRoundingMode(fpcr);
            if altfp then {
                fpcr[FZ] = 0b0;
                fpcr[FZ16] = 0b0
            };
            result = FPRound__2(value_name, fpcr, rounding, true, 'N)
        };
        FPProcessDenorms(type1, type2, 'N, fpcr)
    };
    return(result)
}

val FPMaxNum : forall 'N, 'N in {16, 32, 64}.
  (bits('N), bits('N), FPCRType) -> bits('N)

function FPMaxNum (op1_in, op2_in, fpcr) = {
    type1 : FPType = undefined;
    type2 : FPType = undefined;
    assert('N == 16 | 'N == 32 | 'N == 64);
    op1 : bits('N) = op1_in;
    op2 : bits('N) = op2_in;
    let (__tup_0 : FPType, _, _) = FPUnpack(op1, fpcr) in
      {
          type1 = __tup_0
      };
    let (__tup_0 : FPType, _, _) = FPUnpack(op2, fpcr) in
      {
          type2 = __tup_0
      };
    let type1_nan : bool = type1 == FPType_QNaN | type1 == FPType_SNaN;
    let type2_nan : bool = type2 == FPType_QNaN | type2 == FPType_SNaN;
    let altfp : bool = (HaveAltFP() & not_bool(UsingAArch32())) & fpcr[AH] == 0b1;
    if not_bool((altfp & type1_nan) & type2_nan) then {
        if type1 == FPType_QNaN & type2 != FPType_QNaN then {
            op1 = FPInfinity(0b1, 'N)
        } else if type1 != FPType_QNaN & type2 == FPType_QNaN then {
            op2 = FPInfinity(0b1, 'N)
        } else ()
    };
    let altfmaxfmin : bool = false;
    let result : bits('N) = FPMax__1(op1, op2, fpcr, altfmaxfmin);
    return(result)
}

val IsMerging : FPCRType -> bool

function IsMerging fpcr = {
    let nep : bits(1) = if (HaveSME() & PSTATE.SM == 0b1) & not_bool(IsFullA64Enabled()) then
      0b0
    else
      fpcr[NEP];
    return((HaveAltFP() & not_bool(UsingAArch32())) & nep == 0b1)
}

val FPMin : forall 'N, 'N in {16, 32, 64}.
  (bits('N), bits('N), FPCRType) -> bits('N)

val FPMin__1 : forall 'N ('altfp : Bool),
  'N in {16, 32, 64}.
  (bits('N), bits('N), FPCRType, bool('altfp)) -> bits('N)

function FPMin (op1, op2, fpcr) = {
    let altfp : bool = (HaveAltFP() & not_bool(UsingAArch32())) & fpcr[AH] == 0b1;
    return(FPMin__1(op1, op2, fpcr, altfp))
}

function FPMin__1 (op1, op2, fpcr_in, altfp) = {
    sign1 : bits(1) = undefined;
    sign2 : bits(1) = undefined;
    type1 : FPType = undefined;
    type2 : FPType = undefined;
    value1_name : real = undefined;
    value2_name : real = undefined;
    assert('N == 16 | 'N == 32 | 'N == 64);
    done : bool = undefined;
    result : bits('N) = undefined;
    fpcr : FPCRType = fpcr_in;
    (type1, sign1, value1_name) = FPUnpack(op1, fpcr);
    (type2, sign2, value2_name) = FPUnpack(op2, fpcr);
    if ((altfp & type1 == FPType_Zero) & type2 == FPType_Zero) & sign1 != sign2 then {
        return(FPZero(sign2, 'N))
    } else if altfp & ((type1 == FPType_SNaN | type1 == FPType_QNaN) | type2 == FPType_SNaN | type2 == FPType_QNaN) then {
        FPProcessException(FPExc_InvalidOp, fpcr);
        return(if type2 == FPType_Zero then FPZero(sign2, 'N) else op2)
    } else ();
    (done, result) = FPProcessNaNs(type1, type2, op1, op2, fpcr);
    if not_bool(done) then {
        fptype : FPType = undefined;
        sign : bits(1) = undefined;
        value_name : real = undefined;
        rounding : FPRounding = undefined;
        if value1_name < value2_name then {
            (fptype, sign, value_name) = (type1, sign1, value1_name)
        } else {
            (fptype, sign, value_name) = (type2, sign2, value2_name)
        };
        if fptype == FPType_Infinity then {
            result = FPInfinity(sign, 'N)
        } else if fptype == FPType_Zero then {
            let sign : bits(1) = sign1 | sign2;
            result = FPZero(sign, 'N)
        } else {
            let rounding : FPRounding = FPRoundingMode(fpcr);
            if altfp then {
                fpcr[FZ] = 0b0;
                fpcr[FZ16] = 0b0
            };
            result = FPRound__2(value_name, fpcr, rounding, true, 'N)
        };
        FPProcessDenorms(type1, type2, 'N, fpcr)
    };
    return(result)
}

val FPMinNum : forall 'N, 'N in {16, 32, 64}.
  (bits('N), bits('N), FPCRType) -> bits('N)

function FPMinNum (op1_in, op2_in, fpcr) = {
    type1 : FPType = undefined;
    type2 : FPType = undefined;
    assert('N == 16 | 'N == 32 | 'N == 64);
    op1 : bits('N) = op1_in;
    op2 : bits('N) = op2_in;
    let (__tup_0 : FPType, _, _) = FPUnpack(op1, fpcr) in
      {
          type1 = __tup_0
      };
    let (__tup_0 : FPType, _, _) = FPUnpack(op2, fpcr) in
      {
          type2 = __tup_0
      };
    let type1_nan : bool = type1 == FPType_QNaN | type1 == FPType_SNaN;
    let type2_nan : bool = type2 == FPType_QNaN | type2 == FPType_SNaN;
    let altfp : bool = (HaveAltFP() & not_bool(UsingAArch32())) & fpcr[AH] == 0b1;
    if not_bool((altfp & type1_nan) & type2_nan) then {
        if type1 == FPType_QNaN & type2 != FPType_QNaN then {
            op1 = FPInfinity(0b0, 'N)
        } else if type1 != FPType_QNaN & type2 == FPType_QNaN then {
            op2 = FPInfinity(0b0, 'N)
        } else ()
    };
    let altfmaxfmin : bool = false;
    let result : bits('N) = FPMin__1(op1, op2, fpcr, altfmaxfmin);
    return(result)
}

val FPMul : forall 'N, 'N in {16, 32, 64}.
  (bits('N), bits('N), FPCRType) -> bits('N)

function FPMul (op1, op2, fpcr) = {
    done : bool = undefined;
    inf1 : bool = undefined;
    inf2 : bool = undefined;
    result : bits('N) = undefined;
    sign1 : bits(1) = undefined;
    sign2 : bits(1) = undefined;
    type1 : FPType = undefined;
    type2 : FPType = undefined;
    value1_name : real = undefined;
    value2_name : real = undefined;
    zero1 : bool = undefined;
    zero2 : bool = undefined;
    assert('N == 16 | 'N == 32 | 'N == 64);
    (type1, sign1, value1_name) = FPUnpack(op1, fpcr);
    (type2, sign2, value2_name) = FPUnpack(op2, fpcr);
    (done, result) = FPProcessNaNs(type1, type2, op1, op2, fpcr);
    if not_bool(done) then {
        let inf1 : bool = type1 == FPType_Infinity;
        let inf2 : bool = type2 == FPType_Infinity;
        let zero1 : bool = type1 == FPType_Zero;
        let zero2 : bool = type2 == FPType_Zero;
        if inf1 & zero2 | zero1 & inf2 then {
            result = FPDefaultNaN__1(fpcr, 'N);
            FPProcessException(FPExc_InvalidOp, fpcr)
        } else if inf1 | inf2 then {
            result = FPInfinity(EOR(sign1, sign2), 'N)
        } else if zero1 | zero2 then {
            result = FPZero(EOR(sign1, sign2), 'N)
        } else {
            result = FPRound(value1_name * value2_name, fpcr, 'N)
        };
        FPProcessDenorms(type1, type2, 'N, fpcr)
    };
    return(result)
}

val FPProcessDenorms3 : forall 'N.
  (FPType, FPType, FPType, int('N), FPCRType) -> unit

function FPProcessDenorms3 (type1, type2, type3, N, fpcr) = {
    let altfp : bool = (HaveAltFP() & not_bool(UsingAArch32())) & fpcr[AH] == 0b1;
    if (altfp & N != 16) & ((type1 == FPType_Denormal | type2 == FPType_Denormal) | type3 == FPType_Denormal) then {
        FPProcessException(FPExc_InputDenorm, fpcr)
    };
    ()
}

val FPProcessNaNs3__1 : forall 'N ('fpexc : Bool),
  'N in {16, 32, 64}.
  (FPType, FPType, FPType, bits('N), bits('N), bits('N), FPCRType, bool('fpexc)) -> (bool, bits('N))

function FPProcessNaNs3__1 (type1, type2, type3, op1, op2, op3, fpcr, fpexc) = {
    assert('N == 16 | 'N == 32 | 'N == 64);
    result : bits('N) = undefined;
    let op1_nan : bool = type1 == FPType_SNaN | type1 == FPType_QNaN;
    let op2_nan : bool = type2 == FPType_SNaN | type2 == FPType_QNaN;
    let op3_nan : bool = type3 == FPType_SNaN | type3 == FPType_QNaN;
    let altfp : bool = (HaveAltFP() & not_bool(UsingAArch32())) & fpcr[AH] == 0b1;
    type_nan : FPType = undefined;
    if altfp then {
        if (type1 == FPType_SNaN | type2 == FPType_SNaN) | type3 == FPType_SNaN then {
            type_nan = FPType_SNaN
        } else {
            type_nan = FPType_QNaN
        }
    };
    done : bool = undefined;
    if ((altfp & op1_nan) & op2_nan) & op3_nan then {
        done = true;
        result = FPProcessNaN__1(type_nan, op2, fpcr, fpexc)
    } else if (altfp & op2_nan) & (op1_nan | op3_nan) then {
        done = true;
        result = FPProcessNaN__1(type_nan, op2, fpcr, fpexc)
    } else if (altfp & op3_nan) & op1_nan then {
        done = true;
        result = FPProcessNaN__1(type_nan, op3, fpcr, fpexc)
    } else if type1 == FPType_SNaN then {
        done = true;
        result = FPProcessNaN__1(type1, op1, fpcr, fpexc)
    } else if type2 == FPType_SNaN then {
        done = true;
        result = FPProcessNaN__1(type2, op2, fpcr, fpexc)
    } else if type3 == FPType_SNaN then {
        done = true;
        result = FPProcessNaN__1(type3, op3, fpcr, fpexc)
    } else if type1 == FPType_QNaN then {
        done = true;
        result = FPProcessNaN__1(type1, op1, fpcr, fpexc)
    } else if type2 == FPType_QNaN then {
        done = true;
        result = FPProcessNaN__1(type2, op2, fpcr, fpexc)
    } else if type3 == FPType_QNaN then {
        done = true;
        result = FPProcessNaN__1(type3, op3, fpcr, fpexc)
    } else {
        done = false;
        result = Zeros('N)
    };
    return((done, result))
}

val FPMulAdd : forall 'N, 'N in {16, 32, 64}.
  (bits('N), bits('N), bits('N), FPCRType) -> bits('N)

val FPMulAdd__1 : forall 'N ('fpexc : Bool),
  'N in {16, 32, 64}.
  (bits('N), bits('N), bits('N), FPCRType, bool('fpexc)) -> bits('N)

function FPMulAdd (addend, op1, op2, fpcr) = {
    let fpexc : bool = true;
    return(FPMulAdd__1(addend, op1, op2, fpcr, fpexc))
}

function FPMulAdd__1 (addend, op1, op2, fpcr, fpexc) = {
    done : bool = undefined;
    infA : bool = undefined;
    infP : bool = undefined;
    invalidop : bool = undefined;
    result : bits('N) = undefined;
    result_sign : bits(1) = undefined;
    result_value : real = undefined;
    sign1 : bits(1) = undefined;
    sign2 : bits(1) = undefined;
    signA : bits(1) = undefined;
    signP : bits(1) = undefined;
    type1 : FPType = undefined;
    type2 : FPType = undefined;
    typeA : FPType = undefined;
    value1_name : real = undefined;
    value2_name : real = undefined;
    valueA_name : real = undefined;
    zeroA : bool = undefined;
    zeroP : bool = undefined;
    assert('N == 16 | 'N == 32 | 'N == 64);
    (typeA, signA, valueA_name) = FPUnpack__1(addend, fpcr, fpexc);
    (type1, sign1, value1_name) = FPUnpack__1(op1, fpcr, fpexc);
    (type2, sign2, value2_name) = FPUnpack__1(op2, fpcr, fpexc);
    let rounding : FPRounding = FPRoundingMode(fpcr);
    let inf1 : bool = type1 == FPType_Infinity;
    let zero1 : bool = type1 == FPType_Zero;
    let inf2 : bool = type2 == FPType_Infinity;
    let zero2 : bool = type2 == FPType_Zero;
    (done, result) = FPProcessNaNs3__1(typeA, type1, type2, addend, op1, op2, fpcr, fpexc);
    if not_bool((HaveAltFP() & not_bool(UsingAArch32())) & fpcr[AH] == 0b1) then {
        if typeA == FPType_QNaN & (inf1 & zero2 | zero1 & inf2) then {
            result = FPDefaultNaN__1(fpcr, 'N);
            if fpexc then {
                FPProcessException(FPExc_InvalidOp, fpcr)
            };
            ()
        };
        ()
    };
    if not_bool(done) then {
        let infA : bool = typeA == FPType_Infinity;
        let zeroA : bool = typeA == FPType_Zero;
        let signP : bits(1) = EOR(sign1, sign2);
        let infP : bool = inf1 | inf2;
        let zeroP : bool = zero1 | zero2;
        let invalidop : bool = (inf1 & zero2 | zero1 & inf2) | (infA & infP) & signA != signP;
        if invalidop then {
            result = FPDefaultNaN__1(fpcr, 'N);
            if fpexc then {
                FPProcessException(FPExc_InvalidOp, fpcr)
            };
            ()
        } else if infA & signA == 0b0 | infP & signP == 0b0 then {
            result = FPInfinity(0b0, 'N)
        } else if infA & signA == 0b1 | infP & signP == 0b1 then {
            result = FPInfinity(0b1, 'N)
        } else if (zeroA & zeroP) & signA == signP then {
            result = FPZero(signA, 'N)
        } else {
            let result_value : real = valueA_name + value1_name * value2_name;
            if result_value == 0.0 then {
                let result_sign : bits(1) = if rounding == FPRounding_NEGINF then
                  0b1
                else
                  0b0;
                result = FPZero(result_sign, 'N)
            } else {
                result = FPRound__2(result_value, fpcr, rounding, fpexc, 'N)
            }
        };
        if not_bool(invalidop) & fpexc then {
            FPProcessDenorms3(typeA, type1, type2, 'N, fpcr)
        };
        ()
    };
    return(result)
}

val FPMulAdd_ZA : forall 'N, 'N in {16, 32, 64}.
  (bits('N), bits('N), bits('N), FPCRType) -> bits('N)

function FPMulAdd_ZA (addend, op1, op2, fpcr_in) = {
    fpcr : FPCRType = fpcr_in;
    let fpexc : bool = false;
    fpcr[DN] = 0b1;
    return(FPMulAdd__1(addend, op1, op2, fpcr, fpexc))
}

val FPTwo : forall 'N, 'N in {16, 32, 64}. (bits(1), int('N)) -> bits('N)

function FPTwo (sign, N) = {
    assert(N == 16 | N == 32 | N == 64);
    let 'E = if N == 16 then 5 else if N == 32 then 8 else 11;
    let 'F = N - (E + 1);
    let exp : bits(1 + ('E - 1)) = 0b1 @ Zeros(E - 1);
    let frac : bits('F) = Zeros(F);
    let result : bits(1 + (1 + ('E - 1)) + 'F) = (sign @ exp) @ frac;
    return(result)
}

val FPMulX : forall 'N, 'N in {16, 32, 64}.
  (bits('N), bits('N), FPCRType) -> bits('N)

function FPMulX (op1, op2, fpcr) = {
    inf1 : bool = undefined;
    inf2 : bool = undefined;
    sign1 : bits(1) = undefined;
    sign2 : bits(1) = undefined;
    type1 : FPType = undefined;
    type2 : FPType = undefined;
    value1_name : real = undefined;
    value2_name : real = undefined;
    zero1 : bool = undefined;
    zero2 : bool = undefined;
    assert('N == 16 | 'N == 32 | 'N == 64);
    result : bits('N) = undefined;
    done : bool = undefined;
    (type1, sign1, value1_name) = FPUnpack(op1, fpcr);
    (type2, sign2, value2_name) = FPUnpack(op2, fpcr);
    (done, result) = FPProcessNaNs(type1, type2, op1, op2, fpcr);
    if not_bool(done) then {
        let inf1 : bool = type1 == FPType_Infinity;
        let inf2 : bool = type2 == FPType_Infinity;
        let zero1 : bool = type1 == FPType_Zero;
        let zero2 : bool = type2 == FPType_Zero;
        if inf1 & zero2 | zero1 & inf2 then {
            result = FPTwo(EOR(sign1, sign2), 'N)
        } else if inf1 | inf2 then {
            result = FPInfinity(EOR(sign1, sign2), 'N)
        } else if zero1 | zero2 then {
            result = FPZero(EOR(sign1, sign2), 'N)
        } else {
            result = FPRound(value1_name * value2_name, fpcr, 'N)
        };
        FPProcessDenorms(type1, type2, 'N, fpcr)
    };
    return(result)
}

val FPProcessNaNs3H : forall 'N ('fpexc : Bool), 'N in {32, 64}.
  (FPType, FPType, FPType, bits('N), bits(div('N, 2)), bits(div('N, 2)), FPCRType, bool('fpexc)) -> (bool, bits('N))

function FPProcessNaNs3H (type1, type2, type3, op1, op2, op3, fpcr, fpexc) = {
    assert('N == 32 | 'N == 64);
    result : bits('N) = undefined;
    type_nan : FPType = undefined;
    let altfp : bool = (HaveAltFP() & not_bool(UsingAArch32())) & fpcr[AH] == 0b1;
    let op1_nan : bool = type1 == FPType_SNaN | type1 == FPType_QNaN;
    let op2_nan : bool = type2 == FPType_SNaN | type2 == FPType_QNaN;
    let op3_nan : bool = type3 == FPType_SNaN | type3 == FPType_QNaN;
    if altfp then {
        if (type1 == FPType_SNaN | type2 == FPType_SNaN) | type3 == FPType_SNaN then {
            type_nan = FPType_SNaN
        } else {
            type_nan = FPType_QNaN
        }
    };
    done : bool = undefined;
    if ((altfp & op1_nan) & op2_nan) & op3_nan then {
        done = true;
        result = FPConvertNaN(FPProcessNaN__1(type_nan, op2, fpcr, fpexc), 'N)
    } else if (altfp & op2_nan) & (op1_nan | op3_nan) then {
        done = true;
        result = FPConvertNaN(FPProcessNaN__1(type_nan, op2, fpcr, fpexc), 'N)
    } else if (altfp & op3_nan) & op1_nan then {
        done = true;
        result = FPConvertNaN(FPProcessNaN__1(type_nan, op3, fpcr, fpexc), 'N)
    } else if type1 == FPType_SNaN then {
        done = true;
        result = FPProcessNaN__1(type1, op1, fpcr, fpexc)
    } else if type2 == FPType_SNaN then {
        done = true;
        result = FPConvertNaN(FPProcessNaN__1(type2, op2, fpcr, fpexc), 'N)
    } else if type3 == FPType_SNaN then {
        done = true;
        result = FPConvertNaN(FPProcessNaN__1(type3, op3, fpcr, fpexc), 'N)
    } else if type1 == FPType_QNaN then {
        done = true;
        result = FPProcessNaN__1(type1, op1, fpcr, fpexc)
    } else if type2 == FPType_QNaN then {
        done = true;
        result = FPConvertNaN(FPProcessNaN__1(type2, op2, fpcr, fpexc), 'N)
    } else if type3 == FPType_QNaN then {
        done = true;
        result = FPConvertNaN(FPProcessNaN__1(type3, op3, fpcr, fpexc), 'N)
    } else {
        done = false;
        result = Zeros('N)
    };
    return((done, result))
}

val FPMulAddH : forall 'N, 'N == 32.
  (bits('N), bits(div('N, 2)), bits(div('N, 2)), FPCRType) -> bits('N)

val FPMulAddH__1 : forall 'N ('fpexc : Bool), 'N == 32.
  (bits('N), bits(div('N, 2)), bits(div('N, 2)), FPCRType, bool('fpexc)) -> bits('N)

function FPMulAddH (addend, op1, op2, fpcr) = {
    let fpexc : bool = true;
    return(FPMulAddH__1(addend, op1, op2, fpcr, fpexc))
}

function FPMulAddH__1 (addend, op1, op2, fpcr, fpexc) = {
    done : bool = undefined;
    infA : bool = undefined;
    infP : bool = undefined;
    invalidop : bool = undefined;
    result : bits('N) = undefined;
    result_sign : bits(1) = undefined;
    result_value : real = undefined;
    sign1 : bits(1) = undefined;
    sign2 : bits(1) = undefined;
    signA : bits(1) = undefined;
    signP : bits(1) = undefined;
    type1 : FPType = undefined;
    type2 : FPType = undefined;
    typeA : FPType = undefined;
    value1_name : real = undefined;
    value2_name : real = undefined;
    valueA_name : real = undefined;
    zeroA : bool = undefined;
    zeroP : bool = undefined;
    assert('N == 32);
    let rounding : FPRounding = FPRoundingMode(fpcr);
    (typeA, signA, valueA_name) = FPUnpack__1(addend, fpcr, fpexc);
    (type1, sign1, value1_name) = FPUnpack__1(op1, fpcr, fpexc);
    (type2, sign2, value2_name) = FPUnpack__1(op2, fpcr, fpexc);
    let inf1 : bool = type1 == FPType_Infinity;
    let zero1 : bool = type1 == FPType_Zero;
    let inf2 : bool = type2 == FPType_Infinity;
    let zero2 : bool = type2 == FPType_Zero;
    (done, result) = FPProcessNaNs3H(typeA, type1, type2, addend, op1, op2, fpcr, fpexc);
    if not_bool((HaveAltFP() & not_bool(UsingAArch32())) & fpcr[AH] == 0b1) then {
        if typeA == FPType_QNaN & (inf1 & zero2 | zero1 & inf2) then {
            result = FPDefaultNaN__1(fpcr, 'N);
            if fpexc then {
                FPProcessException(FPExc_InvalidOp, fpcr)
            };
            ()
        };
        ()
    };
    if not_bool(done) then {
        let infA : bool = typeA == FPType_Infinity;
        let zeroA : bool = typeA == FPType_Zero;
        let signP : bits(1) = EOR(sign1, sign2);
        let infP : bool = inf1 | inf2;
        let zeroP : bool = zero1 | zero2;
        let invalidop : bool = (inf1 & zero2 | zero1 & inf2) | (infA & infP) & signA != signP;
        if invalidop then {
            result = FPDefaultNaN__1(fpcr, 'N);
            if fpexc then {
                FPProcessException(FPExc_InvalidOp, fpcr)
            };
            ()
        } else if infA & signA == 0b0 | infP & signP == 0b0 then {
            result = FPInfinity(0b0, 'N)
        } else if infA & signA == 0b1 | infP & signP == 0b1 then {
            result = FPInfinity(0b1, 'N)
        } else if (zeroA & zeroP) & signA == signP then {
            result = FPZero(signA, 'N)
        } else {
            let result_value : real = valueA_name + value1_name * value2_name;
            if result_value == 0.0 then {
                let result_sign : bits(1) = if rounding == FPRounding_NEGINF then
                  0b1
                else
                  0b0;
                result = FPZero(result_sign, 'N)
            } else {
                result = FPRound__2(result_value, fpcr, rounding, fpexc, 'N)
            }
        };
        if not_bool(invalidop) & fpexc then {
            FPProcessDenorm(typeA, 'N, fpcr)
        };
        ()
    };
    return(result)
}

val FPMulAddH_ZA : forall 'N, 'N == 32.
  (bits('N), bits(div('N, 2)), bits(div('N, 2)), FPCRType) -> bits('N)

function FPMulAddH_ZA (addend, op1, op2, fpcr_in) = {
    fpcr : FPCRType = fpcr_in;
    let fpexc : bool = false;
    fpcr[DN] = 0b1;
    return(FPMulAddH__1(addend, op1, op2, fpcr, fpexc))
}

val FPNeg : forall 'N, 'N in {16, 32, 64}. bits('N) -> bits('N)

function FPNeg op = {
    fptype : FPType = undefined;
    assert('N == 16 | 'N == 32 | 'N == 64);
    if not_bool(UsingAArch32()) & HaveAltFP() then {
        let fpcr : FPCRType = FPCR_read();
        if fpcr[AH] == 0b1 then {
            let (__tup_0 : FPType, _, _) = FPUnpack__1(op, fpcr, false) in
              {
                  fptype = __tup_0
              };
            if fptype == FPType_SNaN | fptype == FPType_QNaN then {
                return(op)
            };
            ()
        };
        ()
    };
    return(not_vec([op['N - 1]]) @ op['N - 2 .. 0])
}

val FPOnePointFive : forall 'N, 'N in {16, 32, 64}.
  (bits(1), int('N)) -> bits('N)

function FPOnePointFive (sign, N) = {
    assert(N == 16 | N == 32 | N == 64);
    let 'E = if N == 16 then 5 else if N == 32 then 8 else 11;
    let 'F = N - (E + 1);
    let exp : bits(1 + ('E - 1)) = 0b0 @ Ones(E - 1);
    let frac : bits(1 + ('F - 1)) = 0b1 @ Zeros(F - 1);
    let result : bits(1 + (1 + ('E - 1)) + (1 + ('F - 1))) = (sign @ exp) @ frac;
    return(result)
}

val HaveFeatRPRES : unit -> bool

function HaveFeatRPRES () = {
    return(IsFeatureImplemented(FEAT_RPRES))
}

val FPRecipEstimate : forall 'N, 'N in {16, 32, 64}.
  (bits('N), FPCRType) -> bits('N)

function FPRecipEstimate (operand, fpcr_in) = {
    estimate : int = undefined;
    fptype : FPType = undefined;
    sign : bits(1) = undefined;
    value_name : real = undefined;
    assert('N == 16 | 'N == 32 | 'N == 64);
    fpcr : FPCRType = fpcr_in;
    result : bits('N) = undefined;
    overflow_to_inf : bool = undefined;
    let altfp : bool = (HaveAltFP() & not_bool(UsingAArch32())) & fpcr[AH] == 0b1;
    let fpexc : bool = not_bool(altfp);
    if altfp then {
        (fpcr[FIZ] @ fpcr[FZ]) = 0b11
    };
    if altfp then {
        fpcr[RMode] = 0b00
    };
    (fptype, sign, value_name) = FPUnpack__1(operand, fpcr, fpexc);
    let rounding : FPRounding = FPRoundingMode(fpcr);
    if fptype == FPType_SNaN | fptype == FPType_QNaN then {
        result = FPProcessNaN__1(fptype, operand, fpcr, fpexc)
    } else if fptype == FPType_Infinity then {
        result = FPZero(sign, 'N)
    } else if fptype == FPType_Zero then {
        result = FPInfinity(sign, 'N);
        if fpexc then {
            FPProcessException(FPExc_DivideByZero, fpcr)
        };
        ()
    } else if ('N == 16 & Abs(value_name) < 2.0 ^ negate(16) | 'N == 32 & Abs(value_name) < 2.0 ^ negate(128)) | 'N == 64 & Abs(value_name) < 2.0 ^ negate(1024) then {
        match rounding {
          FPRounding_TIEEVEN => {
              overflow_to_inf = true
          },
          FPRounding_POSINF => {
              overflow_to_inf = sign == 0b0
          },
          FPRounding_NEGINF => {
              overflow_to_inf = sign == 0b1
          },
          FPRounding_ZERO => {
              overflow_to_inf = false
          },
          _ => ()
        };
        result = if overflow_to_inf then FPInfinity(sign, 'N) else
          FPMaxNormal(sign, 'N);
        if fpexc then {
            FPProcessException(FPExc_Overflow, fpcr);
            FPProcessException(FPExc_Inexact, fpcr)
        };
        ()
    } else if (fpcr[FZ] == 0b1 & 'N != 16 | fpcr[FZ16] == 0b1 & 'N == 16) & (('N == 16 & Abs(value_name) >= 2.0 ^ 14 | 'N == 32 & Abs(value_name) >= 2.0 ^ 126) | 'N == 64 & Abs(value_name) >= 2.0 ^ 1022) then {
        result = FPZero(sign, 'N);
        if UsingAArch32() then {
            FPSCR_write() = [FPSCR_read__1() with UFC = 0b1]
        } else {
            if fpexc then {
                FPSR[UFC] = 0b1
            };
            ()
        }
    } else {
        fraction : bits(52) = undefined;
        exp : int = undefined;
        match 'N {
          16 => {
              fraction = operand[9 .. 0] @ Zeros(42);
              exp = UInt(operand[14 .. 10])
          },
          32 => {
              fraction = operand[22 .. 0] @ Zeros(29);
              exp = UInt(operand[30 .. 23])
          },
          64 => {
              fraction = operand[51 .. 0];
              exp = UInt(operand[62 .. 52])
          },
          _ => ()
        };
        if exp == 0 then {
            if [fraction[51]] == 0b0 then {
                exp = negate(1);
                fraction = fraction[49 .. 0] @ 0b00
            } else {
                fraction = fraction[50 .. 0] @ 0b0
            }
        };
        let 'exp = exp;
        scaled : range(0, 4095) = undefined;
        let increasedprecision_name : bool = ('N == 32 & HaveFeatRPRES()) & altfp;
        if not_bool(increasedprecision_name) then {
            scaled = UInt(0b1 @ fraction[51 .. 44])
        } else {
            scaled = UInt(0b1 @ fraction[51 .. 41])
        };
        let 'scaled = scaled;
        result_exp : int = undefined;
        match 'N {
          16 => {
              result_exp = 29 - exp
          },
          32 => {
              result_exp = 253 - exp
          },
          64 => {
              result_exp = 2045 - exp
          },
          _ => ()
        };
        let 'estimate = RecipEstimate(scaled, increasedprecision_name);
        if not_bool(increasedprecision_name) then {
            fraction = estimate[7 .. 0] @ Zeros(44)
        } else {
            fraction = estimate[11 .. 0] @ Zeros(40)
        };
        if result_exp == 0 then {
            fraction = 0b1 @ fraction[51 .. 1]
        } else if result_exp == negate(1) then {
            fraction = 0b01 @ fraction[51 .. 2];
            result_exp = 0
        } else ();
        let 'result_exp = result_exp;
        match 'N {
          16 => {
              result = (sign @ result_exp['N - 12 .. 0]) @ fraction[51 .. 42]
          },
          32 => {
              result = (sign @ result_exp['N - 25 .. 0]) @ fraction[51 .. 29]
          },
          64 => {
              result = (sign @ result_exp['N - 54 .. 0]) @ fraction[51 .. 0]
          },
          _ => ()
        }
    };
    return(result)
}

val FPRecpX : forall 'N, 'N in {16, 32, 64}. (bits('N), FPCRType) -> bits('N)

function FPRecpX (op, fpcr_in) = {
    fptype : FPType = undefined;
    sign : bits(1) = undefined;
    value_name : real = undefined;
    assert('N == 16 | 'N == 32 | 'N == 64);
    fpcr : FPCRType = fpcr_in;
    esize : {5, 8, 11} = 5;
    match 'N {
      16 => {
          esize = 5
      },
      32 => {
          esize = 8
      },
      64 => {
          esize = 11
      },
      _ => ()
    };
    let 'esize = esize;
    result : bits('N) = undefined;
    exp : bits('esize) = undefined;
    let frac : bits('N - ('esize + 1)) = Zeros('N - (esize + 1));
    let altfp : bool = HaveAltFP() & fpcr[AH] == 0b1;
    let fpexc : bool = not_bool(altfp);
    if altfp then {
        (fpcr[FIZ] @ fpcr[FZ]) = 0b11
    };
    (fptype, sign, value_name) = FPUnpack__1(op, fpcr, fpexc);
    match 'N {
      16 => {
          assert(constraint((10 <= 10 + 'esize - 1 & 10 + 'esize - 1 < 'N)));
          exp = op[10 + esize - 1 .. 10]
      },
      32 => {
          assert(constraint((23 <= 23 + 'esize - 1 & 23 + 'esize - 1 < 'N)));
          exp = op[23 + esize - 1 .. 23]
      },
      64 => {
          exp = op[52 + esize - 1 .. 52]
      },
      _ => ()
    };
    let max_exp : bits('esize) = Ones(esize) - 1;
    if fptype == FPType_SNaN | fptype == FPType_QNaN then {
        result = FPProcessNaN__1(fptype, op, fpcr, fpexc)
    } else {
        if IsZero(exp) then {
            result = (sign @ max_exp) @ frac
        } else {
            result = (sign @ not_vec(exp)) @ frac
        }
    };
    return(result)
}

val FPRoundInt : forall 'N ('exact : Bool),
  'N in {16, 32, 64}.
  (bits('N), FPCRType, FPRounding, bool('exact)) -> bits('N)

function FPRoundInt (op, fpcr, rounding, exact) = {
    error : real = undefined;
    fptype : FPType = undefined;
    int_result : int = undefined;
    real_result : real = undefined;
    sign : bits(1) = undefined;
    value_name : real = undefined;
    assert(rounding != FPRounding_ODD);
    assert('N == 16 | 'N == 32 | 'N == 64);
    let altfp : bool = (HaveAltFP() & not_bool(UsingAArch32())) & fpcr[AH] == 0b1;
    let fpexc : bool = not_bool(altfp);
    (fptype, sign, value_name) = FPUnpack__1(op, fpcr, fpexc);
    result : bits('N) = undefined;
    if fptype == FPType_SNaN | fptype == FPType_QNaN then {
        result = FPProcessNaN(fptype, op, fpcr)
    } else if fptype == FPType_Infinity then {
        result = FPInfinity(sign, 'N)
    } else if fptype == FPType_Zero then {
        result = FPZero(sign, 'N)
    } else {
        int_result : int = RoundDown(value_name);
        let error : real = value_name - Real(int_result);
        round_up : bool = undefined;
        match rounding {
          FPRounding_TIEEVEN => {
              round_up = error > 0.5 | error == 0.5 & [int_result[0]] == 0b1
          },
          FPRounding_POSINF => {
              round_up = error != 0.0
          },
          FPRounding_NEGINF => {
              round_up = false
          },
          FPRounding_ZERO => {
              round_up = error != 0.0 & int_result < 0
          },
          FPRounding_TIEAWAY => {
              round_up = error > 0.5 | error == 0.5 & int_result >= 0
          },
          _ => ()
        };
        if round_up then {
            int_result = int_result + 1
        };
        let 'int_result = int_result;
        let real_result : real = Real(int_result);
        if real_result == 0.0 then {
            result = FPZero(sign, 'N)
        } else {
            result = FPRound__1(real_result, fpcr, FPRounding_ZERO, 'N)
        };
        if error != 0.0 & exact then {
            FPProcessException(FPExc_Inexact, fpcr)
        };
        ()
    };
    return(result)
}

val FPRoundIntN : forall 'N 'intsize, 'N in {32, 64}.
  (bits('N), FPCRType, FPRounding, int('intsize)) -> bits('N)

function FPRoundIntN (op, fpcr, rounding, intsize) = {
    error : real = undefined;
    fptype : FPType = undefined;
    int_result : int = undefined;
    overflow : bool = undefined;
    real_result : real = undefined;
    sign : bits(1) = undefined;
    value_name : real = undefined;
    assert(rounding != FPRounding_ODD);
    assert('N == 32 | 'N == 64);
    assert(intsize == 32 | intsize == 64);
    exp : int = undefined;
    result : bits('N) = undefined;
    round_up : bool = undefined;
    let 'E = if 'N == 32 then 8 else 11;
    let 'F = 'N - (E + 1);
    let altfp : bool = (HaveAltFP() & not_bool(UsingAArch32())) & fpcr[AH] == 0b1;
    let fpexc : bool = not_bool(altfp);
    (fptype, sign, value_name) = FPUnpack__1(op, fpcr, fpexc);
    if fptype == FPType_SNaN | fptype == FPType_QNaN | fptype == FPType_Infinity then {
        if 'N == 32 then {
            let 'exp = 126 + intsize;
            result = (0b1 @ exp[E - 1 .. 0]) @ Zeros(F)
        } else {
            let 'exp = 1022 + intsize;
            result = (0b1 @ exp[E - 1 .. 0]) @ Zeros(F)
        };
        FPProcessException(FPExc_InvalidOp, fpcr)
    } else if fptype == FPType_Zero then {
        result = FPZero(sign, 'N)
    } else {
        int_result : int = RoundDown(value_name);
        error : real = value_name - Real(int_result);
        match rounding {
          FPRounding_TIEEVEN => {
              round_up = error > 0.5 | error == 0.5 & [int_result[0]] == 0b1
          },
          FPRounding_POSINF => {
              round_up = error != 0.0
          },
          FPRounding_NEGINF => {
              round_up = false
          },
          FPRounding_ZERO => {
              round_up = error != 0.0 & int_result < 0
          },
          FPRounding_TIEAWAY => {
              round_up = error > 0.5 | error == 0.5 & int_result >= 0
          },
          _ => ()
        };
        if round_up then {
            int_result = int_result + 1
        };
        let 'int_result = int_result;
        let overflow : bool = int_result > pow2(intsize - 1) - 1 | int_result < negate(1) * pow2(intsize - 1);
        if overflow then {
            if 'N == 32 then {
                let 'exp = 126 + intsize;
                result = (0b1 @ exp[E - 1 .. 0]) @ Zeros(F)
            } else {
                let 'exp = 1022 + intsize;
                result = (0b1 @ exp[E - 1 .. 0]) @ Zeros(F)
            };
            FPProcessException(FPExc_InvalidOp, fpcr);
            error = 0.0
        } else {
            let real_result : real = Real(int_result);
            if real_result == 0.0 then {
                result = FPZero(sign, 'N)
            } else {
                result = FPRound__1(real_result, fpcr, FPRounding_ZERO, 'N)
            }
        };
        if error != 0.0 then {
            FPProcessException(FPExc_Inexact, fpcr)
        };
        ()
    };
    return(result)
}

val FPRSqrtEstimate : forall 'N, 'N in {16, 32, 64}.
  (bits('N), FPCRType) -> bits('N)

function FPRSqrtEstimate (operand, fpcr_in) = {
    estimate : int = undefined;
    fptype : FPType = undefined;
    sign : bits(1) = undefined;
    value_name : real = undefined;
    assert('N == 16 | 'N == 32 | 'N == 64);
    fpcr : FPCRType = fpcr_in;
    let altfp : bool = (HaveAltFP() & not_bool(UsingAArch32())) & fpcr[AH] == 0b1;
    let fpexc : bool = not_bool(altfp);
    if altfp then {
        (fpcr[FIZ] @ fpcr[FZ]) = 0b11
    };
    (fptype, sign, value_name) = FPUnpack__1(operand, fpcr, fpexc);
    result : bits('N) = undefined;
    if fptype == FPType_SNaN | fptype == FPType_QNaN then {
        result = FPProcessNaN__1(fptype, operand, fpcr, fpexc)
    } else if fptype == FPType_Zero then {
        result = FPInfinity(sign, 'N);
        if fpexc then {
            FPProcessException(FPExc_DivideByZero, fpcr)
        };
        ()
    } else if sign == 0b1 then {
        result = FPDefaultNaN__1(fpcr, 'N);
        if fpexc then {
            FPProcessException(FPExc_InvalidOp, fpcr)
        };
        ()
    } else if fptype == FPType_Infinity then {
        result = FPZero(0b0, 'N)
    } else {
        fraction : bits(52) = undefined;
        exp : int = undefined;
        match 'N {
          16 => {
              fraction = operand[9 .. 0] @ Zeros(42);
              exp = UInt(operand[14 .. 10])
          },
          32 => {
              fraction = operand[22 .. 0] @ Zeros(29);
              exp = UInt(operand[30 .. 23])
          },
          64 => {
              fraction = operand[51 .. 0];
              exp = UInt(operand[62 .. 52])
          },
          _ => ()
        };
        if exp == 0 then {
            while [fraction[51]] == 0b0 do {
                fraction = fraction[50 .. 0] @ 0b0;
                exp = exp - 1
            };
            fraction = fraction[50 .. 0] @ 0b0
        };
        let fraction = fraction;
        let 'exp = exp;
        scaled : range(0, 4095) = undefined;
        let increasedprecision_name : bool = ('N == 32 & HaveFeatRPRES()) & altfp;
        if not_bool(increasedprecision_name) then {
            if [exp[0]] == 0b0 then {
                scaled = UInt(0b1 @ fraction[51 .. 44])
            } else {
                scaled = UInt(0b01 @ fraction[51 .. 45])
            }
        } else {
            if [exp[0]] == 0b0 then {
                scaled = UInt(0b1 @ fraction[51 .. 41])
            } else {
                scaled = UInt(0b01 @ fraction[51 .. 42])
            }
        };
        let 'scaled = scaled;
        result_exp : int = undefined;
        match 'N {
          16 => {
              result_exp = DIV(44 - exp, 2)
          },
          32 => {
              result_exp = DIV(380 - exp, 2)
          },
          64 => {
              result_exp = DIV(3068 - exp, 2)
          },
          _ => ()
        };
        let 'result_exp = result_exp;
        let 'estimate = RecipSqrtEstimate(scaled, increasedprecision_name);
        match 'N {
          16 => {
              result = ((0b0 @ result_exp['N - 12 .. 0]) @ estimate[7 .. 0]) @ Zeros(2)
          },
          32 => {
              if not_bool(increasedprecision_name) then {
                  result = ((0b0 @ result_exp['N - 25 .. 0]) @ estimate[7 .. 0]) @ Zeros(15)
              } else {
                  result = ((0b0 @ result_exp['N - 25 .. 0]) @ estimate[11 .. 0]) @ Zeros(11)
              }
          },
          64 => {
              result = ((0b0 @ result_exp['N - 54 .. 0]) @ estimate[7 .. 0]) @ Zeros(44)
          },
          _ => ()
        }
    };
    return(result)
}

val FPSqrt : forall 'N, 'N in {16, 32, 64}. (bits('N), FPCRType) -> bits('N)

function FPSqrt (op, fpcr) = {
    fptype : FPType = undefined;
    sign : bits(1) = undefined;
    value_name : real = undefined;
    assert('N == 16 | 'N == 32 | 'N == 64);
    (fptype, sign, value_name) = FPUnpack(op, fpcr);
    result : bits('N) = undefined;
    if fptype == FPType_SNaN | fptype == FPType_QNaN then {
        result = FPProcessNaN(fptype, op, fpcr)
    } else if fptype == FPType_Zero then {
        result = FPZero(sign, 'N)
    } else if fptype == FPType_Infinity & sign == 0b0 then {
        result = FPInfinity(sign, 'N)
    } else if sign == 0b1 then {
        result = FPDefaultNaN__1(fpcr, 'N);
        FPProcessException(FPExc_InvalidOp, fpcr)
    } else {
        result = FPRound(sqrt(value_name), fpcr, 'N);
        FPProcessDenorm(fptype, 'N, fpcr)
    };
    return(result)
}

val FPSub : forall 'N, 'N in {16, 32, 64}.
  (bits('N), bits('N), FPCRType) -> bits('N)

val FPSub__1 : forall 'N ('fpexc : Bool),
  'N in {16, 32, 64}.
  (bits('N), bits('N), FPCRType, bool('fpexc)) -> bits('N)

function FPSub (op1, op2, fpcr) = {
    let fpexc : bool = true;
    return(FPSub__1(op1, op2, fpcr, fpexc))
}

function FPSub__1 (op1, op2, fpcr, fpexc) = {
    done : bool = undefined;
    inf1 : bool = undefined;
    inf2 : bool = undefined;
    result : bits('N) = undefined;
    result_sign : bits(1) = undefined;
    result_value : real = undefined;
    sign1 : bits(1) = undefined;
    sign2 : bits(1) = undefined;
    type1 : FPType = undefined;
    type2 : FPType = undefined;
    value1_name : real = undefined;
    value2_name : real = undefined;
    zero1 : bool = undefined;
    zero2 : bool = undefined;
    assert('N == 16 | 'N == 32 | 'N == 64);
    let rounding : FPRounding = FPRoundingMode(fpcr);
    (type1, sign1, value1_name) = FPUnpack__1(op1, fpcr, fpexc);
    (type2, sign2, value2_name) = FPUnpack__1(op2, fpcr, fpexc);
    (done, result) = FPProcessNaNs__1(type1, type2, op1, op2, fpcr, fpexc);
    if not_bool(done) then {
        let inf1 : bool = type1 == FPType_Infinity;
        let inf2 : bool = type2 == FPType_Infinity;
        let zero1 : bool = type1 == FPType_Zero;
        let zero2 : bool = type2 == FPType_Zero;
        if (inf1 & inf2) & sign1 == sign2 then {
            result = FPDefaultNaN__1(fpcr, 'N);
            if fpexc then {
                FPProcessException(FPExc_InvalidOp, fpcr)
            };
            ()
        } else if inf1 & sign1 == 0b0 | inf2 & sign2 == 0b1 then {
            result = FPInfinity(0b0, 'N)
        } else if inf1 & sign1 == 0b1 | inf2 & sign2 == 0b0 then {
            result = FPInfinity(0b1, 'N)
        } else if (zero1 & zero2) & sign1 == not_vec(sign2) then {
            result = FPZero(sign1, 'N)
        } else {
            let result_value : real = value1_name - value2_name;
            if result_value == 0.0 then {
                let result_sign : bits(1) = if rounding == FPRounding_NEGINF then
                  0b1
                else
                  0b0;
                result = FPZero(result_sign, 'N)
            } else {
                result = FPRound__2(result_value, fpcr, rounding, fpexc, 'N)
            }
        };
        if fpexc then {
            FPProcessDenorms(type1, type2, 'N, fpcr)
        };
        ()
    };
    return(result)
}

val FPSub_ZA : forall 'N, 'N in {16, 32, 64}.
  (bits('N), bits('N), FPCRType) -> bits('N)

function FPSub_ZA (op1, op2, fpcr_in) = {
    fpcr : FPCRType = fpcr_in;
    let fpexc : bool = false;
    fpcr[DN] = 0b1;
    return(FPSub__1(op1, op2, fpcr, fpexc))
}

val FPThree : forall 'N, 'N in {16, 32, 64}. (bits(1), int('N)) -> bits('N)

function FPThree (sign, N) = {
    assert(N == 16 | N == 32 | N == 64);
    let 'E = if N == 16 then 5 else if N == 32 then 8 else 11;
    let 'F = N - (E + 1);
    let exp : bits(1 + ('E - 1)) = 0b1 @ Zeros(E - 1);
    let frac : bits(1 + ('F - 1)) = 0b1 @ Zeros(F - 1);
    let result : bits(1 + (1 + ('E - 1)) + (1 + ('F - 1))) = (sign @ exp) @ frac;
    return(result)
}

val FPToFixed : forall 'M 'N 'fbits ('is_unsigned : Bool),
  ('N in {16, 32, 64} & 'M in {16, 32, 64}).
  (bits('N), int('fbits), bool('is_unsigned), FPCRType, FPRounding, int('M)) -> bits('M)

function FPToFixed (op, fbits, is_unsigned, fpcr, rounding, M) = {
    fptype : FPType = undefined;
    overflow : bool = undefined;
    result : bits('M) = undefined;
    sign : bits(1) = undefined;
    value_name : real = undefined;
    assert('N == 16 | 'N == 32 | 'N == 64);
    assert(M == 16 | M == 32 | M == 64);
    assert(fbits >= 0);
    assert(rounding != FPRounding_ODD);
    let altfp : bool = (HaveAltFP() & not_bool(UsingAArch32())) & fpcr[AH] == 0b1;
    let fpexc : bool = not_bool(altfp);
    (fptype, sign, value_name) = FPUnpack__1(op, fpcr, fpexc);
    if fptype == FPType_SNaN | fptype == FPType_QNaN then {
        FPProcessException(FPExc_InvalidOp, fpcr)
    };
    let value_name : real = value_name * 2.0 ^ fbits;
    int_result : int = RoundDown(value_name);
    let error : real = value_name - Real(int_result);
    round_up : bool = undefined;
    match rounding {
      FPRounding_TIEEVEN => {
          round_up = error > 0.5 | error == 0.5 & [int_result[0]] == 0b1
      },
      FPRounding_POSINF => {
          round_up = error != 0.0
      },
      FPRounding_NEGINF => {
          round_up = false
      },
      FPRounding_ZERO => {
          round_up = error != 0.0 & int_result < 0
      },
      FPRounding_TIEAWAY => {
          round_up = error > 0.5 | error == 0.5 & int_result >= 0
      },
      _ => ()
    };
    if round_up then {
        int_result = int_result + 1
    };
    let 'int_result = int_result;
    (result, overflow) = SatQ(int_result, M, is_unsigned);
    if overflow then {
        FPProcessException(FPExc_InvalidOp, fpcr)
    } else if error != 0.0 then {
        FPProcessException(FPExc_Inexact, fpcr)
    } else ();
    return(result)
}

val FPToFixedJS : forall ('Is64 : Bool) 'M 'N,
  ('M == 64 & 'N == 32).
  (bits('M), FPCRType, bool('Is64), int('N)) -> (bits('N), bits(1))

function FPToFixedJS (op, fpcr, Is64, N) = {
    fptype : FPType = undefined;
    sign : bits(1) = undefined;
    value_name : real = undefined;
    assert('M == 64 & N == 32);
    let fpexc_idenorm : bool = not_bool((HaveAltFP() & not_bool(UsingAArch32())) & fpcr[AH] == 0b1);
    (fptype, sign, value_name) = FPUnpack__1(op, fpcr, fpexc_idenorm);
    z : bits(1) = 0b1;
    if fptype == FPType_SNaN | fptype == FPType_QNaN then {
        FPProcessException(FPExc_InvalidOp, fpcr);
        z = 0b0
    };
    int_result : int = RoundDown(value_name);
    let error : real = value_name - Real(int_result);
    let round_it_up : bool = error != 0.0 & int_result < 0;
    if round_it_up then {
        int_result = int_result + 1
    };
    let 'int_result = int_result;
    result : int = undefined;
    if int_result < 0 then {
        result = int_result - pow2(32) * RoundUp(Real(int_result) / Real(2 ^ 32))
    } else {
        result = int_result - pow2(32) * RoundDown(Real(int_result) / Real(2 ^ 32))
    };
    if int_result < negate(2 ^ 31) | int_result > pow2(31) - 1 then {
        FPProcessException(FPExc_InvalidOp, fpcr);
        z = 0b0
    } else if error != 0.0 then {
        FPProcessException(FPExc_Inexact, fpcr);
        z = 0b0
    } else if sign == 0b1 & value_name == 0.0 then {
        z = 0b0
    } else if (sign == 0b0 & value_name == 0.0) & not_bool(IsZero(op[51 .. 0])) then {
        z = 0b0
    } else ();
    if fptype == FPType_Infinity then {
        result = 0
    };
    let 'result = result;
    return((result[N - 1 .. 0], z))
}

val VFPExpandImm : forall 'N, 'N in {16, 32, 64}. (bits(8), int('N)) -> bits('N)

function VFPExpandImm (imm8, N) = {
    assert(N == 16 | N == 32 | N == 64);
    let 'E = if N == 16 then 5 else if N == 32 then 8 else 11;
    let 'F = N - E - 1;
    let sign : bits(1) = [imm8[7]];
    let exp : bits(1 + ('E - 3) + 2) = (not_vec([imm8[6]]) @ Replicate([imm8[6]], E - 3)) @ imm8[5 .. 4];
    let frac : bits(4 + ('F - 4)) = imm8[3 .. 0] @ Zeros(F - 4);
    let result : bits(1 + (1 + ('E - 3) + 2) + (4 + ('F - 4))) = (sign @ exp) @ frac;
    return(result)
}

val SPSR_read : forall 'N, 'N >= 0. implicit('N) -> bits('N)

function SPSR_read N = {
    result : bits('N) = undefined;
    if UsingAArch32() then {
        assert(N == 32);
        match PSTATE.M {
          ? if ? == M32_FIQ => {
              result = SPSR_fiq.bits[N - 1 .. 0]
          },
          ? if ? == M32_IRQ => {
              result = SPSR_irq.bits[N - 1 .. 0]
          },
          ? if ? == M32_Svc => {
              result = SPSR_svc_read().bits[N - 1 .. 0]
          },
          ? if ? == M32_Monitor => {
              result = SPSR_mon.bits[N - 1 .. 0]
          },
          ? if ? == M32_Abort => {
              result = SPSR_abt.bits[N - 1 .. 0]
          },
          ? if ? == M32_Hyp => {
              result = SPSR_hyp_read().bits[N - 1 .. 0]
          },
          ? if ? == M32_Undef => {
              result = SPSR_und.bits[N - 1 .. 0]
          },
          _ => {
              Unreachable()
          }
        }
    } else {
        assert(N == 64);
        match PSTATE.EL {
          ? if ? == EL1 => {
              result = SPSR_EL1.bits[N - 1 .. 0]
          },
          ? if ? == EL2 => {
              result = SPSR_EL2.bits[N - 1 .. 0]
          },
          ? if ? == EL3 => {
              result = SPSR_EL3.bits[N - 1 .. 0]
          },
          _ => {
              Unreachable()
          }
        }
    };
    return(result)
}

val BranchToAddr : forall 'N, 'N >= 0. (bits('N), BranchType) -> unit

function BranchToAddr (target, branch_type) = {
    Hint_Branch(branch_type);
    if 'N == 32 then {
        assert(UsingAArch32());
        sail_branch_announce(64, ZeroExtend(64, target));
        _PC = ZeroExtend(target, 64)
    } else {
        assert('N == 64 & not_bool(UsingAArch32()));
        sail_branch_announce(64, target[63 .. 0]);
        _PC = target[63 .. 0]
    };
    __BranchTaken = true;
    return()
}

val NextInstrAddr : forall 'N, 'N >= 0. int('N) -> bits('N)

val ResetExternalDebugRegisters : forall ('cold_reset : Bool).
  bool('cold_reset) -> unit

val IsFault : AddressDescriptor -> bool

val IsFault__1 : Fault -> bool

val IsFault__2 : PhysMemRetStatus -> bool

function IsFault addrdesc = {
    return(addrdesc.fault.statuscode != Fault_None)
}

function IsFault__1 fault = {
    return(fault != Fault_None)
}

function IsFault__2 retstatus = {
    return(retstatus.statuscode != Fault_None)
}

bitfield CNTHP_CTL_EL2_Type : bits(64) =
  {ISTATUS : 2..2, IMASK : 1..1, ENABLE : 0..0}

register CNTHP_CTL_EL2 : CNTHP_CTL_EL2_Type

bitfield CNTHP_CTL_Type : bits(32) =
  {ISTATUS : 2..2, IMASK : 1..1, ENABLE : 0..0}

register _CNTHP_CTL : CNTHP_CTL_Type

val CNTHP_CTL_read : unit -> CNTHP_CTL_Type

function CNTHP_CTL_read () = {
    r : CNTHP_CTL_Type = _CNTHP_CTL;
    r.bits[31 .. 0] = Slice(CNTHP_CTL_EL2.bits, 0, 32);
    return(r)
}

val CNTHP_CTL_write : CNTHP_CTL_Type -> unit

function CNTHP_CTL_write value_name = {
    let r : CNTHP_CTL_Type = value_name;
    CNTHP_CTL_EL2.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _CNTHP_CTL = r;
    return()
}

bitfield CNTHP_CVAL_EL2_Type : bits(64) = {CompareValue : 63..0}

register CNTHP_CVAL_EL2 : CNTHP_CVAL_EL2_Type

bitfield CNTHP_CVAL_Type : bits(64) = {CompareValue : 63..0}

register _CNTHP_CVAL : CNTHP_CVAL_Type

val CNTHP_CVAL_read : unit -> CNTHP_CVAL_Type

function CNTHP_CVAL_read () = {
    r : CNTHP_CVAL_Type = _CNTHP_CVAL;
    r.bits[63 .. 0] = Slice(CNTHP_CVAL_EL2.bits, 0, 64);
    return(r)
}

bitfield CNTP_CTL_EL0_Type : bits(64) =
  {ISTATUS : 2..2, IMASK : 1..1, ENABLE : 0..0}

register CNTP_CTL_EL0 : CNTP_CTL_EL0_Type

bitfield CNTP_CTL_Type : bits(32) =
  {ISTATUS : 2..2, IMASK : 1..1, ENABLE : 0..0}

register _CNTP_CTL_NS : CNTP_CTL_Type

val CNTP_CTL_NS_read : unit -> CNTP_CTL_Type

function CNTP_CTL_NS_read () = {
    r : CNTP_CTL_Type = _CNTP_CTL_NS;
    r.bits[31 .. 0] = Slice(CNTP_CTL_EL0.bits, 0, 32);
    return(r)
}

register CNTP_CTL_S : CNTP_CTL_Type

val CNTP_CTL_read : unit -> CNTP_CTL_Type

function CNTP_CTL_read () = {
    r : CNTP_CTL_Type = undefined;
    if ELUsingAArch32(EL3) & CurrentSecurityState() == SS_Secure then {
        r = CNTP_CTL_S
    } else {
        r = CNTP_CTL_NS_read()
    };
    return(r)
}

val CNTP_CTL_NS_write : CNTP_CTL_Type -> unit

function CNTP_CTL_NS_write value_name = {
    let r : CNTP_CTL_Type = value_name;
    CNTP_CTL_EL0.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _CNTP_CTL_NS = r;
    return()
}

val CNTP_CTL_write : CNTP_CTL_Type -> unit

function CNTP_CTL_write value_name = {
    let r : CNTP_CTL_Type = value_name;
    if ELUsingAArch32(EL3) & CurrentSecurityState() == SS_Secure then {
        CNTP_CTL_S = r
    } else {
        CNTP_CTL_NS_write() = r
    };
    return()
}

bitfield CNTP_CVAL_EL0_Type : bits(64) = {CompareValue : 63..0}

register CNTP_CVAL_EL0 : CNTP_CVAL_EL0_Type

bitfield CNTP_CVAL_Type : bits(64) = {CompareValue : 63..0}

register _CNTP_CVAL_NS : CNTP_CVAL_Type

val CNTP_CVAL_NS_read : unit -> CNTP_CVAL_Type

function CNTP_CVAL_NS_read () = {
    r : CNTP_CVAL_Type = _CNTP_CVAL_NS;
    r.bits[63 .. 0] = Slice(CNTP_CVAL_EL0.bits, 0, 64);
    return(r)
}

register CNTP_CVAL_S : CNTP_CVAL_Type

val CNTP_CVAL_read : unit -> CNTP_CVAL_Type

function CNTP_CVAL_read () = {
    r : CNTP_CVAL_Type = undefined;
    if ELUsingAArch32(EL3) & CurrentSecurityState() == SS_Secure then {
        r = CNTP_CVAL_S
    } else {
        r = CNTP_CVAL_NS_read()
    };
    return(r)
}

bitfield CNTV_CTL_EL0_Type : bits(64) =
  {ISTATUS : 2..2, IMASK : 1..1, ENABLE : 0..0}

register CNTV_CTL_EL0 : CNTV_CTL_EL0_Type

bitfield CNTV_CVAL_EL0_Type : bits(64) = {CompareValue : 63..0}

register CNTV_CVAL_EL0 : CNTV_CVAL_EL0_Type

val IsTimerConditionMet : (bits(64), bits(64), bits(1), InterruptID) -> bool

function IsTimerConditionMet (offset, compare_value, imask, intid) = {
    let condition_met : bool = UInt(PhysicalCountInt() - offset) - UInt(compare_value) >= 0;
    let level : Signal = if condition_met & imask == 0b0 then Signal_High else
      Signal_Low;
    SetInterruptRequestLevel(intid, level);
    return(condition_met)
}

val AArch32_CheckTimerConditions : unit -> unit

function AArch32_CheckTimerConditions () = {
    status : bool = undefined;
    let offset : bits(64) = Zeros(64);
    assert(not_bool(HaveAArch64()));
    if HaveEL(EL3) then {
        if CNTP_CTL_S[ENABLE] == 0b1 then {
            status = IsTimerConditionMet(offset, CNTP_CVAL_S.bits, CNTP_CTL_S[IMASK], InterruptID_CNTPS);
            CNTP_CTL_S[ISTATUS] = if status then 0b1 else 0b0
        };
        if CNTP_CTL_NS_read()[ENABLE] == 0b1 then {
            status = IsTimerConditionMet(offset, CNTP_CVAL_NS_read().bits, CNTP_CTL_NS_read()[IMASK], InterruptID_CNTP);
            CNTP_CTL_NS_write() = [CNTP_CTL_NS_read() with ISTATUS = if status then
              0b1
            else
              0b0]
        };
        ()
    } else {
        if CNTP_CTL_read()[ENABLE] == 0b1 then {
            status = IsTimerConditionMet(offset, CNTP_CVAL_read().bits, CNTP_CTL_read()[IMASK], InterruptID_CNTP);
            CNTP_CTL_write() = [CNTP_CTL_read() with ISTATUS = if status then
              0b1
            else
              0b0]
        };
        ()
    };
    if HaveEL(EL2) & CNTHP_CTL_read()[ENABLE] == 0b1 then {
        status = IsTimerConditionMet(offset, CNTHP_CVAL_read().bits, CNTHP_CTL_read()[IMASK], InterruptID_CNTHP);
        CNTHP_CTL_write() = [CNTHP_CTL_read() with ISTATUS = if status then 0b1
        else
          0b0]
    };
    if CNTV_CTL_EL0[ENABLE] == 0b1 then {
        let status : bool = IsTimerConditionMet(CNTVOFF_EL2, CNTV_CVAL_EL0.bits, CNTV_CTL_EL0[IMASK], InterruptID_CNTV);
        CNTV_CTL_EL0[ISTATUS] = if status then 0b1 else 0b0
    };
    return()
}

bitfield CNTHPS_CTL_EL2_Type : bits(64) =
  {ISTATUS : 2..2, IMASK : 1..1, ENABLE : 0..0}

register CNTHPS_CTL_EL2 : CNTHPS_CTL_EL2_Type

bitfield CNTHPS_CVAL_EL2_Type : bits(64) = {CompareValue : 63..0}

register CNTHPS_CVAL_EL2 : CNTHPS_CVAL_EL2_Type

bitfield CNTHVS_CTL_EL2_Type : bits(64) =
  {ISTATUS : 2..2, IMASK : 1..1, ENABLE : 0..0}

register CNTHVS_CTL_EL2 : CNTHVS_CTL_EL2_Type

bitfield CNTHVS_CVAL_EL2_Type : bits(64) = {CompareValue : 63..0}

register CNTHVS_CVAL_EL2 : CNTHVS_CVAL_EL2_Type

bitfield CNTHV_CTL_EL2_Type : bits(64) =
  {ISTATUS : 2..2, IMASK : 1..1, ENABLE : 0..0}

register CNTHV_CTL_EL2 : CNTHV_CTL_EL2_Type

bitfield CNTHV_CVAL_EL2_Type : bits(64) = {CompareValue : 63..0}

register CNTHV_CVAL_EL2 : CNTHV_CVAL_EL2_Type

bitfield CNTPS_CTL_EL1_Type : bits(64) =
  {ISTATUS : 2..2, IMASK : 1..1, ENABLE : 0..0}

register CNTPS_CTL_EL1 : CNTPS_CTL_EL1_Type

bitfield CNTPS_CVAL_EL1_Type : bits(64) = {CompareValue : 63..0}

register CNTPS_CVAL_EL1 : CNTPS_CVAL_EL1_Type

val AArch64_CheckTimerConditions : unit -> unit

function AArch64_CheckTimerConditions () = {
    status : bool = undefined;
    offset : bits(64) = undefined;
    imask : bits(1) = undefined;
    let ss : SecurityState = CurrentSecurityState();
    ecv : bool = false;
    if HaveECVExt() then {
        ecv = (CNTHCTL_EL2[ECV] == 0b1 & SCR_EL3[ECVEn] == 0b1) & EL2Enabled()
    };
    if ecv then {
        offset = CNTPOFF_EL2
    } else {
        offset = Zeros(64)
    };
    if CNTP_CTL_EL0[ENABLE] == 0b1 then {
        imask = CNTP_CTL_EL0[IMASK];
        if (HaveRME() & (ss == SS_Root | ss == SS_Realm)) & CNTHCTL_EL2[CNTPMASK] == 0b1 then {
            imask = 0b1
        };
        status = IsTimerConditionMet(offset, CNTP_CVAL_EL0.bits, imask, InterruptID_CNTP);
        CNTP_CTL_EL0[ISTATUS] = if status then 0b1 else 0b0
    };
    if (HaveEL(EL3) | HaveEL(EL2) & not_bool(HaveSecureEL2Ext())) & CNTHP_CTL_EL2[ENABLE] == 0b1 then {
        status = IsTimerConditionMet(Zeros(64), CNTHP_CVAL_EL2.bits, CNTHP_CTL_EL2[IMASK], InterruptID_CNTHP);
        CNTHP_CTL_EL2[ISTATUS] = if status then 0b1 else 0b0
    };
    if (HaveEL(EL2) & HaveSecureEL2Ext()) & CNTHPS_CTL_EL2[ENABLE] == 0b1 then {
        status = IsTimerConditionMet(Zeros(64), CNTHPS_CVAL_EL2.bits, CNTHPS_CTL_EL2[IMASK], InterruptID_CNTHPS);
        CNTHPS_CTL_EL2[ISTATUS] = if status then 0b1 else 0b0
    };
    if CNTPS_CTL_EL1[ENABLE] == 0b1 then {
        status = IsTimerConditionMet(offset, CNTPS_CVAL_EL1.bits, CNTPS_CTL_EL1[IMASK], InterruptID_CNTPS);
        CNTPS_CTL_EL1[ISTATUS] = if status then 0b1 else 0b0
    };
    if CNTV_CTL_EL0[ENABLE] == 0b1 then {
        imask : bits(1) = CNTV_CTL_EL0[IMASK];
        if (HaveRME() & (ss == SS_Root | ss == SS_Realm)) & CNTHCTL_EL2[CNTVMASK] == 0b1 then {
            imask = 0b1
        };
        status = IsTimerConditionMet(CNTVOFF_EL2, CNTV_CVAL_EL0.bits, imask, InterruptID_CNTV);
        CNTV_CTL_EL0[ISTATUS] = if status then 0b1 else 0b0
    };
    if (HaveVirtHostExt() & (HaveEL(EL3) | not_bool(HaveSecureEL2Ext()))) & CNTHV_CTL_EL2[ENABLE] == 0b1 then {
        status = IsTimerConditionMet(Zeros(64), CNTHV_CVAL_EL2.bits, CNTHV_CTL_EL2[IMASK], InterruptID_CNTHV);
        CNTHV_CTL_EL2[ISTATUS] = if status then 0b1 else 0b0
    };
    if (HaveSecureEL2Ext() & HaveVirtHostExt()) & CNTHVS_CTL_EL2[ENABLE] == 0b1 then {
        let status : bool = IsTimerConditionMet(Zeros(64), CNTHVS_CVAL_EL2.bits, CNTHVS_CTL_EL2[IMASK], InterruptID_CNTHVS);
        CNTHVS_CTL_EL2[ISTATUS] = if status then 0b1 else 0b0
    };
    return()
}

bitfield CNTCR_Type : bits(32) =
  {FCREQ : 17..8, SCEN : 2..2, HDBG : 1..1, EN : 0..0}

register CNTCR : CNTCR_Type

bitfield CNTSCR_Type : bits(32) = {ScaleVal : 31..0}

register CNTSCR : CNTSCR_Type

val HaveCNTSCExt : unit -> bool

function HaveCNTSCExt () = {
    return(IsFeatureImplemented(FEAT_CNTSC))
}

val SetEventRegister : unit -> unit

function SetEventRegister () = {
    EventRegister = 0b1;
    __WakeupRequest();
    return()
}

val TestEventCNTP : (bits(64), bits(64)) -> unit

function TestEventCNTP (prev_physical_count, current_physical_count) = {
    n : int = undefined;
    offset : bits(64) = undefined;
    previousbit : bits(1) = undefined;
    samplebit : bits(1) = undefined;
    if CNTHCTL_EL2[EVNTEN] == 0b1 then {
        n : int = UInt(CNTHCTL_EL2[EVNTI]);
        if HaveECVExt() & CNTHCTL_EL2[EVNTIS] == 0b1 then {
            n = n + 8
        };
        let 'n = n;
        ecv : bool = false;
        if HaveECVExt() then {
            let ecv : bool = (EL2Enabled() & CNTHCTL_EL2[ECV] == 0b1) & SCR_EL3[ECVEn] == 0b1;
            offset = if ecv then CNTPOFF_EL2 else Zeros(64)
        };
        assert(constraint((0 <= 'n & 'n < 64)));
        let samplebit : bits(1) = [(current_physical_count - offset)[n]];
        let previousbit : bits(1) = [(prev_physical_count - offset)[n]];
        if CNTHCTL_EL2[EVNTDIR] == 0b0 then {
            if previousbit == 0b0 & samplebit == 0b1 then {
                SetEventRegister()
            };
            ()
        } else {
            if previousbit == 0b1 & samplebit == 0b0 then {
                SetEventRegister()
            };
            ()
        }
    };
    let n = n;
    return()
}

bitfield CNTKCTL_EL1_Type : bits(64) =
  {
    EVNTIS : 17..17,
    EL0PTEN : 9..9,
    EL0VTEN : 8..8,
    EVNTI : 7..4,
    EVNTDIR : 3..3,
    EVNTEN : 2..2,
    EL0VCTEN : 1..1,
    EL0PCTEN : 0..0
  }

register CNTKCTL_EL1 : CNTKCTL_EL1_Type

val TestEventCNTV : (bits(64), bits(64)) -> unit

function TestEventCNTV (prev_physical_count, current_physical_count) = {
    n : int = undefined;
    offset : bits(64) = undefined;
    previousbit : bits(1) = undefined;
    samplebit : bits(1) = undefined;
    if not_bool(HaveVirtHostExt() & (HCR_EL2[E2H] @ HCR_EL2[TGE]) == 0b11) & CNTKCTL_EL1[EVNTEN] == 0b1 then {
        n : int = UInt(CNTKCTL_EL1[EVNTI]);
        if HaveECVExt() & CNTKCTL_EL1[EVNTIS] == 0b1 then {
            n = n + 8
        };
        let 'n = n;
        if HaveEL(EL2) & (not_bool(EL2Enabled()) | (HCR_EL2[E2H] @ HCR_EL2[TGE]) != 0b11) then {
            offset = CNTVOFF_EL2
        } else {
            offset = Zeros(64)
        };
        assert(constraint((0 <= 'n & 'n < 64)));
        let samplebit : bits(1) = [(current_physical_count - offset)[n]];
        let previousbit : bits(1) = [(prev_physical_count - offset)[n]];
        if CNTKCTL_EL1[EVNTDIR] == 0b0 then {
            if previousbit == 0b0 & samplebit == 0b1 then {
                SetEventRegister()
            };
            ()
        } else {
            if previousbit == 0b1 & samplebit == 0b0 then {
                SetEventRegister()
            };
            ()
        }
    };
    let n = n;
    return()
}

val GenericCounterTick : unit -> unit

function GenericCounterTick () = {
    if CNTCR[EN] == 0b0 then {
        if not_bool(HaveAArch64()) then {
            AArch32_CheckTimerConditions()
        } else {
            AArch64_CheckTimerConditions()
        };
        return()
    };
    let prev_physical_count : bits(64) = PhysicalCountInt();
    if HaveCNTSCExt() & CNTCR[SCEN] == 0b1 then {
        PhysicalCount = PhysicalCount + ZeroExtend(CNTSCR.bits, 88)
    } else {
        PhysicalCount[87 .. 24] = PhysicalCount[87 .. 24] + 1
    };
    if not_bool(HaveAArch64()) then {
        AArch32_CheckTimerConditions()
    } else {
        AArch64_CheckTimerConditions()
    };
    TestEventCNTP(prev_physical_count, PhysicalCountInt());
    TestEventCNTV(prev_physical_count, PhysicalCountInt());
    return()
}

val HaveMPAMExt : unit -> bool

function HaveMPAMExt () = {
    return(IsFeatureImplemented(FEAT_MPAM))
}

val Have16bitVMID : unit -> bool

function Have16bitVMID () = {
    return(IsFeatureImplemented(FEAT_VMID16))
}

val AArch64_HaveHPDExt : unit -> bool

function AArch64_HaveHPDExt () = {
    return(IsFeatureImplemented(FEAT_HPDS))
}

val HaveQRDMLAHExt : unit -> bool

function HaveQRDMLAHExt () = {
    return(IsFeatureImplemented(FEAT_RDM))
}

val HaveCommonNotPrivateTransExt : unit -> bool

function HaveCommonNotPrivateTransExt () = {
    return(IsFeatureImplemented(FEAT_TTCNP))
}

val HaveExtendedExecuteNeverExt : unit -> bool

function HaveExtendedExecuteNeverExt () = {
    return(IsFeatureImplemented(FEAT_XNX))
}

val AArch32_HaveHPDExt : unit -> bool

function AArch32_HaveHPDExt () = {
    return(IsFeatureImplemented(FEAT_AA32HPD))
}

val Have52BitVAExt : unit -> bool

function Have52BitVAExt () = {
    return(IsFeatureImplemented(FEAT_LVA))
}

val Have52BitPAExt : unit -> bool

function Have52BitPAExt () = {
    return(IsFeatureImplemented(FEAT_LPA))
}

val HaveV82Debug : unit -> bool

function HaveV82Debug () = {
    return(IsFeatureImplemented(FEAT_Debugv8p2))
}

val HaveTrapLoadStoreMultipleDeviceExt : unit -> bool

function HaveTrapLoadStoreMultipleDeviceExt () = {
    return(IsFeatureImplemented(FEAT_LSMAOC))
}

val HaveFJCVTZSExt : unit -> bool

function HaveFJCVTZSExt () = {
    return(IsFeatureImplemented(FEAT_JSCVT))
}

val HaveFCADDExt : unit -> bool

function HaveFCADDExt () = {
    return(IsFeatureImplemented(FEAT_FCMA))
}

val HaveDOTPExt : unit -> bool

function HaveDOTPExt () = {
    return(IsFeatureImplemented(FEAT_DotProd))
}

val HaveSmallTranslationTableExt : unit -> bool

function HaveSmallTranslationTableExt () = {
    return(IsFeatureImplemented(FEAT_TTST))
}

val HaveLSE2Ext : unit -> bool

function HaveLSE2Ext () = {
    return(IsFeatureImplemented(FEAT_LSE2))
}

val HaveFP16MulNoRoundingToFP32Ext : unit -> bool

function HaveFP16MulNoRoundingToFP32Ext () = {
    return(IsFeatureImplemented(FEAT_FHM))
}

val HaveFlagManipulateExt : unit -> bool

function HaveFlagManipulateExt () = {
    return(IsFeatureImplemented(FEAT_FlagM))
}

val HaveFlagFormatExt : unit -> bool

function HaveFlagFormatExt () = {
    return(IsFeatureImplemented(FEAT_FlagM2))
}

val HaveSelfHostedTrace : unit -> bool

function HaveSelfHostedTrace () = {
    return(IsFeatureImplemented(FEAT_TRF))
}

val HaveBlockBBM : unit -> bool

function HaveBlockBBM () = {
    return(IsFeatureImplemented(FEAT_BBM))
}

val Havev8p4Debug : unit -> bool

function Havev8p4Debug () = {
    return(IsFeatureImplemented(FEAT_Debugv8p4))
}

val HaveStage2MemAttrControl : unit -> bool

function HaveStage2MemAttrControl () = {
    return(IsFeatureImplemented(FEAT_S2FWB))
}

val HaveIDSExt : unit -> bool

function HaveIDSExt () = {
    return(IsFeatureImplemented(FEAT_IDST))
}

val HaveFrintExt : unit -> bool

function HaveFrintExt () = {
    return(IsFeatureImplemented(FEAT_FRINTTS))
}

val HaveE0PDExt : unit -> bool

function HaveE0PDExt () = {
    return(IsFeatureImplemented(FEAT_E0PD))
}

val HaveGTGExt : unit -> bool

function HaveGTGExt () = {
    return(IsFeatureImplemented(FEAT_GTG))
}

val HaveSBExt : unit -> bool

function HaveSBExt () = {
    return(IsFeatureImplemented(FEAT_SB))
}

val HaveMTEAsyncExt : unit -> bool

function HaveMTEAsyncExt () = {
    return(IsFeatureImplemented(FEAT_MTE4))
}

val HaveMTEPermExt : unit -> bool

function HaveMTEPermExt () = {
    return(IsFeatureImplemented(FEAT_MTE_PERM))
}

val HaveDGHExt : unit -> bool

function HaveDGHExt () = {
    return(IsFeatureImplemented(FEAT_DGH))
}

val HaveBF16Ext : unit -> bool

function HaveBF16Ext () = {
    return(IsFeatureImplemented(FEAT_BF16))
}

val HaveEBF16 : unit -> bool

function HaveEBF16 () = {
    return(IsFeatureImplemented(FEAT_EBF16))
}

val HaveAArch32BF16Ext : unit -> bool

function HaveAArch32BF16Ext () = {
    return(IsFeatureImplemented(FEAT_AA32BF16))
}

val HaveFGTExt : unit -> bool

function HaveFGTExt () = {
    return(IsFeatureImplemented(FEAT_FGT))
}

val HaveInt8MatMulExt : unit -> bool

function HaveInt8MatMulExt () = {
    return(IsFeatureImplemented(FEAT_I8MM))
}

val HaveAArch32Int8MatMulExt : unit -> bool

function HaveAArch32Int8MatMulExt () = {
    return(IsFeatureImplemented(FEAT_AA32I8MM))
}

val HavePMUv3p4 : unit -> bool

function HavePMUv3p4 () = {
    return(IsFeatureImplemented(FEAT_PMUv3p4))
}

val HaveDoPD : unit -> bool

function HaveDoPD () = {
    return(IsFeatureImplemented(FEAT_DoPD))
}

val Have56BitVAExt : unit -> bool

function Have56BitVAExt () = {
    return(IsFeatureImplemented(FEAT_LVA3))
}

val Have128BitDescriptorExt : unit -> bool

function Have128BitDescriptorExt () = {
    return(IsFeatureImplemented(FEAT_D128))
}

val HaveAIEExt : unit -> bool

function HaveAIEExt () = {
    return(IsFeatureImplemented(FEAT_AIE))
}

val HaveFeatTCR2 : unit -> bool

function HaveFeatTCR2 () = {
    return(IsFeatureImplemented(FEAT_TCR2))
}

val HavePAN3Ext : unit -> bool

function HavePAN3Ext () = {
    return(IsFeatureImplemented(FEAT_PAN3))
}

val HaveMTEAsymFaultExt : unit -> bool

function HaveMTEAsymFaultExt () = {
    return(IsFeatureImplemented(FEAT_MTE4))
}

val HaveFeatLS64_V : unit -> bool

function HaveFeatLS64_V () = {
    return(IsFeatureImplemented(FEAT_LS64_V))
}

val HaveFeatLS64_ACCDATA : unit -> bool

function HaveFeatLS64_ACCDATA () = {
    return(IsFeatureImplemented(FEAT_LS64_ACCDATA))
}

val HaveFeatXS : unit -> bool

function HaveFeatXS () = {
    return(IsFeatureImplemented(FEAT_XS))
}

val HaveFeatEBEP : unit -> bool

function HaveFeatEBEP () = {
    return(IsFeatureImplemented(FEAT_EBEP))
}

val HaveStatisticalProfilingFDS : unit -> bool

function HaveStatisticalProfilingFDS () = {
    return(IsFeatureImplemented(FEAT_SPE_FDS))
}

val HaveFeatHBC : unit -> bool

function HaveFeatHBC () = {
    return(IsFeatureImplemented(FEAT_HBC))
}

val HaveFeatMOPS : unit -> bool

function HaveFeatMOPS () = {
    return(IsFeatureImplemented(FEAT_MOPS))
}

val HaveFeatTIDCP1 : unit -> bool

function HaveFeatTIDCP1 () = {
    return(IsFeatureImplemented(FEAT_TIDCP1))
}

val HaveFeatCMOW : unit -> bool

function HaveFeatCMOW () = {
    return(IsFeatureImplemented(FEAT_CMOW))
}

val HaveMTECanonicalTagCheckingExt : unit -> bool

function HaveMTECanonicalTagCheckingExt () = {
    return(IsFeatureImplemented(FEAT_MTE_CANONICAL_TAGS))
}

val HaveLRCPC3Ext : unit -> bool

function HaveLRCPC3Ext () = {
    return(IsFeatureImplemented(FEAT_LRCPC3))
}

val HaveMTEStoreOnlyExt : unit -> bool

function HaveMTEStoreOnlyExt () = {
    return(IsFeatureImplemented(FEAT_MTE_STORE_ONLY))
}

val HaveCSSC : unit -> bool

function HaveCSSC () = {
    return(IsFeatureImplemented(FEAT_CSSC))
}

val HaveS1PIExt : unit -> bool

function HaveS1PIExt () = {
    return(IsFeatureImplemented(FEAT_S1PIE))
}

val HaveS1POExt : unit -> bool

function HaveS1POExt () = {
    return(IsFeatureImplemented(FEAT_S1POE))
}

val HaveS2PIExt : unit -> bool

function HaveS2PIExt () = {
    return(IsFeatureImplemented(FEAT_S2PIE))
}

val HaveS2POExt : unit -> bool

function HaveS2POExt () = {
    return(IsFeatureImplemented(FEAT_S2POE))
}

val HaveFeatCLRBHB : unit -> bool

function HaveFeatCLRBHB () = {
    return(IsFeatureImplemented(FEAT_CLRBHB))
}

val HaveTHExt : unit -> bool

function HaveTHExt () = {
    return(IsFeatureImplemented(FEAT_THE))
}

val HaveLSE128 : unit -> bool

function HaveLSE128 () = {
    return(IsFeatureImplemented(FEAT_LSE128))
}

val HaveSysReg128 : unit -> bool

function HaveSysReg128 () = {
    return(IsFeatureImplemented(FEAT_SYSREG128))
}

val HaveSysInstr128 : unit -> bool

function HaveSysInstr128 () = {
    return(IsFeatureImplemented(FEAT_SYSINSTR128))
}

val IsG1ActivityMonitorImplemented : forall 'i. int('i) -> bool

val IsG1ActivityMonitorOffsetImplemented : forall 'i. int('i) -> bool

val HaveRASv2Ext : unit -> bool

function HaveRASv2Ext () = {
    return(IsFeatureImplemented(FEAT_RASv2))
}

val HaveFeatMEC : unit -> bool

function HaveFeatMEC () = {
    return(IsFeatureImplemented(FEAT_MEC))
}

val HaveAccessFlagUpdateForTableExt : unit -> bool

function HaveAccessFlagUpdateForTableExt () = {
    return(IsFeatureImplemented(FEAT_HAFT))
}

val HaveFeatABLE : unit -> bool

function HaveFeatABLE () = {
    return(IsFeatureImplemented(FEAT_ABLE))
}

val PAREncodeShareability : MemoryAttributes -> bits(2)

function PAREncodeShareability memattrs = {
    if memattrs.memtype == MemType_Device | memattrs.inner.attrs == MemAttr_NC & memattrs.outer.attrs == MemAttr_NC then {
        return(0b10)
    };
    match memattrs.shareability {
      Shareability_NSH => {
          return(0b00)
      },
      Shareability_ISH => {
          return(0b11)
      },
      Shareability_OSH => {
          return(0b10)
      },
      _ => {
          return(undefined : bits(2))
      }
    }
}

val EncodePARAttrs : MemoryAttributes -> bits(8)

function EncodePARAttrs memattrs = {
    result : bits(8) = undefined;
    if HaveMTEExt() & memattrs.tags == MemTag_AllocationTagged then {
        if HaveMTEPermExt() & memattrs.notagaccess then {
            result[7 .. 0] = 0b11100000
        } else {
            result[7 .. 0] = 0b11110000
        };
        return(result)
    };
    if memattrs.memtype == MemType_Device then {
        result[7 .. 4] = 0b0000;
        match memattrs.device {
          DeviceType_nGnRnE => {
              result[3 .. 0] = 0b0000
          },
          DeviceType_nGnRE => {
              result[3 .. 0] = 0b0100
          },
          DeviceType_nGRE => {
              result[3 .. 0] = 0b1000
          },
          DeviceType_GRE => {
              result[3 .. 0] = 0b1100
          },
          _ => {
              Unreachable()
          }
        };
        result[0] = Bit(not_vec(memattrs.xs))
    } else {
        if memattrs.xs == 0b0 then {
            if ((memattrs.outer.attrs == MemAttr_WT & memattrs.inner.attrs == MemAttr_WT) & not_bool(memattrs.outer.transient)) & memattrs.outer.hints == MemHint_RA then {
                return(0b10100000)
            } else if memattrs.outer.attrs == MemAttr_NC & memattrs.inner.attrs == MemAttr_NC then {
                return(0b01000000)
            } else ()
        };
        if memattrs.outer.attrs == MemAttr_WT then {
            result[7 .. 6] = if memattrs.outer.transient then 0b00 else 0b10;
            result[5 .. 4] = memattrs.outer.hints
        } else if memattrs.outer.attrs == MemAttr_WB then {
            result[7 .. 6] = if memattrs.outer.transient then 0b01 else 0b11;
            result[5 .. 4] = memattrs.outer.hints
        } else {
            result[7 .. 4] = 0b0100
        };
        if memattrs.inner.attrs == MemAttr_WT then {
            result[3 .. 2] = if memattrs.inner.transient then 0b00 else 0b10;
            result[1 .. 0] = memattrs.inner.hints
        } else if memattrs.inner.attrs == MemAttr_WB then {
            result[3 .. 2] = if memattrs.inner.transient then 0b01 else 0b11;
            result[1 .. 0] = memattrs.inner.hints
        } else {
            result[3 .. 0] = 0b0100
        }
    };
    return(result)
}

val ReportedPARAttrs : bits(8) -> bits(8)

val ReportedPARShareability : bits(2) -> bits(2)

val DecodeShareability : bits(2) -> Shareability

function DecodeShareability sh = {
    match sh {
      0b10 => {
          return(Shareability_OSH)
      },
      0b11 => {
          return(Shareability_ISH)
      },
      0b00 => {
          return(Shareability_NSH)
      },
      _ => {
          match ConstrainUnpredictable(Unpredictable_Shareability) {
            Constraint_OSH => {
                return(Shareability_OSH)
            },
            Constraint_ISH => {
                return(Shareability_ISH)
            },
            Constraint_NSH => {
                return(Shareability_NSH)
            },
            _ => {
                return(undefined : Shareability)
            }
          }
      }
    }
}

val S2CombineS1Shareability : (Shareability, Shareability) -> Shareability

function S2CombineS1Shareability (s1_shareability, s2_shareability) = {
    if s1_shareability == Shareability_OSH | s2_shareability == Shareability_OSH then {
        return(Shareability_OSH)
    } else if s1_shareability == Shareability_ISH | s2_shareability == Shareability_ISH then {
        return(Shareability_ISH)
    } else {
        return(Shareability_NSH)
    }
}

val EffectiveShareability : MemoryAttributes -> Shareability

function EffectiveShareability memattrs = {
    if memattrs.memtype == MemType_Device | memattrs.inner.attrs == MemAttr_NC & memattrs.outer.attrs == MemAttr_NC then {
        return(Shareability_OSH)
    } else {
        return(memattrs.shareability)
    }
}

val DecodeDevice : bits(2) -> DeviceType

function DecodeDevice device = {
    match device {
      0b00 => {
          return(DeviceType_nGnRnE)
      },
      0b01 => {
          return(DeviceType_nGnRE)
      },
      0b10 => {
          return(DeviceType_nGRE)
      },
      0b11 => {
          return(DeviceType_GRE)
      },
      _ => {
          return(undefined : DeviceType)
      }
    }
}

val S2CombineS1Device : (DeviceType, DeviceType) -> DeviceType

function S2CombineS1Device (s1_device, s2_device) = {
    if s1_device == DeviceType_nGnRnE | s2_device == DeviceType_nGnRnE then {
        return(DeviceType_nGnRnE)
    } else if s1_device == DeviceType_nGnRE | s2_device == DeviceType_nGnRE then {
        return(DeviceType_nGnRE)
    } else if s1_device == DeviceType_nGRE | s2_device == DeviceType_nGRE then {
        return(DeviceType_nGRE)
    } else {
        return(DeviceType_GRE)
    }
}

val DecodeSDFAttr : bits(2) -> MemAttrHints

function DecodeSDFAttr rgn = {
    sdfattr : MemAttrHints = undefined;
    match rgn {
      0b00 => {
          sdfattr.attrs = MemAttr_NC
      },
      0b01 => {
          sdfattr.attrs = MemAttr_WB;
          sdfattr.hints = MemHint_RWA
      },
      0b10 => {
          sdfattr.attrs = MemAttr_WT;
          sdfattr.hints = MemHint_RA
      },
      0b11 => {
          sdfattr.attrs = MemAttr_WB;
          sdfattr.hints = MemHint_RA
      }
    };
    sdfattr.transient = false;
    return(sdfattr)
}

val DecodeLDFAttr : bits(4) -> MemAttrHints

function DecodeLDFAttr attr = {
    ldfattr : MemAttrHints = undefined;
    if (match attr {
      [_, bitzero, _, _] => true,
      _ => false
    }) : bool then {
        ldfattr.attrs = MemAttr_WT
    } else if attr == 0b0100 then {
        ldfattr.attrs = MemAttr_NC
    } else if (match attr {
      [_, bitone, _, _] => true,
      _ => false
    }) : bool then {
        ldfattr.attrs = MemAttr_WB
    } else {
        Unreachable()
    };
    if ldfattr.attrs != MemAttr_NC then {
        match attr[1 .. 0] {
          0b00 => {
              ldfattr.hints = MemHint_No
          },
          0b01 => {
              ldfattr.hints = MemHint_WA
          },
          0b10 => {
              ldfattr.hints = MemHint_RA
          },
          0b11 => {
              ldfattr.hints = MemHint_RWA
          }
        }
    };
    if ldfattr.attrs != MemAttr_NC & ldfattr.hints != MemHint_No then {
        ldfattr.transient = [attr[3]] == 0b0
    };
    return(ldfattr)
}

val S2DecodeCacheability : bits(2) -> MemAttrHints

function S2DecodeCacheability attr = {
    s2attr : MemAttrHints = undefined;
    match attr {
      0b01 => {
          s2attr.attrs = MemAttr_NC
      },
      0b10 => {
          s2attr.attrs = MemAttr_WT
      },
      0b11 => {
          s2attr.attrs = MemAttr_WB
      },
      _ => {
          match ConstrainUnpredictable(Unpredictable_S2RESMEMATTR) {
            Constraint_NC => {
                s2attr.attrs = MemAttr_NC
            },
            Constraint_WT => {
                s2attr.attrs = MemAttr_WT
            },
            Constraint_WB => {
                s2attr.attrs = MemAttr_WB
            },
            _ => ()
          }
      }
    };
    s2attr.hints = __UNKNOWN_bits(2);
    s2attr.transient = __UNKNOWN_boolean();
    return(s2attr)
}

val S2CombineS1AttrHints : (MemAttrHints, MemAttrHints) -> MemAttrHints

function S2CombineS1AttrHints (s1_attrhints, s2_attrhints) = {
    attrhints : MemAttrHints = undefined;
    if s1_attrhints.attrs == MemAttr_NC | s2_attrhints.attrs == MemAttr_NC then {
        attrhints.attrs = MemAttr_NC
    } else if s1_attrhints.attrs == MemAttr_WT | s2_attrhints.attrs == MemAttr_WT then {
        attrhints.attrs = MemAttr_WT
    } else {
        attrhints.attrs = MemAttr_WB
    };
    if attrhints.attrs != MemAttr_NC then {
        attrhints.hints = s1_attrhints.hints;
        attrhints.transient = s1_attrhints.transient
    };
    return(attrhints)
}

val WalkMemAttrs : (bits(2), bits(2), bits(2)) -> MemoryAttributes

function WalkMemAttrs (sh, irgn, orgn) = {
    walkmemattrs : MemoryAttributes = undefined;
    walkmemattrs.memtype = MemType_Normal;
    walkmemattrs.shareability = DecodeShareability(sh);
    walkmemattrs.inner = DecodeSDFAttr(irgn);
    walkmemattrs.outer = DecodeSDFAttr(orgn);
    walkmemattrs.tags = MemTag_Untagged;
    if walkmemattrs.inner.attrs == MemAttr_WB & walkmemattrs.outer.attrs == MemAttr_WB then {
        walkmemattrs.xs = 0b0
    } else {
        walkmemattrs.xs = 0b1
    };
    walkmemattrs.notagaccess = false;
    return(walkmemattrs)
}

val NormalNCMemAttr : unit -> MemoryAttributes

function NormalNCMemAttr () = {
    non_cacheable : MemAttrHints = undefined;
    non_cacheable.attrs = MemAttr_NC;
    nc_memattrs : MemoryAttributes = undefined;
    nc_memattrs.memtype = MemType_Normal;
    nc_memattrs.outer = non_cacheable;
    nc_memattrs.inner = non_cacheable;
    nc_memattrs.shareability = Shareability_OSH;
    nc_memattrs.tags = MemTag_Untagged;
    nc_memattrs.notagaccess = false;
    return(nc_memattrs)
}

val S1ConstrainUnpredictableRESMAIR : forall ('s1aarch64 : Bool).
  (bits(8), bool('s1aarch64)) -> bool

function S1ConstrainUnpredictableRESMAIR (attr, s1aarch64) = {
    match attr {
      [bitzero, bitzero, bitzero, bitzero, _, _, bitzero, bitone] => {
          return(not_bool(s1aarch64 & HaveFeatXS()))
      },
      [bitzero, bitzero, bitzero, bitzero, _, _, _, _] => {
          return(attr[1 .. 0] != 0b00)
      },
      0b01000000 => {
          return(not_bool(s1aarch64 & HaveFeatXS()))
      },
      0b10100000 => {
          return(not_bool(s1aarch64 & HaveFeatXS()))
      },
      0b11110000 => {
          return(not_bool(s1aarch64 & HaveMTE2Ext()))
      },
      [_, _, _, _, bitzero, bitzero, bitzero, bitzero] => {
          return(true)
      },
      _ => {
          return(false)
      }
    }
}

val S1DecodeMemAttrs : forall ('s1aarch64 : Bool).
  (bits(8), bits(2), bool('s1aarch64), S1TTWParams) -> MemoryAttributes

function S1DecodeMemAttrs (attr_in, sh, s1aarch64, walkparams) = {
    attr : bits(8) = attr_in;
    if S1ConstrainUnpredictableRESMAIR(attr, s1aarch64) then {
        let (_, __tup_1 : bits(8)) = ConstrainUnpredictableBits(Unpredictable_RESMAIR, 8);
        attr = __tup_1
    };
    memattrs : MemoryAttributes = undefined;
    match attr {
      [bitzero, bitzero, bitzero, bitzero, _, _, _, _] => {
          memattrs.memtype = MemType_Device;
          memattrs.device = DecodeDevice(attr[3 .. 2]);
          memattrs.xs = if s1aarch64 then not_vec([attr[0]]) else 0b1
      },
      0b01000000 => {
          assert(s1aarch64 & HaveFeatXS());
          memattrs.memtype = MemType_Normal;
          memattrs.outer.attrs = MemAttr_NC;
          memattrs.inner.attrs = MemAttr_NC;
          memattrs.xs = 0b0
      },
      0b10100000 => {
          assert(s1aarch64 & HaveFeatXS());
          memattrs.memtype = MemType_Normal;
          memattrs.outer.attrs = MemAttr_WT;
          memattrs.outer.hints = MemHint_RA;
          memattrs.outer.transient = false;
          memattrs.inner.attrs = MemAttr_WT;
          memattrs.inner.hints = MemHint_RA;
          memattrs.inner.transient = false;
          memattrs.xs = 0b0
      },
      0b11110000 => {
          assert(s1aarch64 & HaveMTE2Ext());
          memattrs.memtype = MemType_Normal;
          memattrs.outer.attrs = MemAttr_WB;
          memattrs.outer.hints = MemHint_RWA;
          memattrs.outer.transient = false;
          memattrs.inner.attrs = MemAttr_WB;
          memattrs.inner.hints = MemHint_RWA;
          memattrs.inner.transient = false;
          memattrs.xs = 0b0
      },
      _ => {
          memattrs.memtype = MemType_Normal;
          memattrs.outer = DecodeLDFAttr(attr[7 .. 4]);
          memattrs.inner = DecodeLDFAttr(attr[3 .. 0]);
          if memattrs.inner.attrs == MemAttr_WB & memattrs.outer.attrs == MemAttr_WB then {
              memattrs.xs = 0b0
          } else {
              memattrs.xs = 0b1
          }
      }
    };
    if s1aarch64 & attr == 0b11110000 then {
        memattrs.tags = MemTag_AllocationTagged
    } else if s1aarch64 & walkparams.mtx == 0b1 then {
        memattrs.tags = MemTag_CanonicallyTagged
    } else {
        memattrs.tags = MemTag_Untagged
    };
    memattrs.notagaccess = false;
    memattrs.shareability = DecodeShareability(sh);
    return(memattrs)
}

val S2MemTagType : (MemoryAttributes, MemTagType) -> MemTagType

function S2MemTagType (s2_memattrs, s1_tagtype) = {
    if not_bool(HaveMTE2Ext()) then {
        return(MemTag_Untagged)
    };
    if ((((((s1_tagtype == MemTag_AllocationTagged & s2_memattrs.memtype == MemType_Normal) & s2_memattrs.inner.attrs == MemAttr_WB) & s2_memattrs.inner.hints == MemHint_RWA) & not_bool(s2_memattrs.inner.transient)) & s2_memattrs.outer.attrs == MemAttr_WB) & s2_memattrs.outer.hints == MemHint_RWA) & not_bool(s2_memattrs.outer.transient) then {
        return(MemTag_AllocationTagged)
    };
    if s1_tagtype != MemTag_AllocationTagged then {
        return(s1_tagtype)
    };
    return(MemTag_Untagged)
}

val S2DecodeMemAttrs : forall ('s2aarch64 : Bool).
  (bits(4), bits(2), bool('s2aarch64)) -> MemoryAttributes

function S2DecodeMemAttrs (attr, sh, s2aarch64) = {
    memattrs : MemoryAttributes = undefined;
    match attr {
      [bitzero, bitzero, _, _] => {
          memattrs.memtype = MemType_Device;
          memattrs.device = DecodeDevice(attr[1 .. 0])
      },
      0b0100 => {
          if s2aarch64 & HaveMTEPermExt() then {
              memattrs.memtype = MemType_Normal;
              memattrs.outer = S2DecodeCacheability(0b11);
              memattrs.inner = S2DecodeCacheability(0b11)
          } else {
              memattrs.memtype = MemType_Normal;
              memattrs.outer = S2DecodeCacheability(attr[3 .. 2]);
              memattrs.inner = S2DecodeCacheability(attr[1 .. 0])
          }
      },
      _ => {
          memattrs.memtype = MemType_Normal;
          memattrs.outer = S2DecodeCacheability(attr[3 .. 2]);
          memattrs.inner = S2DecodeCacheability(attr[1 .. 0])
      }
    };
    memattrs.shareability = DecodeShareability(sh);
    if s2aarch64 & HaveMTEPermExt() then {
        memattrs.notagaccess = attr == 0b0100
    } else {
        memattrs.notagaccess = false
    };
    return(memattrs)
}

val S2CombineS1MemAttrs : forall ('s2aarch64 : Bool).
  (MemoryAttributes, MemoryAttributes, bool('s2aarch64)) -> MemoryAttributes

function S2CombineS1MemAttrs (s1_memattrs, s2_memattrs, s2aarch64) = {
    memattrs : MemoryAttributes = undefined;
    if s1_memattrs.memtype == MemType_Device & s2_memattrs.memtype == MemType_Device then {
        memattrs.memtype = MemType_Device;
        memattrs.device = S2CombineS1Device(s1_memattrs.device, s2_memattrs.device)
    } else if s1_memattrs.memtype == MemType_Device then {
        memattrs = s1_memattrs
    } else if s2_memattrs.memtype == MemType_Device then {
        memattrs = s2_memattrs
    } else {
        memattrs.memtype = MemType_Normal;
        memattrs.inner = S2CombineS1AttrHints(s1_memattrs.inner, s2_memattrs.inner);
        memattrs.outer = S2CombineS1AttrHints(s1_memattrs.outer, s2_memattrs.outer)
    };
    memattrs.tags = S2MemTagType(memattrs, s1_memattrs.tags);
    if not_bool(HaveMTEPermExt()) then {
        memattrs.notagaccess = false
    } else {
        memattrs.notagaccess = s2_memattrs.notagaccess & s1_memattrs.tags == MemTag_AllocationTagged
    };
    memattrs.shareability = S2CombineS1Shareability(s1_memattrs.shareability, s2_memattrs.shareability);
    if (memattrs.memtype == MemType_Normal & memattrs.inner.attrs == MemAttr_WB) & memattrs.outer.attrs == MemAttr_WB then {
        memattrs.xs = 0b0
    } else if s2aarch64 then {
        memattrs.xs = s2_memattrs.xs & s1_memattrs.xs
    } else {
        memattrs.xs = s1_memattrs.xs
    };
    memattrs.shareability = EffectiveShareability(memattrs);
    return(memattrs)
}

bitfield GPCCR_EL3_Type : bits(64) =
  {
    L0GPTSZ : 23..20,
    GPCP : 17..17,
    GPC : 16..16,
    PGS : 15..14,
    SH : 13..12,
    ORGN : 11..10,
    IRGN : 9..8,
    PPS : 2..0
  }

register GPCCR_EL3 : GPCCR_EL3_Type

val DecodePPS : unit -> int

function DecodePPS () = {
    match GPCCR_EL3[PPS] {
      0b000 => {
          return(32)
      },
      0b001 => {
          return(36)
      },
      0b010 => {
          return(40)
      },
      0b011 => {
          return(42)
      },
      0b100 => {
          return(44)
      },
      0b101 => {
          return(48)
      },
      0b110 => {
          return(52)
      },
      _ => {
          Unreachable();
          return(undefined : int)
      }
    }
}

val AbovePPS : bits(56) -> bool

function AbovePPS address = {
    let 'pps = DecodePPS();
    if pps >= 56 then {
        return(false)
    };
    return(not_bool(is_zero_subrange(address, 55, pps)))
}

val GPCFault : forall 'level. (GPCF, int('level)) -> GPCFRecord

function GPCFault (gpf, level) = {
    fault : GPCFRecord = undefined;
    fault.gpf = gpf;
    fault.level = level;
    return(fault)
}

val AArch64_PAMax : unit -> {32, 36, 40, 42, 44, 48, 52, 56}

function AArch64_PAMax () = {
    let 'pamax = __IMPDEF_integer("Maximum Physical Address Size");
    assert(pamax == 32 | pamax == 36 | pamax == 40 | pamax == 42 | pamax == 44 | pamax == 48 | pamax == 52 | pamax == 56);
    return(pamax)
}

val GPCRegistersConsistent : unit -> bool

function GPCRegistersConsistent () = {
    if GPCCR_EL3[PPS] == 0b111 | DecodePPS() > AArch64_PAMax() then {
        return(false)
    };
    if GPCCR_EL3[PGS] == 0b11 then {
        return(false)
    };
    if GPCCR_EL3[SH] == 0b01 then {
        return(false)
    };
    if (GPCCR_EL3[ORGN] @ GPCCR_EL3[IRGN]) == 0b0000 & GPCCR_EL3[SH] != 0b10 then {
        return(false)
    };
    return(true)
}

val GPICheck : (PASpace, bits(4)) -> bool

function GPICheck (paspace, gpi) = {
    match gpi {
      ? if ? == GPT_NoAccess => {
          return(false)
      },
      ? if ? == GPT_Secure => {
          assert(HaveSecureEL2Ext());
          return(paspace == PAS_Secure)
      },
      ? if ? == GPT_NonSecure => {
          return(paspace == PAS_NonSecure)
      },
      ? if ? == GPT_Root => {
          return(paspace == PAS_Root)
      },
      ? if ? == GPT_Realm => {
          return(paspace == PAS_Realm)
      },
      ? if ? == GPT_Any => {
          return(true)
      },
      _ => {
          Unreachable();
          return(undefined : bool)
      }
    }
}

bitfield GPTBR_EL3_Type : bits(64) = {BADDR : 39..0}

register GPTBR_EL3 : GPTBR_EL3_Type

val GPIValid : bits(4) -> bool

function GPIValid gpi = {
    if gpi == GPT_Secure then {
        return(HaveSecureEL2Ext())
    };
    return(gpi == GPT_NoAccess | gpi == GPT_NonSecure | gpi == GPT_Root | gpi == GPT_Realm | gpi == GPT_Any)
}

val GPTL0Size : unit -> int

function GPTL0Size () = {
    match GPCCR_EL3[L0GPTSZ] {
      0b0000 => {
          return(GPTRange_1GB)
      },
      0b0100 => {
          return(GPTRange_16GB)
      },
      0b0110 => {
          return(GPTRange_64GB)
      },
      0b1001 => {
          return(GPTRange_512GB)
      },
      _ => {
          Unreachable()
      }
    };
    return(30)
}

val DecodeGPTBlock : (PGSe, bits(64)) -> (GPCF, GPTEntry)

function DecodeGPTBlock (pgs, entry) = {
    assert(entry[3 .. 0] == GPT_Block);
    result : GPTEntry = undefined;
    if not_bool(IsZero(entry[63 .. 8])) then {
        return((GPCF_Walk, __UNKNOWN_GPTEntry()))
    };
    if not_bool(GPIValid(entry[7 .. 4])) then {
        return((GPCF_Walk, __UNKNOWN_GPTEntry()))
    };
    result.gpi = entry[7 .. 4];
    result.level = 0;
    match pgs {
      PGS_4KB => {
          result.size = GPTRange_4KB
      },
      PGS_16KB => {
          result.size = GPTRange_16KB
      },
      PGS_64KB => {
          result.size = GPTRange_64KB
      },
      _ => {
          Unreachable()
      }
    };
    result.contig_size = GPTL0Size();
    return((GPCF_None, result))
}

val DecodeGPTContiguous : (PGSe, bits(64)) -> (GPCF, GPTEntry)

function DecodeGPTContiguous (pgs, entry) = {
    assert(entry[3 .. 0] == GPT_Contig);
    result : GPTEntry = undefined;
    if not_bool(IsZero(entry[63 .. 10])) then {
        return((GPCF_Walk, result))
    };
    result.gpi = entry[7 .. 4];
    if not_bool(GPIValid(result.gpi)) then {
        return((GPCF_Walk, result))
    };
    match pgs {
      PGS_4KB => {
          result.size = GPTRange_4KB
      },
      PGS_16KB => {
          result.size = GPTRange_16KB
      },
      PGS_64KB => {
          result.size = GPTRange_64KB
      },
      _ => {
          Unreachable()
      }
    };
    match entry[9 .. 8] {
      0b01 => {
          result.contig_size = GPTRange_2MB
      },
      0b10 => {
          result.contig_size = GPTRange_32MB
      },
      0b11 => {
          result.contig_size = GPTRange_512MB
      },
      _ => {
          return((GPCF_Walk, __UNKNOWN_GPTEntry()))
      }
    };
    result.level = 1;
    return((GPCF_None, result))
}

val DecodeGPTGranules : forall 'index.
  (PGSe, int('index), bits(64)) -> (GPCF, GPTEntry)

function DecodeGPTGranules (pgs, index, entry) = {
    result : GPTEntry = undefined;
    foreach (i from 0 to 15 by 1 in inc) {
        if not_bool(GPIValid(Slice(entry, i * 4, 4))) then {
            return((GPCF_Walk, result))
        };
        ()
    };
    result.gpi = Slice(entry, index * 4, 4);
    match pgs {
      PGS_4KB => {
          result.size = GPTRange_4KB
      },
      PGS_16KB => {
          result.size = GPTRange_16KB
      },
      PGS_64KB => {
          result.size = GPTRange_64KB
      },
      _ => {
          Unreachable()
      }
    };
    result.contig_size = result.size;
    result.level = 1;
    return((GPCF_None, result))
}

val DecodeGPTTable : (PGSe, bits(64)) -> (GPCF, GPTTable)

function DecodeGPTTable (pgs, entry) = {
    assert(entry[3 .. 0] == GPT_Table);
    result : GPTTable = undefined;
    if not_bool(IsZero(entry[63 .. 52] @ entry[11 .. 4])) then {
        return((GPCF_Walk, __UNKNOWN_GPTTable()))
    };
    let 'l0sz = GPTL0Size();
    p : {12, 14, 16} = 12;
    match pgs {
      PGS_4KB => {
          p = 12
      },
      PGS_16KB => {
          p = 14
      },
      PGS_64KB => {
          p = 16
      },
      _ => {
          Unreachable()
      }
    };
    let 'p = p;
    if not_bool(is_zero_subrange(entry, l0sz - p - 2, 12)) then {
        return((GPCF_Walk, __UNKNOWN_GPTTable()))
    };
    match pgs {
      PGS_4KB => {
          result.address = entry[55 .. 17] @ Zeros(17)
      },
      PGS_16KB => {
          result.address = entry[55 .. 15] @ Zeros(15)
      },
      PGS_64KB => {
          result.address = entry[55 .. 13] @ Zeros(13)
      },
      _ => {
          Unreachable()
      }
    };
    if AbovePPS(result.address) then {
        return((GPCF_AddressSize, __UNKNOWN_GPTTable()))
    };
    return((GPCF_None, result))
}

val DecodePGS : bits(2) -> PGSe

function DecodePGS pgs = {
    match pgs {
      0b00 => {
          return(PGS_4KB)
      },
      0b10 => {
          return(PGS_16KB)
      },
      0b01 => {
          return(PGS_64KB)
      },
      _ => {
          Unreachable();
          return(undefined : PGSe)
      }
    }
}

val GPIIndex : bits(56) -> int

function GPIIndex pa = {
    match DecodePGS(GPCCR_EL3[PGS]) {
      PGS_4KB => {
          return(UInt(pa[15 .. 12]))
      },
      PGS_16KB => {
          return(UInt(pa[17 .. 14]))
      },
      PGS_64KB => {
          return(UInt(pa[19 .. 16]))
      },
      _ => {
          Unreachable();
          return(undefined : int)
      }
    }
}

val GPTLevel0Index : bits(56) -> int

function GPTLevel0Index pa = {
    let 'pps = DecodePPS();
    let 'l0sz = GPTL0Size();
    if pps <= l0sz then {
        return(0)
    };
    assert(constraint((0 <= 'l0sz & 'pps - 1 < 56)));
    return(UInt(pa[pps - 1 .. l0sz]))
}

val GPTLevel1Index : bits(56) -> int

function GPTLevel1Index pa = {
    let 'l0sz = GPTL0Size();
    match DecodePGS(GPCCR_EL3[PGS]) {
      PGS_4KB => {
          assert(constraint((16 <= 'l0sz - 1 & 'l0sz - 1 < 56)));
          return(UInt(pa[l0sz - 1 .. 16]))
      },
      PGS_16KB => {
          assert(constraint((18 <= 'l0sz - 1 & 'l0sz - 1 < 56)));
          return(UInt(pa[l0sz - 1 .. 18]))
      },
      PGS_64KB => {
          assert(constraint((20 <= 'l0sz - 1 & 'l0sz - 1 < 56)));
          return(UInt(pa[l0sz - 1 .. 20]))
      },
      _ => {
          Unreachable();
          return(undefined : int)
      }
    }
}

val GPTTLBCache : (PGSe, GPTEntry) -> unit

val GPTTLBLookup : (bits(56), PGSe) -> GPTTLBLine

register __tlb_enabled : bool = false

val GPTWalk : (bits(56), AccessDescriptor) -> (GPCFRecord, GPTEntry)

function GPTWalk (pa, accdesc) = {
    gpi_index : int = undefined;
    gpttlbline : GPTTLBLine = undefined;
    let pgs : PGSe = DecodePGS(GPCCR_EL3[PGS]);
    if __tlb_enabled then {
        let gpttlbline : GPTTLBLine = GPTTLBLookup(pa, pgs);
        if gpttlbline.valid_name then {
            return((GPCNoFault(), gpttlbline.gpt_entry))
        };
        ()
    };
    base : bits(56) = ZeroExtend(GPTBR_EL3[BADDR] @ Zeros(12), 56);
    let 'pps = DecodePPS();
    let 'l0sz = GPTL0Size();
    let 'alignment = Max(pps - l0sz + 3, 12);
    assert(constraint(56 >= 'alignment));
    let base : bits(56) = base & not_vec(ZeroExtend(Ones(alignment), 56));
    let gptaccdesc : AccessDescriptor = CreateAccDescGPTW(accdesc);
    gptaddrdesc : AddressDescriptor = undefined;
    gptaddrdesc.memattrs = WalkMemAttrs(GPCCR_EL3[SH], GPCCR_EL3[ORGN], GPCCR_EL3[IRGN]);
    gptaddrdesc.fault = NoFault__1(gptaccdesc);
    gptaddrdesc.paddress.paspace = PAS_Root;
    gptaddrdesc.paddress.address = base + GPTLevel0Index(pa) * 8;
    level_0_entry : bits(64) = undefined;
    memstatus : PhysMemRetStatus = undefined;
    (memstatus, level_0_entry) = PhysMemRead(gptaddrdesc, 8, gptaccdesc, None());
    if IsFault__2(memstatus) then {
        return((GPCFault(GPCF_EABT, 0), __UNKNOWN_GPTEntry()))
    };
    result : GPTEntry = undefined;
    table : GPTTable = undefined;
    gpf : GPCF = undefined;
    match level_0_entry[3 .. 0] {
      ? if ? == GPT_Block => {
          (gpf, result) = DecodeGPTBlock(pgs, level_0_entry);
          result.pa = pa;
          if __tlb_enabled & gpf == GPCF_None then {
              GPTTLBCache(pgs, result)
          };
          return((GPCFault(gpf, 0), result))
      },
      ? if ? == GPT_Table => {
          (gpf, table) = DecodeGPTTable(pgs, level_0_entry);
          if gpf != GPCF_None then {
              return((GPCFault(gpf, 0), __UNKNOWN_GPTEntry()))
          };
          ()
      },
      _ => {
          return((GPCFault(GPCF_Walk, 0), __UNKNOWN_GPTEntry()))
      }
    };
    assert(level_0_entry[3 .. 0] == GPT_Table);
    let 'offset = GPTLevel1Index(pa) * 8;
    gptaddrdesc.paddress.address = table.address + offset;
    level_1_entry : bits(64) = undefined;
    (memstatus, level_1_entry) = PhysMemRead(gptaddrdesc, 8, gptaccdesc, None());
    if IsFault__2(memstatus) then {
        return((GPCFault(GPCF_EABT, 1), __UNKNOWN_GPTEntry()))
    };
    match level_1_entry[3 .. 0] {
      ? if ? == GPT_Contig => {
          (gpf, result) = DecodeGPTContiguous(pgs, level_1_entry)
      },
      _ => {
          let 'gpi_index = GPIIndex(pa);
          (gpf, result) = DecodeGPTGranules(pgs, gpi_index, level_1_entry)
      }
    };
    if gpf != GPCF_None then {
        return((GPCFault(gpf, 1), __UNKNOWN_GPTEntry()))
    };
    result.pa = pa;
    if __tlb_enabled then {
        GPTTLBCache(pgs, result)
    };
    return((GPCNoFault(), result))
}

val SetTLBIncludesGPT : forall 'gpt_range. (TLBContext, int('gpt_range)) -> unit

val TLBIncludesGPT : TLBContext -> bool

val GranuleProtectionCheck : (AddressDescriptor, AccessDescriptor) -> GPCFRecord

function GranuleProtectionCheck (addrdesc, accdesc) = {
    gpcf : GPCFRecord = undefined;
    gpt_entry : GPTEntry = undefined;
    assert(HaveRME());
    if __tlb_enabled & accdesc.acctype != AccessType_TTW then {
        if TLBIncludesGPT(addrdesc.tlbcontext) then {
            return(GPCNoFault())
        };
        ()
    };
    let address : FullAddress = addrdesc.paddress;
    if GPCCR_EL3[GPC] == 0b0 then {
        if __tlb_enabled then {
            SetTLBIncludesGPT(addrdesc.tlbcontext, 56)
        };
        return(GPCNoFault())
    };
    if not_bool(GPCRegistersConsistent()) then {
        return(GPCFault(GPCF_Walk, 0))
    };
    if AbovePPS(address.address) then {
        if address.paspace == PAS_NonSecure then {
            if __tlb_enabled & accdesc.acctype != AccessType_TTW then {
                SetTLBIncludesGPT(addrdesc.tlbcontext, 56)
            };
            return(GPCNoFault())
        } else {
            return(GPCFault(GPCF_Fail, 0))
        }
    };
    let gpt_base : bits(56) = ZeroExtend(GPTBR_EL3[BADDR] @ Zeros(12), 56);
    if AbovePPS(gpt_base) then {
        return(GPCFault(GPCF_AddressSize, 0))
    };
    (gpcf, gpt_entry) = GPTWalk(address.address, accdesc);
    if gpcf.gpf != GPCF_None then {
        return(gpcf)
    };
    let permitted : bool = GPICheck(address.paspace, gpt_entry.gpi);
    if not_bool(permitted) then {
        let gpcf : GPCFRecord = GPCFault(GPCF_Fail, gpt_entry.level);
        return(gpcf)
    };
    if __tlb_enabled & accdesc.acctype != AccessType_TTW then {
        SetTLBIncludesGPT(addrdesc.tlbcontext, gpt_entry.contig_size)
    };
    return(GPCNoFault())
}

val FetchDescriptor : forall 'N, 'N in {32, 64, 128}.
  (bits(1), AddressDescriptor, AccessDescriptor, FaultRecord, int('N), TranslationInfo) -> (FaultRecord, bits('N))

function FetchDescriptor (ee, walkaddress, walkaccess, fault_in, N, translation_info) = {
    assert((N == 32 | N == 64) | N == 128);
    descriptor : bits('N) = undefined;
    fault : FaultRecord = fault_in;
    if HaveRME() then {
        fault.gpcf = GranuleProtectionCheck(walkaddress, walkaccess);
        if fault.gpcf.gpf != GPCF_None then {
            fault.statuscode = Fault_GPCFOnWalk;
            fault.paddress = walkaddress.paddress;
            fault.gpcfs2walk = fault.secondstage;
            return((fault, __UNKNOWN_bits(N)))
        };
        ()
    };
    memstatus : PhysMemRetStatus = undefined;
    (memstatus, descriptor) = PhysMemRead(walkaddress, DIV(N, 8), walkaccess, Some(translation_info));
    if IsFault__2(memstatus) then {
        let iswrite : bool = false;
        fault = HandleExternalTTWAbort(memstatus, iswrite, walkaddress, walkaccess, DIV(N, 8), fault);
        if IsFault__1(fault.statuscode) then {
            return((fault, __UNKNOWN_bits(N)))
        };
        ()
    };
    if ee == 0b1 then {
        descriptor = BigEndianReverse(descriptor)
    };
    let descriptor = descriptor;
    return((fault, descriptor))
}

val ContiguousSize : forall 'level. (bits(1), TGx, int('level)) -> int

function ContiguousSize (d128, tgx, level) = {
    if d128 == 0b1 then {
        match tgx {
          TGx_4KB => {
              assert(level == 1 | level == 2 | level == 3);
              return(if level == 1 then 2 else 4)
          },
          TGx_16KB => {
              assert(level == 1 | level == 2 | level == 3);
              if level == 1 then {
                  return(2)
              } else if level == 2 then {
                  return(4)
              } else {
                  return(6)
              }
          },
          TGx_64KB => {
              assert(level == 2 | level == 3);
              return(if level == 2 then 6 else 4)
          },
          _ => {
              return(undefined : int)
          }
        }
    } else {
        match tgx {
          TGx_4KB => {
              assert(level == 1 | level == 2 | level == 3);
              return(4)
          },
          TGx_16KB => {
              assert(level == 2 | level == 3);
              return(if level == 2 then 5 else 7)
          },
          TGx_64KB => {
              assert(level == 2 | level == 3);
              return(5)
          },
          _ => {
              return(undefined : int)
          }
        }
    }
}

val TGxGranuleBits : TGx -> int

function TGxGranuleBits tgx = {
    match tgx {
      TGx_4KB => {
          return(12)
      },
      TGx_16KB => {
          return(14)
      },
      TGx_64KB => {
          return(16)
      },
      _ => {
          return(undefined : int)
      }
    }
}

val TranslationSize : forall 'level. (bits(1), TGx, int('level)) -> int

function TranslationSize (d128, tgx, level) = {
    let 'granulebits = TGxGranuleBits(tgx);
    let 'descsizelog2 = if d128 == 0b1 then 4 else 3;
    let 'blockbits = (FINAL_LEVEL - level) * (granulebits - descsizelog2);
    return(granulebits + blockbits)
}

val StageOA : (bits(64), bits(1), TGx, TTWState) -> FullAddress

function StageOA (ia, d128, tgx, walkstate) = {
    oa : FullAddress = undefined;
    csize : int = undefined;
    let 'tsize = TranslationSize(d128, tgx, walkstate.level);
    if walkstate.contiguous == 0b1 then {
        csize = ContiguousSize(d128, tgx, walkstate.level)
    } else {
        csize = 0
    };
    let 'csize = csize;
    let 'ia_msb = tsize + csize;
    oa.paspace = walkstate.baseaddress.paspace;
    assert(constraint((0 <= 'ia_msb & 'ia_msb <= 55)));
    assert(constraint(0 <= 'ia_msb - 1));
    oa.address = walkstate.baseaddress.address[55 .. ia_msb] @ ia[ia_msb - 1 .. 0];
    return(oa)
}

val RegimeUsingAArch32 : Regime -> bool

function RegimeUsingAArch32 regime = {
    match regime {
      Regime_EL10 => {
          return(ELUsingAArch32(EL1))
      },
      Regime_EL30 => {
          return(true)
      },
      Regime_EL20 => {
          return(false)
      },
      Regime_EL2 => {
          return(ELUsingAArch32(EL2))
      },
      Regime_EL3 => {
          return(false)
      },
      _ => {
          return(undefined : bool)
      }
    }
}

val SecurityStateForRegime : Regime -> SecurityState

function SecurityStateForRegime regime = {
    match regime {
      Regime_EL3 => {
          return(SecurityStateAtEL(EL3))
      },
      Regime_EL30 => {
          return(SS_Secure)
      },
      Regime_EL2 => {
          return(SecurityStateAtEL(EL2))
      },
      Regime_EL20 => {
          return(SecurityStateAtEL(EL2))
      },
      Regime_EL10 => {
          return(SecurityStateAtEL(EL1))
      },
      _ => {
          return(undefined : SecurityState)
      }
    }
}

val DecodePASpace : (bits(1), bits(1)) -> PASpace

function DecodePASpace (nse, ns) = {
    match nse @ ns {
      0b00 => {
          return(PAS_Secure)
      },
      0b01 => {
          return(PAS_NonSecure)
      },
      0b10 => {
          return(PAS_Root)
      },
      0b11 => {
          return(PAS_Realm)
      },
      _ => {
          return(undefined : PASpace)
      }
    }
}

val HasUnprivileged : Regime -> bool

function HasUnprivileged regime = {
    return(regime == Regime_EL20 | regime == Regime_EL30 | regime == Regime_EL10)
}

val CreateAddressDescriptor : (bits(64), FullAddress, MemoryAttributes) -> AddressDescriptor

function CreateAddressDescriptor (va, pa, memattrs) = {
    addrdesc : AddressDescriptor = undefined;
    addrdesc.paddress = pa;
    addrdesc.vaddress = va;
    addrdesc.memattrs = memattrs;
    addrdesc.fault = NoFault();
    addrdesc.s1assured = false;
    return(addrdesc)
}

val CreateFaultyAddressDescriptor : (bits(64), FaultRecord) -> AddressDescriptor

function CreateFaultyAddressDescriptor (va, fault) = {
    addrdesc : AddressDescriptor = undefined;
    addrdesc.vaddress = va;
    addrdesc.fault = fault;
    return(addrdesc)
}

val AlignmentFault : AccessDescriptor -> FaultRecord

function AlignmentFault accdesc = {
    fault : FaultRecord = undefined;
    fault.statuscode = Fault_Alignment;
    fault.access = accdesc;
    fault.secondstage = false;
    fault.s2fs1walk = false;
    fault.write = not_bool(accdesc.read) & accdesc.write;
    fault.gpcfs2walk = false;
    fault.gpcf = GPCNoFault();
    fault.level = 0; // interface-v9: later ASL assumes uninit level is zero.
    return(fault)
}

val ExclusiveFault : AccessDescriptor -> FaultRecord

function ExclusiveFault accdesc = {
    fault : FaultRecord = undefined;
    fault.statuscode = Fault_Exclusive;
    fault.access = accdesc;
    fault.secondstage = false;
    fault.s2fs1walk = false;
    fault.write = not_bool(accdesc.read) & accdesc.write;
    fault.gpcfs2walk = false;
    fault.gpcf = GPCNoFault();
    return(fault)
}

val AArch64_MaxTxSZ : TGx -> int

function AArch64_MaxTxSZ tgx = {
    if HaveSmallTranslationTableExt() then {
        match tgx {
          TGx_4KB => {
              return(48)
          },
          TGx_16KB => {
              return(48)
          },
          TGx_64KB => {
              return(47)
          }
        }
    };
    return(39)
}

val AArch64_S1MinTxSZ : (Regime, bits(1), bits(1), TGx) -> int

function AArch64_S1MinTxSZ (regime, d128, ds, tgx) = {
    if Have56BitVAExt() & d128 == 0b1 then {
        if HasUnprivileged(regime) then {
            return(9)
        } else {
            return(8)
        }
    };
    if Have52BitVAExt() & tgx == TGx_64KB | ds == 0b1 then {
        return(12)
    };
    return(16)
}

val AArch64_S1TxSZFaults : (Regime, S1TTWParams) -> bool

function AArch64_S1TxSZFaults (regime, walkparams) = {
    let 'mintxsz = AArch64_S1MinTxSZ(regime, walkparams.d128, walkparams.ds, walkparams.tgx);
    let 'maxtxsz = AArch64_MaxTxSZ(walkparams.tgx);
    if UInt(walkparams.txsz) < mintxsz then {
        return(Have52BitVAExt() | __IMPDEF_boolean("Fault on TxSZ value below minimum"))
    };
    if UInt(walkparams.txsz) > maxtxsz then {
        return(__IMPDEF_boolean("Fault on TxSZ value above maximum"))
    };
    return(false)
}

val AArch64_PACEffectiveTxSZ : (Regime, S1TTWParams) -> bits(6)

function AArch64_PACEffectiveTxSZ (regime, walkparams) = {
    let 's1maxtxsz = AArch64_MaxTxSZ(walkparams.tgx);
    let 's1mintxsz = AArch64_S1MinTxSZ(regime, walkparams.d128, walkparams.ds, walkparams.tgx);
    if AArch64_S1TxSZFaults(regime, walkparams) then {
        if ConstrainUnpredictable(Unpredictable_RESTnSZ) == Constraint_FORCE then {
            if UInt(walkparams.txsz) < s1mintxsz then {
                return(s1mintxsz[5 .. 0])
            };
            if UInt(walkparams.txsz) > s1maxtxsz then {
                return(s1maxtxsz[5 .. 0])
            };
            ()
        };
        ()
    } else if UInt(walkparams.txsz) < s1mintxsz then {
        return(s1mintxsz[5 .. 0])
    } else if UInt(walkparams.txsz) > s1maxtxsz then {
        return(s1maxtxsz[5 .. 0])
    } else ();
    return(walkparams.txsz)
}

val AArch64_GetVARange : bits(64) -> VARange

function AArch64_GetVARange va = {
    if [va[55]] == 0b0 then {
        return(VARange_LOWER)
    } else {
        return(VARange_UPPER)
    }
}

val AArch64_HaveS1TG : TGx -> bool

function AArch64_HaveS1TG tgx = {
    match tgx {
      TGx_4KB => {
          return(__IMPDEF_boolean("Has 4K Translation Granule"))
      },
      TGx_16KB => {
          return(__IMPDEF_boolean("Has 16K Translation Granule"))
      },
      TGx_64KB => {
          return(__IMPDEF_boolean("Has 64K Translation Granule"))
      },
      _ => {
          return(undefined : bool)
      }
    }
}

val AArch64_S1DecodeTG0 : bits(2) -> TGx

function AArch64_S1DecodeTG0 tg0_in = {
    tg0 : bits(2) = tg0_in;
    tgx : TGx = undefined;
    if tg0 == 0b11 then {
        tg0 = __IMPDEF_bits(2, "TG0 encoded granule size")
    };
    match tg0 {
      0b00 => {
          tgx = TGx_4KB
      },
      0b01 => {
          tgx = TGx_64KB
      },
      0b10 => {
          tgx = TGx_16KB
      },
      _ => ()
    };
    if not_bool(AArch64_HaveS1TG(tgx)) then {
        match __IMPDEF_bits(2, "TG0 encoded granule size") {
          0b00 => {
              tgx = TGx_4KB
          },
          0b01 => {
              tgx = TGx_64KB
          },
          0b10 => {
              tgx = TGx_16KB
          },
          _ => ()
        }
    };
    return(tgx)
}

val AArch64_S1DecodeTG1 : bits(2) -> TGx

function AArch64_S1DecodeTG1 tg1_in = {
    tg1 : bits(2) = tg1_in;
    tgx : TGx = undefined;
    if tg1 == 0b00 then {
        tg1 = __IMPDEF_bits(2, "TG1 encoded granule size")
    };
    match tg1 {
      0b10 => {
          tgx = TGx_4KB
      },
      0b11 => {
          tgx = TGx_64KB
      },
      0b01 => {
          tgx = TGx_16KB
      },
      _ => ()
    };
    if not_bool(AArch64_HaveS1TG(tgx)) then {
        match __IMPDEF_bits(2, "TG1 encoded granule size") {
          0b10 => {
              tgx = TGx_4KB
          },
          0b11 => {
              tgx = TGx_64KB
          },
          0b01 => {
              tgx = TGx_16KB
          },
          _ => ()
        }
    };
    return(tgx)
}

val IsTCR2EL1Enabled : unit -> bool

function IsTCR2EL1Enabled () = {
    if not_bool(HaveFeatTCR2()) then {
        return(false)
    };
    if HaveEL(EL3) & SCR_EL3[TCR2En] == 0b0 then {
        return(false)
    } else if EL2Enabled() & (not_bool(IsHCRXEL2Enabled()) | HCRX_EL2[TCR2En] == 0b0) then {
        return(false)
    } else {
        return(true)
    }
}

bitfield MAIR2_EL1_Type : bits(64) =
  {
    Attr7 : 63..56,
    Attr6 : 55..48,
    Attr5 : 47..40,
    Attr4 : 39..32,
    Attr3 : 31..24,
    Attr2 : 23..16,
    Attr1 : 15..8,
    Attr0 : 7..0
  }

register MAIR2_EL1 : MAIR2_EL1_Type

bitfield MAIR_EL1_Type : bits(64) =
  {
    Attr7 : 63..56,
    Attr6 : 55..48,
    Attr5 : 47..40,
    Attr4 : 39..32,
    Attr3 : 31..24,
    Attr2 : 23..16,
    Attr1 : 15..8,
    Attr0 : 7..0
  }

register MAIR_EL1 : MAIR_EL1_Type

bitfield PIRE0_EL1_Type : bits(64) =
  {
    Perm15 : 63..60,
    Perm14 : 59..56,
    Perm13 : 55..52,
    Perm12 : 51..48,
    Perm11 : 47..44,
    Perm10 : 43..40,
    Perm9 : 39..36,
    Perm8 : 35..32,
    Perm7 : 31..28,
    Perm6 : 27..24,
    Perm5 : 23..20,
    Perm4 : 19..16,
    Perm3 : 15..12,
    Perm2 : 11..8,
    Perm1 : 7..4,
    Perm0 : 3..0
  }

register PIRE0_EL1 : PIRE0_EL1_Type

bitfield PIR_EL1_Type : bits(64) =
  {
    Perm15 : 63..60,
    Perm14 : 59..56,
    Perm13 : 55..52,
    Perm12 : 51..48,
    Perm11 : 47..44,
    Perm10 : 43..40,
    Perm9 : 39..36,
    Perm8 : 35..32,
    Perm7 : 31..28,
    Perm6 : 27..24,
    Perm5 : 23..20,
    Perm4 : 19..16,
    Perm3 : 15..12,
    Perm2 : 11..8,
    Perm1 : 7..4,
    Perm0 : 3..0
  }

register PIR_EL1 : PIR_EL1_Type

bitfield TCR2_EL1_Type : bits(64) =
  {
    DisCH1 : 15..15,
    DisCH0 : 14..14,
    HAFT : 11..11,
    PTTWI : 10..10,
    D128 : 5..5,
    AIE : 4..4,
    POE : 3..3,
    E0POE : 2..2,
    PIE : 1..1,
    PnCH : 0..0
  }

register TCR2_EL1 : TCR2_EL1_Type

val AArch64_S1TTWParamsEL10 : VARange -> S1TTWParams

function AArch64_S1TTWParamsEL10 varange = {
    walkparams : S1TTWParams = undefined;
    if Have128BitDescriptorExt() & IsTCR2EL1Enabled() then {
        walkparams.d128 = TCR2_EL1[D128]
    } else {
        walkparams.d128 = 0b0
    };
    if varange == VARange_LOWER then {
        walkparams.tgx = AArch64_S1DecodeTG0(TCR_EL1[TG0]);
        walkparams.txsz = TCR_EL1[T0SZ];
        walkparams.irgn = TCR_EL1[IRGN0];
        walkparams.orgn = TCR_EL1[ORGN0];
        walkparams.sh = TCR_EL1[SH0];
        walkparams.tbi = TCR_EL1[TBI0];
        walkparams.nfd = if HaveSVE() | HaveTME() then TCR_EL1[NFD0] else 0b0;
        walkparams.tbid = if HavePACExt() then TCR_EL1[TBID0] else 0b0;
        walkparams.e0pd = if HaveE0PDExt() then TCR_EL1[E0PD0] else 0b0;
        walkparams.hpd = if AArch64_HaveHPDExt() then TCR_EL1[HPD0] else 0b0;
        walkparams.mtx = if HaveMTE4Ext() then TCR_EL1[MTX0] else 0b0;
        walkparams.skl = if walkparams.d128 == 0b1 then TTBR0_EL1_read()[SKL]
        else
          0b00;
        walkparams.disch = if walkparams.d128 == 0b1 then TCR2_EL1[DisCH0] else
          0b0
    } else {
        walkparams.tgx = AArch64_S1DecodeTG1(TCR_EL1[TG1]);
        walkparams.txsz = TCR_EL1[T1SZ];
        walkparams.irgn = TCR_EL1[IRGN1];
        walkparams.orgn = TCR_EL1[ORGN1];
        walkparams.sh = TCR_EL1[SH1];
        walkparams.tbi = TCR_EL1[TBI1];
        walkparams.nfd = if HaveSVE() | HaveTME() then TCR_EL1[NFD1] else 0b0;
        walkparams.tbid = if HavePACExt() then TCR_EL1[TBID1] else 0b0;
        walkparams.e0pd = if HaveE0PDExt() then TCR_EL1[E0PD1] else 0b0;
        walkparams.hpd = if AArch64_HaveHPDExt() then TCR_EL1[HPD1] else 0b0;
        walkparams.mtx = if HaveMTE4Ext() then TCR_EL1[MTX1] else 0b0;
        walkparams.skl = if walkparams.d128 == 0b1 then TTBR1_EL1_read()[SKL]
        else
          0b00;
        walkparams.disch = if walkparams.d128 == 0b1 then TCR2_EL1[DisCH1] else
          0b0
    };
    walkparams.mair = Mk_MAIRType(MAIR_EL1.bits);
    if HaveAIEExt() then {
        walkparams.mair2 = Mk_MAIRType(MAIR2_EL1.bits)
    };
    walkparams.aie = if HaveAIEExt() & IsTCR2EL1Enabled() then TCR2_EL1[AIE]
    else
      0b0;
    walkparams.wxn = SCTLR_EL1[WXN];
    walkparams.ps = TCR_EL1[IPS];
    walkparams.ee = SCTLR_EL1[EE];
    if HaveEL(EL3) & (not_bool(HaveRME()) | HaveSecureEL2Ext()) then {
        walkparams.sif = SCR_EL3[SIF]
    } else {
        walkparams.sif = 0b0
    };
    if EL2Enabled() then {
        walkparams.dc = HCR_EL2[DC];
        walkparams.dct = if HaveMTE2Ext() then HCR_EL2[DCT] else 0b0
    };
    if HaveTrapLoadStoreMultipleDeviceExt() then {
        walkparams.ntlsmd = SCTLR_EL1[nTLSMD]
    } else {
        walkparams.ntlsmd = 0b1
    };
    if EL2Enabled() then {
        if (HCR_EL2[NV] @ HCR_EL2[NV1]) == 0b01 then {
            match ConstrainUnpredictable(Unpredictable_NVNV1) {
              Constraint_NVNV1_00 => {
                  walkparams.nv1 = 0b0
              },
              Constraint_NVNV1_01 => {
                  walkparams.nv1 = 0b1
              },
              Constraint_NVNV1_11 => {
                  walkparams.nv1 = 0b1
              },
              _ => ()
            }
        } else {
            walkparams.nv1 = HCR_EL2[NV1]
        }
    } else {
        walkparams.nv1 = 0b0
    };
    walkparams.cmow = if HaveFeatCMOW() then SCTLR_EL1[CMOW] else 0b0;
    walkparams.ha = if HaveAccessFlagUpdateExt() then TCR_EL1[HA] else 0b0;
    walkparams.hd = if HaveDirtyBitModifierExt() then TCR_EL1[HD] else 0b0;
    if (walkparams.tgx == TGx_4KB | walkparams.tgx == TGx_16KB) & Have52BitIPAAndPASpaceExt() then {
        walkparams.ds = TCR_EL1[DS]
    } else {
        walkparams.ds = 0b0
    };
    if walkparams.d128 == 0b1 then {
        walkparams.pie = 0b1
    } else {
        walkparams.pie = if HaveS1PIExt() & IsTCR2EL1Enabled() then
          TCR2_EL1[PIE]
        else
          0b0
    };
    if HaveS1PIExt() then {
        walkparams.pir = Mk_S1PIRType(PIR_EL1.bits);
        if walkparams.nv1 != 0b1 then {
            walkparams.pire0 = Mk_S1PIRType(PIRE0_EL1.bits)
        };
        ()
    };
    if HavePAN3Ext() then {
        walkparams.epan = if walkparams.pie == 0b0 then SCTLR_EL1[EPAN] else 0b1
    } else {
        walkparams.epan = 0b0
    };
    if (HaveTHExt() & walkparams.d128 == 0b0) & IsTCR2EL1Enabled() then {
        walkparams.pnch = TCR2_EL1[PnCH]
    } else {
        walkparams.pnch = 0b0
    };
    if (HaveAccessFlagUpdateForTableExt() & walkparams.ha == 0b1) & IsTCR2EL1Enabled() then {
        walkparams.haft = TCR2_EL1[HAFT]
    } else {
        walkparams.haft = 0b0
    };
    walkparams.emec = if HaveFeatMEC() & IsSCTLR2EL2Enabled() then
      SCTLR2_EL2[EMEC]
    else
      0b0;
    return(walkparams)
}

val IsTCR2EL2Enabled : unit -> bool

function IsTCR2EL2Enabled () = {
    if not_bool(HaveFeatTCR2()) then {
        return(false)
    };
    if HaveEL(EL3) & SCR_EL3[TCR2En] == 0b0 then {
        return(false)
    };
    return(EL2Enabled())
}

bitfield MAIR2_EL2_Type : bits(64) =
  {
    Attr7 : 63..56,
    Attr6 : 55..48,
    Attr5 : 47..40,
    Attr4 : 39..32,
    Attr3 : 31..24,
    Attr2 : 23..16,
    Attr1 : 15..8,
    Attr0 : 7..0
  }

register MAIR2_EL2 : MAIR2_EL2_Type

bitfield MAIR_EL2_Type : bits(64) =
  {
    Attr7 : 63..56,
    Attr6 : 55..48,
    Attr5 : 47..40,
    Attr4 : 39..32,
    Attr3 : 31..24,
    Attr2 : 23..16,
    Attr1 : 15..8,
    Attr0 : 7..0
  }

register MAIR_EL2 : MAIR_EL2_Type

bitfield PIR_EL2_Type : bits(64) =
  {
    Perm15 : 63..60,
    Perm14 : 59..56,
    Perm13 : 55..52,
    Perm12 : 51..48,
    Perm11 : 47..44,
    Perm10 : 43..40,
    Perm9 : 39..36,
    Perm8 : 35..32,
    Perm7 : 31..28,
    Perm6 : 27..24,
    Perm5 : 23..20,
    Perm4 : 19..16,
    Perm3 : 15..12,
    Perm2 : 11..8,
    Perm1 : 7..4,
    Perm0 : 3..0
  }

register PIR_EL2 : PIR_EL2_Type

bitfield TCR2_EL2_Type : bits(64) =
  {
    DisCH1 : 15..15,
    DisCH0 : 14..14,
    AMEC1 : 13..13,
    AMEC0 : 12..12,
    HAFT : 11..11,
    PTTWI : 10..10,
    SKL1 : 9..8,
    SKL0 : 7..6,
    D128 : 5..5,
    AIE : 4..4,
    POE : 3..3,
    E0POE : 2..2,
    PIE : 1..1,
    PnCH : 0..0
  }

register TCR2_EL2 : TCR2_EL2_Type

val AArch64_S1TTWParamsEL2 : SecurityState -> S1TTWParams

function AArch64_S1TTWParamsEL2 ss = {
    walkparams : S1TTWParams = undefined;
    walkparams.tgx = AArch64_S1DecodeTG0(TCR_EL2[TG0]);
    walkparams.txsz = TCR_EL2[T0SZ];
    walkparams.ps = TCR_EL2[PS];
    walkparams.irgn = TCR_EL2[IRGN0];
    walkparams.orgn = TCR_EL2[ORGN0];
    walkparams.sh = TCR_EL2[SH0];
    walkparams.tbi = TCR_EL2[TBI];
    walkparams.mair = Mk_MAIRType(MAIR_EL2.bits);
    if HaveAIEExt() then {
        walkparams.mair2 = Mk_MAIRType(MAIR2_EL2.bits)
    };
    walkparams.aie = if HaveAIEExt() & IsTCR2EL2Enabled() then TCR2_EL2[AIE]
    else
      0b0;
    walkparams.wxn = SCTLR_EL2[WXN];
    walkparams.ee = SCTLR_EL2[EE];
    if HaveEL(EL3) & (not_bool(HaveRME()) | HaveSecureEL2Ext()) then {
        walkparams.sif = SCR_EL3[SIF]
    } else {
        walkparams.sif = 0b0
    };
    walkparams.tbid = if HavePACExt() then TCR_EL2[TBID] else 0b0;
    walkparams.hpd = if AArch64_HaveHPDExt() then TCR_EL2[HPD] else 0b0;
    walkparams.ha = if HaveAccessFlagUpdateExt() then
      Slice(TCR_EL2.bits, if HCR_EL2[E2H] == 0b0 then 21 else 39, 1)
    else
      0b0;
    walkparams.hd = if HaveDirtyBitModifierExt() then
      Slice(TCR_EL2.bits, if HCR_EL2[E2H] == 0b0 then 22 else 40, 1)
    else
      0b0;
    if (walkparams.tgx == TGx_4KB | walkparams.tgx == TGx_16KB) & Have52BitIPAAndPASpaceExt() then {
        walkparams.ds = Slice(TCR_EL2.bits, if HCR_EL2[E2H] == 0b0 then 32 else
          59, 1)
    } else {
        walkparams.ds = 0b0
    };
    walkparams.pie = if HaveS1PIExt() & IsTCR2EL2Enabled() then TCR2_EL2[PIE]
    else
      0b0;
    if HaveS1PIExt() then {
        walkparams.pir = Mk_S1PIRType(PIR_EL2.bits)
    };
    walkparams.mtx = if HaveMTE4Ext() then TCR_EL2[MTX] else 0b0;
    walkparams.pnch = if HaveTHExt() & IsTCR2EL2Enabled() then TCR2_EL2[PnCH]
    else
      0b0;
    if (HaveAccessFlagUpdateForTableExt() & walkparams.ha == 0b1) & IsTCR2EL2Enabled() then {
        walkparams.haft = TCR2_EL2[HAFT]
    } else {
        walkparams.haft = 0b0
    };
    walkparams.emec = if HaveFeatMEC() & IsSCTLR2EL2Enabled() then
      SCTLR2_EL2[EMEC]
    else
      0b0;
    if (HaveFeatMEC() & ss == SS_Realm) & IsTCR2EL2Enabled() then {
        walkparams.amec = TCR2_EL2[AMEC0]
    } else {
        walkparams.amec = 0b0
    };
    return(walkparams)
}

bitfield PIRE0_EL2_Type : bits(64) =
  {
    Perm15 : 63..60,
    Perm14 : 59..56,
    Perm13 : 55..52,
    Perm12 : 51..48,
    Perm11 : 47..44,
    Perm10 : 43..40,
    Perm9 : 39..36,
    Perm8 : 35..32,
    Perm7 : 31..28,
    Perm6 : 27..24,
    Perm5 : 23..20,
    Perm4 : 19..16,
    Perm3 : 15..12,
    Perm2 : 11..8,
    Perm1 : 7..4,
    Perm0 : 3..0
  }

register PIRE0_EL2 : PIRE0_EL2_Type

val AArch64_S1TTWParamsEL20 : (SecurityState, VARange) -> S1TTWParams

function AArch64_S1TTWParamsEL20 (ss, varange) = {
    walkparams : S1TTWParams = undefined;
    if Have128BitDescriptorExt() & IsTCR2EL2Enabled() then {
        walkparams.d128 = TCR2_EL2[D128]
    } else {
        walkparams.d128 = 0b0
    };
    if varange == VARange_LOWER then {
        walkparams.tgx = AArch64_S1DecodeTG0(TCR_EL2[TG0]);
        walkparams.txsz = TCR_EL2[T0SZ];
        walkparams.irgn = TCR_EL2[IRGN0];
        walkparams.orgn = TCR_EL2[ORGN0];
        walkparams.sh = TCR_EL2[SH0];
        walkparams.tbi = TCR_EL2[TBI0];
        walkparams.nfd = if HaveSVE() | HaveTME() then TCR_EL2[NFD0] else 0b0;
        walkparams.tbid = if HavePACExt() then TCR_EL2[TBID0] else 0b0;
        walkparams.e0pd = if HaveE0PDExt() then TCR_EL2[E0PD0] else 0b0;
        walkparams.hpd = if AArch64_HaveHPDExt() then TCR_EL2[HPD0] else 0b0;
        walkparams.mtx = if HaveMTE4Ext() then TCR_EL2[MTX0] else 0b0;
        walkparams.skl = if walkparams.d128 == 0b1 then TTBR0_EL2_read()[SKL]
        else
          0b00;
        walkparams.disch = if walkparams.d128 == 0b1 then TCR2_EL2[DisCH0] else
          0b0
    } else {
        walkparams.tgx = AArch64_S1DecodeTG1(TCR_EL2[TG1]);
        walkparams.txsz = TCR_EL2[T1SZ];
        walkparams.irgn = TCR_EL2[IRGN1];
        walkparams.orgn = TCR_EL2[ORGN1];
        walkparams.sh = TCR_EL2[SH1];
        walkparams.tbi = TCR_EL2[TBI1];
        walkparams.nfd = if HaveSVE() | HaveTME() then TCR_EL2[NFD1] else 0b0;
        walkparams.tbid = if HavePACExt() then TCR_EL2[TBID1] else 0b0;
        walkparams.e0pd = if HaveE0PDExt() then TCR_EL2[E0PD1] else 0b0;
        walkparams.hpd = if AArch64_HaveHPDExt() then TCR_EL2[HPD1] else 0b0;
        walkparams.mtx = if HaveMTE4Ext() then TCR_EL2[MTX1] else 0b0;
        walkparams.skl = if walkparams.d128 == 0b1 then TTBR1_EL2[SKL] else 0b00;
        walkparams.disch = if walkparams.d128 == 0b1 then TCR2_EL2[DisCH1] else
          0b0
    };
    walkparams.mair = Mk_MAIRType(MAIR_EL2.bits);
    if HaveAIEExt() then {
        walkparams.mair2 = Mk_MAIRType(MAIR2_EL2.bits)
    };
    walkparams.aie = if HaveAIEExt() & IsTCR2EL2Enabled() then TCR2_EL2[AIE]
    else
      0b0;
    walkparams.wxn = SCTLR_EL2[WXN];
    walkparams.ps = TCR_EL2[IPS];
    walkparams.ee = SCTLR_EL2[EE];
    if HaveEL(EL3) & (not_bool(HaveRME()) | HaveSecureEL2Ext()) then {
        walkparams.sif = SCR_EL3[SIF]
    } else {
        walkparams.sif = 0b0
    };
    if HaveTrapLoadStoreMultipleDeviceExt() then {
        walkparams.ntlsmd = SCTLR_EL2[nTLSMD]
    } else {
        walkparams.ntlsmd = 0b1
    };
    walkparams.cmow = if HaveFeatCMOW() then SCTLR_EL2[CMOW] else 0b0;
    walkparams.ha = if HaveAccessFlagUpdateExt() then
      Slice(TCR_EL2.bits, if HCR_EL2[E2H] == 0b0 then 21 else 39, 1)
    else
      0b0;
    walkparams.hd = if HaveDirtyBitModifierExt() then
      Slice(TCR_EL2.bits, if HCR_EL2[E2H] == 0b0 then 22 else 40, 1)
    else
      0b0;
    if (walkparams.tgx == TGx_4KB | walkparams.tgx == TGx_16KB) & Have52BitIPAAndPASpaceExt() then {
        walkparams.ds = Slice(TCR_EL2.bits, if HCR_EL2[E2H] == 0b0 then 32 else
          59, 1)
    } else {
        walkparams.ds = 0b0
    };
    if walkparams.d128 == 0b1 then {
        walkparams.pie = 0b1
    } else {
        walkparams.pie = if HaveS1PIExt() & IsTCR2EL2Enabled() then
          TCR2_EL2[PIE]
        else
          0b0
    };
    if HaveS1PIExt() then {
        walkparams.pir = Mk_S1PIRType(PIR_EL2.bits);
        walkparams.pire0 = Mk_S1PIRType(PIRE0_EL2.bits)
    };
    if HavePAN3Ext() then {
        walkparams.epan = if walkparams.pie == 0b0 then SCTLR_EL2[EPAN] else 0b1
    } else {
        walkparams.epan = 0b0
    };
    if (HaveTHExt() & walkparams.d128 == 0b0) & IsTCR2EL2Enabled() then {
        walkparams.pnch = TCR2_EL2[PnCH]
    } else {
        walkparams.pnch = 0b0
    };
    if (HaveAccessFlagUpdateForTableExt() & walkparams.ha == 0b1) & IsTCR2EL2Enabled() then {
        walkparams.haft = TCR2_EL2[HAFT]
    } else {
        walkparams.haft = 0b0
    };
    walkparams.emec = if HaveFeatMEC() & IsSCTLR2EL2Enabled() then
      SCTLR2_EL2[EMEC]
    else
      0b0;
    if (HaveFeatMEC() & ss == SS_Realm) & IsTCR2EL2Enabled() then {
        walkparams.amec = if varange == VARange_LOWER then TCR2_EL2[AMEC0] else
          TCR2_EL2[AMEC1]
    } else {
        walkparams.amec = 0b0
    };
    return(walkparams)
}

bitfield MAIR2_EL3_Type : bits(64) =
  {
    Attr7 : 63..56,
    Attr6 : 55..48,
    Attr5 : 47..40,
    Attr4 : 39..32,
    Attr3 : 31..24,
    Attr2 : 23..16,
    Attr1 : 15..8,
    Attr0 : 7..0
  }

register MAIR2_EL3 : MAIR2_EL3_Type

bitfield MAIR_EL3_Type : bits(64) =
  {
    Attr7 : 63..56,
    Attr6 : 55..48,
    Attr5 : 47..40,
    Attr4 : 39..32,
    Attr3 : 31..24,
    Attr2 : 23..16,
    Attr1 : 15..8,
    Attr0 : 7..0
  }

register MAIR_EL3 : MAIR_EL3_Type

bitfield PIR_EL3_Type : bits(64) =
  {
    Perm15 : 63..60,
    Perm14 : 59..56,
    Perm13 : 55..52,
    Perm12 : 51..48,
    Perm11 : 47..44,
    Perm10 : 43..40,
    Perm9 : 39..36,
    Perm8 : 35..32,
    Perm7 : 31..28,
    Perm6 : 27..24,
    Perm5 : 23..20,
    Perm4 : 19..16,
    Perm3 : 15..12,
    Perm2 : 11..8,
    Perm1 : 7..4,
    Perm0 : 3..0
  }

register PIR_EL3 : PIR_EL3_Type

bitfield SCTLR2_EL3_Type : bits(64) =
  {EnANERR : 4..4, EnADERR : 3..3, EMEC : 1..1}

register SCTLR2_EL3 : SCTLR2_EL3_Type

bitfield TTBR0_EL3_Type : bits(64) = {SKL : 2..1, CnP : 0..0}

register TTBR0_EL3 : TTBR0_EL3_Type

val AArch64_S1TTWParamsEL3 : unit -> S1TTWParams

function AArch64_S1TTWParamsEL3 () = {
    walkparams : S1TTWParams = undefined;
    walkparams.tgx = AArch64_S1DecodeTG0(TCR_EL3[TG0]);
    walkparams.txsz = TCR_EL3[T0SZ];
    walkparams.ps = TCR_EL3[PS];
    walkparams.irgn = TCR_EL3[IRGN0];
    walkparams.orgn = TCR_EL3[ORGN0];
    walkparams.sh = TCR_EL3[SH0];
    walkparams.tbi = TCR_EL3[TBI];
    walkparams.mair = Mk_MAIRType(MAIR_EL3.bits);
    if HaveAIEExt() then {
        walkparams.mair2 = Mk_MAIRType(MAIR2_EL3.bits)
    };
    walkparams.aie = if HaveAIEExt() then TCR_EL3[AIE] else 0b0;
    walkparams.wxn = SCTLR_EL3[WXN];
    walkparams.ee = SCTLR_EL3[EE];
    walkparams.sif = if not_bool(HaveRME()) | HaveSecureEL2Ext() then
      SCR_EL3[SIF]
    else
      0b0;
    walkparams.tbid = if HavePACExt() then TCR_EL3[TBID] else 0b0;
    walkparams.hpd = if AArch64_HaveHPDExt() then TCR_EL3[HPD] else 0b0;
    walkparams.ha = if HaveAccessFlagUpdateExt() then TCR_EL3[HA] else 0b0;
    walkparams.hd = if HaveDirtyBitModifierExt() then TCR_EL3[HD] else 0b0;
    if (walkparams.tgx == TGx_4KB | walkparams.tgx == TGx_16KB) & Have52BitIPAAndPASpaceExt() then {
        walkparams.ds = TCR_EL3[DS]
    } else {
        walkparams.ds = 0b0
    };
    walkparams.d128 = if Have128BitDescriptorExt() then TCR_EL3[D128] else 0b0;
    walkparams.skl = if walkparams.d128 == 0b1 then TTBR0_EL3[SKL] else 0b00;
    walkparams.disch = if walkparams.d128 == 0b1 then TCR_EL3[DisCH0] else 0b0;
    if walkparams.d128 == 0b1 then {
        walkparams.pie = 0b1
    } else {
        walkparams.pie = if HaveS1PIExt() then TCR_EL3[PIE] else 0b0
    };
    if HaveS1PIExt() then {
        walkparams.pir = Mk_S1PIRType(PIR_EL3.bits)
    };
    walkparams.mtx = if HaveMTE4Ext() then TCR_EL3[MTX] else 0b0;
    if HaveTHExt() & walkparams.d128 == 0b0 then {
        walkparams.pnch = TCR_EL3[PnCH]
    } else {
        walkparams.pnch = 0b0
    };
    if HaveAccessFlagUpdateForTableExt() & walkparams.ha == 0b1 then {
        walkparams.haft = TCR_EL3[HAFT]
    } else {
        walkparams.haft = 0b0
    };
    walkparams.emec = if HaveFeatMEC() then SCTLR2_EL3[EMEC] else 0b0;
    return(walkparams)
}

val AArch64_GetS1TTWParams : (Regime, SecurityState, bits(64)) -> S1TTWParams

function AArch64_GetS1TTWParams (regime, ss, va) = {
    walkparams : S1TTWParams = undefined;
    let varange : VARange = AArch64_GetVARange(va);
    match regime {
      Regime_EL3 => {
          walkparams = AArch64_S1TTWParamsEL3()
      },
      Regime_EL2 => {
          walkparams = AArch64_S1TTWParamsEL2(ss)
      },
      Regime_EL20 => {
          walkparams = AArch64_S1TTWParamsEL20(ss, varange)
      },
      Regime_EL10 => {
          walkparams = AArch64_S1TTWParamsEL10(varange)
      },
      _ => ()
    };
    return(walkparams)
}

val CalculateBottomPACBit : bits(1) -> int

function CalculateBottomPACBit top_bit = {
    let regime : Regime = TranslationRegime(PSTATE.EL);
    let ss : SecurityState = CurrentSecurityState();
    let walkparams : S1TTWParams = AArch64_GetS1TTWParams(regime, ss, Replicate(top_bit, 64));
    let 'bottom_PAC_bit = 64 - UInt(AArch64_PACEffectiveTxSZ(regime, walkparams));
    return(bottom_PAC_bit)
}

val HaveEnhancedPAC : unit -> bool

function HaveEnhancedPAC () = {
    return(IsFeatureImplemented(FEAT_EPAC))
}

val HaveEnhancedPAC2 : unit -> bool

function HaveEnhancedPAC2 () = {
    return(IsFeatureImplemented(FEAT_PAuth2))
}

val HaveFPAC : unit -> bool

function HaveFPAC () = {
    return(IsFeatureImplemented(FEAT_FPAC))
}

val HaveFPACCombined : unit -> bool

function HaveFPACCombined () = {
    return(IsFeatureImplemented(FEAT_FPACCOMBINE))
}

val ConstPACField : unit -> bool

function ConstPACField () = {
    return(IsFeatureImplemented(FEAT_CONSTPACFIELD))
}

val HavePACQARMA3Generic : unit -> bool

function HavePACQARMA3Generic () = {
    return(IsFeatureImplemented(FEAT_PACQARMA3))
}

val HavePACQARMA3Auth : unit -> bool

function HavePACQARMA3Auth () = {
    return(IsFeatureImplemented(FEAT_PACQARMA3))
}

val HavePACQARMA5Generic : unit -> bool

function HavePACQARMA5Generic () = {
    return(IsFeatureImplemented(FEAT_PACQARMA5))
}

val HavePACQARMA5Auth : unit -> bool

function HavePACQARMA5Auth () = {
    return(IsFeatureImplemented(FEAT_PACQARMA5))
}

val HavePACIMPGeneric : unit -> bool

function HavePACIMPGeneric () = {
    return(IsFeatureImplemented(FEAT_PACIMP))
}

val HavePACIMPAuth : unit -> bool

function HavePACIMPAuth () = {
    return(IsFeatureImplemented(FEAT_PACIMP))
}

val PtrHasUpperAndLowerAddRanges : unit -> bool

function PtrHasUpperAndLowerAddRanges () = {
    let regime : Regime = TranslationRegime(PSTATE.EL);
    return(HasUnprivileged(regime))
}

val ComputePACIMPDEF : (bits(64), bits(64), bits(64), bits(64)) -> bits(64)

val PACCellInvShuffle : bits(64) -> bits(64)

function PACCellInvShuffle indata = {
    outdata : bits(64) = undefined;
    outdata[3 .. 0] = indata[15 .. 12];
    outdata[7 .. 4] = indata[27 .. 24];
    outdata[11 .. 8] = indata[51 .. 48];
    outdata[15 .. 12] = indata[39 .. 36];
    outdata[19 .. 16] = indata[59 .. 56];
    outdata[23 .. 20] = indata[47 .. 44];
    outdata[27 .. 24] = indata[7 .. 4];
    outdata[31 .. 28] = indata[19 .. 16];
    outdata[35 .. 32] = indata[35 .. 32];
    outdata[39 .. 36] = indata[55 .. 52];
    outdata[43 .. 40] = indata[31 .. 28];
    outdata[47 .. 44] = indata[11 .. 8];
    outdata[51 .. 48] = indata[23 .. 20];
    outdata[55 .. 52] = indata[3 .. 0];
    outdata[59 .. 56] = indata[43 .. 40];
    outdata[63 .. 60] = indata[63 .. 60];
    return(outdata)
}

val PACCellShuffle : bits(64) -> bits(64)

function PACCellShuffle indata = {
    outdata : bits(64) = undefined;
    outdata[3 .. 0] = indata[55 .. 52];
    outdata[7 .. 4] = indata[27 .. 24];
    outdata[11 .. 8] = indata[47 .. 44];
    outdata[15 .. 12] = indata[3 .. 0];
    outdata[19 .. 16] = indata[31 .. 28];
    outdata[23 .. 20] = indata[51 .. 48];
    outdata[27 .. 24] = indata[7 .. 4];
    outdata[31 .. 28] = indata[43 .. 40];
    outdata[35 .. 32] = indata[35 .. 32];
    outdata[39 .. 36] = indata[15 .. 12];
    outdata[43 .. 40] = indata[59 .. 56];
    outdata[47 .. 44] = indata[23 .. 20];
    outdata[51 .. 48] = indata[11 .. 8];
    outdata[55 .. 52] = indata[39 .. 36];
    outdata[59 .. 56] = indata[19 .. 16];
    outdata[63 .. 60] = indata[63 .. 60];
    return(outdata)
}

val PACInvSub : bits(64) -> bits(64)

function PACInvSub Tinput = {
    Toutput : bits(64) = undefined;
    foreach (i from 0 to 15 by 1 in inc) {
        match Tinput[4 * i + 3 .. 4 * i] {
          0b0000 => {
              Toutput[4 * i + 3 .. 4 * i] = 0b0101
          },
          0b0001 => {
              Toutput[4 * i + 3 .. 4 * i] = 0b1110
          },
          0b0010 => {
              Toutput[4 * i + 3 .. 4 * i] = 0b1101
          },
          0b0011 => {
              Toutput[4 * i + 3 .. 4 * i] = 0b1000
          },
          0b0100 => {
              Toutput[4 * i + 3 .. 4 * i] = 0b1010
          },
          0b0101 => {
              Toutput[4 * i + 3 .. 4 * i] = 0b1011
          },
          0b0110 => {
              Toutput[4 * i + 3 .. 4 * i] = 0b0001
          },
          0b0111 => {
              Toutput[4 * i + 3 .. 4 * i] = 0b1001
          },
          0b1000 => {
              Toutput[4 * i + 3 .. 4 * i] = 0b0010
          },
          0b1001 => {
              Toutput[4 * i + 3 .. 4 * i] = 0b0110
          },
          0b1010 => {
              Toutput[4 * i + 3 .. 4 * i] = 0b1111
          },
          0b1011 => {
              Toutput[4 * i + 3 .. 4 * i] = 0b0000
          },
          0b1100 => {
              Toutput[4 * i + 3 .. 4 * i] = 0b0100
          },
          0b1101 => {
              Toutput[4 * i + 3 .. 4 * i] = 0b1100
          },
          0b1110 => {
              Toutput[4 * i + 3 .. 4 * i] = 0b0111
          },
          0b1111 => {
              Toutput[4 * i + 3 .. 4 * i] = 0b0011
          },
          _ => ()
        }
    };
    return(Toutput)
}

val RotCell : forall 'amount,
  (0 <= 4 - 'amount & 7 - 'amount < 8).
  (bits(4), int('amount)) -> bits(4)

function RotCell (incell_name, amount) = {
    tmp : bits(8) = undefined;
    tmp[7 .. 0] = incell_name[3 .. 0] @ incell_name[3 .. 0];
    let outcell : bits(4) = tmp[7 - amount .. 4 - amount];
    return(outcell)
}

val PACMult : bits(64) -> bits(64)

function PACMult Sinput = {
    t0 : bits(4) = undefined;
    t1 : bits(4) = undefined;
    t2 : bits(4) = undefined;
    t3 : bits(4) = undefined;
    Soutput : bits(64) = undefined;
    foreach (i from 0 to 3 by 1 in inc) {
        t0[3 .. 0] = EOR(RotCell(Sinput[4 * (i + 8) + 3 .. 4 * (i + 8)], 1), RotCell(Sinput[4 * (i + 4) + 3 .. 4 * (i + 4)], 2));
        t0[3 .. 0] = EOR(t0[3 .. 0], RotCell(Sinput[4 * i + 3 .. 4 * i], 1));
        t1[3 .. 0] = EOR(RotCell(Sinput[4 * (i + 12) + 3 .. 4 * (i + 12)], 1), RotCell(Sinput[4 * (i + 4) + 3 .. 4 * (i + 4)], 1));
        t1[3 .. 0] = EOR(t1[3 .. 0], RotCell(Sinput[4 * i + 3 .. 4 * i], 2));
        t2[3 .. 0] = EOR(RotCell(Sinput[4 * (i + 12) + 3 .. 4 * (i + 12)], 2), RotCell(Sinput[4 * (i + 8) + 3 .. 4 * (i + 8)], 1));
        t2[3 .. 0] = EOR(t2[3 .. 0], RotCell(Sinput[4 * i + 3 .. 4 * i], 1));
        t3[3 .. 0] = EOR(RotCell(Sinput[4 * (i + 12) + 3 .. 4 * (i + 12)], 1), RotCell(Sinput[4 * (i + 8) + 3 .. 4 * (i + 8)], 2));
        t3[3 .. 0] = EOR(t3[3 .. 0], RotCell(Sinput[4 * (i + 4) + 3 .. 4 * (i + 4)], 1));
        Soutput[4 * i + 3 .. 4 * i] = t3[3 .. 0];
        Soutput[4 * (i + 4) + 3 .. 4 * (i + 4)] = t2[3 .. 0];
        Soutput[4 * (i + 8) + 3 .. 4 * (i + 8)] = t1[3 .. 0];
        Soutput[4 * (i + 12) + 3 .. 4 * (i + 12)] = t0[3 .. 0]
    };
    return(Soutput)
}

val PACSub : bits(64) -> bits(64)

function PACSub Tinput = {
    Toutput : bits(64) = undefined;
    foreach (i from 0 to 15 by 1 in inc) {
        match Tinput[4 * i + 3 .. 4 * i] {
          0b0000 => {
              Toutput[4 * i + 3 .. 4 * i] = 0b1011
          },
          0b0001 => {
              Toutput[4 * i + 3 .. 4 * i] = 0b0110
          },
          0b0010 => {
              Toutput[4 * i + 3 .. 4 * i] = 0b1000
          },
          0b0011 => {
              Toutput[4 * i + 3 .. 4 * i] = 0b1111
          },
          0b0100 => {
              Toutput[4 * i + 3 .. 4 * i] = 0b1100
          },
          0b0101 => {
              Toutput[4 * i + 3 .. 4 * i] = 0b0000
          },
          0b0110 => {
              Toutput[4 * i + 3 .. 4 * i] = 0b1001
          },
          0b0111 => {
              Toutput[4 * i + 3 .. 4 * i] = 0b1110
          },
          0b1000 => {
              Toutput[4 * i + 3 .. 4 * i] = 0b0011
          },
          0b1001 => {
              Toutput[4 * i + 3 .. 4 * i] = 0b0111
          },
          0b1010 => {
              Toutput[4 * i + 3 .. 4 * i] = 0b0100
          },
          0b1011 => {
              Toutput[4 * i + 3 .. 4 * i] = 0b0101
          },
          0b1100 => {
              Toutput[4 * i + 3 .. 4 * i] = 0b1101
          },
          0b1101 => {
              Toutput[4 * i + 3 .. 4 * i] = 0b0010
          },
          0b1110 => {
              Toutput[4 * i + 3 .. 4 * i] = 0b0001
          },
          0b1111 => {
              Toutput[4 * i + 3 .. 4 * i] = 0b1010
          },
          _ => ()
        }
    };
    return(Toutput)
}

val PACSub1 : bits(64) -> bits(64)

function PACSub1 Tinput = {
    Toutput : bits(64) = undefined;
    foreach (i from 0 to 15 by 1 in inc) {
        match Tinput[4 * i + 3 .. 4 * i] {
          0b0000 => {
              Toutput[4 * i + 3 .. 4 * i] = 0b1010
          },
          0b0001 => {
              Toutput[4 * i + 3 .. 4 * i] = 0b1101
          },
          0b0010 => {
              Toutput[4 * i + 3 .. 4 * i] = 0b1110
          },
          0b0011 => {
              Toutput[4 * i + 3 .. 4 * i] = 0b0110
          },
          0b0100 => {
              Toutput[4 * i + 3 .. 4 * i] = 0b1111
          },
          0b0101 => {
              Toutput[4 * i + 3 .. 4 * i] = 0b0111
          },
          0b0110 => {
              Toutput[4 * i + 3 .. 4 * i] = 0b0011
          },
          0b0111 => {
              Toutput[4 * i + 3 .. 4 * i] = 0b0101
          },
          0b1000 => {
              Toutput[4 * i + 3 .. 4 * i] = 0b1001
          },
          0b1001 => {
              Toutput[4 * i + 3 .. 4 * i] = 0b1000
          },
          0b1010 => {
              Toutput[4 * i + 3 .. 4 * i] = 0b0000
          },
          0b1011 => {
              Toutput[4 * i + 3 .. 4 * i] = 0b1100
          },
          0b1100 => {
              Toutput[4 * i + 3 .. 4 * i] = 0b1011
          },
          0b1101 => {
              Toutput[4 * i + 3 .. 4 * i] = 0b0001
          },
          0b1110 => {
              Toutput[4 * i + 3 .. 4 * i] = 0b0010
          },
          0b1111 => {
              Toutput[4 * i + 3 .. 4 * i] = 0b0100
          },
          _ => ()
        }
    };
    return(Toutput)
}

val TweakCellInvRot : bits(4) -> bits(4)

function TweakCellInvRot incell_name = {
    outcell : bits(4) = undefined;
    outcell[3] = Bit([incell_name[2]]);
    outcell[2] = Bit([incell_name[1]]);
    outcell[1] = Bit([incell_name[0]]);
    outcell[0] = Bit(EOR([incell_name[0]], [incell_name[3]]));
    return(outcell)
}

val TweakInvShuffle : bits(64) -> bits(64)

function TweakInvShuffle indata = {
    outdata : bits(64) = undefined;
    outdata[3 .. 0] = TweakCellInvRot(indata[51 .. 48]);
    outdata[7 .. 4] = indata[55 .. 52];
    outdata[11 .. 8] = indata[23 .. 20];
    outdata[15 .. 12] = indata[27 .. 24];
    outdata[19 .. 16] = indata[3 .. 0];
    outdata[23 .. 20] = indata[7 .. 4];
    outdata[27 .. 24] = TweakCellInvRot(indata[11 .. 8]);
    outdata[31 .. 28] = indata[15 .. 12];
    outdata[35 .. 32] = TweakCellInvRot(indata[31 .. 28]);
    outdata[39 .. 36] = TweakCellInvRot(indata[63 .. 60]);
    outdata[43 .. 40] = TweakCellInvRot(indata[59 .. 56]);
    outdata[47 .. 44] = TweakCellInvRot(indata[19 .. 16]);
    outdata[51 .. 48] = indata[35 .. 32];
    outdata[55 .. 52] = indata[39 .. 36];
    outdata[59 .. 56] = indata[43 .. 40];
    outdata[63 .. 60] = TweakCellInvRot(indata[47 .. 44]);
    return(outdata)
}

val TweakCellRot : bits(4) -> bits(4)

function TweakCellRot incell_name = {
    outcell : bits(4) = undefined;
    outcell[3] = Bit(EOR([incell_name[0]], [incell_name[1]]));
    outcell[2] = Bit([incell_name[3]]);
    outcell[1] = Bit([incell_name[2]]);
    outcell[0] = Bit([incell_name[1]]);
    return(outcell)
}

val TweakShuffle : bits(64) -> bits(64)

function TweakShuffle indata = {
    outdata : bits(64) = undefined;
    outdata[3 .. 0] = indata[19 .. 16];
    outdata[7 .. 4] = indata[23 .. 20];
    outdata[11 .. 8] = TweakCellRot(indata[27 .. 24]);
    outdata[15 .. 12] = indata[31 .. 28];
    outdata[19 .. 16] = TweakCellRot(indata[47 .. 44]);
    outdata[23 .. 20] = indata[11 .. 8];
    outdata[27 .. 24] = indata[15 .. 12];
    outdata[31 .. 28] = TweakCellRot(indata[35 .. 32]);
    outdata[35 .. 32] = indata[51 .. 48];
    outdata[39 .. 36] = indata[55 .. 52];
    outdata[43 .. 40] = indata[59 .. 56];
    outdata[47 .. 44] = TweakCellRot(indata[63 .. 60]);
    outdata[51 .. 48] = TweakCellRot(indata[3 .. 0]);
    outdata[55 .. 52] = indata[7 .. 4];
    outdata[59 .. 56] = TweakCellRot(indata[43 .. 40]);
    outdata[63 .. 60] = TweakCellRot(indata[39 .. 36]);
    return(outdata)
}

val ComputePACQARMA : forall ('isqarma3 : Bool).
  (bits(64), bits(64), bits(64), bits(64), bool('isqarma3)) -> bits(64)

function ComputePACQARMA (data, modifier, key0, key1, isqarma3) = {
    roundkey : bits(64) = undefined;
    let Alpha : bits(64) = 0xC0AC29B7C97C50DD;
    iterations : {2, 4} = 2;
    RC[0] = 0x0000000000000000;
    RC[1] = 0x13198A2E03707344;
    RC[2] = 0xA4093822299F31D0;
    if isqarma3 then {
        iterations = 2
    } else {
        iterations = 4;
        RC[3] = 0x082EFA98EC4E6C89;
        RC[4] = 0x452821E638D01377
    };
    let 'iterations = iterations;
    let modk0 : bits(64) = ([key0[0]] @ key0[63 .. 2]) @ EOR([key0[63]], [key0[1]]);
    runningmod : bits(64) = modifier;
    workingval : bits(64) = EOR(data, key0);
    foreach (i from 0 to iterations by 1 in inc) {
        roundkey = EOR(key1, runningmod);
        workingval = EOR(workingval, roundkey);
        workingval = EOR(workingval, RC[i]);
        if i > 0 then {
            workingval = PACCellShuffle(workingval);
            workingval = PACMult(workingval)
        };
        if isqarma3 then {
            workingval = PACSub1(workingval)
        } else {
            workingval = PACSub(workingval)
        };
        runningmod = TweakShuffle(runningmod[63 .. 0])
    };
    roundkey : bits(64) = EOR(modk0, runningmod);
    workingval : bits(64) = EOR(workingval, roundkey);
    workingval : bits(64) = PACCellShuffle(workingval);
    workingval : bits(64) = PACMult(workingval);
    if isqarma3 then {
        workingval = PACSub1(workingval)
    } else {
        workingval = PACSub(workingval)
    };
    workingval : bits(64) = PACCellShuffle(workingval);
    workingval : bits(64) = PACMult(workingval);
    workingval : bits(64) = EOR(key1, workingval);
    workingval : bits(64) = PACCellInvShuffle(workingval);
    if isqarma3 then {
        workingval = PACSub1(workingval)
    } else {
        workingval = PACInvSub(workingval)
    };
    workingval : bits(64) = PACMult(workingval);
    workingval : bits(64) = PACCellInvShuffle(workingval);
    workingval : bits(64) = EOR(workingval, key0);
    workingval : bits(64) = EOR(workingval, runningmod);
    foreach (i from 0 to iterations by 1 in inc) {
        if isqarma3 then {
            workingval = PACSub1(workingval)
        } else {
            workingval = PACInvSub(workingval)
        };
        if i < iterations then {
            workingval = PACMult(workingval);
            workingval = PACCellInvShuffle(workingval)
        };
        runningmod = TweakInvShuffle(runningmod[63 .. 0]);
        roundkey = EOR(key1, runningmod);
        workingval = EOR(workingval, RC[iterations - i]);
        workingval = EOR(workingval, roundkey);
        workingval = EOR(workingval, Alpha)
    };
    let workingval : bits(64) = EOR(workingval, modk0);
    return(workingval)
}

val UsePACIMP : forall ('isgeneric : Bool). bool('isgeneric) -> bool

function UsePACIMP isgeneric = {
    return(if isgeneric then HavePACIMPGeneric() else HavePACIMPAuth())
}

val UsePACQARMA3 : forall ('isgeneric : Bool). bool('isgeneric) -> bool

function UsePACQARMA3 isgeneric = {
    return(if isgeneric then HavePACQARMA3Generic() else HavePACQARMA3Auth())
}

val UsePACQARMA5 : forall ('isgeneric : Bool). bool('isgeneric) -> bool

function UsePACQARMA5 isgeneric = {
    return(if isgeneric then HavePACQARMA5Generic() else HavePACQARMA5Auth())
}

val ComputePAC : forall ('isgeneric : Bool).
  (bits(64), bits(64), bits(64), bits(64), bool('isgeneric)) -> bits(64)

function ComputePAC (data, modifier, key0, key1, isgeneric) = {
    if UsePACIMP(isgeneric) then {
        return(ComputePACIMPDEF(data, modifier, key0, key1))
    };
    if UsePACQARMA3(isgeneric) then {
        let isqarma3 : bool = true;
        return(ComputePACQARMA(data, modifier, key0, key1, isqarma3))
    };
    if UsePACQARMA5(isgeneric) then {
        let isqarma3 : bool = false;
        return(ComputePACQARMA(data, modifier, key0, key1, isqarma3))
    } else {
        return(undefined : bits(64))
    }
}

val Strip : forall ('data : Bool). (bits(64), bool('data)) -> bits(64)

function Strip (A, data) = {
    original_ptr : bits(64) = undefined;
    let tbi : bool = EffectiveTBI(A, not_bool(data), PSTATE.EL) == 0b1;
    let mtx : bool = EffectiveMTX(A, not_bool(data), PSTATE.EL) == 0b1;
    let 'bottom_PAC_bit = CalculateBottomPACBit([A[55]]);
    let extfield : bits(64) = Replicate([A[55]], 64);
    if tbi & bottom_PAC_bit >= 55 then {
        return(A)
    };
    if tbi then {
        assert(constraint((0 <= 56 - 'bottom_PAC_bit - 1 & 56 - 'bottom_PAC_bit - 1 < 64)));
        assert(constraint((0 <= 'bottom_PAC_bit - 1 & 'bottom_PAC_bit - 1 < 64)));
        original_ptr = (A[63 .. 56] @ extfield[56 - bottom_PAC_bit - 1 .. 0]) @ A[bottom_PAC_bit - 1 .. 0]
    } else if mtx then {
        assert(constraint((0 <= 56 - 'bottom_PAC_bit - 1 & 56 - 'bottom_PAC_bit - 1 < 64)));
        assert(constraint((0 <= 'bottom_PAC_bit - 1 & 'bottom_PAC_bit - 1 < 64)));
        original_ptr = ((extfield[63 .. 60] @ A[59 .. 56]) @ extfield[56 - bottom_PAC_bit - 1 .. 0]) @ A[bottom_PAC_bit - 1 .. 0]
    } else {
        assert(constraint((0 <= 64 - 'bottom_PAC_bit - 1 & 64 - 'bottom_PAC_bit - 1 < 64)));
        assert(constraint((0 <= 'bottom_PAC_bit - 1 & 'bottom_PAC_bit - 1 < 64)));
        original_ptr = extfield[64 - bottom_PAC_bit - 1 .. 0] @ A[bottom_PAC_bit - 1 .. 0]
    };
    return(original_ptr)
}

val AArch64_PACFailException : bits(2) -> unit

function AArch64_PACFailException syndrome = {
    let route_to_el2 : bool = (PSTATE.EL == EL0 & EL2Enabled()) & HCR_EL2[TGE] == 0b1;
    let preferred_exception_return : bits(64) = ThisInstrAddr(64);
    let 'vect_offset = UInt(0x0);
    except : ExceptionRecord = ExceptionSyndrome(Exception_PACFail);
    except.syndrome[1 .. 0] = syndrome;
    except.syndrome[24 .. 2] = Zeros(23);
    sail_take_exception(None());
    if UInt(PSTATE.EL) > UInt(EL0) then {
        AArch64_TakeException(PSTATE.EL, except, preferred_exception_return, vect_offset)
    } else if route_to_el2 then {
        AArch64_TakeException(EL2, except, preferred_exception_return, vect_offset)
    } else {
        AArch64_TakeException(EL1, except, preferred_exception_return, vect_offset)
    }
}

val Auth : forall ('data : Bool) ('is_combined : Bool).
  (bits(64), bits(64), bits(128), bool('data), bits(1), bool('is_combined)) -> bits(64)

function Auth (ptr, modifier, K, data, key_number, is_combined) = {
    result : bits(64) = undefined;
    original_ptr : bits(64) = undefined;
    error_code : bits(2) = undefined;
    let isgeneric : bool = false;
    let tbi : bool = EffectiveTBI(ptr, not_bool(data), PSTATE.EL) == 0b1;
    let mtx : bool = EffectiveMTX(ptr, not_bool(data), PSTATE.EL) == 0b1;
    let 'bottom_PAC_bit = CalculateBottomPACBit([ptr[55]]);
    let extfield : bits(64) = Replicate([ptr[55]], 64);
    if tbi & bottom_PAC_bit >= 55 then {
        return(ptr)
    };
    if tbi then {
        assert(constraint((0 <= 56 - 'bottom_PAC_bit - 1 & 56 - 'bottom_PAC_bit - 1 < 64)));
        assert(constraint((0 <= 'bottom_PAC_bit - 1 & 'bottom_PAC_bit - 1 < 64)));
        original_ptr = (ptr[63 .. 56] @ extfield[56 - bottom_PAC_bit - 1 .. 0]) @ ptr[bottom_PAC_bit - 1 .. 0]
    } else if mtx then {
        assert(constraint((0 <= 56 - 'bottom_PAC_bit - 1 & 56 - 'bottom_PAC_bit - 1 < 64)));
        assert(constraint((0 <= 'bottom_PAC_bit - 1 & 'bottom_PAC_bit - 1 < 64)));
        original_ptr = ((extfield[63 .. 60] @ ptr[59 .. 56]) @ extfield[56 - bottom_PAC_bit - 1 .. 0]) @ ptr[bottom_PAC_bit - 1 .. 0]
    } else {
        assert(constraint((0 <= 64 - 'bottom_PAC_bit - 1 & 64 - 'bottom_PAC_bit - 1 < 64)));
        assert(constraint((0 <= 'bottom_PAC_bit - 1 & 'bottom_PAC_bit - 1 < 64)));
        original_ptr = extfield[64 - bottom_PAC_bit - 1 .. 0] @ ptr[bottom_PAC_bit - 1 .. 0]
    };
    let PAC : bits(64) = ComputePAC(original_ptr, modifier, K[127 .. 64], K[63 .. 0], isgeneric);
    if tbi then {
        if not_bool(HaveEnhancedPAC2()) then {
            assert(constraint((0 <= 'bottom_PAC_bit & 'bottom_PAC_bit <= 54)));
            if PAC[54 .. bottom_PAC_bit] == ptr[54 .. bottom_PAC_bit] then {
                result = original_ptr
            } else {
                let error_code : bits(2) = key_number @ not_vec(key_number);
                result = (original_ptr[63 .. 55] @ error_code) @ original_ptr[52 .. 0]
            }
        } else {
            result = ptr;
            assert(constraint((0 <= 'bottom_PAC_bit & 'bottom_PAC_bit <= 54)));
            result[54 .. bottom_PAC_bit] = EOR(result[54 .. bottom_PAC_bit], PAC[54 .. bottom_PAC_bit]);
            if HaveFPACCombined() | HaveFPAC() & not_bool(is_combined) then {
                if result[54 .. bottom_PAC_bit] != Replicate([result[55]], 55 - bottom_PAC_bit) then {
                    let error_code : bits(2) = (if data then 0b1 else 0b0) @ key_number;
                    AArch64_PACFailException(error_code)
                };
                ()
            };
            ()
        }
    } else if mtx then {
        assert(HaveEnhancedPAC2());
        result = ptr;
        assert(constraint((0 <= 'bottom_PAC_bit & 'bottom_PAC_bit <= 54)));
        result[54 .. bottom_PAC_bit] = EOR(result[54 .. bottom_PAC_bit], PAC[54 .. bottom_PAC_bit]);
        result[63 .. 60] = EOR(result[63 .. 60], PAC[63 .. 60]);
        if HaveFPACCombined() | HaveFPAC() & not_bool(is_combined) then {
            if result[54 .. bottom_PAC_bit] != Replicate([result[55]], 55 - bottom_PAC_bit) | result[63 .. 60] != Replicate([result[55]], 4) then {
                let error_code : bits(2) = (if data then 0b1 else 0b0) @ key_number;
                AArch64_PACFailException(error_code)
            };
            ()
        };
        ()
    } else {
        if not_bool(HaveEnhancedPAC2()) then {
            assert(constraint((0 <= 'bottom_PAC_bit & 'bottom_PAC_bit <= 54)));
            if PAC[54 .. bottom_PAC_bit] == ptr[54 .. bottom_PAC_bit] & PAC[63 .. 56] == ptr[63 .. 56] then {
                result = original_ptr
            } else {
                let error_code : bits(2) = key_number @ not_vec(key_number);
                result = ([original_ptr[63]] @ error_code) @ original_ptr[60 .. 0]
            }
        } else {
            result = ptr;
            assert(constraint((0 <= 'bottom_PAC_bit & 'bottom_PAC_bit <= 54)));
            result[54 .. bottom_PAC_bit] = EOR(result[54 .. bottom_PAC_bit], PAC[54 .. bottom_PAC_bit]);
            result[63 .. 56] = EOR(result[63 .. 56], PAC[63 .. 56]);
            if HaveFPACCombined() | HaveFPAC() & not_bool(is_combined) then {
                if result[63 .. bottom_PAC_bit] != Replicate([result[55]], 64 - bottom_PAC_bit) then {
                    let error_code : bits(2) = (if data then 0b1 else 0b0) @ key_number;
                    AArch64_PACFailException(error_code)
                };
                ()
            };
            ()
        }
    };
    return(result)
}

val TrapPACUse : bits(2) -> unit

function TrapPACUse target_el = {
    assert((HaveEL(target_el) & target_el != EL0) & UInt(target_el) >= UInt(PSTATE.EL));
    let preferred_exception_return : bits(64) = ThisInstrAddr(64);
    let 'vect_offset = 0;
    let except : ExceptionRecord = ExceptionSyndrome(Exception_PACTrap);
    sail_take_exception(None());
    AArch64_TakeException(target_el, except, preferred_exception_return, vect_offset)
}

val AddPAC : forall ('data : Bool).
  (bits(64), bits(64), bits(128), bool('data)) -> bits(64)

function AddPAC (ptr, modifier, K, data) = {
    result : bits(64) = undefined;
    ext_ptr : bits(64) = undefined;
    selbit : bits(1) = undefined;
    let isgeneric : bool = false;
    let tbi : bool = EffectiveTBI(ptr, not_bool(data), PSTATE.EL) == 0b1;
    let mtx : bool = EffectiveMTX(ptr, not_bool(data), PSTATE.EL) == 0b1;
    let 'top_bit = if tbi then 55 else 63;
    if PtrHasUpperAndLowerAddRanges() then {
        assert(S1TranslationRegime__1() == EL1 | S1TranslationRegime__1() == EL2);
        if S1TranslationRegime__1() == EL1 then {
            if data then {
                if TCR_EL1[TBI1] == 0b1 | TCR_EL1[TBI0] == 0b1 then {
                    selbit = [ptr[55]]
                } else {
                    selbit = [ptr[63]]
                }
            } else {
                if TCR_EL1[TBI1] == 0b1 & TCR_EL1[TBID1] == 0b0 | TCR_EL1[TBI0] == 0b1 & TCR_EL1[TBID0] == 0b0 then {
                    selbit = [ptr[55]]
                } else {
                    selbit = [ptr[63]]
                }
            }
        } else {
            if data then {
                if TCR_EL2[TBI1] == 0b1 | TCR_EL2[TBI0] == 0b1 then {
                    selbit = [ptr[55]]
                } else {
                    selbit = [ptr[63]]
                }
            } else {
                if TCR_EL2[TBI1] == 0b1 & TCR_EL2[TBID1] == 0b0 | TCR_EL2[TBI0] == 0b1 & TCR_EL2[TBID0] == 0b0 then {
                    selbit = [ptr[55]]
                } else {
                    selbit = [ptr[63]]
                }
            }
        }
    } else {
        selbit = if tbi then [ptr[55]] else [ptr[63]]
    };
    if HaveEnhancedPAC2() & ConstPACField() then {
        selbit = [ptr[55]]
    };
    let selbit = selbit;
    let 'bottom_PAC_bit = CalculateBottomPACBit(selbit);
    if tbi & bottom_PAC_bit >= 55 then {
        return(ptr)
    };
    let extfield : bits(64) = Replicate(selbit, 64);
    if tbi then {
        assert(constraint((0 <= 56 - 'bottom_PAC_bit - 1 & 56 - 'bottom_PAC_bit - 1 < 64)));
        assert(constraint((0 <= 'bottom_PAC_bit - 1 & 'bottom_PAC_bit - 1 < 64)));
        ext_ptr = (ptr[63 .. 56] @ extfield[56 - bottom_PAC_bit - 1 .. 0]) @ ptr[bottom_PAC_bit - 1 .. 0]
    } else if mtx then {
        assert(constraint((0 <= 56 - 'bottom_PAC_bit - 1 & 56 - 'bottom_PAC_bit - 1 < 64)));
        assert(constraint((0 <= 'bottom_PAC_bit - 1 & 'bottom_PAC_bit - 1 < 64)));
        ext_ptr = ((extfield[63 .. 60] @ ptr[59 .. 56]) @ extfield[56 - bottom_PAC_bit - 1 .. 0]) @ ptr[bottom_PAC_bit - 1 .. 0]
    } else {
        assert(constraint((0 <= 64 - 'bottom_PAC_bit - 1 & 64 - 'bottom_PAC_bit - 1 < 64)));
        assert(constraint((0 <= 'bottom_PAC_bit - 1 & 'bottom_PAC_bit - 1 < 64)));
        ext_ptr = extfield[64 - bottom_PAC_bit - 1 .. 0] @ ptr[bottom_PAC_bit - 1 .. 0]
    };
    PAC : bits(64) = ComputePAC(ext_ptr, modifier, K[127 .. 64], K[63 .. 0], isgeneric);
    unusedbits_mask : bits(64) = Zeros(64);
    assert(constraint((0 <= 'bottom_PAC_bit & 'bottom_PAC_bit <= 54)));
    unusedbits_mask[54 .. bottom_PAC_bit] = Ones(54 - bottom_PAC_bit + 1);
    if tbi then {
        unusedbits_mask[63 .. 56] = Ones(8)
    } else if mtx then {
        unusedbits_mask[63 .. 60] = Ones(4)
    } else ();
    if not_bool(IsZero(ptr & unusedbits_mask)) & (ptr & unusedbits_mask) != unusedbits_mask then {
        if HaveEnhancedPAC() then {
            PAC = 0x0000000000000000
        } else if not_bool(HaveEnhancedPAC2()) then {
            PAC[top_bit - 1] = Bit(not_vec([PAC[top_bit - 1]]))
        } else ()
    };
    if not_bool(HaveEnhancedPAC2()) then {
        if tbi then {
            assert(constraint((0 <= 'bottom_PAC_bit - 1 & 'bottom_PAC_bit - 1 < 64)));
            result = ((ptr[63 .. 56] @ selbit) @ PAC[54 .. bottom_PAC_bit]) @ ptr[bottom_PAC_bit - 1 .. 0]
        } else {
            assert(constraint((0 <= 'bottom_PAC_bit - 1 & 'bottom_PAC_bit - 1 < 64)));
            result = ((PAC[63 .. 56] @ selbit) @ PAC[54 .. bottom_PAC_bit]) @ ptr[bottom_PAC_bit - 1 .. 0];
            assert(not_bool(mtx))
        }
    } else {
        if tbi then {
            assert(constraint((0 <= 'bottom_PAC_bit - 1 & 'bottom_PAC_bit - 1 < 64)));
            result = ((ptr[63 .. 56] @ selbit) @ EOR(ptr[54 .. bottom_PAC_bit], PAC[54 .. bottom_PAC_bit])) @ ptr[bottom_PAC_bit - 1 .. 0]
        } else if mtx then {
            assert(constraint((0 <= 'bottom_PAC_bit - 1 & 'bottom_PAC_bit - 1 < 64)));
            result = (((EOR(ptr[63 .. 60], PAC[63 .. 60]) @ ptr[59 .. 56]) @ selbit) @ EOR(ptr[54 .. bottom_PAC_bit], PAC[54 .. bottom_PAC_bit])) @ ptr[bottom_PAC_bit - 1 .. 0]
        } else {
            assert(constraint((0 <= 'bottom_PAC_bit - 1 & 'bottom_PAC_bit - 1 < 64)));
            result = ((EOR(ptr[63 .. 56], PAC[63 .. 56]) @ selbit) @ EOR(ptr[54 .. bottom_PAC_bit], PAC[54 .. bottom_PAC_bit])) @ ptr[bottom_PAC_bit - 1 .. 0]
        }
    };
    return(result)
}

type APIAKeyHi_EL1_Type = bits(64)

register APIAKeyHi_EL1 : APIAKeyHi_EL1_Type

type APIAKeyLo_EL1_Type = bits(64)

register APIAKeyLo_EL1 : APIAKeyLo_EL1_Type

val AddPACIA : (bits(64), bits(64)) -> bits(64)

function AddPACIA (x, y) = {
    TrapEL2 : bool = undefined;
    TrapEL3 : bool = undefined;
    Enable : bits(1) = undefined;
    let APIAKey_EL1 : bits(128) = APIAKeyHi_EL1[63 .. 0] @ APIAKeyLo_EL1[63 .. 0];
    match PSTATE.EL {
      ? if ? == EL0 => {
          let IsEL1Regime : bool = S1TranslationRegime__1() == EL1;
          Enable = if IsEL1Regime then SCTLR_EL1[EnIA] else SCTLR_EL2[EnIA];
          TrapEL2 = (EL2Enabled() & HCR_EL2[API] == 0b0) & (HCR_EL2[TGE] == 0b0 | HCR_EL2[E2H] == 0b0);
          TrapEL3 = HaveEL(EL3) & SCR_EL3[API] == 0b0
      },
      ? if ? == EL1 => {
          Enable = SCTLR_EL1[EnIA];
          TrapEL2 = EL2Enabled() & HCR_EL2[API] == 0b0;
          TrapEL3 = HaveEL(EL3) & SCR_EL3[API] == 0b0
      },
      ? if ? == EL2 => {
          Enable = SCTLR_EL2[EnIA];
          TrapEL2 = false;
          TrapEL3 = HaveEL(EL3) & SCR_EL3[API] == 0b0
      },
      ? if ? == EL3 => {
          Enable = SCTLR_EL3[EnIA];
          TrapEL2 = false;
          TrapEL3 = false
      },
      _ => ()
    };
    if Enable == 0b0 then {
        return(x)
    } else if TrapEL3 & EL3SDDUndefPriority() then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if TrapEL2 then {
        TrapPACUse(EL2);
        return(undefined : bits(64))
    } else if TrapEL3 then {
        if EL3SDDUndef() then {
            throw(Error_Undefined());
            return(undefined : bits(64))
        } else {
            TrapPACUse(EL3);
            return(undefined : bits(64))
        }
    } else {
        return(AddPAC(x, y, APIAKey_EL1, false))
    }
}

type APIBKeyHi_EL1_Type = bits(64)

register APIBKeyHi_EL1 : APIBKeyHi_EL1_Type

type APIBKeyLo_EL1_Type = bits(64)

register APIBKeyLo_EL1 : APIBKeyLo_EL1_Type

val AddPACIB : (bits(64), bits(64)) -> bits(64)

function AddPACIB (x, y) = {
    TrapEL2 : bool = undefined;
    TrapEL3 : bool = undefined;
    Enable : bits(1) = undefined;
    let APIBKey_EL1 : bits(128) = APIBKeyHi_EL1[63 .. 0] @ APIBKeyLo_EL1[63 .. 0];
    match PSTATE.EL {
      ? if ? == EL0 => {
          let IsEL1Regime : bool = S1TranslationRegime__1() == EL1;
          Enable = if IsEL1Regime then SCTLR_EL1[EnIB] else SCTLR_EL2[EnIB];
          TrapEL2 = (EL2Enabled() & HCR_EL2[API] == 0b0) & (HCR_EL2[TGE] == 0b0 | HCR_EL2[E2H] == 0b0);
          TrapEL3 = HaveEL(EL3) & SCR_EL3[API] == 0b0
      },
      ? if ? == EL1 => {
          Enable = SCTLR_EL1[EnIB];
          TrapEL2 = EL2Enabled() & HCR_EL2[API] == 0b0;
          TrapEL3 = HaveEL(EL3) & SCR_EL3[API] == 0b0
      },
      ? if ? == EL2 => {
          Enable = SCTLR_EL2[EnIB];
          TrapEL2 = false;
          TrapEL3 = HaveEL(EL3) & SCR_EL3[API] == 0b0
      },
      ? if ? == EL3 => {
          Enable = SCTLR_EL3[EnIB];
          TrapEL2 = false;
          TrapEL3 = false
      },
      _ => ()
    };
    if Enable == 0b0 then {
        return(x)
    } else if TrapEL3 & EL3SDDUndefPriority() then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if TrapEL2 then {
        TrapPACUse(EL2);
        return(undefined : bits(64))
    } else if TrapEL3 then {
        if EL3SDDUndef() then {
            throw(Error_Undefined());
            return(undefined : bits(64))
        } else {
            TrapPACUse(EL3);
            return(undefined : bits(64))
        }
    } else {
        return(AddPAC(x, y, APIBKey_EL1, false))
    }
}

type APDAKeyHi_EL1_Type = bits(64)

register APDAKeyHi_EL1 : APDAKeyHi_EL1_Type

type APDAKeyLo_EL1_Type = bits(64)

register APDAKeyLo_EL1 : APDAKeyLo_EL1_Type

val AddPACDA : (bits(64), bits(64)) -> bits(64)

function AddPACDA (x, y) = {
    TrapEL2 : bool = undefined;
    TrapEL3 : bool = undefined;
    Enable : bits(1) = undefined;
    let APDAKey_EL1 : bits(128) = APDAKeyHi_EL1[63 .. 0] @ APDAKeyLo_EL1[63 .. 0];
    match PSTATE.EL {
      ? if ? == EL0 => {
          let IsEL1Regime : bool = S1TranslationRegime__1() == EL1;
          Enable = if IsEL1Regime then SCTLR_EL1[EnDA] else SCTLR_EL2[EnDA];
          TrapEL2 = (EL2Enabled() & HCR_EL2[API] == 0b0) & (HCR_EL2[TGE] == 0b0 | HCR_EL2[E2H] == 0b0);
          TrapEL3 = HaveEL(EL3) & SCR_EL3[API] == 0b0
      },
      ? if ? == EL1 => {
          Enable = SCTLR_EL1[EnDA];
          TrapEL2 = EL2Enabled() & HCR_EL2[API] == 0b0;
          TrapEL3 = HaveEL(EL3) & SCR_EL3[API] == 0b0
      },
      ? if ? == EL2 => {
          Enable = SCTLR_EL2[EnDA];
          TrapEL2 = false;
          TrapEL3 = HaveEL(EL3) & SCR_EL3[API] == 0b0
      },
      ? if ? == EL3 => {
          Enable = SCTLR_EL3[EnDA];
          TrapEL2 = false;
          TrapEL3 = false
      },
      _ => ()
    };
    if Enable == 0b0 then {
        return(x)
    } else if TrapEL3 & EL3SDDUndefPriority() then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if TrapEL2 then {
        TrapPACUse(EL2);
        return(undefined : bits(64))
    } else if TrapEL3 then {
        if EL3SDDUndef() then {
            throw(Error_Undefined());
            return(undefined : bits(64))
        } else {
            TrapPACUse(EL3);
            return(undefined : bits(64))
        }
    } else {
        return(AddPAC(x, y, APDAKey_EL1, true))
    }
}

type APDBKeyHi_EL1_Type = bits(64)

register APDBKeyHi_EL1 : APDBKeyHi_EL1_Type

type APDBKeyLo_EL1_Type = bits(64)

register APDBKeyLo_EL1 : APDBKeyLo_EL1_Type

val AddPACDB : (bits(64), bits(64)) -> bits(64)

function AddPACDB (x, y) = {
    TrapEL2 : bool = undefined;
    TrapEL3 : bool = undefined;
    Enable : bits(1) = undefined;
    let APDBKey_EL1 : bits(128) = APDBKeyHi_EL1[63 .. 0] @ APDBKeyLo_EL1[63 .. 0];
    match PSTATE.EL {
      ? if ? == EL0 => {
          let IsEL1Regime : bool = S1TranslationRegime__1() == EL1;
          Enable = if IsEL1Regime then SCTLR_EL1[EnDB] else SCTLR_EL2[EnDB];
          TrapEL2 = (EL2Enabled() & HCR_EL2[API] == 0b0) & (HCR_EL2[TGE] == 0b0 | HCR_EL2[E2H] == 0b0);
          TrapEL3 = HaveEL(EL3) & SCR_EL3[API] == 0b0
      },
      ? if ? == EL1 => {
          Enable = SCTLR_EL1[EnDB];
          TrapEL2 = EL2Enabled() & HCR_EL2[API] == 0b0;
          TrapEL3 = HaveEL(EL3) & SCR_EL3[API] == 0b0
      },
      ? if ? == EL2 => {
          Enable = SCTLR_EL2[EnDB];
          TrapEL2 = false;
          TrapEL3 = HaveEL(EL3) & SCR_EL3[API] == 0b0
      },
      ? if ? == EL3 => {
          Enable = SCTLR_EL3[EnDB];
          TrapEL2 = false;
          TrapEL3 = false
      },
      _ => ()
    };
    if Enable == 0b0 then {
        return(x)
    } else if TrapEL3 & EL3SDDUndefPriority() then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if TrapEL2 then {
        TrapPACUse(EL2);
        return(undefined : bits(64))
    } else if TrapEL3 then {
        if EL3SDDUndef() then {
            throw(Error_Undefined());
            return(undefined : bits(64))
        } else {
            TrapPACUse(EL3);
            return(undefined : bits(64))
        }
    } else {
        return(AddPAC(x, y, APDBKey_EL1, true))
    }
}

type APGAKeyHi_EL1_Type = bits(64)

register APGAKeyHi_EL1 : APGAKeyHi_EL1_Type

type APGAKeyLo_EL1_Type = bits(64)

register APGAKeyLo_EL1 : APGAKeyLo_EL1_Type

val AddPACGA : (bits(64), bits(64)) -> bits(64)

function AddPACGA (x, y) = {
    TrapEL2 : bool = undefined;
    TrapEL3 : bool = undefined;
    let isgeneric : bool = true;
    let APGAKey_EL1 : bits(128) = APGAKeyHi_EL1[63 .. 0] @ APGAKeyLo_EL1[63 .. 0];
    match PSTATE.EL {
      ? if ? == EL0 => {
          TrapEL2 = (EL2Enabled() & HCR_EL2[API] == 0b0) & (HCR_EL2[TGE] == 0b0 | HCR_EL2[E2H] == 0b0);
          TrapEL3 = HaveEL(EL3) & SCR_EL3[API] == 0b0
      },
      ? if ? == EL1 => {
          TrapEL2 = EL2Enabled() & HCR_EL2[API] == 0b0;
          TrapEL3 = HaveEL(EL3) & SCR_EL3[API] == 0b0
      },
      ? if ? == EL2 => {
          TrapEL2 = false;
          TrapEL3 = HaveEL(EL3) & SCR_EL3[API] == 0b0
      },
      ? if ? == EL3 => {
          TrapEL2 = false;
          TrapEL3 = false
      },
      _ => ()
    };
    if TrapEL3 & EL3SDDUndefPriority() then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if TrapEL2 then {
        TrapPACUse(EL2);
        return(undefined : bits(64))
    } else if TrapEL3 then {
        if EL3SDDUndef() then {
            throw(Error_Undefined());
            return(undefined : bits(64))
        } else {
            TrapPACUse(EL3);
            return(undefined : bits(64))
        }
    } else {
        return(ComputePAC(x, y, APGAKey_EL1[127 .. 64], APGAKey_EL1[63 .. 0], isgeneric)[63 .. 32] @ Zeros(32))
    }
}

val AuthIA : forall ('is_combined : Bool).
  (bits(64), bits(64), bool('is_combined)) -> bits(64)

function AuthIA (x, y, is_combined) = {
    TrapEL2 : bool = undefined;
    TrapEL3 : bool = undefined;
    Enable : bits(1) = undefined;
    let APIAKey_EL1 : bits(128) = APIAKeyHi_EL1[63 .. 0] @ APIAKeyLo_EL1[63 .. 0];
    match PSTATE.EL {
      ? if ? == EL0 => {
          let IsEL1Regime : bool = S1TranslationRegime__1() == EL1;
          Enable = if IsEL1Regime then SCTLR_EL1[EnIA] else SCTLR_EL2[EnIA];
          TrapEL2 = (EL2Enabled() & HCR_EL2[API] == 0b0) & (HCR_EL2[TGE] == 0b0 | HCR_EL2[E2H] == 0b0);
          TrapEL3 = HaveEL(EL3) & SCR_EL3[API] == 0b0
      },
      ? if ? == EL1 => {
          Enable = SCTLR_EL1[EnIA];
          TrapEL2 = EL2Enabled() & HCR_EL2[API] == 0b0;
          TrapEL3 = HaveEL(EL3) & SCR_EL3[API] == 0b0
      },
      ? if ? == EL2 => {
          Enable = SCTLR_EL2[EnIA];
          TrapEL2 = false;
          TrapEL3 = HaveEL(EL3) & SCR_EL3[API] == 0b0
      },
      ? if ? == EL3 => {
          Enable = SCTLR_EL3[EnIA];
          TrapEL2 = false;
          TrapEL3 = false
      },
      _ => ()
    };
    if Enable == 0b0 then {
        return(x)
    } else if TrapEL3 & EL3SDDUndefPriority() then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if TrapEL2 then {
        TrapPACUse(EL2);
        return(undefined : bits(64))
    } else if TrapEL3 then {
        if EL3SDDUndef() then {
            throw(Error_Undefined());
            return(undefined : bits(64))
        } else {
            TrapPACUse(EL3);
            return(undefined : bits(64))
        }
    } else {
        return(Auth(x, y, APIAKey_EL1, false, 0b0, is_combined))
    }
}

val AuthIB : forall ('is_combined : Bool).
  (bits(64), bits(64), bool('is_combined)) -> bits(64)

function AuthIB (x, y, is_combined) = {
    TrapEL2 : bool = undefined;
    TrapEL3 : bool = undefined;
    Enable : bits(1) = undefined;
    let APIBKey_EL1 : bits(128) = APIBKeyHi_EL1[63 .. 0] @ APIBKeyLo_EL1[63 .. 0];
    match PSTATE.EL {
      ? if ? == EL0 => {
          let IsEL1Regime : bool = S1TranslationRegime__1() == EL1;
          Enable = if IsEL1Regime then SCTLR_EL1[EnIB] else SCTLR_EL2[EnIB];
          TrapEL2 = (EL2Enabled() & HCR_EL2[API] == 0b0) & (HCR_EL2[TGE] == 0b0 | HCR_EL2[E2H] == 0b0);
          TrapEL3 = HaveEL(EL3) & SCR_EL3[API] == 0b0
      },
      ? if ? == EL1 => {
          Enable = SCTLR_EL1[EnIB];
          TrapEL2 = EL2Enabled() & HCR_EL2[API] == 0b0;
          TrapEL3 = HaveEL(EL3) & SCR_EL3[API] == 0b0
      },
      ? if ? == EL2 => {
          Enable = SCTLR_EL2[EnIB];
          TrapEL2 = false;
          TrapEL3 = HaveEL(EL3) & SCR_EL3[API] == 0b0
      },
      ? if ? == EL3 => {
          Enable = SCTLR_EL3[EnIB];
          TrapEL2 = false;
          TrapEL3 = false
      },
      _ => ()
    };
    if Enable == 0b0 then {
        return(x)
    } else if TrapEL3 & EL3SDDUndefPriority() then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if TrapEL2 then {
        TrapPACUse(EL2);
        return(undefined : bits(64))
    } else if TrapEL3 then {
        if EL3SDDUndef() then {
            throw(Error_Undefined());
            return(undefined : bits(64))
        } else {
            TrapPACUse(EL3);
            return(undefined : bits(64))
        }
    } else {
        return(Auth(x, y, APIBKey_EL1, false, 0b1, is_combined))
    }
}

val AuthDA : forall ('is_combined : Bool).
  (bits(64), bits(64), bool('is_combined)) -> bits(64)

function AuthDA (x, y, is_combined) = {
    TrapEL2 : bool = undefined;
    TrapEL3 : bool = undefined;
    Enable : bits(1) = undefined;
    let APDAKey_EL1 : bits(128) = APDAKeyHi_EL1[63 .. 0] @ APDAKeyLo_EL1[63 .. 0];
    match PSTATE.EL {
      ? if ? == EL0 => {
          let IsEL1Regime : bool = S1TranslationRegime__1() == EL1;
          Enable = if IsEL1Regime then SCTLR_EL1[EnDA] else SCTLR_EL2[EnDA];
          TrapEL2 = (EL2Enabled() & HCR_EL2[API] == 0b0) & (HCR_EL2[TGE] == 0b0 | HCR_EL2[E2H] == 0b0);
          TrapEL3 = HaveEL(EL3) & SCR_EL3[API] == 0b0
      },
      ? if ? == EL1 => {
          Enable = SCTLR_EL1[EnDA];
          TrapEL2 = EL2Enabled() & HCR_EL2[API] == 0b0;
          TrapEL3 = HaveEL(EL3) & SCR_EL3[API] == 0b0
      },
      ? if ? == EL2 => {
          Enable = SCTLR_EL2[EnDA];
          TrapEL2 = false;
          TrapEL3 = HaveEL(EL3) & SCR_EL3[API] == 0b0
      },
      ? if ? == EL3 => {
          Enable = SCTLR_EL3[EnDA];
          TrapEL2 = false;
          TrapEL3 = false
      },
      _ => ()
    };
    if Enable == 0b0 then {
        return(x)
    } else if TrapEL3 & EL3SDDUndefPriority() then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if TrapEL2 then {
        TrapPACUse(EL2);
        return(undefined : bits(64))
    } else if TrapEL3 then {
        if EL3SDDUndef() then {
            throw(Error_Undefined());
            return(undefined : bits(64))
        } else {
            TrapPACUse(EL3);
            return(undefined : bits(64))
        }
    } else {
        return(Auth(x, y, APDAKey_EL1, true, 0b0, is_combined))
    }
}

val AuthDB : forall ('is_combined : Bool).
  (bits(64), bits(64), bool('is_combined)) -> bits(64)

function AuthDB (x, y, is_combined) = {
    TrapEL2 : bool = undefined;
    TrapEL3 : bool = undefined;
    Enable : bits(1) = undefined;
    let APDBKey_EL1 : bits(128) = APDBKeyHi_EL1[63 .. 0] @ APDBKeyLo_EL1[63 .. 0];
    match PSTATE.EL {
      ? if ? == EL0 => {
          let IsEL1Regime : bool = S1TranslationRegime__1() == EL1;
          Enable = if IsEL1Regime then SCTLR_EL1[EnDB] else SCTLR_EL2[EnDB];
          TrapEL2 = (EL2Enabled() & HCR_EL2[API] == 0b0) & (HCR_EL2[TGE] == 0b0 | HCR_EL2[E2H] == 0b0);
          TrapEL3 = HaveEL(EL3) & SCR_EL3[API] == 0b0
      },
      ? if ? == EL1 => {
          Enable = SCTLR_EL1[EnDB];
          TrapEL2 = EL2Enabled() & HCR_EL2[API] == 0b0;
          TrapEL3 = HaveEL(EL3) & SCR_EL3[API] == 0b0
      },
      ? if ? == EL2 => {
          Enable = SCTLR_EL2[EnDB];
          TrapEL2 = false;
          TrapEL3 = HaveEL(EL3) & SCR_EL3[API] == 0b0
      },
      ? if ? == EL3 => {
          Enable = SCTLR_EL3[EnDB];
          TrapEL2 = false;
          TrapEL3 = false
      },
      _ => ()
    };
    if Enable == 0b0 then {
        return(x)
    } else if TrapEL3 & EL3SDDUndefPriority() then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if TrapEL2 then {
        TrapPACUse(EL2);
        return(undefined : bits(64))
    } else if TrapEL3 then {
        if EL3SDDUndef() then {
            throw(Error_Undefined());
            return(undefined : bits(64))
        } else {
            TrapPACUse(EL3);
            return(undefined : bits(64))
        }
    } else {
        return(Auth(x, y, APDBKey_EL1, true, 0b1, is_combined))
    }
}

val X_read : forall 'n 'width,
  'width in {8, 16, 32, 64}.
  (int('n), int('width)) -> bits('width)

function X_read (n, width) = {
    assert(n >= 0 & n <= 31);
    assert(width == 8 | width == 16 | width == 32 | width == 64);
    if n != 31 then {
        return(_R(n)[width - 1 .. 0])
    } else {
        return(Zeros(width))
    }
}

val V_read : forall 'n 'width,
  'width in {8, 16, 32, 64, 128}.
  (int('n), int('width)) -> bits('width)

function V_read (n, width) = {
    assert(n >= 0 & n <= 31);
    assert(width == 8 | width == 16 | width == 32 | width == 64 | width == 128);
    return(_Z[n][width - 1 .. 0])
}

val Vpart_read : forall 'n 'part 'width,
  'width >= 0.
  (int('n), int('part), int('width)) -> bits('width)

function Vpart_read (n, part, width) = {
    assert(n >= 0 & n <= 31);
    assert(part == 0 | part == 1);
    if part == 0 then {
        assert(width < 128);
        assert(constraint('width in {8, 16, 32, 64, 128}));
        return(V_read(n, width))
    } else {
        assert(width == 32 | width == 64);
        let vreg : bits(128) = V_read(n, 128);
        return(vreg[width * 2 - 1 .. width])
    }
}

val Vpart_set : forall 'n 'part 'width,
  'width >= 0.
  (int('n), int('part), int('width), bits('width)) -> unit

function Vpart_set (n, part, width, value_name) = {
    assert(n >= 0 & n <= 31);
    assert(part == 0 | part == 1);
    if part == 0 then {
        assert(width < 128);
        assert(constraint('width in {8, 16, 32, 64, 128}));
        V_set(n, width) = value_name
    } else {
        assert(width == 64);
        let vreg : bits(64) = V_read(n, 64);
        V_set(n, 128) = value_name[63 .. 0] @ vreg
    }
}

val AArch64_ResetGeneralRegisters : unit -> unit

function AArch64_ResetGeneralRegisters () = {
    foreach (i from 0 to 30 by 1 in inc) {
        X_set(i, 64) = __UNKNOWN_bits(64)
    };
    return()
}

val AArch64_ResetSIMDFPRegisters : unit -> unit

function AArch64_ResetSIMDFPRegisters () = {
    foreach (i from 0 to 31 by 1 in inc) {
        V_set(i, 128) = __UNKNOWN_bits(128)
    };
    return()
}

val AArch64_ResetSpecialRegisters : unit -> unit

function AArch64_ResetSpecialRegisters () = {
    SP_EL0 = __UNKNOWN_bits(64);
    SP_EL1 = __UNKNOWN_bits(64);
    SPSR_EL1 = Mk_SPSR_EL1_Type(__UNKNOWN_bits(64));
    ELR_EL1 = __UNKNOWN_bits(64);
    if HaveEL(EL2) then {
        SP_EL2 = __UNKNOWN_bits(64);
        SPSR_EL2 = Mk_SPSR_EL2_Type(__UNKNOWN_bits(64));
        ELR_EL2 = __UNKNOWN_bits(64)
    };
    if HaveEL(EL3) then {
        SP_EL3 = __UNKNOWN_bits(64);
        SPSR_EL3 = Mk_SPSR_EL3_Type(__UNKNOWN_bits(64));
        ELR_EL3 = __UNKNOWN_bits(64)
    };
    if HaveAArch32EL(EL1) then {
        SPSR_fiq.bits[31 .. 0] = __UNKNOWN_bits(32);
        SPSR_irq.bits[31 .. 0] = __UNKNOWN_bits(32);
        SPSR_abt.bits[31 .. 0] = __UNKNOWN_bits(32);
        SPSR_und.bits[31 .. 0] = __UNKNOWN_bits(32)
    };
    DLR_EL0 = __UNKNOWN_bits(64);
    DSPSR_EL0 = Mk_DSPSR_EL0_Type(__UNKNOWN_bits(64));
    return()
}

val ELR_read : bits(2) -> bits(64)

val ELR_read__1 : unit -> bits(64)

function ELR_read el = {
    r : bits(64) = undefined;
    match el {
      ? if ? == EL1 => {
          r = ELR_EL1
      },
      ? if ? == EL2 => {
          r = ELR_EL2
      },
      ? if ? == EL3 => {
          r = ELR_EL3
      },
      _ => {
          Unreachable()
      }
    };
    return(r)
}

function ELR_read__1 () = {
    assert(PSTATE.EL != EL0);
    return(ELR_read(PSTATE.EL))
}

bitfield CNTKCTL_Type : bits(32) =
  {
    EVNTIS : 17..17,
    PL0PTEN : 9..9,
    PL0VTEN : 8..8,
    EVNTI : 7..4,
    EVNTDIR : 3..3,
    EVNTEN : 2..2,
    PL0VCTEN : 1..1,
    PL0PCTEN : 0..0
  }

register _CNTKCTL : CNTKCTL_Type

val CNTKCTL_read__1 : unit -> CNTKCTL_Type

function CNTKCTL_read__1 () = {
    r : CNTKCTL_Type = _CNTKCTL;
    r.bits[31 .. 0] = Slice(CNTKCTL_EL1.bits, 0, 32);
    return(r)
}

val CheckTransactionalSystemAccess : (bits(2), bits(3), bits(4), bits(4), bits(3), bits(1)) -> bool

function CheckTransactionalSystemAccess (op0, op1, crn, crm, op2, read) = {
    match ((((read @ op0) @ op1) @ crn) @ crm) @ op2 {
      [bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitzero, _, _, _, _, bitone, bitone, _] => {
          return(true)
      },
      0b00101101110100001 => {
          return(true)
      },
      [bitzero, bitone, bitone, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, _] => {
          return(true)
      },
      [bitzero, bitone, bitone, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, _] => {
          return(true)
      },
      0b01100001000110000 => {
          return(true)
      },
      0b01101110011100100 => {
          return(true)
      },
      0b11101100100101001 => {
          return(PSTATE.EL == EL0)
      },
      0b11100000100101001 => {
          return(PSTATE.EL == EL1 | PSTATE.EL == EL2 & HCR_EL2[E2H] == 0b1)
      },
      0b11110000100101001 => {
          return(PSTATE.EL == EL2 & HCR_EL2[E2H] == 0b0)
      },
      0b11111000100101001 => {
          return(PSTATE.EL == EL3)
      },
      0b00101101110111000 => {
          return(true)
      },
      0b10101101110111001 => {
          return(true)
      },
      0b00101101110111010 => {
          return(true)
      },
      0b10101101110111011 => {
          return(true)
      },
      0b00100001110111110 => {
          return(true)
      },
      0b11110100100101001 => {
          return(false)
      },
      0b11100000100101010 => {
          return(false)
      },
      0b11100000100101000 => {
          return(false)
      },
      0b11110100100101000 => {
          return(false)
      },
      0b11110000100101000 => {
          return(false)
      },
      0b11111000100101000 => {
          return(false)
      },
      [bitone, bitone, bitone, _, _, _, bitzero, _, _, _, _, _, _, _, _, _, _] => {
          return(true)
      },
      [bitone, bitone, bitone, _, _, _, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _] => {
          return(true)
      },
      [bitone, bitone, bitone, _, _, _, bitone, bitzero, bitone, bitzero, _, _, _, _, _, _, _] => {
          return(true)
      },
      [bitone, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitone, _, bitzero, bitzero, bitzero, bitone, bitzero] => {
          return(true)
      },
      0b11100011001011011 => {
          return(true)
      },
      [bitone, bitone, bitone, _, _, _, bitone, bitone, bitzero, bitone, _, _, _, _, _, _, _] => {
          return(true)
      },
      [bitone, bitone, bitone, _, _, _, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _] => {
          return(true)
      },
      0b00101101110011111 => {
          return(true)
      },
      [bitzero, bitzero, bitone, bitzero, bitone, bitone, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, bitone, bitzero, _] => {
          return(true)
      },
      [_, bitone, bitone, _, _, _, bitone, _, bitone, bitone, _, _, _, _, _, _, _] => {
          return(__IMPDEF_boolean(""))
      },
      _ => {
          return(false)
      }
    }
}

val AArch64_CheckSystemAccess : (bits(2), bits(3), bits(4), bits(4), bits(3), bits(5), bits(1)) -> unit

function AArch64_CheckSystemAccess (op0, op1, crn, crm, op2, rt, read) = {
    if HaveBTIExt() then {
        BranchTargetCheck()
    };
    if (HaveTME() & TSTATE.depth > 0) & not_bool(CheckTransactionalSystemAccess(op0, op1, crn, crm, op2, read)) then {
        FailTransaction(TMFailure_ERR, false)
    };
    return()
}

val SetInGuardedPage : forall ('guardedpage : Bool). bool('guardedpage) -> unit

function SetInGuardedPage guardedpage = {
    InGuardedPage = guardedpage
}

val BTypeCompatible_BTI : bits(2) -> bool

function BTypeCompatible_BTI hintcode = {
    match hintcode {
      0b00 => {
          return(false)
      },
      0b01 => {
          return(PSTATE.BTYPE != 0b11)
      },
      0b10 => {
          return(PSTATE.BTYPE != 0b10)
      },
      0b11 => {
          return(true)
      },
      _ => {
          return(undefined : bool)
      }
    }
}

val BTypeCompatible_PACIXSP : unit -> bool

function BTypeCompatible_PACIXSP () = {
    index : int = undefined;
    if PSTATE.BTYPE == 0b01 | PSTATE.BTYPE == 0b10 then {
        return(true)
    } else if PSTATE.BTYPE == 0b11 then {
        let 'index = if PSTATE.EL == EL0 then 35 else 36;
        return([SCTLR_read__1().bits[index]] == 0b0)
    } else {
        return(false)
    }
}

val AArch64_ExecutingERETInstr : unit -> bool

function AArch64_ExecutingERETInstr () = {
    let instr : bits(32) = ThisInstr();
    return(instr[31 .. 12] == 0b11010110100111110000)
}

val SetBTypeCompatible : forall ('x : Bool). bool('x) -> unit

function SetBTypeCompatible x = {
    BTypeCompatible = x
}

val SetBTypeNext : bits(2) -> unit

function SetBTypeNext x = {
    BTypeNext = x
}

val AArch64_AllocationTagAccessIsEnabled : bits(2) -> bool

function AArch64_AllocationTagAccessIsEnabled el = {
    if SCR_EL3[ATA] == 0b0 & (el == EL0 | el == EL1 | el == EL2) then {
        return(false)
    };
    if ((HCR_EL2[ATA] == 0b0 & (el == EL0 | el == EL1)) & EL2Enabled()) & (HCR_EL2[E2H] @ HCR_EL2[TGE]) != 0b11 then {
        return(false)
    };
    let regime : Regime = TranslationRegime(el);
    match regime {
      Regime_EL3 => {
          return(SCTLR_EL3[ATA] == 0b1)
      },
      Regime_EL2 => {
          return(SCTLR_EL2[ATA] == 0b1)
      },
      Regime_EL20 => {
          return(if el == EL0 then SCTLR_EL2[ATA0] == 0b1 else
            SCTLR_EL2[ATA] == 0b1)
      },
      Regime_EL10 => {
          return(if el == EL0 then SCTLR_EL1[ATA0] == 0b1 else
            SCTLR_EL1[ATA] == 0b1)
      },
      _ => {
          Unreachable();
          return(undefined : bool)
      }
    }
}

bitfield GCR_EL1_Type : bits(64) = {RRND : 16..16, Exclude : 15..0}

register GCR_EL1 : GCR_EL1_Type

bitfield RGSR_EL1_Type : bits(64) = {SEED : 55..8, TAG : 3..0}

register RGSR_EL1 : RGSR_EL1_Type

val AArch64_NextRandomTagBit : unit -> bits(1)

function AArch64_NextRandomTagBit () = {
    assert(GCR_EL1[RRND] == 0b0);
    let lfsr : bits(16) = RGSR_EL1[SEED][15 .. 0];
    let top : bits(1) = EOR(EOR(EOR([lfsr[5]], [lfsr[3]]), [lfsr[2]]), [lfsr[0]]);
    RGSR_EL1[SEED][15 .. 0] = top @ lfsr[15 .. 1];
    return(top)
}

val AArch64_RandomTag : unit -> bits(4)

function AArch64_RandomTag () = {
    tag : bits(4) = undefined;
    foreach (i from 0 to 3 by 1 in inc) {
        tag[i] = Bit(AArch64_NextRandomTagBit())
    };
    return(tag)
}

val AArch64_ChooseNonExcludedTag : (bits(4), bits(4), bits(16)) -> bits(4)

function AArch64_ChooseNonExcludedTag (tag_in, offset_in, exclude) = {
    tag : bits(4) = tag_in;
    offset : bits(4) = offset_in;
    if IsOnes(exclude) then {
        return(0b0000)
    };
    if offset == 0b0000 then {
        while [exclude[UInt(tag)]] == 0b1 do {
            tag = tag + 0b0001
        }
    };
    while offset != 0b0000 do {
        offset = offset - 0b0001;
        tag = tag + 0b0001;
        while [exclude[UInt(tag)]] == 0b1 do {
            tag = tag + 0b0001
        }
    };
    return(tag)
}

val ChooseRandomNonExcludedTag : bits(16) -> bits(4)

val AllInAlignedQuantity : forall 'alignment 'size.
  (bits(64), int('size), int('alignment)) -> bool

function AllInAlignedQuantity (address, size, alignment) = {
    assert(size <= alignment);
    return(Align(address + size - 1, alignment) == Align(address, alignment))
}

val AArch64_SPAlignmentFault : unit -> unit

function AArch64_SPAlignmentFault () = {
    let preferred_exception_return : bits(64) = ThisInstrAddr(64);
    let 'vect_offset = UInt(0x0);
    let except : ExceptionRecord = ExceptionSyndrome(Exception_SPAlignment);
    target_el : bits(2) = EL1;
    if UInt(PSTATE.EL) > UInt(EL1) then {
        target_el = PSTATE.EL
    } else if EL2Enabled() & HCR_EL2[TGE] == 0b1 then {
        target_el = EL2
    } else ();
    sail_take_exception(None());
    AArch64_TakeException(target_el, except, preferred_exception_return, vect_offset)
}

val SP_read : unit -> bits(64)

function SP_read () = {
    if PSTATE.SP == 0b0 then {
        return(SP_EL0)
    } else {
        match PSTATE.EL {
          ? if ? == EL0 => {
              return(SP_EL0)
          },
          ? if ? == EL1 => {
              return(SP_EL1)
          },
          ? if ? == EL2 => {
              return(SP_EL2)
          },
          ? if ? == EL3 => {
              return(SP_EL3)
          },
          _ => {
              return(undefined : bits(64))
          }
        }
    }
}

val CheckSPAlignment : unit -> unit

function CheckSPAlignment () = {
    let sp : bits(64) = SP_read();
    stack_align_check : bool = undefined;
    if PSTATE.EL == EL0 then {
        stack_align_check = SCTLR_read__1()[SA0] != 0b0
    } else {
        stack_align_check = SCTLR_read__1()[SA] != 0b0
    };
    if stack_align_check & sp != Align(sp, 16) then {
        AArch64_SPAlignmentFault()
    };
    return()
}

val AArch64_UnalignedAccessFaults : forall 'size.
  (AccessDescriptor, bits(64), int('size)) -> bool

function AArch64_UnalignedAccessFaults (accdesc, address, size) = {
    if AlignmentEnforced() then {
        return(true)
    } else if accdesc.acctype == AccessType_GCS then {
        return(true)
    } else if accdesc.rcw then {
        return(true)
    } else if accdesc.ls64 then {
        return(true)
    } else if accdesc.exclusive | accdesc.atomicop then {
        return(not_bool(HaveLSE2Ext()) | not_bool(AllInAlignedQuantity(address, size, 16)))
    } else if (accdesc.acqsc | accdesc.acqpc) | accdesc.relsc then {
        return(not_bool(HaveLSE2Ext()) | SCTLR_read__1()[nAA] == 0b0 & not_bool(AllInAlignedQuantity(address, size, 16)))
    } else {
        return(false)
    }
}

val StoreOnlyTagCheckingEnabled : bits(2) -> bool

function StoreOnlyTagCheckingEnabled el = {
    assert(HaveMTEStoreOnlyExt());
    tcso : bits(1) = undefined;
    match el {
      ? if ? == EL0 => {
          if not_bool(ELIsInHost(el)) then {
              tcso = SCTLR_EL1[TCSO0]
          } else {
              tcso = SCTLR_EL2[TCSO0]
          }
      },
      ? if ? == EL1 => {
          tcso = SCTLR_EL1[TCSO]
      },
      ? if ? == EL2 => {
          tcso = SCTLR_EL2[TCSO]
      },
      _ => {
          tcso = SCTLR_EL3[TCSO]
      }
    };
    return(tcso == 0b1)
}

val AArch64_AccessIsTagChecked : (bits(64), AccessDescriptor) -> bool

function AArch64_AccessIsTagChecked (vaddr, accdesc) = {
    assert(accdesc.tagchecked);
    if UsingAArch32() then {
        return(false)
    };
    let is_instr : bool = false;
    if EffectiveMTX(vaddr, is_instr, PSTATE.EL) == 0b0 & EffectiveTBI(vaddr, is_instr, PSTATE.EL) == 0b0 then {
        return(false)
    };
    if EffectiveTCMA(vaddr, PSTATE.EL) == 0b1 & (vaddr[59 .. 55] == 0b00000 | vaddr[59 .. 55] == 0b11111) then {
        return(false)
    };
    if not_bool(AArch64_AllocationTagAccessIsEnabled(accdesc.el)) then {
        return(false)
    };
    if PSTATE.TCO == 0b1 then {
        return(false)
    };
    if (HaveMTEStoreOnlyExt() & not_bool(accdesc.write)) & StoreOnlyTagCheckingEnabled(accdesc.el) then {
        return(false)
    };
    return(true)
}

val PhysMemTagRead : (AddressDescriptor, AccessDescriptor) -> (PhysMemRetStatus, bits(4))

val AArch64_AllocationTagCheck : (AddressDescriptor, AccessDescriptor, bits(4)) -> bool

function AArch64_AllocationTagCheck (memaddrdesc, accdesc, ptag) = {
    memstatus : PhysMemRetStatus = undefined;
    readtag : bits(4) = undefined;
    if memaddrdesc.memattrs.tags == MemTag_AllocationTagged then {
        (memstatus, readtag) = PhysMemTagRead(memaddrdesc, accdesc);
        if IsFault__2(memstatus) then {
            HandleExternalReadAbort(memstatus, memaddrdesc, 1, accdesc)
        };
        return(ptag == readtag)
    } else {
        return(true)
    }
}

val AArch64_CanonicalTagCheck : (AddressDescriptor, bits(4)) -> bool

function AArch64_CanonicalTagCheck (memaddrdesc, ptag) = {
    let expected_tag : bits(4) = if [memaddrdesc.vaddress[55]] == 0b0 then
      0b0000
    else
      0b1111;
    return(ptag == expected_tag)
}

val AArch64_CheckTag : (AddressDescriptor, AccessDescriptor, bits(4)) -> bool

function AArch64_CheckTag (memaddrdesc, accdesc, ptag) = {
    if memaddrdesc.memattrs.tags == MemTag_AllocationTagged then {
        return(AArch64_AllocationTagCheck(memaddrdesc, accdesc, ptag))
    } else if memaddrdesc.memattrs.tags == MemTag_CanonicallyTagged then {
        return(AArch64_CanonicalTagCheck(memaddrdesc, ptag))
    } else {
        return(true)
    }
}

val AArch64_PhysicalTag : bits(64) -> bits(4)

function AArch64_PhysicalTag vaddr = {
    return(vaddr[59 .. 56])
}

val AArch64_EffectiveTCF : bits(2) -> bits(2)

function AArch64_EffectiveTCF el = {
    tcf : bits(2) = undefined;
    let regime : Regime = TranslationRegime(el);
    match regime {
      Regime_EL3 => {
          tcf = SCTLR_EL3[TCF]
      },
      Regime_EL2 => {
          tcf = SCTLR_EL2[TCF]
      },
      Regime_EL20 => {
          tcf = if el == EL0 then SCTLR_EL2[TCF0] else SCTLR_EL2[TCF]
      },
      Regime_EL10 => {
          tcf = if el == EL0 then SCTLR_EL1[TCF0] else SCTLR_EL1[TCF]
      },
      _ => {
          Unreachable()
      }
    };
    if tcf == 0b11 then {
        if not_bool(HaveMTEAsymFaultExt()) then {
            let (_, __tup_1 : bits(2)) = ConstrainUnpredictableBits(Unpredictable_RESTCF, 2);
            tcf = __tup_1
        };
        ()
    };
    return(tcf)
}

val AArch64_RaiseTagCheckFault : (bits(64), FaultRecord) -> unit

function AArch64_RaiseTagCheckFault (va, fault) = {
    let preferred_exception_return : bits(64) = ThisInstrAddr(64);
    let 'vect_offset = UInt(0x0);
    target_el : bits(2) = EL1;
    if UInt(PSTATE.EL) > UInt(EL1) then {
        target_el = PSTATE.EL
    } else if (PSTATE.EL == EL0 & EL2Enabled()) & HCR_EL2[TGE] == 0b1 then {
        target_el = EL2
    } else ();
    let except : ExceptionRecord = AArch64_AbortSyndrome(Exception_DataAbort, fault, va, target_el);
    sail_take_exception(Some(fault));
    AArch64_TakeException(target_el, except, preferred_exception_return, vect_offset)
}

bitfield TFSRE0_EL1_Type : bits(64) = {TF1 : 1..1, TF0 : 0..0}

register TFSRE0_EL1 : TFSRE0_EL1_Type

bitfield TFSR_EL1_Type : bits(64) = {TF1 : 1..1, TF0 : 0..0}

register TFSR_EL1 : TFSR_EL1_Type

bitfield TFSR_EL2_Type : bits(64) = {TF1 : 1..1, TF0 : 0..0}

register TFSR_EL2 : TFSR_EL2_Type

bitfield TFSR_EL3_Type : bits(64) = {TF0 : 0..0}

register TFSR_EL3 : TFSR_EL3_Type

val AArch64_ReportTagCheckFault : (bits(2), bits(1)) -> unit

function AArch64_ReportTagCheckFault (el, ttbr) = {
    match el {
      ? if ? == EL3 => {
          assert(ttbr == 0b0);
          TFSR_EL3[TF0] = 0b1
      },
      ? if ? == EL2 => {
          if ttbr == 0b0 then {
              TFSR_EL2[TF0] = 0b1
          } else {
              TFSR_EL2[TF1] = 0b1
          }
      },
      ? if ? == EL1 => {
          if ttbr == 0b0 then {
              TFSR_EL1[TF0] = 0b1
          } else {
              TFSR_EL1[TF1] = 0b1
          }
      },
      ? if ? == EL0 => {
          if ttbr == 0b0 then {
              TFSRE0_EL1[TF0] = 0b1
          } else {
              TFSRE0_EL1[TF1] = 0b1
          }
      },
      _ => ()
    }
}

val AArch64_TagCheckFault : (bits(64), AccessDescriptor) -> unit

function AArch64_TagCheckFault (vaddress, accdesc) = {
    let tcf : bits(2) = AArch64_EffectiveTCF(accdesc.el);
    fault : FaultRecord = NoFault__1(accdesc);
    fault.statuscode = Fault_TagCheck;
    match tcf {
      0b00 => {
          return()
      },
      0b01 => {
          AArch64_RaiseTagCheckFault(vaddress, fault)
      },
      0b10 => {
          if HaveMTEAsyncExt() then {
              AArch64_ReportTagCheckFault(accdesc.el, [vaddress[55]])
          } else {
              return()
          }
      },
      0b11 => {
          if HaveMTEAsymFaultExt() then {
              if accdesc.read then {
                  AArch64_RaiseTagCheckFault(vaddress, fault)
              } else {
                  AArch64_ReportTagCheckFault(accdesc.el, [vaddress[55]])
              }
          } else {
              return()
          }
      }
    }
}

val NumBreakpointsImplemented : unit -> int

function NumBreakpointsImplemented () = {
    return(__IMPDEF_integer("Number of breakpoints"))
}

val NumContextAwareBreakpointsImplemented : unit -> int

function NumContextAwareBreakpointsImplemented () = {
    return(__IMPDEF_integer("Number of context-aware breakpoints"))
}

val AArch64_ReservedBreakpointType : forall 'n.
  (int('n), bits(1), bits(4)) -> (Constraint, bits(1), bits(4))

function AArch64_ReservedBreakpointType (n, bt2_in, bt_in) = {
    bt2 : bits(1) = bt2_in;
    bt : bits(4) = bt_in;
    reserved : bool = false;
    let context_aware : bool = n >= NumBreakpointsImplemented() - NumContextAwareBreakpointsImplemented();
    if bt2 == 0b0 then {
        if not_bool((match bt {
          [bitzero, _, bitzero, _] => true,
          _ => false
        }) : bool) & not_bool(context_aware) then {
            reserved = true
        };
        if (match bt {
          [bitone, _, _, _] => true,
          _ => false
        }) : bool & not_bool(HaveEL(EL2)) then {
            reserved = true
        };
        if ((match bt {
          [bitzero, bitone, bitone, _] => true,
          [bitone, bitone, _, _] => true,
          _ => false
        }) : bool & not_bool(HaveVirtHostExt())) & not_bool(HaveV82Debug()) then {
            reserved = true
        };
        if ((match bt {
          [bitzero, bitone, bitzero, _] => true,
          _ => false
        }) : bool & not_bool(HaveFeatABLE())) & not_bool(HaveAArch32EL(EL1)) then {
            reserved = true
        };
        ()
    } else {
        if not_bool((match bt {
          [bitzero, _, bitzero, _] => true,
          _ => false
        }) : bool) then {
            reserved = true
        };
        ()
    };
    if reserved then {
        c : Constraint = undefined;
        (c, (bt2 @ bt)) = ConstrainUnpredictableBits(Unpredictable_RESBPTYPE, 5);
        assert(c == Constraint_DISABLED | c == Constraint_UNKNOWN);
        if c == Constraint_DISABLED then {
            return((c, __UNKNOWN_bit(), __UNKNOWN_bits(4)))
        };
        ()
    };
    return((Constraint_NONE, bt2, bt))
}

bitfield CONTEXTIDR_EL2_Type : bits(64) = {PROCID : 31..0}

register CONTEXTIDR_EL2 : CONTEXTIDR_EL2_Type

bitfield DBGBCR_EL1_Type : bits(64) =
  {
    LBNX : 31..30,
    SSCE : 29..29,
    MASK : 28..24,
    BT : 23..20,
    LBN : 19..16,
    SSC : 15..14,
    HMC : 13..13,
    BAS : 8..5,
    BT2 : 3..3,
    PMC : 2..1,
    E : 0..0
  }

register DBGBCR_EL1 : vector(64, DBGBCR_EL1_Type)

bitfield DBGBVR_EL1_Type : bits(64) =
  {
    RESS : (63..57 @ (56..53 @ 52..49)),
    VA : (56..53 @ (52..49 @ 48..2)),
    VMID : (47..40 @ 39..32),
    ContextID2 : 63..32,
    ContextID : 31..0
  }

register DBGBVR_EL1 : vector(64, DBGBVR_EL1_Type)

val DebugAddrTop : unit -> int

function DebugAddrTop () = {
    if Have56BitVAExt() then {
        return(55)
    } else if Have52BitVAExt() then {
        return(52)
    } else {
        return(48)
    }
}

bitfield EDSCR2_Type : bits(32) = {EHBWE : 3..3}

register _EDSCR2 : EDSCR2_Type

val EDSCR2_read : unit -> EDSCR2_Type

function EDSCR2_read () = {
    r : EDSCR2_Type = _EDSCR2;
    r.bits[31 .. 0] = Slice(MDSCR_EL1.bits, 32, 32);
    return(r)
}

val HaltOnBreakpointOrWatchpoint : unit -> bool

function HaltOnBreakpointOrWatchpoint () = {
    return((HaltingAllowed() & EDSCR_read()[HDE] == 0b1) & OSLSR_EL1[OSLK] == 0b0)
}

val NumWatchpointsImplemented : unit -> int

function NumWatchpointsImplemented () = {
    return(__IMPDEF_integer("Number of watchpoints"))
}

val SelfHostedExtendedBPWPEnabled : unit -> bool

function SelfHostedExtendedBPWPEnabled () = {
    if NumBreakpointsImplemented() <= 16 & NumWatchpointsImplemented() <= 16 then {
        return(false)
    };
    if HaveEL(EL3) & MDCR_EL3[EBWE] == 0b0 | EL2Enabled() & MDCR_EL2[EBWE] == 0b0 then {
        return(false)
    };
    return(MDSCR_EL1[EMBWE] == 0b1)
}

val IsBreakpointEnabled : forall 'n, (0 <= 'n & 'n < 64). int('n) -> bool

function IsBreakpointEnabled n = {
    if n > 15 & (not_bool(HaltOnBreakpointOrWatchpoint()) & not_bool(SelfHostedExtendedBPWPEnabled()) | HaltOnBreakpointOrWatchpoint() & EDSCR2_read()[EHBWE] == 0b0) then {
        return(false)
    };
    return(DBGBCR_EL1[n][E] == 0b1)
}

bitfield VTCR_EL2_Type : bits(64) =
  {
    HAFT : 44..44,
    TL0 : 41..41,
    GCSH : 40..40,
    D128 : 38..38,
    S2POE : 37..37,
    S2PIE : 36..36,
    TL1 : 35..35,
    AssuredOnly : 34..34,
    SL2 : 33..33,
    DS : 32..32,
    NSA : 30..30,
    NSW : 29..29,
    HWU62 : 28..28,
    HWU61 : 27..27,
    HWU60 : 26..26,
    HWU59 : 25..25,
    HD : 22..22,
    HA : 21..21,
    VS : 19..19,
    PS : 18..16,
    TG0 : 15..14,
    SH0 : 13..12,
    ORGN0 : 11..10,
    IRGN0 : 9..8,
    SL0 : 7..6,
    T0SZ : 5..0
  }

register VTCR_EL2 : VTCR_EL2_Type

bitfield VTTBR_Type : bits(64) = {VMID : 55..48, BADDR : 47..1, CnP : 0..0}

register VTTBR : VTTBR_Type

bitfield VTTBR_EL2_Type : bits(128) = {VMID : 63..48, SKL : 2..1, CnP : 0..0}

register _VTTBR_EL2 : VTTBR_EL2_Type

val VTTBR_EL2_read : unit -> VTTBR_EL2_Type

function VTTBR_EL2_read () = {
    r : VTTBR_EL2_Type = _VTTBR_EL2;
    r.bits[63 .. 0] = Slice(VTTBR.bits, 0, 64);
    return(r)
}

val AArch64_BreakpointValueMatch : forall ('isbreakpnt : Bool) ('linked_to : Bool) 'n_in.
  (int('n_in), bits(64), bool('linked_to), bool('isbreakpnt)) -> (bool, bool)

function AArch64_BreakpointValueMatch (n_in, vaddress, linked_to, isbreakpnt) = {
    n : int = n_in;
    c : Constraint = undefined;
    if n >= NumBreakpointsImplemented() then {
        (c, n) = ConstrainUnpredictableInteger(0, NumBreakpointsImplemented() - 1, Unpredictable_BPNOTIMPL);
        assert(c == Constraint_DISABLED | c == Constraint_UNKNOWN);
        if c == Constraint_DISABLED then {
            return((false, false))
        };
        ()
    };
    let 'n = n;
    assert(constraint((0 <= 'n & 'n < 64)));
    if not_bool(IsBreakpointEnabled(n)) then {
        return((false, false))
    };
    dbgtype : bits(4) = DBGBCR_EL1[n][BT];
    bt2 : bits(1) = if HaveFeatABLE() then DBGBCR_EL1[n][BT2] else 0b0;
    (c, bt2, dbgtype) = AArch64_ReservedBreakpointType(n, bt2, dbgtype);
    if c == Constraint_DISABLED then {
        return((false, false))
    };
    let match_addr : bool = (match dbgtype {
      [bitzero, _, bitzero, _] => true,
      _ => false
    }) : bool;
    let mismatch : bool = (match dbgtype {
      [bitzero, bitone, bitzero, _] => true,
      _ => false
    }) : bool;
    let match_vmid : bool = (match dbgtype {
      [bitone, bitzero, _, _] => true,
      _ => false
    }) : bool;
    let match_cid : bool = (match dbgtype {
      [bitzero, bitzero, bitone, _] => true,
      _ => false
    }) : bool;
    let match_cid1 : bool = (match dbgtype {
      [bitone, bitzero, bitone, _] => true,
      [_, bitone, bitone, _] => true,
      _ => false
    }) : bool;
    let match_cid2 : bool = (match dbgtype {
      [bitone, bitone, _, _] => true,
      _ => false
    }) : bool;
    let linking_enabled : bool = (match dbgtype {
      [_, _, bitone, bitone] => true,
      [bitone, _, _, bitone] => true,
      _ => false
    }) : bool | bt2 == 0b1;
    if linked_to & not_bool(linking_enabled) then {
        return((false, false))
    };
    if (not_bool(linked_to) & linking_enabled) & not_bool(match_addr) then {
        return((false, false))
    };
    if (linked_to & match_addr) & isbreakpnt then {
        if not_bool(ConstrainUnpredictableBool(Unpredictable_BPLINKEDADDRMATCH)) then {
            return((false, false))
        };
        ()
    };
    if mismatch & UsingAArch32() then {
        return((false, false))
    };
    bvr_match : bool = false;
    bxvr_match : bool = false;
    mask : int = undefined;
    if HaveFeatABLE() then {
        mask = UInt(DBGBCR_EL1[n][MASK]);
        if mask == 1 | mask == 2 then {
            (c, mask) = ConstrainUnpredictableInteger(3, 31, Unpredictable_RESBPMASK);
            assert(c == Constraint_DISABLED | c == Constraint_NONE | c == Constraint_UNKNOWN);
            match c {
              Constraint_DISABLED => {
                  return((false, false))
              },
              Constraint_NONE => {
                  mask = 0
              },
              _ => ()
            }
        };
        if mask != 0 then {
            if ((match_cid | match_cid1) | match_cid2) | DBGBCR_EL1[n][BAS] != 0b1111 & HaveAArch32() then {
                if not_bool(ConstrainUnpredictableBool(Unpredictable_BPMASK)) then {
                    return((false, false))
                };
                ()
            };
            ()
        } else {
            if mismatch then {
                return((false, false))
            };
            ()
        }
    } else {
        mask = 0
    };
    let 'mask = mask;
    if match_addr then {
        byte_select_match : bool = undefined;
        let 'byte = UInt(vaddress[1 .. 0]);
        if HaveAArch32() then {
            assert(byte == 0 | byte == 2);
            byte_select_match = [DBGBCR_EL1[n][BAS][byte]] == 0b1
        } else {
            assert(byte == 0);
            byte_select_match = true
        };
        top : int = DebugAddrTop();
        let 'bottom = 2;
        if ((top < 55 & not_bool(is_ones_subrange(DBGBVR_EL1[n].bits, 63, top))) & not_bool(is_zero_subrange(DBGBVR_EL1[n].bits, 63, top))) & ConstrainUnpredictableBool(Unpredictable_DBGxVR_RESS) then {
            top = 63
        };
        let 'top = top;
        if mask > bottom then {
            assert(constraint((0 <= 'mask & 'mask <= 'top & 'top < 64)));
            bvr_match = vaddress[top .. mask] == DBGBVR_EL1[n].bits[top .. mask] & byte_select_match;
            if bvr_match & not_bool(is_zero_subrange(DBGBVR_EL1[n].bits, mask - 1, bottom)) then {
                bvr_match = ConstrainUnpredictableBool(Unpredictable_BPMASKEDBITS)
            };
            ()
        } else {
            assert(constraint((0 <= 'bottom & 'bottom <= 'top & 'top < 64)));
            bvr_match = vaddress[top .. bottom] == DBGBVR_EL1[n].bits[top .. bottom] & byte_select_match
        }
    } else if match_cid then {
        if IsInHost() then {
            bvr_match = CONTEXTIDR_EL2.bits[31 .. 0] == DBGBVR_EL1[n].bits[31 .. 0]
        } else {
            bvr_match = (PSTATE.EL == EL0 | PSTATE.EL == EL1) & CONTEXTIDR_EL1.bits[31 .. 0] == DBGBVR_EL1[n].bits[31 .. 0]
        }
    } else if match_cid1 then {
        bvr_match = ((PSTATE.EL == EL0 | PSTATE.EL == EL1) & not_bool(IsInHost())) & CONTEXTIDR_EL1.bits[31 .. 0] == DBGBVR_EL1[n].bits[31 .. 0]
    } else ();
    if match_vmid then {
        vmid : bits(16) = undefined;
        bvr_vmid : bits(16) = undefined;
        if not_bool(Have16bitVMID()) | VTCR_EL2[VS] == 0b0 then {
            vmid = ZeroExtend(VTTBR_EL2_read()[VMID][7 .. 0], 16);
            bvr_vmid = ZeroExtend(DBGBVR_EL1[n].bits[39 .. 32], 16)
        } else {
            vmid = VTTBR_EL2_read()[VMID];
            bvr_vmid = DBGBVR_EL1[n].bits[47 .. 32]
        };
        bxvr_match = (((PSTATE.EL == EL0 | PSTATE.EL == EL1) & EL2Enabled()) & not_bool(IsInHost())) & vmid == bvr_vmid
    } else if match_cid2 then {
        bxvr_match = (PSTATE.EL != EL3 & EL2Enabled()) & DBGBVR_EL1[n].bits[63 .. 32] == CONTEXTIDR_EL2.bits[31 .. 0]
    } else ();
    let bvr_match_valid : bool = (match_addr | match_cid) | match_cid1;
    let bxvr_match_valid : bool = match_vmid | match_cid2;
    let value_match_name : bool = (not_bool(bxvr_match_valid) | bxvr_match) & (not_bool(bvr_match_valid) | bvr_match);
    return((value_match_name, mismatch))
}

val CheckValidStateMatch : forall ('isbreakpnt : Bool).
  (bits(2), bits(1), bits(1), bits(2), bool('isbreakpnt)) -> (Constraint, bits(2), bits(1), bits(1), bits(2))

function CheckValidStateMatch (ssc_in, ssce_in, hmc_in, pxc_in, isbreakpnt) = {
    if not_bool(HaveRME()) then {
        assert(ssce_in == 0b0)
    };
    reserved : bool = false;
    ssc : bits(2) = ssc_in;
    ssce : bits(1) = ssce_in;
    hmc : bits(1) = hmc_in;
    pxc : bits(2) = pxc_in;
    match ((hmc @ ssce) @ ssc) @ pxc {
      0b001110 => {
          reserved = true
      },
      [bitzero, bitzero, bitone, _, _, _] => {
          reserved = not_bool(HaveSecureState())
      },
      [bitone, bitzero, bitzero, bitzero, _, bitzero] => {
          reserved = true
      },
      0b100110 => {
          reserved = true
      },
      [bitone, bitzero, bitone, _, bitone, bitzero] => {
          reserved = true
      },
      [_, bitone, _, _, _, _] => {
          reserved = ssc != 0b01 | (hmc @ pxc) == 0b000 | (hmc @ pxc) == 0b110
      },
      _ => {
          reserved = false
      }
    };
    if ((not_bool(isbreakpnt) | not_bool(HaveAArch32EL(EL1))) & (hmc @ pxc) == 0b000) & ssc != 0b11 then {
        reserved = true
    };
    if (not_bool(HaveEL(EL3)) & not_bool(HaveEL(EL2))) & (hmc != 0b0 | ssc != 0b00) then {
        reserved = true
    };
    if (not_bool(HaveEL(EL3)) & (ssc == 0b01 | ssc == 0b10)) & ((hmc @ ssc) @ pxc) != 0b10100 then {
        reserved = true
    };
    if (not_bool(HaveEL(EL3)) | not_bool(HaveAArch64())) & ((hmc @ ssc) @ pxc) == 0b11000 then {
        reserved = true
    };
    if not_bool(HaveEL(EL2)) & ((hmc @ ssc) @ pxc) == 0b11100 then {
        reserved = true
    };
    if not_bool(HaveSecureEL2Ext()) & (match (hmc @ ssc) @ pxc {
      0b01100 => true,
      0b10100 => true,
      [_, bitone, bitone, _, bitone] => true,
      _ => false
    }) : bool then {
        reserved = true
    };
    if reserved then {
        c : Constraint = undefined;
        (c, (hmc @ ssc @ ssce @ pxc)) = ConstrainUnpredictableBits(Unpredictable_RESBPWPCTRL, 6);
        assert(c == Constraint_DISABLED | c == Constraint_UNKNOWN);
        if c == Constraint_DISABLED then {
            return((c, __UNKNOWN_bits(2), __UNKNOWN_bit(), __UNKNOWN_bit(), __UNKNOWN_bits(2)))
        };
        ()
    };
    return((Constraint_NONE, ssc, ssce, hmc, pxc))
}

val ContextMatchingBreakpointRange : unit -> (int, int)

function ContextMatchingBreakpointRange () = {
    let 'b = NumBreakpointsImplemented();
    let 'c = NumContextAwareBreakpointsImplemented();
    if b <= 16 then {
        return((b - c, b - 1))
    } else if c <= 16 then {
        return((16 - c, 15))
    } else {
        return((0, c - 1))
    }
}

val IsContextMatchingBreakpoint : forall 'n. int('n) -> bool

function IsContextMatchingBreakpoint n = {
    lower : int = undefined;
    upper : int = undefined;
    (lower, upper) = ContextMatchingBreakpointRange();
    let 'upper = upper;
    let 'lower = lower;
    return(n >= lower & n <= upper)
}

val AArch64_StateMatch : forall ('isbreakpnt : Bool) ('linked_in : Bool) 'linked_n_in.
  (bits(2), bits(1), bits(1), bits(2), bool('linked_in), int('linked_n_in), bool('isbreakpnt), bits(64), AccessDescriptor) -> bool

function AArch64_StateMatch (ssc_in, ssce_in, hmc_in, pxc_in, linked_in, linked_n_in, isbreakpnt, vaddress, accdesc) = {
    first_ctx_cmp : int = undefined;
    last_ctx_cmp : int = undefined;
    linked_to : bool = undefined;
    if not_bool(HaveRME()) then {
        assert(ssce_in == 0b0)
    };
    ssc : bits(2) = ssc_in;
    ssce : bits(1) = ssce_in;
    hmc : bits(1) = hmc_in;
    pxc : bits(2) = pxc_in;
    linked : bool = linked_in;
    linked_n : int = linked_n_in;
    c : Constraint = undefined;
    (c, ssc, ssce, hmc, pxc) = CheckValidStateMatch(ssc, ssce, hmc, pxc, isbreakpnt);
    if c == Constraint_DISABLED then {
        return(false)
    };
    let EL3_match : bool = (HaveEL(EL3) & hmc == 0b1) & [ssc[0]] == 0b0;
    let EL2_match : bool = HaveEL(EL2) & (hmc == 0b1 & (ssc @ pxc) != 0b1000 | ssc == 0b11);
    let EL1_match : bool = [pxc[0]] == 0b1;
    let EL0_match : bool = [pxc[1]] == 0b1;
    priv_match : bool = undefined;
    match accdesc.el {
      ? if ? == EL3 => {
          priv_match = EL3_match
      },
      ? if ? == EL2 => {
          priv_match = EL2_match
      },
      ? if ? == EL1 => {
          priv_match = EL1_match
      },
      ? if ? == EL0 => {
          priv_match = EL0_match
      },
      _ => ()
    };
    ss_match : bool = undefined;
    match ssce @ ssc {
      0b000 => {
          ss_match = hmc == 0b1 | accdesc.ss != SS_Root
      },
      0b001 => {
          ss_match = accdesc.ss == SS_NonSecure
      },
      0b010 => {
          ss_match = hmc == 0b1 & accdesc.ss == SS_Root | accdesc.ss == SS_Secure
      },
      0b011 => {
          ss_match = hmc == 0b1 & accdesc.ss != SS_Root | accdesc.ss == SS_Secure
      },
      0b101 => {
          ss_match = accdesc.ss == SS_Realm
      },
      _ => ()
    };
    linked_match : bool = false;
    is_linked_mismatch : bool = false;
    if linked then {
        if not_bool(IsContextMatchingBreakpoint(linked_n)) then {
            (first_ctx_cmp, last_ctx_cmp) = ContextMatchingBreakpointRange();
            let 'last_ctx_cmp = last_ctx_cmp;
            let 'first_ctx_cmp = first_ctx_cmp;
            (c, linked_n) = ConstrainUnpredictableInteger(first_ctx_cmp, last_ctx_cmp, Unpredictable_BPNOTCTXCMP);
            assert(c == Constraint_DISABLED | c == Constraint_NONE | c == Constraint_UNKNOWN);
            match c {
              Constraint_DISABLED => {
                  return(false)
              },
              Constraint_NONE => {
                  linked = false
              },
              _ => ()
            }
        };
        ()
    };
    let 'linked_n = linked_n;
    if linked then {
        let linked_to : bool = true;
        (linked_match, is_linked_mismatch) = AArch64_BreakpointValueMatch(linked_n, vaddress, linked_to, isbreakpnt)
    };
    return((priv_match & ss_match) & ((not_bool(linked) | not_bool(is_linked_mismatch) & linked_match) | is_linked_mismatch & not_bool(linked_match)))
}

val AArch64_BreakpointMatch : forall 'n 'size, (0 <= 'n & 'n < 64).
  (int('n), bits(64), AccessDescriptor, int('size)) -> (bool, bool)

function AArch64_BreakpointMatch (n, vaddress, accdesc, size) = {
    match_i : bool = undefined;
    valid_mismatch_name : bool = undefined;
    value_match_name : bool = undefined;
    assert(not_bool(ELUsingAArch32(S1TranslationRegime__1())));
    assert(n < NumBreakpointsImplemented());
    let linking_enabled : bool = (match DBGBCR_EL1[n][BT] {
      [bitzero, _, bitone, bitone] => true,
      [bitone, _, _, bitone] => true,
      _ => false
    }) : bool | HaveFeatABLE() & DBGBCR_EL1[n][BT2] == 0b1;
    if linking_enabled then {
        return((false, false))
    };
    let enabled : bool = IsBreakpointEnabled(n);
    let linked : bool = (match DBGBCR_EL1[n][BT] {
      [bitzero, _, bitzero, bitone] => true,
      _ => false
    }) : bool;
    let isbreakpnt : bool = true;
    let linked_to : bool = false;
    let lbnx : bits(2) = if Havev8p9Debug() then DBGBCR_EL1[n][LBNX] else 0b00;
    let 'linked_n = UInt(lbnx @ DBGBCR_EL1[n][LBN]);
    let ssce : bits(1) = if HaveRME() then DBGBCR_EL1[n][SSCE] else 0b0;
    let state_match : bool = AArch64_StateMatch(DBGBCR_EL1[n][SSC], ssce, DBGBCR_EL1[n][HMC], DBGBCR_EL1[n][PMC], linked, linked_n, isbreakpnt, vaddress, accdesc);
    (value_match_name, valid_mismatch_name) = AArch64_BreakpointValueMatch(n, vaddress, linked_to, isbreakpnt);
    if HaveAArch32() & size == 4 then {
        let (__tup_0 : bool, _) =
          AArch64_BreakpointValueMatch(n, vaddress + 2, linked_to, isbreakpnt)
        in
          {
              match_i = __tup_0
          };
        if not_bool(value_match_name) & match_i then {
            value_match_name = ConstrainUnpredictableBool(Unpredictable_BPMATCHHALF)
        };
        ()
    };
    if [vaddress[1]] == 0b1 & DBGBCR_EL1[n][BAS] == 0b1111 then {
        if value_match_name then {
            value_match_name = ConstrainUnpredictableBool(Unpredictable_BPMATCHHALF)
        };
        ()
    };
    let val_match : bool = (value_match_name & state_match) & enabled;
    let is_mismatch : bool = (valid_mismatch_name & state_match) & enabled;
    return((val_match, is_mismatch))
}

val AArch64_CheckBreakpoint : forall 'size.
  (FaultRecord, bits(64), AccessDescriptor, int('size)) -> FaultRecord

function AArch64_CheckBreakpoint (fault_in, vaddress, accdesc, size) = {
    is_mismatch_i : bool = undefined;
    match_i : bool = undefined;
    reason : bits(6) = undefined;
    assert(not_bool(ELUsingAArch32(S1TranslationRegime__1())));
    assert(UsingAArch32() & (size == 2 | size == 4) | size == 4);
    fault : FaultRecord = fault_in;
    val_match : bool = false;
    mismatch : bool = true;
    mismatch_bp : bool = false;
    foreach (i from 0 to (NumBreakpointsImplemented() - 1) by 1 in inc) {
        assert(constraint(('loop_i < 64 | not('size in {2, 4, 4}))));
        (match_i, is_mismatch_i) = AArch64_BreakpointMatch(i, vaddress, accdesc, size);
        if is_mismatch_i then {
            mismatch_bp = true;
            mismatch = mismatch & not_bool(match_i)
        } else {
            val_match = val_match | match_i
        }
    };
    if val_match | mismatch & mismatch_bp then {
        fault.statuscode = Fault_Debug;
        if HaltOnBreakpointOrWatchpoint() then {
            let reason : bits(6) = DebugHalt_Breakpoint;
            Halt(reason)
        };
        ()
    };
    return(fault)
}

bitfield DBGWCR_EL1_Type : bits(64) =
  {
    LBNX : 31..30,
    SSCE : 29..29,
    MASK : 28..24,
    WT : 20..20,
    LBN : 19..16,
    SSC : 15..14,
    HMC : 13..13,
    BAS : 12..5,
    LSC : 4..3,
    PAC : 2..1,
    E : 0..0
  }

register DBGWCR_EL1 : vector(64, DBGWCR_EL1_Type)

bitfield DBGWVR_EL1_Type : bits(64) =
  {RESS : (63..57 @ (56..53 @ 52..49)), VA : (56..53 @ (52..49 @ 48..2))}

register DBGWVR_EL1 : vector(64, DBGWVR_EL1_Type)

val AArch64_WatchpointByteMatch : forall 'n, (0 <= 'n & 'n < 64).
  (int('n), bits(64)) -> bool

function AArch64_WatchpointByteMatch (n, vaddress) = {
    LSB : bits(8) = undefined;
    MSB : bits(8) = undefined;
    top : int = DebugAddrTop();
    bottom : {2, 3} = if [DBGWVR_EL1[n].bits[2]] == 0b1 then 2 else 3;
    byte_select_match : bool = let 'bottom = bottom in
      {
          [DBGWCR_EL1[n][BAS][UInt(vaddress[bottom - 1 .. 0])]] != 0b0
      };
    mask : int = UInt(DBGWCR_EL1[n][MASK]);
    if mask > 0 & not_bool(IsOnes(DBGWCR_EL1[n][BAS])) then {
        byte_select_match = ConstrainUnpredictableBool(Unpredictable_WPMASKANDBAS)
    } else {
        let LSB : bits(8) = DBGWCR_EL1[n][BAS] & not_vec(DBGWCR_EL1[n][BAS] - 1);
        let MSB : bits(8) = DBGWCR_EL1[n][BAS] + LSB;
        if not_bool(IsZero(MSB & MSB - 1)) then {
            byte_select_match = ConstrainUnpredictableBool(Unpredictable_WPBASCONTIGUOUS);
            bottom = 3
        };
        ()
    };
    let 'bottom = bottom;
    if mask > 0 & mask <= 2 then {
        c : Constraint = undefined;
        (c, mask) = ConstrainUnpredictableInteger(3, 31, Unpredictable_RESWPMASK);
        assert(c == Constraint_DISABLED | c == Constraint_NONE | c == Constraint_UNKNOWN);
        match c {
          Constraint_DISABLED => {
              return(false)
          },
          Constraint_NONE => {
              mask = 0
          },
          _ => ()
        }
    };
    let 'mask = mask;
    if ((top < 55 & not_bool(is_ones_subrange(DBGWVR_EL1[n].bits, 63, top))) & not_bool(is_zero_subrange(DBGWVR_EL1[n].bits, 63, top))) & ConstrainUnpredictableBool(Unpredictable_DBGxVR_RESS) then {
        top = 63
    };
    let 'top = top;
    WVR_match : bool = undefined;
    if mask > bottom then {
        assert(constraint((0 <= 'mask & 'mask <= 'top & 'top < 64)));
        WVR_match = vaddress[top .. mask] == DBGWVR_EL1[n].bits[top .. mask];
        if WVR_match & not_bool(is_zero_subrange(DBGWVR_EL1[n].bits, mask - 1, bottom)) then {
            WVR_match = ConstrainUnpredictableBool(Unpredictable_WPMASKEDBITS)
        };
        ()
    } else {
        assert(constraint((0 <= 'bottom & 'bottom <= 'top & 'top < 64)));
        WVR_match = vaddress[top .. bottom] == DBGWVR_EL1[n].bits[top .. bottom]
    };
    return(WVR_match & byte_select_match)
}

val IsWatchpointEnabled : forall 'n, (0 <= 'n & 'n < 64). int('n) -> bool

function IsWatchpointEnabled n = {
    if n > 15 & (not_bool(HaltOnBreakpointOrWatchpoint()) & not_bool(SelfHostedExtendedBPWPEnabled()) | HaltOnBreakpointOrWatchpoint() & EDSCR2_read()[EHBWE] == 0b0) then {
        return(false)
    };
    return(DBGWCR_EL1[n][E] == 0b1)
}

val AArch64_WatchpointMatch : forall 'n 'size, (0 <= 'n & 'n < 64).
  (int('n), bits(64), int('size), AccessDescriptor) -> bool

function AArch64_WatchpointMatch (n, vaddress, size, accdesc) = {
    assert(not_bool(ELUsingAArch32(S1TranslationRegime__1())));
    assert(n < NumWatchpointsImplemented());
    let enabled : bool = IsWatchpointEnabled(n);
    let linked : bool = DBGWCR_EL1[n][WT] == 0b1;
    let isbreakpnt : bool = false;
    let lbnx : bits(2) = if Havev8p9Debug() then DBGWCR_EL1[n][LBNX] else 0b00;
    let 'linked_n = UInt(lbnx @ DBGWCR_EL1[n][LBN]);
    let ssce : bits(1) = if HaveRME() then DBGWCR_EL1[n][SSCE] else 0b0;
    let state_match : bool = AArch64_StateMatch(DBGWCR_EL1[n][SSC], ssce, DBGWCR_EL1[n][HMC], DBGWCR_EL1[n][PAC], linked, linked_n, isbreakpnt, PC_read(), accdesc);
    ls_match : bool = undefined;
    match DBGWCR_EL1[n][LSC][1 .. 0] {
      0b00 => {
          ls_match = false
      },
      0b01 => {
          ls_match = accdesc.read
      },
      0b10 => {
          ls_match = accdesc.write | accdesc.acctype == AccessType_DC
      },
      0b11 => {
          ls_match = true
      },
      _ => ()
    };
    value_match_name : bool = false;
    foreach (byte from 0 to (size - 1) by 1 in inc) {
        value_match_name = value_match_name | AArch64_WatchpointByteMatch(n, vaddress + byte)
    };
    return(((value_match_name & state_match) & ls_match) & enabled)
}

type EDWAR_Type = bits(64)

register EDWAR : EDWAR_Type

val AArch64_CheckWatchpoint : forall 'size.
  (FaultRecord, bits(64), AccessDescriptor, int('size)) -> FaultRecord

function AArch64_CheckWatchpoint (fault_in, vaddress, accdesc, size) = {
    reason : bits(6) = undefined;
    assert(not_bool(ELUsingAArch32(S1TranslationRegime__1())));
    fault : FaultRecord = fault_in;
    if accdesc.acctype == AccessType_DC then {
        if accdesc.cacheop != CacheOp_Invalidate then {
            return(fault)
        };
        ()
    } else if not_bool(IsDataAccess(accdesc.acctype)) then {
        return(fault)
    } else ();
    foreach (i from 0 to (NumWatchpointsImplemented() - 1) by 1 in inc) {
        assert(constraint('loop_i < 64));
        if AArch64_WatchpointMatch(i, vaddress, size, accdesc) then {
            fault.statuscode = Fault_Debug;
            if [DBGWCR_EL1[i][LSC][0]] == 0b1 & accdesc.read then {
                fault.write = false
            } else if [DBGWCR_EL1[i][LSC][1]] == 0b1 & accdesc.write then {
                fault.write = true
            } else ()
        };
        ()
    };
    if ((fault.statuscode == Fault_Debug & HaltOnBreakpointOrWatchpoint()) & not_bool(accdesc.nonfault)) & not_bool(accdesc.firstfault & not_bool(accdesc.first)) then {
        let reason : bits(6) = DebugHalt_Watchpoint;
        EDWAR = vaddress;
        Halt(reason)
    };
    return(fault)
}

val AArch64_CheckDebug : forall 'size.
  (bits(64), AccessDescriptor, int('size)) -> FaultRecord

function AArch64_CheckDebug (vaddress, accdesc, size) = {
    mask : bits(1) = undefined;
    ss : SecurityState = undefined;
    fault : FaultRecord = NoFault__1(accdesc);
    generate_exception : bool = undefined;
    let d_side : bool = IsDataAccess(accdesc.acctype) | accdesc.acctype == AccessType_DC;
    let i_side : bool = accdesc.acctype == AccessType_IFETCH;
    if accdesc.acctype == AccessType_NV2 then {
        let mask : bits(1) = 0b0;
        let ss : SecurityState = CurrentSecurityState();
        generate_exception = AArch64_GenerateDebugExceptionsFrom(EL2, ss, mask) & MDSCR_EL1[MDE] == 0b1
    } else {
        generate_exception = AArch64_GenerateDebugExceptions() & MDSCR_EL1[MDE] == 0b1
    };
    let halt : bool = HaltOnBreakpointOrWatchpoint();
    if generate_exception | halt then {
        if d_side then {
            fault = AArch64_CheckWatchpoint(fault, vaddress, accdesc, size)
        } else if i_side then {
            fault = AArch64_CheckBreakpoint(fault, vaddress, accdesc, size)
        } else ()
    };
    return(fault)
}

val AArch64_MemSwapTableDesc : forall 'N, 'N in {64, 128}.
  (FaultRecord, bits('N), bits('N), bits(1), AccessDescriptor, AddressDescriptor, TranslationInfo) -> (FaultRecord, bits('N))

function AArch64_MemSwapTableDesc (fault_in, prev_desc, new_desc, ee, descaccess, descpaddr, translation_info) = {
    ordered_new_desc : bits('N) = undefined;
    fault : FaultRecord = fault_in;
    iswrite : bool = undefined;
    if HaveRME() then {
        fault.gpcf = GranuleProtectionCheck(descpaddr, descaccess);
        if fault.gpcf.gpf != GPCF_None then {
            fault.statuscode = Fault_GPCFOnWalk;
            fault.paddress = descpaddr.paddress;
            fault.gpcfs2walk = fault.secondstage;
            return((fault, __UNKNOWN_bits('N)))
        };
        ()
    };
    mem_desc : bits('N) = undefined;
    memstatus : PhysMemRetStatus = undefined;
    (memstatus, mem_desc) = PhysMemRead(descpaddr, DIV('N, 8), descaccess, Some(translation_info));
    if ee == 0b1 then {
        mem_desc = BigEndianReverse(mem_desc)
    };
    if IsFault__2(memstatus) then {
        iswrite = false;
        fault = HandleExternalTTWAbort(memstatus, iswrite, descpaddr, descaccess, DIV('N, 8), fault);
        if IsFault__1(fault.statuscode) then {
            return((fault, __UNKNOWN_bits('N)))
        };
        ()
    };
    if mem_desc == prev_desc then {
        let ordered_new_desc : bits('N) = if ee == 0b1 then
          BigEndianReverse(new_desc)
        else
          new_desc;
        let memstatus : PhysMemRetStatus = PhysMemWrite(descpaddr, DIV('N, 8), descaccess, Some(translation_info), ordered_new_desc);
        if IsFault__2(memstatus) then {
            let iswrite : bool = true;
            fault = HandleExternalTTWAbort(memstatus, iswrite, descpaddr, descaccess, DIV('N, 8), fault);
            if IsFault__1(fault.statuscode) then {
                return((fault, __UNKNOWN_bits('N)))
            };
            ()
        };
        mem_desc = new_desc
    };
    return((fault, mem_desc))
}

val AArch64_S1DirectBasePermissions : (Regime, TTWState, S1TTWParams, AccessDescriptor) -> S1AccessControls

function AArch64_S1DirectBasePermissions (regime, walkstate, walkparams, accdesc) = {
    r : bits(1) = undefined;
    w : bits(1) = undefined;
    x : bits(1) = undefined;
    pr : bits(1) = undefined;
    pw : bits(1) = undefined;
    px : bits(1) = undefined;
    ur : bits(1) = undefined;
    uw : bits(1) = undefined;
    ux : bits(1) = undefined;
    let permissions : Permissions = walkstate.permissions;
    s1perms : S1AccessControls = undefined;
    if HasUnprivileged(regime) then {
        match permissions.ap[2 .. 1] {
          0b00 => {
              (pr, pw, ur, uw) = (0b1, 0b1, 0b0, 0b0)
          },
          0b01 => {
              (pr, pw, ur, uw) = (0b1, 0b1, 0b1, 0b1)
          },
          0b10 => {
              (pr, pw, ur, uw) = (0b1, 0b0, 0b0, 0b0)
          },
          0b11 => {
              (pr, pw, ur, uw) = (0b1, 0b0, 0b1, 0b0)
          }
        };
        match permissions.ap_table {
          0b00 => {
              (pr, pw, ur, uw) = (pr, pw, ur, uw)
          },
          0b01 => {
              (pr, pw, ur, uw) = (pr, pw, 0b0, 0b0)
          },
          0b10 => {
              (pr, pw, ur, uw) = (pr, 0b0, ur, 0b0)
          },
          0b11 => {
              (pr, pw, ur, uw) = (pr, 0b0, 0b0, 0b0)
          }
        };
        px = not_vec((permissions.pxn | permissions.pxn_table) | uw);
        ux = not_vec(permissions.uxn | permissions.uxn_table);
        if (HavePANExt() & accdesc.pan) & not_bool(regime == Regime_EL10 & walkparams.nv1 == 0b1) then {
            if ((__IMPDEF_boolean("SCR_EL3.SIF affects EPAN") & accdesc.ss == SS_Secure) & walkstate.baseaddress.paspace == PAS_NonSecure) & walkparams.sif == 0b1 then {
                ux = 0b0
            };
            if ((__IMPDEF_boolean("Realm EL2&0 regime affects EPAN") & accdesc.ss == SS_Realm) & regime == Regime_EL20) & walkstate.baseaddress.paspace != PAS_Realm then {
                ux = 0b0
            };
            let pan : bits(1) = PSTATE.PAN & ((ur | uw) | walkparams.epan & ux);
            pr = pr & not_vec(pan);
            pw = pw & not_vec(pan)
        };
        ()
    } else {
        match [permissions.ap[2]] {
          0b0 => {
              (pr, pw) = (0b1, 0b1)
          },
          0b1 => {
              (pr, pw) = (0b1, 0b0)
          }
        };
        match [permissions.ap_table[1]] {
          0b0 => {
              (pr, pw) = (pr, pw)
          },
          0b1 => {
              (pr, pw) = (pr, 0b0)
          }
        };
        px = not_vec(permissions.xn | permissions.xn_table)
    };
    (r, w, x) = if accdesc.el == EL0 then (ur, uw, ux) else (pr, pw, px);
    let wxn : bits(1) = (walkparams.wxn & w) & x;
    if accdesc.ss == SS_Secure & walkstate.baseaddress.paspace == PAS_NonSecure then {
        x = x & not_vec(walkparams.sif)
    };
    if accdesc.ss == SS_Root & walkstate.baseaddress.paspace != PAS_Root then {
        x = 0b0
    };
    if (accdesc.ss == SS_Realm & (regime == Regime_EL2 | regime == Regime_EL20)) & walkstate.baseaddress.paspace != PAS_Realm then {
        x = 0b0
    };
    let x = x;
    s1perms.r = r;
    s1perms.w = w;
    s1perms.x = x;
    s1perms.gcs = 0b0;
    s1perms.wxn = wxn;
    s1perms.overlay = true;
    return(s1perms)
}

val AArch64_S1E0POEnabled : (Regime, bits(1)) -> bool

function AArch64_S1E0POEnabled (regime, nv1) = {
    assert(HasUnprivileged(regime));
    if not_bool(HaveS1POExt()) then {
        return(false)
    };
    match regime {
      Regime_EL20 => {
          return(IsTCR2EL2Enabled() & TCR2_EL2[E0POE] == 0b1)
      },
      Regime_EL10 => {
          return((IsTCR2EL1Enabled() & nv1 == 0b0) & TCR2_EL1[E0POE] == 0b1)
      },
      _ => {
          return(undefined : bool)
      }
    }
}

val AArch64_S1IndirectBasePermissions : (Regime, TTWState, S1TTWParams, AccessDescriptor) -> S1AccessControls

function AArch64_S1IndirectBasePermissions (regime, walkstate, walkparams, accdesc) = {
    gcs : bits(1) = undefined;
    overlay : bits(1) = undefined;
    r : bits(1) = undefined;
    w : bits(1) = undefined;
    wxn : bits(1) = undefined;
    x : bits(1) = undefined;
    pgcs : bits(1) = undefined;
    pr : bits(1) = undefined;
    pw : bits(1) = undefined;
    px : bits(1) = undefined;
    u_overlay : bits(1) = undefined;
    ugcs : bits(1) = undefined;
    ur : bits(1) = undefined;
    uw : bits(1) = undefined;
    uwxn : bits(1) = undefined;
    ux : bits(1) = undefined;
    let permissions : Permissions = walkstate.permissions;
    s1perms : S1AccessControls = undefined;
    match permissions.ppi {
      0b0000 => {
          (pr, pw, px, pgcs) = (0b0, 0b0, 0b0, 0b0)
      },
      0b0001 => {
          (pr, pw, px, pgcs) = (0b1, 0b0, 0b0, 0b0)
      },
      0b0010 => {
          (pr, pw, px, pgcs) = (0b0, 0b0, 0b1, 0b0)
      },
      0b0011 => {
          (pr, pw, px, pgcs) = (0b1, 0b0, 0b1, 0b0)
      },
      0b0100 => {
          (pr, pw, px, pgcs) = (0b0, 0b0, 0b0, 0b0)
      },
      0b0101 => {
          (pr, pw, px, pgcs) = (0b1, 0b1, 0b0, 0b0)
      },
      0b0110 => {
          (pr, pw, px, pgcs) = (0b1, 0b1, 0b1, 0b0)
      },
      0b0111 => {
          (pr, pw, px, pgcs) = (0b1, 0b1, 0b1, 0b0)
      },
      0b1000 => {
          (pr, pw, px, pgcs) = (0b1, 0b0, 0b0, 0b0)
      },
      0b1001 => {
          (pr, pw, px, pgcs) = (0b1, 0b0, 0b0, 0b1)
      },
      0b1010 => {
          (pr, pw, px, pgcs) = (0b1, 0b0, 0b1, 0b0)
      },
      0b1011 => {
          (pr, pw, px, pgcs) = (0b0, 0b0, 0b0, 0b0)
      },
      0b1100 => {
          (pr, pw, px, pgcs) = (0b1, 0b1, 0b0, 0b0)
      },
      0b1101 => {
          (pr, pw, px, pgcs) = (0b0, 0b0, 0b0, 0b0)
      },
      0b1110 => {
          (pr, pw, px, pgcs) = (0b1, 0b1, 0b1, 0b0)
      },
      0b1111 => {
          (pr, pw, px, pgcs) = (0b0, 0b0, 0b0, 0b0)
      }
    };
    let p_overlay : bits(1) = not_vec([permissions.ppi[3]]);
    let pwxn : bits(1) = if permissions.ppi == 0b0110 then 0b1 else 0b0;
    if HasUnprivileged(regime) then {
        match permissions.upi {
          0b0000 => {
              (ur, uw, ux, ugcs) = (0b0, 0b0, 0b0, 0b0)
          },
          0b0001 => {
              (ur, uw, ux, ugcs) = (0b1, 0b0, 0b0, 0b0)
          },
          0b0010 => {
              (ur, uw, ux, ugcs) = (0b0, 0b0, 0b1, 0b0)
          },
          0b0011 => {
              (ur, uw, ux, ugcs) = (0b1, 0b0, 0b1, 0b0)
          },
          0b0100 => {
              (ur, uw, ux, ugcs) = (0b0, 0b0, 0b0, 0b0)
          },
          0b0101 => {
              (ur, uw, ux, ugcs) = (0b1, 0b1, 0b0, 0b0)
          },
          0b0110 => {
              (ur, uw, ux, ugcs) = (0b1, 0b1, 0b1, 0b0)
          },
          0b0111 => {
              (ur, uw, ux, ugcs) = (0b1, 0b1, 0b1, 0b0)
          },
          0b1000 => {
              (ur, uw, ux, ugcs) = (0b1, 0b0, 0b0, 0b0)
          },
          0b1001 => {
              (ur, uw, ux, ugcs) = (0b1, 0b0, 0b0, 0b1)
          },
          0b1010 => {
              (ur, uw, ux, ugcs) = (0b1, 0b0, 0b1, 0b0)
          },
          0b1011 => {
              (ur, uw, ux, ugcs) = (0b0, 0b0, 0b0, 0b0)
          },
          0b1100 => {
              (ur, uw, ux, ugcs) = (0b1, 0b1, 0b0, 0b0)
          },
          0b1101 => {
              (ur, uw, ux, ugcs) = (0b0, 0b0, 0b0, 0b0)
          },
          0b1110 => {
              (ur, uw, ux, ugcs) = (0b1, 0b1, 0b1, 0b0)
          },
          0b1111 => {
              (ur, uw, ux, ugcs) = (0b0, 0b0, 0b0, 0b0)
          }
        };
        u_overlay = not_vec([permissions.upi[3]]);
        uwxn = if permissions.upi == 0b0110 then 0b1 else 0b0;
        if (px == 0b1 | pgcs == 0b1) & (uw == 0b1 | ugcs == 0b1) then {
            (pr, pw, px, pgcs) = (0b0, 0b0, 0b0, 0b0);
            (ur, uw, ux, ugcs) = (0b0, 0b0, 0b0, 0b0)
        };
        if (HavePANExt() & accdesc.pan) & not_bool(regime == Regime_EL10 & walkparams.nv1 == 0b1) then {
            if PSTATE.PAN == 0b1 & permissions.upi != 0b0000 then {
                (pr, pw) = (0b0, 0b0)
            };
            ()
        };
        ()
    };
    let uwxn = uwxn;
    let u_overlay = u_overlay;
    if accdesc.el == EL0 then {
        (r, w, x, gcs, wxn, overlay) = (ur, uw, ux, ugcs, uwxn, u_overlay)
    } else {
        (r, w, x, gcs, wxn, overlay) = (pr, pw, px, pgcs, pwxn, p_overlay)
    };
    if accdesc.ss == SS_Secure & walkstate.baseaddress.paspace == PAS_NonSecure then {
        x = x & not_vec(walkparams.sif);
        gcs = 0b0
    };
    if accdesc.ss == SS_Root & walkstate.baseaddress.paspace != PAS_Root then {
        x = 0b0;
        gcs = 0b0
    };
    if (accdesc.ss == SS_Realm & (regime == Regime_EL2 | regime == Regime_EL20)) & walkstate.baseaddress.paspace != PAS_Realm then {
        x = 0b0;
        gcs = 0b0
    };
    let x = x;
    let gcs = gcs;
    s1perms.r = r;
    s1perms.w = w;
    s1perms.x = x;
    s1perms.gcs = gcs;
    s1perms.wxn = wxn;
    s1perms.overlay = overlay == 0b1;
    return(s1perms)
}

bitfield POR_EL1_Type : bits(64) =
  {
    Perm15 : 63..60,
    Perm14 : 59..56,
    Perm13 : 55..52,
    Perm12 : 51..48,
    Perm11 : 47..44,
    Perm10 : 43..40,
    Perm9 : 39..36,
    Perm8 : 35..32,
    Perm7 : 31..28,
    Perm6 : 27..24,
    Perm5 : 23..20,
    Perm4 : 19..16,
    Perm3 : 15..12,
    Perm2 : 11..8,
    Perm1 : 7..4,
    Perm0 : 3..0
  }

register POR_EL1 : POR_EL1_Type

bitfield POR_EL2_Type : bits(64) =
  {
    Perm15 : 63..60,
    Perm14 : 59..56,
    Perm13 : 55..52,
    Perm12 : 51..48,
    Perm11 : 47..44,
    Perm10 : 43..40,
    Perm9 : 39..36,
    Perm8 : 35..32,
    Perm7 : 31..28,
    Perm6 : 27..24,
    Perm5 : 23..20,
    Perm4 : 19..16,
    Perm3 : 15..12,
    Perm2 : 11..8,
    Perm1 : 7..4,
    Perm0 : 3..0
  }

register POR_EL2 : POR_EL2_Type

bitfield POR_EL3_Type : bits(64) =
  {
    Perm15 : 63..60,
    Perm14 : 59..56,
    Perm13 : 55..52,
    Perm12 : 51..48,
    Perm11 : 47..44,
    Perm10 : 43..40,
    Perm9 : 39..36,
    Perm8 : 35..32,
    Perm7 : 31..28,
    Perm6 : 27..24,
    Perm5 : 23..20,
    Perm4 : 19..16,
    Perm3 : 15..12,
    Perm2 : 11..8,
    Perm1 : 7..4,
    Perm0 : 3..0
  }

register POR_EL3 : POR_EL3_Type

val AArch64_S1POR : Regime -> S1PORType

function AArch64_S1POR regime = {
    match regime {
      Regime_EL3 => {
          return(Mk_S1PORType(POR_EL3.bits))
      },
      Regime_EL2 => {
          return(Mk_S1PORType(POR_EL2.bits))
      },
      Regime_EL20 => {
          return(Mk_S1PORType(POR_EL2.bits))
      },
      Regime_EL10 => {
          return(Mk_S1PORType(POR_EL1.bits))
      },
      _ => {
          return(undefined : S1PORType)
      }
    }
}

bitfield POR_EL0_Type : bits(64) =
  {
    Perm15 : 63..60,
    Perm14 : 59..56,
    Perm13 : 55..52,
    Perm12 : 51..48,
    Perm11 : 47..44,
    Perm10 : 43..40,
    Perm9 : 39..36,
    Perm8 : 35..32,
    Perm7 : 31..28,
    Perm6 : 27..24,
    Perm5 : 23..20,
    Perm4 : 19..16,
    Perm3 : 15..12,
    Perm2 : 11..8,
    Perm1 : 7..4,
    Perm0 : 3..0
  }

register POR_EL0 : POR_EL0_Type

val AArch64_S1OverlayPermissions : (Regime, TTWState, AccessDescriptor) -> S1AccessControls

function AArch64_S1OverlayPermissions (regime, walkstate, accdesc) = {
    r : bits(1) = undefined;
    w : bits(1) = undefined;
    x : bits(1) = undefined;
    pr : bits(1) = undefined;
    pw : bits(1) = undefined;
    px : bits(1) = undefined;
    ur : bits(1) = undefined;
    uw : bits(1) = undefined;
    ux : bits(1) = undefined;
    let permissions : Permissions = walkstate.permissions;
    s1overlay_perms : S1AccessControls = undefined;
    let por : S1PORType = AArch64_S1POR(regime);
    let 'bit_index = 4 * UInt(permissions.po_index);
    let ppo : bits(4) = por.bits[bit_index + 3 .. bit_index];
    match ppo {
      0b0000 => {
          (pr, pw, px) = (0b0, 0b0, 0b0)
      },
      0b0001 => {
          (pr, pw, px) = (0b1, 0b0, 0b0)
      },
      0b0010 => {
          (pr, pw, px) = (0b0, 0b0, 0b1)
      },
      0b0011 => {
          (pr, pw, px) = (0b1, 0b0, 0b1)
      },
      0b0100 => {
          (pr, pw, px) = (0b0, 0b1, 0b0)
      },
      0b0101 => {
          (pr, pw, px) = (0b1, 0b1, 0b0)
      },
      0b0110 => {
          (pr, pw, px) = (0b0, 0b1, 0b1)
      },
      0b0111 => {
          (pr, pw, px) = (0b1, 0b1, 0b1)
      },
      [bitone, _, _, _] => {
          (pr, pw, px) = (0b0, 0b0, 0b0)
      }
    };
    if HasUnprivileged(regime) then {
        let upo : bits(4) = POR_EL0.bits[bit_index + 3 .. bit_index];
        match upo {
          0b0000 => {
              (ur, uw, ux) = (0b0, 0b0, 0b0)
          },
          0b0001 => {
              (ur, uw, ux) = (0b1, 0b0, 0b0)
          },
          0b0010 => {
              (ur, uw, ux) = (0b0, 0b0, 0b1)
          },
          0b0011 => {
              (ur, uw, ux) = (0b1, 0b0, 0b1)
          },
          0b0100 => {
              (ur, uw, ux) = (0b0, 0b1, 0b0)
          },
          0b0101 => {
              (ur, uw, ux) = (0b1, 0b1, 0b0)
          },
          0b0110 => {
              (ur, uw, ux) = (0b0, 0b1, 0b1)
          },
          0b0111 => {
              (ur, uw, ux) = (0b1, 0b1, 0b1)
          },
          [bitone, _, _, _] => {
              (ur, uw, ux) = (0b0, 0b0, 0b0)
          }
        }
    };
    (r, w, x) = if accdesc.el == EL0 then (ur, uw, ux) else (pr, pw, px);
    s1overlay_perms.or = r;
    s1overlay_perms.ow = w;
    s1overlay_perms.ox = x;
    return(s1overlay_perms)
}

val AArch64_S1POEnabled : Regime -> bool

function AArch64_S1POEnabled regime = {
    if not_bool(HaveS1POExt()) then {
        return(false)
    };
    match regime {
      Regime_EL3 => {
          return(TCR_EL3[POE] == 0b1)
      },
      Regime_EL2 => {
          return(IsTCR2EL2Enabled() & TCR2_EL2[POE] == 0b1)
      },
      Regime_EL20 => {
          return(IsTCR2EL2Enabled() & TCR2_EL2[POE] == 0b1)
      },
      Regime_EL10 => {
          return(IsTCR2EL1Enabled() & TCR2_EL1[POE] == 0b1)
      },
      _ => {
          return(undefined : bool)
      }
    }
}

val AArch64_S1ComputePermissions : (Regime, TTWState, S1TTWParams, AccessDescriptor) -> S1AccessControls

function AArch64_S1ComputePermissions (regime, walkstate, walkparams, accdesc) = {
    s1overlay_perms : S1AccessControls = undefined;
    let permissions : Permissions = walkstate.permissions;
    s1perms : S1AccessControls = undefined;
    if walkparams.pie == 0b1 then {
        s1perms = AArch64_S1IndirectBasePermissions(regime, walkstate, walkparams, accdesc)
    } else {
        s1perms = AArch64_S1DirectBasePermissions(regime, walkstate, walkparams, accdesc)
    };
    if accdesc.el == EL0 & not_bool(AArch64_S1E0POEnabled(regime, walkparams.nv1)) then {
        s1perms.overlay = false
    } else if accdesc.el != EL0 & not_bool(AArch64_S1POEnabled(regime)) then {
        s1perms.overlay = false
    } else ();
    if s1perms.overlay then {
        let s1overlay_perms : S1AccessControls = AArch64_S1OverlayPermissions(regime, walkstate, accdesc);
        s1perms.or = s1overlay_perms.or;
        s1perms.ow = s1overlay_perms.ow;
        s1perms.ox = s1overlay_perms.ox
    };
    if (s1perms.overlay & s1perms.wxn == 0b1) & s1perms.ox == 0b1 then {
        s1perms.ow = 0b0
    } else if s1perms.wxn == 0b1 then {
        s1perms.x = 0b0
    } else ();
    return(s1perms)
}

val AArch64_S1CheckPermissions : (FaultRecord, Regime, TTWState, S1TTWParams, AccessDescriptor) -> FaultRecord

function AArch64_S1CheckPermissions (fault_in, regime, walkstate, walkparams, accdesc) = {
    fault : FaultRecord = fault_in;
    let permissions : Permissions = walkstate.permissions;
    let s1perms : S1AccessControls = AArch64_S1ComputePermissions(regime, walkstate, walkparams, accdesc);
    if accdesc.acctype == AccessType_IFETCH then {
        if s1perms.overlay & s1perms.ox == 0b0 then {
            fault.statuscode = Fault_Permission;
            fault.overlay = true
        } else if walkstate.memattrs.memtype == MemType_Device & ConstrainUnpredictable(Unpredictable_INSTRDEVICE) == Constraint_FAULT then {
            fault.statuscode = Fault_Permission
        } else if s1perms.x == 0b0 then {
            fault.statuscode = Fault_Permission
        } else ()
    } else if accdesc.acctype == AccessType_DC then {
        if accdesc.cacheop == CacheOp_Invalidate then {
            if s1perms.overlay & s1perms.ow == 0b0 then {
                fault.statuscode = Fault_Permission;
                fault.overlay = true
            } else if s1perms.w == 0b0 then {
                fault.statuscode = Fault_Permission
            } else ()
        } else if accdesc.el == EL0 then {
            if s1perms.overlay & s1perms.or == 0b0 then {
                fault.statuscode = Fault_Permission;
                fault.overlay = true
            } else if (((walkparams.cmow == 0b1 & accdesc.opscope == CacheOpScope_PoC) & accdesc.cacheop == CacheOp_CleanInvalidate) & s1perms.overlay) & s1perms.ow == 0b0 then {
                fault.statuscode = Fault_Permission;
                fault.overlay = true
            } else if s1perms.r == 0b0 then {
                fault.statuscode = Fault_Permission
            } else if ((walkparams.cmow == 0b1 & accdesc.opscope == CacheOpScope_PoC) & accdesc.cacheop == CacheOp_CleanInvalidate) & s1perms.w == 0b0 then {
                fault.statuscode = Fault_Permission
            } else ()
        } else ()
    } else if accdesc.acctype == AccessType_IC then {
        if accdesc.el == EL0 then {
            if (s1perms.overlay & s1perms.or == 0b0) & __IMPDEF_boolean("Permission fault on EL0 IC_IVAU execution") then {
                fault.statuscode = Fault_Permission;
                fault.overlay = true
            } else if (walkparams.cmow == 0b1 & s1perms.overlay) & s1perms.ow == 0b0 then {
                fault.statuscode = Fault_Permission;
                fault.overlay = true
            } else if s1perms.r == 0b0 & __IMPDEF_boolean("Permission fault on EL0 IC_IVAU execution") then {
                fault.statuscode = Fault_Permission
            } else if walkparams.cmow == 0b1 & s1perms.w == 0b0 then {
                fault.statuscode = Fault_Permission
            } else ()
        };
        ()
    } else if HaveGCS() & accdesc.acctype == AccessType_GCS then {
        if s1perms.gcs == 0b0 then {
            fault.statuscode = Fault_Permission
        } else if (accdesc.write & (walkparams.ha @ walkparams.hd) != 0b11) & permissions.ndirty == 0b1 then {
            fault.statuscode = Fault_Permission;
            fault.dirtybit = true;
            fault.write = true
        } else ()
    } else if (accdesc.read & s1perms.overlay) & s1perms.or == 0b0 then {
        fault.statuscode = Fault_Permission;
        fault.overlay = true;
        fault.write = false
    } else if (accdesc.write & s1perms.overlay) & s1perms.ow == 0b0 then {
        fault.statuscode = Fault_Permission;
        fault.overlay = true;
        fault.write = true
    } else if accdesc.read & s1perms.r == 0b0 then {
        fault.statuscode = Fault_Permission;
        fault.write = false
    } else if accdesc.write & s1perms.w == 0b0 then {
        fault.statuscode = Fault_Permission;
        fault.write = true
    } else if (accdesc.write & accdesc.tagaccess) & walkstate.memattrs.tags == MemTag_CanonicallyTagged then {
        fault.statuscode = Fault_Permission;
        fault.write = true;
        fault.s1tagnotdata = true
    } else if ((accdesc.write & not_bool((walkparams.ha @ walkparams.hd) == 0b11)) & walkparams.pie == 0b1) & permissions.ndirty == 0b1 then {
        fault.statuscode = Fault_Permission;
        fault.dirtybit = true;
        fault.write = true
    } else ();
    return(fault)
}

val AArch64_S1DCacheEnabled : Regime -> bool

function AArch64_S1DCacheEnabled regime = {
    match regime {
      Regime_EL3 => {
          return(SCTLR_EL3[C] == 0b1)
      },
      Regime_EL2 => {
          return(SCTLR_EL2[C] == 0b1)
      },
      Regime_EL20 => {
          return(SCTLR_EL2[C] == 0b1)
      },
      Regime_EL10 => {
          return(SCTLR_EL1[C] == 0b1)
      },
      _ => {
          return(undefined : bool)
      }
    }
}

val AArch64_AddrTop : (bits(1), AccessType, bits(1)) -> int

function AArch64_AddrTop (tbid, acctype, tbi) = {
    if tbid == 0b1 & acctype == AccessType_IFETCH then {
        return(63)
    };
    if tbi == 0b1 then {
        return(55)
    } else {
        return(63)
    }
}

bitfield MECID_P0_EL2_Type : bits(64) = {MECID : 15..0}

register MECID_P0_EL2 : MECID_P0_EL2_Type

bitfield VMECID_P_EL2_Type : bits(64) = {MECID : 15..0}

register VMECID_P_EL2 : VMECID_P_EL2_Type

val AArch64_S1DisabledOutputMECID : (S1TTWParams, Regime, PASpace) -> bits(16)

function AArch64_S1DisabledOutputMECID (walkparams, regime, paspace) = {
    if walkparams.emec == 0b0 then {
        return(DEFAULT_MECID)
    };
    if not_bool(regime == Regime_EL2 | regime == Regime_EL20 | regime == Regime_EL10) then {
        return(DEFAULT_MECID)
    };
    if paspace != PAS_Realm then {
        return(DEFAULT_MECID)
    };
    if regime == Regime_EL10 then {
        return(VMECID_P_EL2[MECID])
    } else {
        return(MECID_P0_EL2[MECID])
    }
}

val AArch64_S1HasAlignmentFault : forall ('aligned : Bool).
  (AccessDescriptor, bool('aligned), bits(1), MemoryAttributes) -> bool

function AArch64_S1HasAlignmentFault (accdesc, aligned, ntlsmd, memattrs) = {
    if accdesc.acctype == AccessType_IFETCH then {
        return(false)
    } else if (HaveMTEExt() & accdesc.tagaccess) & accdesc.write then {
        return(memattrs.memtype == MemType_Device & ConstrainUnpredictable(Unpredictable_DEVICETAGSTORE) == Constraint_FAULT)
    } else if accdesc.a32lsmd & ntlsmd == 0b0 then {
        return(memattrs.memtype == MemType_Device & memattrs.device != DeviceType_GRE)
    } else if accdesc.acctype == AccessType_DCZero then {
        return(memattrs.memtype == MemType_Device)
    } else {
        return(memattrs.memtype == MemType_Device & not_bool(aligned))
    }
}

val AArch64_S1ICacheEnabled : Regime -> bool

function AArch64_S1ICacheEnabled regime = {
    match regime {
      Regime_EL3 => {
          return(SCTLR_EL3[I] == 0b1)
      },
      Regime_EL2 => {
          return(SCTLR_EL2[I] == 0b1)
      },
      Regime_EL20 => {
          return(SCTLR_EL2[I] == 0b1)
      },
      Regime_EL10 => {
          return(SCTLR_EL1[I] == 0b1)
      },
      _ => {
          return(undefined : bool)
      }
    }
}

val AArch64_S1DisabledOutput : forall ('aligned : Bool).
  (FaultRecord, Regime, bits(64), AccessDescriptor, bool('aligned)) -> (FaultRecord, AddressDescriptor)

function AArch64_S1DisabledOutput (fault_in, regime, va_in, accdesc, aligned) = {
    ipa : AddressDescriptor = undefined;
    va : bits(64) = va_in;
    let walkparams : S1TTWParams = AArch64_GetS1TTWParams(regime, accdesc.ss, va);
    fault : FaultRecord = fault_in;
    SetInGuardedPage(false);
    oa : FullAddress = undefined;
    oa.address = va[55 .. 0];
    match accdesc.ss {
      SS_Secure => {
          oa.paspace = PAS_Secure
      },
      SS_NonSecure => {
          oa.paspace = PAS_NonSecure
      },
      SS_Root => {
          oa.paspace = PAS_Root
      },
      SS_Realm => {
          oa.paspace = PAS_Realm
      }
    };
    memattrs : MemoryAttributes = undefined;
    if (regime == Regime_EL10 & EL2Enabled()) & walkparams.dc == 0b1 then {
        default_cacheability : MemAttrHints = undefined;
        default_cacheability.attrs = MemAttr_WB;
        default_cacheability.hints = MemHint_RWA;
        default_cacheability.transient = false;
        memattrs.memtype = MemType_Normal;
        memattrs.outer = default_cacheability;
        memattrs.inner = default_cacheability;
        memattrs.shareability = Shareability_NSH;
        if walkparams.dct == 0b1 then {
            memattrs.tags = MemTag_AllocationTagged
        } else if walkparams.mtx == 0b1 then {
            memattrs.tags = MemTag_CanonicallyTagged;
            if walkparams.tbi == 0b0 then {
                va[59 .. 56] = Replicate([va[55]], 4)
            };
            ()
        } else {
            memattrs.tags = MemTag_Untagged
        };
        memattrs.xs = 0b0
    } else if accdesc.acctype == AccessType_IFETCH then {
        i_cache_attr : MemAttrHints = undefined;
        if AArch64_S1ICacheEnabled(regime) then {
            i_cache_attr.attrs = MemAttr_WT;
            i_cache_attr.hints = MemHint_RA;
            i_cache_attr.transient = false
        } else {
            i_cache_attr.attrs = MemAttr_NC
        };
        memattrs.memtype = MemType_Normal;
        memattrs.outer = i_cache_attr;
        memattrs.inner = i_cache_attr;
        memattrs.shareability = Shareability_OSH;
        if walkparams.mtx == 0b1 then {
            memattrs.tags = MemTag_CanonicallyTagged
        } else {
            memattrs.tags = MemTag_Untagged
        };
        memattrs.xs = 0b1
    } else {
        memattrs.memtype = MemType_Device;
        memattrs.device = DeviceType_nGnRnE;
        memattrs.shareability = Shareability_OSH;
        if walkparams.mtx == 0b1 then {
            memattrs.tags = MemTag_CanonicallyTagged;
            if walkparams.tbi == 0b0 then {
                if HasUnprivileged(regime) then {
                    va[59 .. 56] = Replicate([va[55]], 4)
                } else {
                    va[59 .. 56] = 0b0000
                }
            };
            ()
        } else {
            memattrs.tags = MemTag_Untagged
        };
        memattrs.xs = 0b1
    };
    memattrs.notagaccess = false;
    fault.level = 0;
    let 'addrtop = AArch64_AddrTop(walkparams.tbid, accdesc.acctype, walkparams.tbi);
    if not_bool(is_zero_subrange(va, addrtop, AArch64_PAMax())) then {
        fault.statuscode = Fault_AddressSize
    } else if AArch64_S1HasAlignmentFault(accdesc, aligned, walkparams.ntlsmd, memattrs) then {
        fault.statuscode = Fault_Alignment
    } else ();
    if fault.statuscode != Fault_None then {
        return((fault, __UNKNOWN_AddressDescriptor()))
    } else {
        ipa : AddressDescriptor = CreateAddressDescriptor(va_in, oa, memattrs);
        ipa.mecid = AArch64_S1DisabledOutputMECID(walkparams, regime, ipa.paddress.paspace);
        return((fault, ipa))
    }
}

val AArch64_S1Enabled : (Regime, AccessType) -> bool

function AArch64_S1Enabled (regime, acctype) = {
    match regime {
      Regime_EL3 => {
          return(SCTLR_EL3[M] == 0b1)
      },
      Regime_EL2 => {
          return(SCTLR_EL2[M] == 0b1)
      },
      Regime_EL20 => {
          return(SCTLR_EL2[M] == 0b1)
      },
      Regime_EL10 => {
          return((not_bool(EL2Enabled()) | (HCR_EL2[DC] @ HCR_EL2[TGE]) == 0b00) & SCTLR_EL1[M] == 0b1)
      },
      _ => {
          return(undefined : bool)
      }
    }
}

bitfield MECID_A0_EL2_Type : bits(64) = {MECID : 15..0}

register MECID_A0_EL2 : MECID_A0_EL2_Type

bitfield MECID_A1_EL2_Type : bits(64) = {MECID : 15..0}

register MECID_A1_EL2 : MECID_A1_EL2_Type

bitfield MECID_P1_EL2_Type : bits(64) = {MECID : 15..0}

register MECID_P1_EL2 : MECID_P1_EL2_Type

bitfield MECID_RL_A_EL3_Type : bits(64) = {MECID : 15..0}

register MECID_RL_A_EL3 : MECID_RL_A_EL3_Type

val AArch64_S1OutputMECID : forall 'N, 'N in {64, 128}.
  (S1TTWParams, Regime, VARange, PASpace, bits('N)) -> bits(16)

function AArch64_S1OutputMECID (walkparams, regime, varange, paspace, descriptor) = {
    assert('N == 64 | 'N == 128);
    if walkparams.emec == 0b0 then {
        return(DEFAULT_MECID)
    };
    if paspace != PAS_Realm then {
        return(DEFAULT_MECID)
    };
    let descriptor_amec : bits(1) = if walkparams.d128 == 0b1 then {
        assert(constraint(103 < 'N));
        [descriptor[103]]
    } else [descriptor[63]];
    match regime {
      Regime_EL3 => {
          return(MECID_RL_A_EL3[MECID])
      },
      Regime_EL2 => {
          if descriptor_amec == 0b0 then {
              return(MECID_P0_EL2[MECID])
          } else {
              return(MECID_A0_EL2[MECID])
          }
      },
      Regime_EL20 => {
          if varange == VARange_LOWER then {
              if descriptor_amec == 0b0 then {
                  return(MECID_P0_EL2[MECID])
              } else {
                  return(MECID_A0_EL2[MECID])
              }
          } else {
              if descriptor_amec == 0b0 then {
                  return(MECID_P1_EL2[MECID])
              } else {
                  return(MECID_A1_EL2[MECID])
              }
          }
      },
      Regime_EL10 => {
          return(VMECID_P_EL2[MECID])
      },
      _ => {
          return(undefined : bits(16))
      }
    }
}

val AArch64_BlockBBMSupportLevel : unit -> int

function AArch64_BlockBBMSupportLevel () = {
    if not_bool(HaveBlockBBM()) then {
        return(__UNKNOWN_integer())
    } else {
        return(__IMPDEF_integer("Block BBM support level"))
    }
}

val AArch64_BlocknTFaults : forall 'N, 'N >= 0. (bits(1), bits('N)) -> bool

function AArch64_BlocknTFaults (d128, descriptor) = {
    if not_bool(HaveBlockBBM()) then {
        return(false)
    };
    let nT : bits(1) = if d128 == 0b1 then {
        assert(constraint(6 < 'N));
        [descriptor[6]]
    } else {
        assert(constraint(16 < 'N));
        [descriptor[16]]
    };
    let 'bbm_level = AArch64_BlockBBMSupportLevel();
    let nT_faults : bool = __IMPDEF_boolean("BBM level 1 or 2 support nT bit causes Translation Fault");
    return(((bbm_level == 1 | bbm_level == 2) & nT == 0b1) & nT_faults)
}

val AArch64_IASize : bits(6) -> int

function AArch64_IASize txsz = {
    return(64 - UInt(txsz))
}

val AArch64_ContiguousBitFaults : forall 'level.
  (bits(1), bits(6), TGx, int('level)) -> bool

function AArch64_ContiguousBitFaults (d128, txsz, tgx, level) = {
    let 'iasize = AArch64_IASize(txsz);
    let 'tsize = TranslationSize(d128, tgx, level) + ContiguousSize(d128, tgx, level);
    return(tsize > iasize & __IMPDEF_boolean("Translation fault on misprogrammed contiguous bit"))
}

val AArch64_BlockDescSupported : forall 'level.
  (bits(1), bits(1), TGx, int('level)) -> bool

function AArch64_BlockDescSupported (d128, ds, tgx, level) = {
    match tgx {
      TGx_4KB => {
          return((level == 0 & (ds == 0b1 | d128 == 0b1) | level == 1) | level == 2)
      },
      TGx_16KB => {
          return(level == 1 & (ds == 0b1 | d128 == 0b1) | level == 2)
      },
      TGx_64KB => {
          return(level == 1 & (d128 == 0b1 | AArch64_PAMax() >= 52) | level == 2)
      }
    };
    return(false)
}

val AArch64_DecodeDescriptorType : forall 'N 'level, 0 < 'N.
  (bits('N), bits(1), bits(1), TGx, int('level)) -> DescriptorType

function AArch64_DecodeDescriptorType (descriptor, d128, ds, tgx, level) = {
    if [descriptor[0]] == 0b0 then {
        return(DescriptorType_Invalid)
    } else if d128 == 0b1 then {
        assert(constraint(110 < 'N));
        let skl : bits(2) = descriptor[110 .. 109];
        if (tgx == TGx_16KB | tgx == TGx_64KB) & UInt(skl) == 3 then {
            return(DescriptorType_Invalid)
        };
        let 'effective_level = level + UInt(skl);
        if effective_level > FINAL_LEVEL then {
            return(DescriptorType_Invalid)
        } else if effective_level == FINAL_LEVEL then {
            return(DescriptorType_Leaf)
        } else {
            return(DescriptorType_Table)
        }
    } else {
        assert(constraint(1 < 'N));
        if [descriptor[1]] == 0b1 then {
            if level == FINAL_LEVEL then {
                return(DescriptorType_Leaf)
            } else {
                return(DescriptorType_Table)
            }
        } else if [descriptor[1]] == 0b0 then {
            if AArch64_BlockDescSupported(d128, ds, tgx, level) then {
                return(DescriptorType_Leaf)
            } else {
                return(DescriptorType_Invalid)
            }
        } else {
            return(undefined : DescriptorType)
        }
    }
}

val VMID_read : unit -> bits(16)

function VMID_read () = {
    if EL2Enabled() then {
        if not_bool(ELUsingAArch32(EL2)) then {
            if Have16bitVMID() & VTCR_EL2[VS] == 0b1 then {
                return(VTTBR_EL2_read()[VMID])
            } else {
                return(ZeroExtend(VTTBR_EL2_read()[VMID][7 .. 0], 16))
            }
        } else {
            return(ZeroExtend(VTTBR[VMID], 16))
        }
    } else if HaveEL(EL2) & HaveSecureEL2Ext() then {
        return(Zeros(16))
    } else {
        return(VMID_NONE)
    }
}

val AArch64_TLBContextEL10 : (SecurityState, bits(64), TGx) -> TLBContext

function AArch64_TLBContextEL10 (ss, va, tg) = {
    tlbcontext : TLBContext = undefined;
    tlbcontext.ss = ss;
    tlbcontext.regime = Regime_EL10;
    tlbcontext.vmid = VMID_read();
    tlbcontext.asid = if TCR_EL1[A1] == 0b0 then TTBR0_EL1_read()[ASID] else
      TTBR1_EL1_read()[ASID];
    if TCR_EL1[AS] == 0b0 then {
        tlbcontext.asid[15 .. 8] = Zeros(8)
    };
    tlbcontext.tg = tg;
    tlbcontext.ia = va;
    if HaveCommonNotPrivateTransExt() then {
        if AArch64_GetVARange(va) == VARange_LOWER then {
            tlbcontext.cnp = TTBR0_EL1_read()[CnP]
        } else {
            tlbcontext.cnp = TTBR1_EL1_read()[CnP]
        }
    } else {
        tlbcontext.cnp = 0b0
    };
    return(tlbcontext)
}

val AArch64_TLBContextEL2 : (SecurityState, bits(64), TGx) -> TLBContext

function AArch64_TLBContextEL2 (ss, va, tg) = {
    tlbcontext : TLBContext = undefined;
    tlbcontext.ss = ss;
    tlbcontext.regime = Regime_EL2;
    tlbcontext.tg = tg;
    tlbcontext.ia = va;
    tlbcontext.cnp = if HaveCommonNotPrivateTransExt() then
      TTBR0_EL2_read()[CnP]
    else
      0b0;
    return(tlbcontext)
}

val AArch64_TLBContextEL20 : (SecurityState, bits(64), TGx) -> TLBContext

function AArch64_TLBContextEL20 (ss, va, tg) = {
    tlbcontext : TLBContext = undefined;
    tlbcontext.ss = ss;
    tlbcontext.regime = Regime_EL20;
    tlbcontext.asid = if TCR_EL2[A1] == 0b0 then TTBR0_EL2_read()[ASID] else
      TTBR1_EL2[ASID];
    if TCR_EL2[AS] == 0b0 then {
        tlbcontext.asid[15 .. 8] = Zeros(8)
    };
    tlbcontext.tg = tg;
    tlbcontext.ia = va;
    if HaveCommonNotPrivateTransExt() then {
        if AArch64_GetVARange(va) == VARange_LOWER then {
            tlbcontext.cnp = TTBR0_EL2_read()[CnP]
        } else {
            tlbcontext.cnp = TTBR1_EL2[CnP]
        }
    } else {
        tlbcontext.cnp = 0b0
    };
    return(tlbcontext)
}

val AArch64_TLBContextEL3 : (SecurityState, bits(64), TGx) -> TLBContext

function AArch64_TLBContextEL3 (ss, va, tg) = {
    tlbcontext : TLBContext = undefined;
    tlbcontext.ss = ss;
    tlbcontext.regime = Regime_EL3;
    tlbcontext.tg = tg;
    tlbcontext.ia = va;
    tlbcontext.cnp = if HaveCommonNotPrivateTransExt() then TTBR0_EL3[CnP] else
      0b0;
    return(tlbcontext)
}

val AArch64_GetS1TLBContext : (Regime, SecurityState, bits(64), TGx) -> TLBContext

function AArch64_GetS1TLBContext (regime, ss, va, tg) = {
    tlbcontext : TLBContext = undefined;
    match regime {
      Regime_EL3 => {
          tlbcontext = AArch64_TLBContextEL3(ss, va, tg)
      },
      Regime_EL2 => {
          tlbcontext = AArch64_TLBContextEL2(ss, va, tg)
      },
      Regime_EL20 => {
          tlbcontext = AArch64_TLBContextEL20(ss, va, tg)
      },
      Regime_EL10 => {
          tlbcontext = AArch64_TLBContextEL10(ss, va, tg)
      },
      _ => ()
    };
    tlbcontext.includes_s1_name = true;
    tlbcontext.includes_s2_name = false;
    tlbcontext.includes_gpt_name = false;
    return(tlbcontext)
}

val AArch64_PhysicalAddressSize : (bits(1), bits(3), TGx) -> int

function AArch64_PhysicalAddressSize (d128, encoded_ps, tgx) = {
    ps : {32, 36, 40, 42, 44, 48, 52, 56} = 32;
    max_ps : int = undefined;
    match encoded_ps {
      0b000 => {
          ps = 32
      },
      0b001 => {
          ps = 36
      },
      0b010 => {
          ps = 40
      },
      0b011 => {
          ps = 42
      },
      0b100 => {
          ps = 44
      },
      0b101 => {
          ps = 48
      },
      0b110 => {
          ps = 52
      },
      0b111 => {
          ps = 56
      }
    };
    let 'ps = ps;
    if not_bool(Have56BitPAExt()) | d128 == 0b0 then {
        if tgx != TGx_64KB & not_bool(Have52BitIPAAndPASpaceExt()) then {
            max_ps = Min(48, AArch64_PAMax())
        } else if not_bool(Have52BitPAExt()) then {
            max_ps = Min(48, AArch64_PAMax())
        } else {
            max_ps = Min(52, AArch64_PAMax())
        }
    } else {
        max_ps = AArch64_PAMax()
    };
    let 'max_ps = max_ps;
    return(Min(ps, max_ps))
}

val AArch64_OAOutOfRange : (bits(56), bits(1), bits(3), TGx) -> bool

function AArch64_OAOutOfRange (address, d128, ps, tgx) = {
    let 'oasize = AArch64_PhysicalAddressSize(d128, ps, tgx);
    if oasize < 56 then {
        return(not_bool(is_zero_subrange(address, 55, oasize)))
    } else {
        return(false)
    }
}

val AArch64_S1AMECFault : forall 'N, 'N in {64, 128}.
  (S1TTWParams, PASpace, Regime, bits('N)) -> bool

function AArch64_S1AMECFault (walkparams, paspace, regime, descriptor) = {
    assert('N == 64 | 'N == 128);
    let descriptor_amec : bits(1) = if walkparams.d128 == 0b1 then {
        assert(constraint(103 < 'N));
        [descriptor[103]]
    } else [descriptor[63]];
    return((((walkparams.emec @ walkparams.amec) == 0b10 & (regime == Regime_EL2 | regime == Regime_EL20)) & paspace == PAS_Realm) & descriptor_amec == 0b1)
}

val AArch64_S1EPD : (Regime, bits(64)) -> bits(1)

function AArch64_S1EPD (regime, va) = {
    assert(HasUnprivileged(regime));
    let varange : VARange = AArch64_GetVARange(va);
    match regime {
      Regime_EL20 => {
          return(if varange == VARange_LOWER then TCR_EL2[EPD0] else
            TCR_EL2[EPD1])
      },
      Regime_EL10 => {
          return(if varange == VARange_LOWER then TCR_EL1[EPD0] else
            TCR_EL1[EPD1])
      },
      _ => {
          return(undefined : bits(1))
      }
    }
}

val AArch64_S1StartLevel : S1TTWParams -> int

function AArch64_S1StartLevel walkparams = {
    let 'iasize = AArch64_IASize(walkparams.txsz);
    let 'granulebits = TGxGranuleBits(walkparams.tgx);
    let 'descsizelog2 = if walkparams.d128 == 0b1 then 4 else 3;
    let 'stride = granulebits - descsizelog2;
    s1startlevel : int = FINAL_LEVEL - DIV(iasize - 1 - granulebits, stride);
    if walkparams.d128 == 0b1 then {
        s1startlevel = s1startlevel + UInt(walkparams.skl)
    };
    let 's1startlevel = s1startlevel;
    return(s1startlevel)
}

val AArch64_S1TTBR : (Regime, bits(64)) -> bits(128)

function AArch64_S1TTBR (regime, va) = {
    let varange : VARange = AArch64_GetVARange(va);
    match regime {
      Regime_EL3 => {
          return(ZeroExtend(TTBR0_EL3.bits, 128))
      },
      Regime_EL2 => {
          return(ZeroExtend(TTBR0_EL2_read().bits, 128))
      },
      Regime_EL20 => {
          if varange == VARange_LOWER then {
              return(ZeroExtend(TTBR0_EL2_read().bits, 128))
          } else {
              return(ZeroExtend(TTBR1_EL2.bits, 128))
          }
      },
      Regime_EL10 => {
          if varange == VARange_LOWER then {
              return(ZeroExtend(TTBR0_EL1_read().bits, 128))
          } else {
              return(ZeroExtend(TTBR1_EL1_read().bits, 128))
          }
      },
      _ => {
          return(undefined : bits(128))
      }
    }
}

val AArch64_S1TTBaseAddress : forall 'N, 'N >= 0.
  (S1TTWParams, Regime, bits('N)) -> bits(56)

function AArch64_S1TTBaseAddress (walkparams, regime, ttbr) = {
    tablebase : bits(56) = Zeros(56);
    let 'iasize = AArch64_IASize(walkparams.txsz);
    let 'granulebits = TGxGranuleBits(walkparams.tgx);
    let 'descsizelog2 = if walkparams.d128 == 0b1 then 4 else 3;
    let 'stride = granulebits - descsizelog2;
    let 'startlevel = AArch64_S1StartLevel(walkparams);
    let 'levels = FINAL_LEVEL - startlevel;
    tsize : int = iasize - (levels * stride + granulebits) + descsizelog2;
    if Have56BitPAExt() & walkparams.d128 == 0b1 then {
        tsize = Max(tsize, 5);
        if regime == Regime_EL3 then {
            assert(constraint(55 < 'N));
            tablebase[55 .. 5] = ttbr[55 .. 5]
        } else {
            assert(constraint(87 < 'N));
            tablebase[55 .. 5] = ttbr[87 .. 80] @ ttbr[47 .. 5]
        }
    } else if (Have52BitPAExt() & walkparams.tgx == TGx_64KB) & walkparams.ps == 0b110 | walkparams.ds == 0b1 then {
        tsize = Max(tsize, 6);
        assert(constraint(5 < 'N));
        assert(constraint(47 < 'N));
        tablebase[51 .. 6] = ttbr[5 .. 2] @ ttbr[47 .. 6]
    } else {
        assert(constraint(47 < 'N));
        tablebase[47 .. 1] = ttbr[47 .. 1]
    };
    let 'tsize = tsize;
    let tablebase : bits(56) = Align(tablebase, (1 << tsize));
    return(tablebase)
}

val AArch64_S1InitialTTWState : (S1TTWParams, bits(64), Regime, SecurityState) -> TTWState

function AArch64_S1InitialTTWState (walkparams, va, regime, ss) = {
    walkstate : TTWState = undefined;
    tablebase : FullAddress = undefined;
    permissions : Permissions = undefined;
    let ttbr : bits(128) = AArch64_S1TTBR(regime, va);
    match ss {
      SS_Secure => {
          tablebase.paspace = PAS_Secure
      },
      SS_NonSecure => {
          tablebase.paspace = PAS_NonSecure
      },
      SS_Root => {
          tablebase.paspace = PAS_Root
      },
      SS_Realm => {
          tablebase.paspace = PAS_Realm
      }
    };
    tablebase.address = AArch64_S1TTBaseAddress(walkparams, regime, ttbr);
    permissions.ap_table = 0b00;
    if HasUnprivileged(regime) then {
        permissions.uxn_table = 0b0;
        permissions.pxn_table = 0b0
    } else {
        permissions.xn_table = 0b0
    };
    walkstate.baseaddress = tablebase;
    walkstate.level = AArch64_S1StartLevel(walkparams);
    walkstate.istable = true;
    walkstate.nG = if HasUnprivileged(regime) then 0b1 else 0b0;
    walkstate.memattrs = WalkMemAttrs(walkparams.sh, walkparams.irgn, walkparams.orgn);
    walkstate.permissions = permissions;
    if walkparams.d128 == 0b1 | walkparams.pnch == 0b1 then {
        walkstate.s1assured = true
    } else {
        walkstate.s1assured = false
    };
    walkstate.disch = walkparams.disch;
    return(walkstate)
}

val AArch64_ContiguousBit : forall 'N 'level, 52 < 'N.
  (TGx, bits(1), int('level), bits('N)) -> bits(1)

function AArch64_ContiguousBit (tgx, d128, level, descriptor) = {
    if d128 == 0b1 then {
        if tgx == TGx_64KB & level == 1 | tgx == TGx_4KB & level == 0 then {
            return(0b0)
        } else {
            assert(constraint(111 < 'N));
            return([descriptor[111]])
        }
    };
    if tgx == TGx_64KB & level == 1 then {
        return(0b0)
    };
    if tgx == TGx_16KB & level == 1 then {
        return(0b0)
    };
    if tgx == TGx_4KB & level == 0 then {
        return(0b0)
    };
    return([descriptor[52]])
}

val AArch64_LeafBase : forall 'N 'level, 'N >= 0.
  (bits('N), bits(1), bits(1), TGx, int('level)) -> bits(56)

function AArch64_LeafBase (descriptor, d128, ds, tgx, level) = {
    leafbase : bits(56) = Zeros(56);
    let 'granulebits = TGxGranuleBits(tgx);
    let 'descsizelog2 = if d128 == 0b1 then 4 else 3;
    let 'stride = granulebits - descsizelog2;
    let 'leafsize = granulebits + stride * (FINAL_LEVEL - level);
    assert(constraint((0 <= 'leafsize & 'leafsize <= 47 & 47 < 'N)));
    leafbase[47 .. 0] = descriptor[47 .. leafsize] @ Zeros(leafsize);
    if Have56BitPAExt() & d128 == 0b1 then {
        assert(constraint(55 < 'N));
        leafbase[55 .. 48] = descriptor[55 .. 48];
        return(leafbase)
    };
    if Have52BitPAExt() & tgx == TGx_64KB then {
        leafbase[51 .. 48] = descriptor[15 .. 12]
    } else if ds == 0b1 then {
        assert(constraint(49 < 'N));
        leafbase[51 .. 48] = descriptor[9 .. 8] @ descriptor[49 .. 48]
    } else ();
    return(leafbase)
}

val AArch64_MAIRAttr : forall 'index.
  (int('index), MAIRType, MAIRType) -> bits(8)

function AArch64_MAIRAttr (index, mair2, mair) = {
    bit_index : int = 8 * index;
    assert(index < 8 | HaveAIEExt() & index < 16);
    if index > 7 then {
        let 'bit_index = bit_index - 64;
        assert(constraint((0 <= 'bit_index & 'bit_index <= 'bit_index + 7 & 'bit_index + 7 < 64)));
        return(mair2.bits[bit_index + 7 .. bit_index])
    } else {
        let 'bit_index = bit_index;
        assert(constraint((0 <= 'bit_index & 'bit_index <= 'bit_index + 7 & 'bit_index + 7 < 64)));
        return(mair.bits[bit_index + 7 .. bit_index])
    }
}

val AArch64_S1ApplyOutputPerms : forall 'N, 'N >= 0.
  (Permissions, bits('N), Regime, S1TTWParams) -> Permissions

function AArch64_S1ApplyOutputPerms (permissions_in, descriptor, regime, walkparams) = {
    bit_index : int = undefined;
    permissions : Permissions = permissions_in;
    pi_index : bits(4) = undefined;
    if walkparams.pie == 0b1 then {
        if walkparams.d128 == 0b1 then {
            assert(constraint(118 < 'N));
            pi_index = descriptor[118 .. 115]
        } else {
            assert(constraint(54 < 'N));
            pi_index = (descriptor[54 .. 53] @ [descriptor[51]]) @ [descriptor[6]]
        };
        let 'bit_index = 4 * UInt(pi_index);
        permissions.ppi = walkparams.pir.bits[bit_index + 3 .. bit_index];
        permissions.upi = walkparams.pire0.bits[bit_index + 3 .. bit_index];
        assert(constraint(7 < 'N));
        permissions.ndirty = [descriptor[7]]
    } else {
        if (regime == Regime_EL10 & EL2Enabled()) & walkparams.nv1 == 0b1 then {
            assert(constraint(7 < 'N));
            permissions.ap[2 .. 1] = [descriptor[7]] @ 0b0;
            assert(constraint(54 < 'N));
            permissions.pxn = [descriptor[54]]
        } else if HasUnprivileged(regime) then {
            assert(constraint(7 < 'N));
            permissions.ap[2 .. 1] = descriptor[7 .. 6];
            assert(constraint(54 < 'N));
            permissions.uxn = [descriptor[54]];
            permissions.pxn = [descriptor[53]]
        } else {
            assert(constraint(7 < 'N));
            permissions.ap[2 .. 1] = [descriptor[7]] @ 0b1;
            assert(constraint(54 < 'N));
            permissions.xn = [descriptor[54]]
        };
        assert(constraint(51 < 'N));
        if (walkparams.ha == 0b1 & walkparams.hd == 0b1) & [descriptor[51]] == 0b1 then {
            permissions.ap[2] = Bit(0b0)
        };
        ()
    };
    let poe : bool = AArch64_S1POEnabled(regime);
    let e0poe : bool = HasUnprivileged(regime) & AArch64_S1E0POEnabled(regime, walkparams.nv1);
    if poe | e0poe then {
        if walkparams.d128 == 0b1 then {
            assert(constraint(124 < 'N));
            permissions.po_index = descriptor[124 .. 121]
        } else {
            assert(constraint(62 < 'N));
            permissions.po_index = 0b0 @ descriptor[62 .. 60]
        }
    };
    return(permissions)
}

val AArch64_S1NextWalkStateLeaf : forall 'N ('s2fs1mro : Bool), 'N >= 0.
  (TTWState, bool('s2fs1mro), Regime, SecurityState, S1TTWParams, bits('N)) -> TTWState

function AArch64_S1NextWalkStateLeaf (currentstate, s2fs1mro, regime, ss, walkparams, descriptor) = {
    nextstate : TTWState = undefined;
    baseaddress : FullAddress = undefined;
    baseaddress.address = AArch64_LeafBase(descriptor, walkparams.d128, walkparams.ds, walkparams.tgx, currentstate.level);
    if currentstate.baseaddress.paspace == PAS_Secure then {
        let ns : bits(1) = if walkparams.d128 == 0b1 then {
            assert(constraint(127 < 'N));
            [descriptor[127]]
        } else {
            assert(constraint(5 < 'N));
            [descriptor[5]]
        };
        baseaddress.paspace = if ns == 0b0 then PAS_Secure else PAS_NonSecure
    } else if currentstate.baseaddress.paspace == PAS_Root then {
        nse : bits(1) = undefined;
        ns : bits(1) = undefined;
        (nse @ ns) = if walkparams.d128 == 0b1 then {
            assert(constraint(11 < 'N));
            assert(constraint(127 < 'N));
            [descriptor[11]] @ [descriptor[127]]
        } else {
            assert(constraint(11 < 'N));
            [descriptor[11]] @ [descriptor[5]]
        };
        baseaddress.paspace = DecodePASpace(nse, ns);
        if baseaddress.paspace == PAS_Secure & not_bool(HaveSecureState()) then {
            baseaddress.paspace = PAS_NonSecure
        };
        ()
    } else if currentstate.baseaddress.paspace == PAS_Realm & (regime == Regime_EL2 | regime == Regime_EL20) then {
        let ns : bits(1) = if walkparams.d128 == 0b1 then {
            assert(constraint(127 < 'N));
            [descriptor[127]]
        } else {
            assert(constraint(5 < 'N));
            [descriptor[5]]
        };
        baseaddress.paspace = if ns == 0b0 then PAS_Realm else PAS_NonSecure
    } else if currentstate.baseaddress.paspace == PAS_Realm then {
        baseaddress.paspace = PAS_Realm
    } else {
        baseaddress.paspace = PAS_NonSecure
    };
    nextstate.istable = false;
    nextstate.level = currentstate.level;
    nextstate.baseaddress = baseaddress;
    attrindx : bits(4) = undefined;
    if walkparams.aie == 0b1 then {
        if walkparams.d128 == 0b1 then {
            assert(constraint(5 < 'N));
            attrindx = descriptor[5 .. 2]
        } else {
            assert(constraint(59 < 'N));
            attrindx = [descriptor[59]] @ descriptor[4 .. 2]
        }
    } else {
        assert(constraint(4 < 'N));
        attrindx = 0b0 @ descriptor[4 .. 2]
    };
    sh : bits(2) = undefined;
    if walkparams.d128 == 0b1 then {
        assert(constraint(9 < 'N));
        sh = descriptor[9 .. 8]
    } else if walkparams.ds == 0b1 then {
        sh = walkparams.sh
    } else {
        assert(constraint(9 < 'N));
        sh = descriptor[9 .. 8]
    };
    let attr : bits(8) = AArch64_MAIRAttr(UInt(attrindx), walkparams.mair2, walkparams.mair);
    let s1aarch64 : bool = true;
    nextstate.memattrs = S1DecodeMemAttrs(attr, sh, s1aarch64, walkparams);
    nextstate.permissions = AArch64_S1ApplyOutputPerms(currentstate.permissions, descriptor, regime, walkparams);
    protectedbit : bits(1) = undefined;
    if walkparams.d128 == 0b1 then {
        assert(constraint(114 < 'N));
        protectedbit = [descriptor[114]]
    } else {
        protectedbit = if walkparams.pnch == 0b1 then {
            assert(constraint(52 < 'N));
            [descriptor[52]]
        } else 0b0
    };
    if (currentstate.s1assured & s2fs1mro) & protectedbit == 0b1 then {
        nextstate.s1assured = true
    } else {
        nextstate.s1assured = false
    };
    if walkparams.pnch == 0b1 | currentstate.disch == 0b1 then {
        nextstate.contiguous = 0b0
    } else {
        assert(constraint(52 < 'N));
        nextstate.contiguous = AArch64_ContiguousBit(walkparams.tgx, walkparams.d128, currentstate.level, descriptor)
    };
    if not_bool(HasUnprivileged(regime)) then {
        nextstate.nG = 0b0
    } else if ss == SS_Secure & currentstate.baseaddress.paspace == PAS_NonSecure then {
        nextstate.nG = 0b1
    } else {
        assert(constraint(11 < 'N));
        nextstate.nG = [descriptor[11]]
    };
    if walkparams.d128 == 0b1 then {
        assert(constraint(113 < 'N));
        nextstate.guardedpage = [descriptor[113]]
    } else {
        assert(constraint(50 < 'N));
        nextstate.guardedpage = [descriptor[50]]
    };
    return(nextstate)
}

val AArch64_NextTableBase : forall 'N, 'N >= 0.
  (bits('N), bits(1), bits(1), TGx) -> bits(56)

function AArch64_NextTableBase (descriptor, d128, ds, tgx) = {
    tablebase : bits(56) = Zeros(56);
    match tgx {
      TGx_4KB => {
          assert(constraint(47 < 'N));
          tablebase[47 .. 12] = descriptor[47 .. 12]
      },
      TGx_16KB => {
          assert(constraint(47 < 'N));
          tablebase[47 .. 14] = descriptor[47 .. 14]
      },
      TGx_64KB => {
          assert(constraint(47 < 'N));
          tablebase[47 .. 16] = descriptor[47 .. 16]
      }
    };
    if Have56BitPAExt() & d128 == 0b1 then {
        assert(constraint(55 < 'N));
        tablebase[55 .. 48] = descriptor[55 .. 48];
        return(tablebase)
    };
    if Have52BitPAExt() & tgx == TGx_64KB then {
        assert(constraint(15 < 'N));
        tablebase[51 .. 48] = descriptor[15 .. 12];
        return(tablebase)
    };
    if ds == 0b1 then {
        assert(constraint(9 < 'N));
        assert(constraint(49 < 'N));
        tablebase[51 .. 48] = descriptor[9 .. 8] @ descriptor[49 .. 48];
        return(tablebase)
    };
    return(tablebase)
}

val AArch64_S1ApplyTablePerms : forall 'N, 'N >= 0.
  (Permissions, bits('N), Regime, S1TTWParams) -> Permissions

function AArch64_S1ApplyTablePerms (permissions_in, descriptor, regime, walkparams) = {
    permissions : Permissions = permissions_in;
    ap_table : bits(2) = undefined;
    pxn_table : bits(1) = undefined;
    uxn_table : bits(1) = undefined;
    xn_table : bits(1) = undefined;
    if (regime == Regime_EL10 & EL2Enabled()) & walkparams.nv1 == 0b1 then {
        if walkparams.d128 == 0b1 then {
            assert(constraint(126 < 'N));
            ap_table = [descriptor[126]] @ 0b0;
            pxn_table = [descriptor[124]]
        } else {
            assert(constraint(62 < 'N));
            ap_table = [descriptor[62]] @ 0b0;
            pxn_table = [descriptor[60]]
        };
        permissions.ap_table = permissions.ap_table | ap_table;
        permissions.pxn_table = permissions.pxn_table | pxn_table
    } else if HasUnprivileged(regime) then {
        if walkparams.d128 == 0b1 then {
            assert(constraint(126 < 'N));
            ap_table = descriptor[126 .. 125];
            uxn_table = [descriptor[124]];
            pxn_table = [descriptor[123]]
        } else {
            assert(constraint(62 < 'N));
            ap_table = descriptor[62 .. 61];
            uxn_table = [descriptor[60]];
            pxn_table = [descriptor[59]]
        };
        permissions.ap_table = permissions.ap_table | ap_table;
        permissions.uxn_table = permissions.uxn_table | uxn_table;
        permissions.pxn_table = permissions.pxn_table | pxn_table
    } else {
        if walkparams.d128 == 0b1 then {
            assert(constraint(126 < 'N));
            ap_table = [descriptor[126]] @ 0b0;
            xn_table = [descriptor[124]]
        } else {
            assert(constraint(62 < 'N));
            ap_table = [descriptor[62]] @ 0b0;
            xn_table = [descriptor[60]]
        };
        permissions.ap_table = permissions.ap_table | ap_table;
        permissions.xn_table = permissions.xn_table | xn_table
    };
    return(permissions)
}

val AArch64_S1NextWalkStateTable : forall 'N ('s2fs1mro : Bool), 'N >= 0.
  (TTWState, bool('s2fs1mro), Regime, S1TTWParams, bits('N)) -> TTWState

function AArch64_S1NextWalkStateTable (currentstate, s2fs1mro, regime, walkparams, descriptor) = {
    skl : bits(2) = undefined;
    nextstate : TTWState = undefined;
    tablebase : FullAddress = undefined;
    tablebase.address = AArch64_NextTableBase(descriptor, walkparams.d128, walkparams.ds, walkparams.tgx);
    if currentstate.baseaddress.paspace == PAS_Secure then {
        let nstable : bits(1) = if walkparams.d128 == 0b1 then {
            assert(constraint(127 < 'N));
            [descriptor[127]]
        } else {
            assert(constraint(63 < 'N));
            [descriptor[63]]
        };
        tablebase.paspace = if nstable == 0b0 then PAS_Secure else PAS_NonSecure
    } else {
        tablebase.paspace = currentstate.baseaddress.paspace
    };
    nextstate.istable = true;
    nextstate.nG = currentstate.nG;
    if walkparams.d128 == 0b1 then {
        assert(constraint(110 < 'N));
        let skl : bits(2) = descriptor[110 .. 109];
        nextstate.level = currentstate.level + UInt(skl) + 1
    } else {
        nextstate.level = currentstate.level + 1
    };
    nextstate.baseaddress = tablebase;
    nextstate.memattrs = currentstate.memattrs;
    if walkparams.hpd == 0b0 & walkparams.pie == 0b0 then {
        nextstate.permissions = AArch64_S1ApplyTablePerms(currentstate.permissions, descriptor, regime, walkparams)
    } else {
        nextstate.permissions = currentstate.permissions
    };
    protectedbit : bits(1) = undefined;
    if walkparams.d128 == 0b1 then {
        assert(constraint(114 < 'N));
        protectedbit = [descriptor[114]]
    } else {
        protectedbit = if walkparams.pnch == 0b1 then {
            assert(constraint(52 < 'N));
            [descriptor[52]]
        } else 0b0
    };
    if (currentstate.s1assured & s2fs1mro) & protectedbit == 0b1 then {
        nextstate.s1assured = true
    } else {
        nextstate.s1assured = false
    };
    nextstate.disch = if walkparams.d128 == 0b1 then {
        assert(constraint(112 < 'N));
        [descriptor[112]]
    } else 0b0;
    return(nextstate)
}

val AArch64_S1SLTTEntryAddress : forall 'level.
  (int('level), S1TTWParams, bits(64), FullAddress) -> FullAddress

function AArch64_S1SLTTEntryAddress (level, walkparams, ia, tablebase) = {
    let 'iasize = AArch64_IASize(walkparams.txsz);
    let 'granulebits = TGxGranuleBits(walkparams.tgx);
    let 'descsizelog2 = if walkparams.d128 == 0b1 then 4 else 3;
    let 'stride = granulebits - descsizelog2;
    let 'levels = FINAL_LEVEL - level;
    let 'lsb = levels * stride + granulebits;
    let 'msb = iasize - 1;
    assert(constraint((0 <= 'lsb & 'lsb <= 'msb & 'msb < 64)));
    assert(constraint(56 >= 'msb - 'lsb + 1 + 'descsizelog2));
    let index : bits(56) = ZeroExtend(ia[msb .. lsb] @ Zeros(descsizelog2), 56);
    descaddress : FullAddress = undefined;
    descaddress.address = tablebase.address | index;
    descaddress.paspace = tablebase.paspace;
    return(descaddress)
}

val AArch64_HaveS2TG : TGx -> bool

function AArch64_HaveS2TG tgx = {
    assert(HaveEL(EL2));
    if HaveGTGExt() then {
        match tgx {
          TGx_4KB => {
              return(__IMPDEF_boolean("Has Stage 2 4K Translation Granule"))
          },
          TGx_16KB => {
              return(__IMPDEF_boolean("Has Stage 2 16K Translation Granule"))
          },
          TGx_64KB => {
              return(__IMPDEF_boolean("Has Stage 2 64K Translation Granule"))
          },
          _ => {
              return(undefined : bool)
          }
        }
    } else {
        return(AArch64_HaveS1TG(tgx))
    }
}

val AArch64_S2DecodeTG0 : bits(2) -> TGx

function AArch64_S2DecodeTG0 tg0_in = {
    tg0 : bits(2) = tg0_in;
    tgx : TGx = undefined;
    if tg0 == 0b11 then {
        tg0 = __IMPDEF_bits(2, "TG0 encoded granule size")
    };
    match tg0 {
      0b00 => {
          tgx = TGx_4KB
      },
      0b01 => {
          tgx = TGx_64KB
      },
      0b10 => {
          tgx = TGx_16KB
      },
      _ => ()
    };
    if not_bool(AArch64_HaveS2TG(tgx)) then {
        match __IMPDEF_bits(2, "TG0 encoded granule size") {
          0b00 => {
              tgx = TGx_4KB
          },
          0b01 => {
              tgx = TGx_64KB
          },
          0b10 => {
              tgx = TGx_16KB
          },
          _ => ()
        }
    };
    return(tgx)
}

bitfield S2PIR_EL2_Type : bits(64) =
  {
    Perm15 : 63..60,
    Perm14 : 59..56,
    Perm13 : 55..52,
    Perm12 : 51..48,
    Perm11 : 47..44,
    Perm10 : 43..40,
    Perm9 : 39..36,
    Perm8 : 35..32,
    Perm7 : 31..28,
    Perm6 : 27..24,
    Perm5 : 23..20,
    Perm4 : 19..16,
    Perm3 : 15..12,
    Perm2 : 11..8,
    Perm1 : 7..4,
    Perm0 : 3..0
  }

register S2PIR_EL2 : S2PIR_EL2_Type

val AArch64_NSS2TTWParams : forall ('s1aarch64 : Bool).
  bool('s1aarch64) -> S2TTWParams

function AArch64_NSS2TTWParams s1aarch64 = {
    walkparams : S2TTWParams = undefined;
    walkparams.vm = HCR_EL2[VM] | HCR_EL2[DC];
    walkparams.tgx = AArch64_S2DecodeTG0(VTCR_EL2[TG0]);
    walkparams.txsz = VTCR_EL2[T0SZ];
    walkparams.ps = VTCR_EL2[PS];
    walkparams.irgn = VTCR_EL2[IRGN0];
    walkparams.orgn = VTCR_EL2[ORGN0];
    walkparams.sh = VTCR_EL2[SH0];
    walkparams.ee = SCTLR_EL2[EE];
    walkparams.d128 = if Have128BitDescriptorExt() then VTCR_EL2[D128] else 0b0;
    if walkparams.d128 == 0b1 then {
        walkparams.skl = VTTBR_EL2_read()[SKL]
    } else {
        walkparams.sl0 = VTCR_EL2[SL0]
    };
    walkparams.ptw = if HCR_EL2[TGE] == 0b0 then HCR_EL2[PTW] else 0b0;
    walkparams.fwb = if HaveStage2MemAttrControl() then HCR_EL2[FWB] else 0b0;
    walkparams.ha = if HaveAccessFlagUpdateExt() then VTCR_EL2[HA] else 0b0;
    walkparams.hd = if HaveDirtyBitModifierExt() then VTCR_EL2[HD] else 0b0;
    if (walkparams.tgx == TGx_4KB | walkparams.tgx == TGx_16KB) & Have52BitIPAAndPASpaceExt() then {
        walkparams.ds = VTCR_EL2[DS]
    } else {
        walkparams.ds = 0b0
    };
    if walkparams.tgx == TGx_4KB & Have52BitIPAAndPASpaceExt() then {
        walkparams.sl2 = VTCR_EL2[SL2] & VTCR_EL2[DS]
    } else {
        walkparams.sl2 = 0b0
    };
    walkparams.cmow = if HaveFeatCMOW() & IsHCRXEL2Enabled() then HCRX_EL2[CMOW]
    else
      0b0;
    if walkparams.d128 == 0b1 then {
        walkparams.s2pie = 0b1
    } else {
        walkparams.s2pie = if HaveS2PIExt() then VTCR_EL2[S2PIE] else 0b0
    };
    walkparams.s2pir = if HaveS2PIExt() then Mk_S2PIRType(S2PIR_EL2.bits) else
      Mk_S2PIRType(Zeros(64));
    if HaveTHExt() & walkparams.d128 != 0b1 then {
        walkparams.assuredonly = VTCR_EL2[AssuredOnly]
    } else {
        walkparams.assuredonly = 0b0
    };
    walkparams.tl0 = if HaveTHExt() then VTCR_EL2[TL0] else 0b0;
    walkparams.tl1 = if HaveTHExt() then VTCR_EL2[TL1] else 0b0;
    if HaveAccessFlagUpdateForTableExt() & walkparams.ha == 0b1 then {
        walkparams.haft = VTCR_EL2[HAFT]
    } else {
        walkparams.haft = 0b0
    };
    return(walkparams)
}

val AArch64_RLS2TTWParams : forall ('s1aarch64 : Bool).
  bool('s1aarch64) -> S2TTWParams

function AArch64_RLS2TTWParams s1aarch64 = {
    walkparams : S2TTWParams = AArch64_NSS2TTWParams(s1aarch64);
    walkparams.emec = if HaveFeatMEC() & IsSCTLR2EL2Enabled() then
      SCTLR2_EL2[EMEC]
    else
      0b0;
    return(walkparams)
}

bitfield VSTCR_EL2_Type : bits(64) =
  {
    SL2 : 33..33,
    SA : 30..30,
    SW : 29..29,
    TG0 : 15..14,
    SL0 : 7..6,
    T0SZ : 5..0
  }

register VSTCR_EL2 : VSTCR_EL2_Type

bitfield VSTTBR_EL2_Type : bits(64) = {SKL : 2..1, CnP : 0..0}

register VSTTBR_EL2 : VSTTBR_EL2_Type

val AArch64_SS2TTWParams : forall ('s1aarch64 : Bool).
  (PASpace, bool('s1aarch64)) -> S2TTWParams

function AArch64_SS2TTWParams (ipaspace, s1aarch64) = {
    walkparams : S2TTWParams = undefined;
    walkparams.d128 = if Have128BitDescriptorExt() then VTCR_EL2[D128] else 0b0;
    if ipaspace == PAS_Secure then {
        walkparams.tgx = AArch64_S2DecodeTG0(VSTCR_EL2[TG0]);
        walkparams.txsz = VSTCR_EL2[T0SZ];
        if walkparams.d128 == 0b1 then {
            walkparams.skl = VSTTBR_EL2[SKL]
        } else {
            walkparams.sl0 = VSTCR_EL2[SL0]
        };
        if walkparams.tgx == TGx_4KB & Have52BitIPAAndPASpaceExt() then {
            walkparams.sl2 = VSTCR_EL2[SL2] & VTCR_EL2[DS]
        } else {
            walkparams.sl2 = 0b0
        }
    } else if ipaspace == PAS_NonSecure then {
        walkparams.tgx = AArch64_S2DecodeTG0(VTCR_EL2[TG0]);
        walkparams.txsz = VTCR_EL2[T0SZ];
        if walkparams.d128 == 0b1 then {
            walkparams.skl = VTTBR_EL2_read()[SKL]
        } else {
            walkparams.sl0 = VTCR_EL2[SL0]
        };
        if walkparams.tgx == TGx_4KB & Have52BitIPAAndPASpaceExt() then {
            walkparams.sl2 = VTCR_EL2[SL2] & VTCR_EL2[DS]
        } else {
            walkparams.sl2 = 0b0
        }
    } else {
        Unreachable()
    };
    walkparams.sw = VSTCR_EL2[SW];
    walkparams.nsw = VTCR_EL2[NSW];
    walkparams.sa = VSTCR_EL2[SA];
    walkparams.nsa = VTCR_EL2[NSA];
    walkparams.vm = HCR_EL2[VM] | HCR_EL2[DC];
    walkparams.ps = VTCR_EL2[PS];
    walkparams.irgn = VTCR_EL2[IRGN0];
    walkparams.orgn = VTCR_EL2[ORGN0];
    walkparams.sh = VTCR_EL2[SH0];
    walkparams.ee = SCTLR_EL2[EE];
    walkparams.ptw = if HCR_EL2[TGE] == 0b0 then HCR_EL2[PTW] else 0b0;
    walkparams.fwb = if HaveStage2MemAttrControl() then HCR_EL2[FWB] else 0b0;
    walkparams.ha = if HaveAccessFlagUpdateExt() then VTCR_EL2[HA] else 0b0;
    walkparams.hd = if HaveDirtyBitModifierExt() then VTCR_EL2[HD] else 0b0;
    if (walkparams.tgx == TGx_4KB | walkparams.tgx == TGx_16KB) & Have52BitIPAAndPASpaceExt() then {
        walkparams.ds = VTCR_EL2[DS]
    } else {
        walkparams.ds = 0b0
    };
    walkparams.cmow = if HaveFeatCMOW() & IsHCRXEL2Enabled() then HCRX_EL2[CMOW]
    else
      0b0;
    if walkparams.d128 == 0b1 then {
        walkparams.s2pie = 0b1
    } else {
        walkparams.s2pie = if HaveS2PIExt() then VTCR_EL2[S2PIE] else 0b0
    };
    walkparams.s2pir = if HaveS2PIExt() then Mk_S2PIRType(S2PIR_EL2.bits) else
      Mk_S2PIRType(Zeros(64));
    if HaveTHExt() & walkparams.d128 != 0b1 then {
        walkparams.assuredonly = VTCR_EL2[AssuredOnly]
    } else {
        walkparams.assuredonly = 0b0
    };
    walkparams.tl0 = if HaveTHExt() then VTCR_EL2[TL0] else 0b0;
    walkparams.tl1 = if HaveTHExt() then VTCR_EL2[TL1] else 0b0;
    if HaveAccessFlagUpdateForTableExt() & walkparams.ha == 0b1 then {
        walkparams.haft = VTCR_EL2[HAFT]
    } else {
        walkparams.haft = 0b0
    };
    walkparams.emec = 0b0;
    return(walkparams)
}

val AArch64_GetS2TTWParams : forall ('s1aarch64 : Bool).
  (SecurityState, PASpace, bool('s1aarch64)) -> S2TTWParams

function AArch64_GetS2TTWParams (ss, ipaspace, s1aarch64) = {
    walkparams : S2TTWParams = undefined;
    if ss == SS_NonSecure then {
        walkparams = AArch64_NSS2TTWParams(s1aarch64)
    } else if HaveSecureEL2Ext() & ss == SS_Secure then {
        walkparams = AArch64_SS2TTWParams(ipaspace, s1aarch64)
    } else if ss == SS_Realm then {
        walkparams = AArch64_RLS2TTWParams(s1aarch64)
    } else {
        Unreachable()
    };
    return(walkparams)
}

val AArch64_IPAIsOutOfRange : (bits(56), S2TTWParams) -> bool

function AArch64_IPAIsOutOfRange (ipa, walkparams) = {
    let 'iasize = AArch64_IASize(walkparams.txsz);
    if iasize < 56 then {
        return(not_bool(is_zero_subrange(ipa, 55, iasize)))
    } else {
        return(false)
    }
}

val AArch64_S2DirectBasePermissions : (Permissions, AccessDescriptor) -> S2AccessControls

function AArch64_S2DirectBasePermissions (permissions, accdesc) = {
    s2perms : S2AccessControls = undefined;
    let r : bits(1) = [permissions.s2ap[0]];
    let w : bits(1) = [permissions.s2ap[1]];
    px : bits(1) = undefined;
    ux : bits(1) = undefined;
    match permissions.s2xn @ permissions.s2xnx {
      0b00 => {
          (px, ux) = (0b1, 0b1)
      },
      0b01 => {
          (px, ux) = (0b0, 0b1)
      },
      0b10 => {
          (px, ux) = (0b0, 0b0)
      },
      0b11 => {
          (px, ux) = (0b1, 0b0)
      }
    };
    let x : bits(1) = if accdesc.el == EL0 then ux else px;
    s2perms.r = r;
    s2perms.w = w;
    s2perms.x = x;
    s2perms.r_rcw = r;
    s2perms.w_rcw = w;
    s2perms.r_mmu = r;
    s2perms.w_mmu = w;
    return(s2perms)
}

val AArch64_S2IndirectBasePermissions : (Permissions, AccessDescriptor) -> S2AccessControls

function AArch64_S2IndirectBasePermissions (permissions, accdesc) = {
    r : bits(1) = undefined;
    w : bits(1) = undefined;
    r_rcw : bits(1) = undefined;
    w_rcw : bits(1) = undefined;
    r_mmu : bits(1) = undefined;
    w_mmu : bits(1) = undefined;
    px : bits(1) = undefined;
    ux : bits(1) = undefined;
    toplevel0 : bits(1) = undefined;
    toplevel1 : bits(1) = undefined;
    s2perms : S2AccessControls = undefined;
    let s2pi : bits(4) = permissions.s2pi;
    match s2pi {
      0b0000 => {
          (r, w, px, ux, w_rcw, w_mmu) = (0b0, 0b0, 0b0, 0b0, 0b0, 0b0)
      },
      0b0001 => {
          (r, w, px, ux, w_rcw, w_mmu) = (0b0, 0b0, 0b0, 0b0, 0b0, 0b0)
      },
      0b0010 => {
          (r, w, px, ux, w_rcw, w_mmu) = (0b1, 0b0, 0b0, 0b0, 0b1, 0b1)
      },
      0b0011 => {
          (r, w, px, ux, w_rcw, w_mmu) = (0b1, 0b0, 0b0, 0b0, 0b1, 0b1)
      },
      0b0100 => {
          (r, w, px, ux, w_rcw, w_mmu) = (0b0, 0b1, 0b0, 0b0, 0b0, 0b0)
      },
      0b0101 => {
          (r, w, px, ux, w_rcw, w_mmu) = (0b0, 0b0, 0b0, 0b0, 0b0, 0b0)
      },
      0b0110 => {
          (r, w, px, ux, w_rcw, w_mmu) = (0b1, 0b0, 0b0, 0b0, 0b1, 0b1)
      },
      0b0111 => {
          (r, w, px, ux, w_rcw, w_mmu) = (0b1, 0b0, 0b0, 0b0, 0b1, 0b1)
      },
      0b1000 => {
          (r, w, px, ux, w_rcw, w_mmu) = (0b1, 0b0, 0b0, 0b0, 0b0, 0b0)
      },
      0b1001 => {
          (r, w, px, ux, w_rcw, w_mmu) = (0b1, 0b0, 0b0, 0b1, 0b0, 0b0)
      },
      0b1010 => {
          (r, w, px, ux, w_rcw, w_mmu) = (0b1, 0b0, 0b1, 0b0, 0b0, 0b0)
      },
      0b1011 => {
          (r, w, px, ux, w_rcw, w_mmu) = (0b1, 0b0, 0b1, 0b1, 0b0, 0b0)
      },
      0b1100 => {
          (r, w, px, ux, w_rcw, w_mmu) = (0b1, 0b1, 0b0, 0b0, 0b1, 0b1)
      },
      0b1101 => {
          (r, w, px, ux, w_rcw, w_mmu) = (0b1, 0b1, 0b0, 0b1, 0b1, 0b1)
      },
      0b1110 => {
          (r, w, px, ux, w_rcw, w_mmu) = (0b1, 0b1, 0b1, 0b0, 0b1, 0b1)
      },
      0b1111 => {
          (r, w, px, ux, w_rcw, w_mmu) = (0b1, 0b1, 0b1, 0b1, 0b1, 0b1)
      }
    };
    let x : bits(1) = if accdesc.el == EL0 then ux else px;
    (r_rcw, r_mmu) = (r, r);
    match s2pi {
      0b0110 => {
          (toplevel0, toplevel1) = (0b1, 0b0)
      },
      0b0011 => {
          (toplevel0, toplevel1) = (0b0, 0b1)
      },
      0b0111 => {
          (toplevel0, toplevel1) = (0b1, 0b1)
      },
      _ => {
          (toplevel0, toplevel1) = (0b0, 0b0)
      }
    };
    s2perms.r = r;
    s2perms.w = w;
    s2perms.x = x;
    s2perms.r_rcw = r_rcw;
    s2perms.r_mmu = r_mmu;
    s2perms.w_rcw = w_rcw;
    s2perms.w_mmu = w_mmu;
    s2perms.toplevel0 = toplevel0;
    s2perms.toplevel1 = toplevel1;
    return(s2perms)
}

bitfield S2POR_EL1_Type : bits(64) =
  {
    Perm15 : 63..60,
    Perm14 : 59..56,
    Perm13 : 55..52,
    Perm12 : 51..48,
    Perm11 : 47..44,
    Perm10 : 43..40,
    Perm9 : 39..36,
    Perm8 : 35..32,
    Perm7 : 31..28,
    Perm6 : 27..24,
    Perm5 : 23..20,
    Perm4 : 19..16,
    Perm3 : 15..12,
    Perm2 : 11..8,
    Perm1 : 7..4,
    Perm0 : 3..0
  }

register S2POR_EL1 : S2POR_EL1_Type

val AArch64_S2OverlayPermissions : (Permissions, AccessDescriptor) -> S2AccessControls

function AArch64_S2OverlayPermissions (permissions, accdesc) = {
    r : bits(1) = undefined;
    w : bits(1) = undefined;
    r_rcw : bits(1) = undefined;
    w_rcw : bits(1) = undefined;
    r_mmu : bits(1) = undefined;
    w_mmu : bits(1) = undefined;
    px : bits(1) = undefined;
    ux : bits(1) = undefined;
    toplevel0 : bits(1) = undefined;
    toplevel1 : bits(1) = undefined;
    s2overlay_perms : S2AccessControls = undefined;
    let 'index = 4 * UInt(permissions.s2po_index);
    let s2po : bits(4) = S2POR_EL1.bits[index + 3 .. index];
    match s2po {
      0b0000 => {
          (r, w, px, ux, w_rcw, w_mmu) = (0b0, 0b0, 0b0, 0b0, 0b0, 0b0)
      },
      0b0001 => {
          (r, w, px, ux, w_rcw, w_mmu) = (0b0, 0b0, 0b0, 0b0, 0b0, 0b0)
      },
      0b0010 => {
          (r, w, px, ux, w_rcw, w_mmu) = (0b1, 0b0, 0b0, 0b0, 0b1, 0b1)
      },
      0b0011 => {
          (r, w, px, ux, w_rcw, w_mmu) = (0b1, 0b0, 0b0, 0b0, 0b1, 0b1)
      },
      0b0100 => {
          (r, w, px, ux, w_rcw, w_mmu) = (0b0, 0b1, 0b0, 0b0, 0b0, 0b0)
      },
      0b0101 => {
          (r, w, px, ux, w_rcw, w_mmu) = (0b0, 0b0, 0b0, 0b0, 0b0, 0b0)
      },
      0b0110 => {
          (r, w, px, ux, w_rcw, w_mmu) = (0b1, 0b0, 0b0, 0b0, 0b1, 0b1)
      },
      0b0111 => {
          (r, w, px, ux, w_rcw, w_mmu) = (0b1, 0b0, 0b0, 0b0, 0b1, 0b1)
      },
      0b1000 => {
          (r, w, px, ux, w_rcw, w_mmu) = (0b1, 0b0, 0b0, 0b0, 0b0, 0b0)
      },
      0b1001 => {
          (r, w, px, ux, w_rcw, w_mmu) = (0b1, 0b0, 0b0, 0b1, 0b0, 0b0)
      },
      0b1010 => {
          (r, w, px, ux, w_rcw, w_mmu) = (0b1, 0b0, 0b1, 0b0, 0b0, 0b0)
      },
      0b1011 => {
          (r, w, px, ux, w_rcw, w_mmu) = (0b1, 0b0, 0b1, 0b1, 0b0, 0b0)
      },
      0b1100 => {
          (r, w, px, ux, w_rcw, w_mmu) = (0b1, 0b1, 0b0, 0b0, 0b1, 0b1)
      },
      0b1101 => {
          (r, w, px, ux, w_rcw, w_mmu) = (0b1, 0b1, 0b0, 0b1, 0b1, 0b1)
      },
      0b1110 => {
          (r, w, px, ux, w_rcw, w_mmu) = (0b1, 0b1, 0b1, 0b0, 0b1, 0b1)
      },
      0b1111 => {
          (r, w, px, ux, w_rcw, w_mmu) = (0b1, 0b1, 0b1, 0b1, 0b1, 0b1)
      }
    };
    let x : bits(1) = if accdesc.el == EL0 then ux else px;
    (r_rcw, r_mmu) = (r, r);
    match s2po {
      0b0110 => {
          (toplevel0, toplevel1) = (0b1, 0b0)
      },
      0b0011 => {
          (toplevel0, toplevel1) = (0b0, 0b1)
      },
      0b0111 => {
          (toplevel0, toplevel1) = (0b1, 0b1)
      },
      _ => {
          (toplevel0, toplevel1) = (0b0, 0b0)
      }
    };
    s2overlay_perms.or = r;
    s2overlay_perms.ow = w;
    s2overlay_perms.ox = x;
    s2overlay_perms.or_rcw = r_rcw;
    s2overlay_perms.ow_rcw = w_rcw;
    s2overlay_perms.or_mmu = r_mmu;
    s2overlay_perms.ow_mmu = w_mmu;
    s2overlay_perms.toplevel0 = toplevel0;
    s2overlay_perms.toplevel1 = toplevel1;
    return(s2overlay_perms)
}

val AArch64_S2ComputePermissions : (Permissions, S2TTWParams, AccessDescriptor) -> S2AccessControls

function AArch64_S2ComputePermissions (permissions, walkparams, accdesc) = {
    s2overlay_perms : S2AccessControls = undefined;
    s2perms : S2AccessControls = undefined;
    if walkparams.s2pie == 0b1 then {
        s2perms = AArch64_S2IndirectBasePermissions(permissions, accdesc);
        s2perms.overlay = HaveS2POExt() & VTCR_EL2[S2POE] == 0b1;
        if s2perms.overlay then {
            let s2overlay_perms : S2AccessControls = AArch64_S2OverlayPermissions(permissions, accdesc);
            s2perms.or = s2overlay_perms.or;
            s2perms.ow = s2overlay_perms.ow;
            s2perms.ox = s2overlay_perms.ox;
            s2perms.or_rcw = s2overlay_perms.or_rcw;
            s2perms.ow_rcw = s2overlay_perms.ow_rcw;
            s2perms.or_mmu = s2overlay_perms.or_mmu;
            s2perms.ow_mmu = s2overlay_perms.ow_mmu;
            if ((s2perms.w @ (s2perms.w_rcw @ s2perms.w_mmu)) & (s2perms.ow @ (s2perms.ow_rcw @ s2perms.ow_mmu))) == 0b011 then {
                s2perms.toplevel0 = s2perms.toplevel0 | s2overlay_perms.toplevel0;
                s2perms.toplevel1 = s2perms.toplevel1 | s2overlay_perms.toplevel1
            } else {
                s2perms.toplevel0 = 0b0;
                s2perms.toplevel1 = 0b0
            }
        };
        ()
    } else {
        s2perms = AArch64_S2DirectBasePermissions(permissions, accdesc)
    };
    return(s2perms)
}

val AArch64_S2CheckPermissions : (FaultRecord, TTWState, S2TTWParams, AddressDescriptor, AccessDescriptor) -> (FaultRecord, bool)

function AArch64_S2CheckPermissions (fault_in, walkstate, walkparams, ipa, accdesc) = {
    let memtype : MemType = walkstate.memattrs.memtype;
    let permissions : Permissions = walkstate.permissions;
    fault : FaultRecord = fault_in;
    let s2perms : S2AccessControls = AArch64_S2ComputePermissions(permissions, walkparams, accdesc);
    r : bits(1) = undefined;
    w : bits(1) = undefined;
    or : bits(1) = undefined;
    ow : bits(1) = undefined;
    if accdesc.acctype == AccessType_TTW then {
        r = s2perms.r_mmu;
        w = s2perms.w_mmu;
        or = s2perms.or_mmu;
        ow = s2perms.ow_mmu
    } else if accdesc.rcw then {
        r = s2perms.r_rcw;
        w = s2perms.w_rcw;
        or = s2perms.or_rcw;
        ow = s2perms.ow_rcw
    } else {
        r = s2perms.r;
        w = s2perms.w;
        or = s2perms.or;
        ow = s2perms.ow
    };
    if accdesc.acctype == AccessType_TTW then {
        if (accdesc.toplevel & accdesc.varange == VARange_LOWER) & (walkparams.tl0 == 0b1 & s2perms.toplevel0 == 0b0 | walkparams.tl1 == 0b1 & (s2perms.toplevel1 @ s2perms.toplevel0) == 0b10) then {
            fault.statuscode = Fault_Permission;
            fault.toplevel = true
        } else if (accdesc.toplevel & accdesc.varange == VARange_UPPER) & (walkparams.tl1 == 0b1 & s2perms.toplevel1 == 0b0 | walkparams.tl0 == 0b1 & (s2perms.toplevel1 @ s2perms.toplevel0) == 0b01) then {
            fault.statuscode = Fault_Permission;
            fault.toplevel = true
        } else if walkparams.ptw == 0b1 & memtype == MemType_Device then {
            fault.statuscode = Fault_Permission
        } else if s2perms.overlay & or == 0b0 then {
            fault.statuscode = Fault_Permission;
            fault.overlay = true
        } else if (accdesc.write & s2perms.overlay) & ow == 0b0 then {
            fault.statuscode = Fault_Permission;
            fault.overlay = true
        } else if accdesc.ss == SS_Realm & walkstate.baseaddress.paspace != PAS_Realm then {
            fault.statuscode = Fault_Permission
        } else if r == 0b0 then {
            fault.statuscode = Fault_Permission
        } else if accdesc.write & w == 0b0 then {
            fault.statuscode = Fault_Permission
        } else if ((accdesc.write & not_bool((walkparams.ha @ walkparams.hd) == 0b11)) & walkparams.s2pie == 0b1) & permissions.s2dirty == 0b0 then {
            fault.statuscode = Fault_Permission;
            fault.dirtybit = true
        } else ()
    } else if walkstate.s2assuredonly == 0b1 & not_bool(ipa.s1assured) | (((walkstate.s2assuredonly != 0b1 & HaveGCS()) & VTCR_EL2[GCSH] == 0b1) & accdesc.acctype == AccessType_GCS) & accdesc.el != EL0 then {
        fault.statuscode = Fault_Permission;
        fault.assuredonly = true
    } else if accdesc.acctype == AccessType_IFETCH then {
        if s2perms.overlay & s2perms.ox == 0b0 then {
            fault.statuscode = Fault_Permission;
            fault.overlay = true
        } else if memtype == MemType_Device & ConstrainUnpredictable(Unpredictable_INSTRDEVICE) == Constraint_FAULT then {
            fault.statuscode = Fault_Permission
        } else if accdesc.ss == SS_Realm & walkstate.baseaddress.paspace != PAS_Realm then {
            fault.statuscode = Fault_Permission
        } else if s2perms.x == 0b0 then {
            fault.statuscode = Fault_Permission
        } else ()
    } else if accdesc.acctype == AccessType_DC then {
        if accdesc.cacheop == CacheOp_Invalidate then {
            if (not_bool(ELUsingAArch32(EL1)) & s2perms.overlay) & ow == 0b0 then {
                fault.statuscode = Fault_Permission;
                fault.overlay = true
            };
            if not_bool(ELUsingAArch32(EL1)) & w == 0b0 then {
                fault.statuscode = Fault_Permission
            };
            ()
        } else if ((not_bool(ELUsingAArch32(EL1)) & accdesc.el == EL0) & s2perms.overlay) & or == 0b0 then {
            fault.statuscode = Fault_Permission;
            fault.overlay = true
        } else if (((walkparams.cmow == 0b1 & accdesc.opscope == CacheOpScope_PoC) & accdesc.cacheop == CacheOp_CleanInvalidate) & s2perms.overlay) & ow == 0b0 then {
            fault.statuscode = Fault_Permission;
            fault.overlay = true
        } else if (not_bool(ELUsingAArch32(EL1)) & accdesc.el == EL0) & r == 0b0 then {
            fault.statuscode = Fault_Permission
        } else if ((walkparams.cmow == 0b1 & accdesc.opscope == CacheOpScope_PoC) & accdesc.cacheop == CacheOp_CleanInvalidate) & w == 0b0 then {
            fault.statuscode = Fault_Permission
        } else ()
    } else if accdesc.acctype == AccessType_IC then {
        if (((not_bool(ELUsingAArch32(EL1)) & accdesc.el == EL0) & s2perms.overlay) & or == 0b0) & __IMPDEF_boolean("Permission fault on EL0 IC_IVAU execution") then {
            fault.statuscode = Fault_Permission;
            fault.overlay = true
        } else if (walkparams.cmow == 0b1 & s2perms.overlay) & ow == 0b0 then {
            fault.statuscode = Fault_Permission;
            fault.overlay = true
        } else if ((not_bool(ELUsingAArch32(EL1)) & accdesc.el == EL0) & r == 0b0) & __IMPDEF_boolean("Permission fault on EL0 IC_IVAU execution") then {
            fault.statuscode = Fault_Permission
        } else if walkparams.cmow == 0b1 & w == 0b0 then {
            fault.statuscode = Fault_Permission
        } else ()
    } else if (accdesc.read & s2perms.overlay) & or == 0b0 then {
        fault.statuscode = Fault_Permission;
        fault.overlay = true;
        fault.write = false
    } else if (accdesc.write & s2perms.overlay) & ow == 0b0 then {
        fault.statuscode = Fault_Permission;
        fault.overlay = true;
        fault.write = true
    } else if accdesc.read & r == 0b0 then {
        fault.statuscode = Fault_Permission;
        fault.write = false
    } else if accdesc.write & w == 0b0 then {
        fault.statuscode = Fault_Permission;
        fault.write = true
    } else if ((accdesc.tagaccess | accdesc.tagchecked) & ipa.memattrs.tags == MemTag_AllocationTagged) & permissions.s2tag_na == 0b1 then {
        fault.statuscode = Fault_Permission;
        fault.tagaccess = true;
        fault.write = accdesc.tagaccess & accdesc.write
    } else if ((accdesc.write & not_bool((walkparams.ha @ walkparams.hd) == 0b11)) & walkparams.s2pie == 0b1) & permissions.s2dirty == 0b0 then {
        fault.statuscode = Fault_Permission;
        fault.dirtybit = true;
        fault.write = true
    } else ();
    mro : bool = undefined;
    if s2perms.overlay then {
        mro = ((s2perms.w @ (s2perms.w_rcw @ s2perms.w_mmu)) & (s2perms.ow @ (s2perms.ow_rcw @ s2perms.ow_mmu))) == 0b011
    } else {
        mro = (s2perms.w @ (s2perms.w_rcw @ s2perms.w_mmu)) == 0b011
    };
    return((fault, mro))
}

val AArch64_S2HasAlignmentFault : forall ('aligned : Bool).
  (AccessDescriptor, bool('aligned), MemoryAttributes) -> bool

function AArch64_S2HasAlignmentFault (accdesc, aligned, memattrs) = {
    if accdesc.acctype == AccessType_IFETCH then {
        return(false)
    } else if (HaveMTEExt() & accdesc.tagaccess) & accdesc.write then {
        return(memattrs.memtype == MemType_Device & ConstrainUnpredictable(Unpredictable_DEVICETAGSTORE) == Constraint_FAULT)
    } else if accdesc.acctype == AccessType_DCZero then {
        return(memattrs.memtype == MemType_Device)
    } else {
        return(memattrs.memtype == MemType_Device & not_bool(aligned))
    }
}

val AArch64_S2StartLevel : S2TTWParams -> int

function AArch64_S2StartLevel walkparams = {
    descsizelog2 : int = undefined;
    granulebits : int = undefined;
    iasize : int = undefined;
    s2startlevel : int = undefined;
    stride : int = undefined;
    if walkparams.d128 == 0b1 then {
        let 'iasize = AArch64_IASize(walkparams.txsz);
        let 'granulebits = TGxGranuleBits(walkparams.tgx);
        let 'descsizelog2 = 4;
        let 'stride = granulebits - descsizelog2;
        s2startlevel : int = FINAL_LEVEL - DIV(iasize - 1 - granulebits, stride);
        let 's2startlevel = s2startlevel + UInt(walkparams.skl);
        return(s2startlevel)
    };
    match walkparams.tgx {
      TGx_4KB => {
          match walkparams.sl2 @ walkparams.sl0 {
            0b000 => {
                return(2)
            },
            0b001 => {
                return(1)
            },
            0b010 => {
                return(0)
            },
            0b011 => {
                return(3)
            },
            0b100 => {
                return(negate(1))
            },
            _ => {
                return(undefined : int)
            }
          }
      },
      TGx_16KB => {
          match walkparams.sl0 {
            0b00 => {
                return(3)
            },
            0b01 => {
                return(2)
            },
            0b10 => {
                return(1)
            },
            0b11 => {
                return(0)
            },
            _ => {
                return(undefined : int)
            }
          }
      },
      TGx_64KB => {
          match walkparams.sl0 {
            0b00 => {
                return(3)
            },
            0b01 => {
                return(2)
            },
            0b10 => {
                return(1)
            },
            _ => {
                return(undefined : int)
            }
          }
      },
      _ => {
          return(undefined : int)
      }
    }
}

val AArch64_S2InconsistentSL : S2TTWParams -> bool

function AArch64_S2InconsistentSL walkparams = {
    let 'startlevel = AArch64_S2StartLevel(walkparams);
    let 'levels = FINAL_LEVEL - startlevel;
    let 'granulebits = TGxGranuleBits(walkparams.tgx);
    let 'descsizelog2 = 3;
    let 'stride = granulebits - descsizelog2;
    let 'sl_min_iasize = levels * stride + granulebits + 1;
    let 'sl_max_iasize = sl_min_iasize + (stride - 1) + 4;
    let 'iasize = AArch64_IASize(walkparams.txsz);
    return(iasize < sl_min_iasize | iasize > sl_max_iasize)
}

val AArch64_S2InvalidSL : S2TTWParams -> bool

function AArch64_S2InvalidSL walkparams = {
    match walkparams.tgx {
      TGx_4KB => {
          match walkparams.sl2 @ walkparams.sl0 {
            [bitone, _, bitone] => {
                return(true)
            },
            [bitone, bitone, _] => {
                return(true)
            },
            0b010 => {
                return(AArch64_PAMax() < 44)
            },
            0b011 => {
                return(not_bool(HaveSmallTranslationTableExt()))
            },
            _ => {
                return(false)
            }
          }
      },
      TGx_16KB => {
          match walkparams.sl0 {
            0b11 => {
                return(walkparams.ds == 0b0)
            },
            0b10 => {
                return(AArch64_PAMax() < 42)
            },
            _ => {
                return(false)
            }
          }
      },
      TGx_64KB => {
          match walkparams.sl0 {
            0b11 => {
                return(true)
            },
            0b10 => {
                return(AArch64_PAMax() < 44)
            },
            _ => {
                return(false)
            }
          }
      },
      _ => {
          return(undefined : bool)
      }
    }
}

val AArch64_S2MinTxSZ : forall ('s1aarch64 : Bool).
  (bits(1), bits(1), TGx, bool('s1aarch64)) -> int

function AArch64_S2MinTxSZ (d128, ds, tgx, s1aarch64) = {
    ips : int = AArch64_PAMax();
    if d128 == 0b0 then {
        if (Have52BitPAExt() & tgx != TGx_64KB) & ds == 0b0 then {
            ips = Min(48, AArch64_PAMax())
        } else {
            ips = Min(52, AArch64_PAMax())
        }
    };
    let 'ips = ips;
    min_txsz : int = 64 - ips;
    if not_bool(s1aarch64) then {
        min_txsz = Min(min_txsz, 24)
    };
    let 'min_txsz = min_txsz;
    return(min_txsz)
}

bitfield VMECID_A_EL2_Type : bits(64) = {MECID : 15..0}

register VMECID_A_EL2 : VMECID_A_EL2_Type

val AArch64_S2OutputMECID : forall 'N, 'N in {64, 128}.
  (S2TTWParams, PASpace, bits('N)) -> bits(16)

function AArch64_S2OutputMECID (walkparams, paspace, descriptor) = {
    assert('N == 64 | 'N == 128);
    if walkparams.emec == 0b0 then {
        return(DEFAULT_MECID)
    };
    if paspace != PAS_Realm then {
        return(DEFAULT_MECID)
    };
    let descriptor_amec : bits(1) = if walkparams.d128 == 0b1 then {
        assert(constraint(103 < 'N));
        [descriptor[103]]
    } else [descriptor[63]];
    if descriptor_amec == 0b0 then {
        return(VMECID_P_EL2[MECID])
    } else {
        return(VMECID_A_EL2[MECID])
    }
}

val AArch64_S2TxSZFaults : forall ('s1aarch64 : Bool).
  (S2TTWParams, bool('s1aarch64)) -> bool

function AArch64_S2TxSZFaults (walkparams, s1aarch64) = {
    let 'mintxsz = AArch64_S2MinTxSZ(walkparams.d128, walkparams.ds, walkparams.tgx, s1aarch64);
    let 'maxtxsz = AArch64_MaxTxSZ(walkparams.tgx);
    if UInt(walkparams.txsz) < mintxsz then {
        return(Have52BitPAExt() | __IMPDEF_boolean("Fault on TxSZ value below minimum"))
    };
    if UInt(walkparams.txsz) > maxtxsz then {
        return(__IMPDEF_boolean("Fault on TxSZ value above maximum"))
    };
    return(false)
}

val AArch64_GetS2TLBContext : (SecurityState, FullAddress, TGx) -> TLBContext

function AArch64_GetS2TLBContext (ss, ipa, tg) = {
    assert(EL2Enabled());
    tlbcontext : TLBContext = undefined;
    tlbcontext.ss = ss;
    tlbcontext.regime = Regime_EL10;
    tlbcontext.ipaspace = ipa.paspace;
    tlbcontext.vmid = VMID_read();
    tlbcontext.tg = tg;
    tlbcontext.ia = ZeroExtend(ipa.address, 64);
    if HaveCommonNotPrivateTransExt() then {
        tlbcontext.cnp = if ipa.paspace == PAS_Secure then VSTTBR_EL2[CnP] else
          VTTBR_EL2_read()[CnP]
    } else {
        tlbcontext.cnp = 0b0
    };
    tlbcontext.includes_s1_name = false;
    tlbcontext.includes_s2_name = true;
    tlbcontext.includes_gpt_name = false;
    return(tlbcontext)
}

val AArch64_S2ApplyFWBMemAttrs : forall 'N, 11 < 'N.
  (MemoryAttributes, S2TTWParams, bits('N)) -> MemoryAttributes

function AArch64_S2ApplyFWBMemAttrs (s1_memattrs, walkparams, descriptor) = {
    s2_device : DeviceType = undefined;
    memattrs : MemoryAttributes = undefined;
    let s2_attr : bits(4) = descriptor[5 .. 2];
    let s2_sh : bits(2) = if walkparams.ds == 0b1 then walkparams.sh else {
        assert(constraint(9 < 'N));
        descriptor[9 .. 8]
    };
    let s2_fnxs : bits(1) = [descriptor[11]];
    if [s2_attr[2]] == 0b0 then {
        let s2_device : DeviceType = DecodeDevice(s2_attr[1 .. 0]);
        memattrs.memtype = MemType_Device;
        if s1_memattrs.memtype == MemType_Device then {
            memattrs.device = S2CombineS1Device(s1_memattrs.device, s2_device)
        } else {
            memattrs.device = s2_device
        };
        memattrs.xs = s1_memattrs.xs
    } else if s2_attr[1 .. 0] == 0b11 then {
        memattrs = s1_memattrs
    } else if s2_attr[1 .. 0] == 0b10 then {
        memattrs.memtype = MemType_Normal;
        memattrs.inner.attrs = MemAttr_WB;
        memattrs.outer.attrs = MemAttr_WB;
        if s1_memattrs.memtype == MemType_Normal & s1_memattrs.inner.attrs != MemAttr_NC then {
            memattrs.inner.hints = s1_memattrs.inner.hints;
            memattrs.inner.transient = s1_memattrs.inner.transient
        } else {
            memattrs.inner.hints = MemHint_RWA;
            memattrs.inner.transient = false
        };
        if s1_memattrs.memtype == MemType_Normal & s1_memattrs.outer.attrs != MemAttr_NC then {
            memattrs.outer.hints = s1_memattrs.outer.hints;
            memattrs.outer.transient = s1_memattrs.outer.transient
        } else {
            memattrs.outer.hints = MemHint_RWA;
            memattrs.outer.transient = false
        };
        memattrs.xs = 0b0
    } else {
        if s1_memattrs.memtype == MemType_Device then {
            memattrs = s1_memattrs
        } else {
            cacheability_attr : MemAttrHints = undefined;
            cacheability_attr.attrs = MemAttr_NC;
            memattrs.memtype = MemType_Normal;
            memattrs.inner = cacheability_attr;
            memattrs.outer = cacheability_attr;
            memattrs.xs = s1_memattrs.xs
        }
    };
    let s2_shareability : Shareability = DecodeShareability(s2_sh);
    memattrs.shareability = S2CombineS1Shareability(s1_memattrs.shareability, s2_shareability);
    memattrs.tags = S2MemTagType(memattrs, s1_memattrs.tags);
    memattrs.notagaccess = s2_attr[3 .. 1] == 0b111 & memattrs.tags == MemTag_AllocationTagged;
    if s2_fnxs == 0b1 then {
        memattrs.xs = 0b0
    };
    memattrs.shareability = EffectiveShareability(memattrs);
    return(memattrs)
}

val AArch64_S2TTBaseAddress : forall 'N, 'N >= 0.
  (S2TTWParams, PASpace, bits('N)) -> bits(56)

function AArch64_S2TTBaseAddress (walkparams, paspace, ttbr) = {
    tablebase : bits(56) = Zeros(56);
    let 'iasize = AArch64_IASize(walkparams.txsz);
    let 'granulebits = TGxGranuleBits(walkparams.tgx);
    let 'descsizelog2 = if walkparams.d128 == 0b1 then 4 else 3;
    let 'stride = granulebits - descsizelog2;
    let 'startlevel = AArch64_S2StartLevel(walkparams);
    let 'levels = FINAL_LEVEL - startlevel;
    tsize : int = iasize - (levels * stride + granulebits) + descsizelog2;
    if Have56BitPAExt() & walkparams.d128 == 0b1 then {
        tsize = Max(tsize, 5);
        if paspace == PAS_Secure then {
            assert(constraint(55 < 'N));
            tablebase[55 .. 5] = ttbr[55 .. 5]
        } else {
            assert(constraint(87 < 'N));
            tablebase[55 .. 5] = ttbr[87 .. 80] @ ttbr[47 .. 5]
        }
    } else if (Have52BitPAExt() & walkparams.tgx == TGx_64KB) & walkparams.ps == 0b110 | walkparams.ds == 0b1 then {
        tsize = Max(tsize, 6);
        assert(constraint(5 < 'N));
        assert(constraint(47 < 'N));
        tablebase[51 .. 6] = ttbr[5 .. 2] @ ttbr[47 .. 6]
    } else {
        assert(constraint(47 < 'N));
        tablebase[47 .. 1] = ttbr[47 .. 1]
    };
    let 'tsize = tsize;
    let tablebase : bits(56) = Align(tablebase, (1 << tsize));
    return(tablebase)
}

val AArch64_S2InitialTTWState : (SecurityState, S2TTWParams) -> TTWState

function AArch64_S2InitialTTWState (ss, walkparams) = {
    walkstate : TTWState = undefined;
    tablebase : FullAddress = undefined;
    let ttbr : bits(128) = ZeroExtend(VTTBR_EL2_read().bits, 128);
    match ss {
      SS_NonSecure => {
          tablebase.paspace = PAS_NonSecure
      },
      SS_Realm => {
          tablebase.paspace = PAS_Realm
      },
      _ => ()
    };
    tablebase.address = AArch64_S2TTBaseAddress(walkparams, tablebase.paspace, ttbr);
    walkstate.baseaddress = tablebase;
    walkstate.level = AArch64_S2StartLevel(walkparams);
    walkstate.istable = true;
    walkstate.memattrs = WalkMemAttrs(walkparams.sh, walkparams.irgn, walkparams.orgn);
    return(walkstate)
}

val AArch64_S2ApplyOutputPerms : forall 'N, 'N >= 0.
  (bits('N), S2TTWParams) -> Permissions

function AArch64_S2ApplyOutputPerms (descriptor, walkparams) = {
    bit_index : int = undefined;
    permissions : Permissions = undefined;
    s2pi_index : bits(4) = undefined;
    if walkparams.s2pie == 0b1 then {
        if walkparams.d128 == 0b1 then {
            assert(constraint(118 < 'N));
            s2pi_index = descriptor[118 .. 115]
        } else {
            assert(constraint(54 < 'N));
            s2pi_index = descriptor[54 .. 53] @ ([descriptor[51]] @ [descriptor[6]])
        };
        let 'bit_index = 4 * UInt(s2pi_index);
        permissions.s2pi = walkparams.s2pir.bits[bit_index + 3 .. bit_index];
        assert(constraint(7 < 'N));
        permissions.s2dirty = [descriptor[7]]
    } else {
        assert(constraint(7 < 'N));
        permissions.s2ap = descriptor[7 .. 6];
        if walkparams.d128 == 0b1 then {
            assert(constraint(118 < 'N));
            permissions.s2xn = [descriptor[118]]
        } else {
            assert(constraint(54 < 'N));
            permissions.s2xn = [descriptor[54]]
        };
        if HaveExtendedExecuteNeverExt() then {
            if walkparams.d128 == 0b1 then {
                assert(constraint(117 < 'N));
                permissions.s2xnx = [descriptor[117]]
            } else {
                assert(constraint(53 < 'N));
                permissions.s2xnx = [descriptor[53]]
            }
        } else {
            permissions.s2xnx = 0b0
        };
        desc_dbm : bits(1) = undefined;
        if walkparams.d128 == 0b1 then {
            assert(constraint(115 < 'N));
            desc_dbm = [descriptor[115]]
        } else {
            assert(constraint(51 < 'N));
            desc_dbm = [descriptor[51]]
        };
        if (walkparams.ha == 0b1 & walkparams.hd == 0b1) & desc_dbm == 0b1 then {
            permissions.s2ap[1] = Bit(0b1)
        };
        ()
    };
    if (walkparams.s2pie == 0b1 & HaveS2POExt()) & VTCR_EL2[S2POE] == 0b1 then {
        if walkparams.d128 == 0b1 then {
            assert(constraint(124 < 'N));
            permissions.s2po_index = descriptor[124 .. 121]
        } else {
            assert(constraint(62 < 'N));
            permissions.s2po_index = descriptor[62 .. 59]
        }
    };
    return(permissions)
}

val AArch64_SS2OutputPASpace : (S2TTWParams, PASpace) -> PASpace

function AArch64_SS2OutputPASpace (walkparams, ipaspace) = {
    if ipaspace == PAS_Secure then {
        if (walkparams.sw @ walkparams.sa) == 0b00 then {
            return(PAS_Secure)
        } else {
            return(PAS_NonSecure)
        }
    } else {
        if (walkparams.sw @ (walkparams.sa @ (walkparams.nsw @ walkparams.nsa))) == 0b0000 then {
            return(PAS_Secure)
        } else {
            return(PAS_NonSecure)
        }
    }
}

val AArch64_S2NextWalkStateLeaf : forall 'N, 52 < 'N.
  (TTWState, SecurityState, S2TTWParams, AddressDescriptor, bits('N)) -> TTWState

function AArch64_S2NextWalkStateLeaf (currentstate, ss, walkparams, ipa, descriptor) = {
    s2aarch64 : bool = undefined;
    nextstate : TTWState = undefined;
    baseaddress : FullAddress = undefined;
    if ss == SS_Secure then {
        baseaddress.paspace = AArch64_SS2OutputPASpace(walkparams, ipa.paddress.paspace)
    } else if ss == SS_Realm then {
        let ns : bits(1) = if walkparams.d128 == 0b1 then {
            assert(constraint(127 < 'N));
            [descriptor[127]]
        } else {
            assert(constraint(55 < 'N));
            [descriptor[55]]
        };
        baseaddress.paspace = if ns == 0b1 then PAS_NonSecure else PAS_Realm
    } else {
        baseaddress.paspace = PAS_NonSecure
    };
    baseaddress.address = AArch64_LeafBase(descriptor, walkparams.d128, walkparams.ds, walkparams.tgx, currentstate.level);
    nextstate.istable = false;
    nextstate.level = currentstate.level;
    nextstate.baseaddress = baseaddress;
    nextstate.permissions = AArch64_S2ApplyOutputPerms(descriptor, walkparams);
    let s2_attr : bits(4) = descriptor[5 .. 2];
    let s2_sh : bits(2) = if walkparams.ds == 0b1 then walkparams.sh else {
        assert(constraint(9 < 'N));
        descriptor[9 .. 8]
    };
    let s2_fnxs : bits(1) = [descriptor[11]];
    if walkparams.fwb == 0b1 then {
        nextstate.memattrs = AArch64_S2ApplyFWBMemAttrs(ipa.memattrs, walkparams, descriptor);
        if s2_attr[3 .. 1] == 0b111 then {
            nextstate.permissions.s2tag_na = 0b1
        } else {
            nextstate.permissions.s2tag_na = 0b0
        }
    } else {
        let s2aarch64 : bool = true;
        nextstate.memattrs = S2DecodeMemAttrs(s2_attr, s2_sh, s2aarch64);
        nextstate.memattrs.xs = not_vec(s2_fnxs);
        if s2_attr == 0b0100 then {
            nextstate.permissions.s2tag_na = 0b1
        } else {
            nextstate.permissions.s2tag_na = 0b0
        }
    };
    nextstate.contiguous = AArch64_ContiguousBit(walkparams.tgx, walkparams.d128, currentstate.level, descriptor);
    if walkparams.d128 == 0b1 then {
        assert(constraint(114 < 'N));
        nextstate.s2assuredonly = [descriptor[114]]
    } else {
        nextstate.s2assuredonly = if walkparams.assuredonly == 0b1 then {
            assert(constraint(58 < 'N));
            [descriptor[58]]
        } else 0b0
    };
    return(nextstate)
}

val AArch64_S2NextWalkStateTable : forall 'N, 'N >= 0.
  (TTWState, S2TTWParams, bits('N)) -> TTWState

function AArch64_S2NextWalkStateTable (currentstate, walkparams, descriptor) = {
    skl : bits(2) = undefined;
    nextstate : TTWState = undefined;
    tablebase : FullAddress = undefined;
    tablebase.address = AArch64_NextTableBase(descriptor, walkparams.d128, walkparams.ds, walkparams.tgx);
    tablebase.paspace = currentstate.baseaddress.paspace;
    nextstate.istable = true;
    if walkparams.d128 == 0b1 then {
        assert(constraint(110 < 'N));
        let skl : bits(2) = descriptor[110 .. 109];
        nextstate.level = currentstate.level + UInt(skl) + 1
    } else {
        nextstate.level = currentstate.level + 1
    };
    nextstate.baseaddress = tablebase;
    nextstate.memattrs = currentstate.memattrs;
    return(nextstate)
}

val AArch64_S2SLTTEntryAddress : (S2TTWParams, bits(56), FullAddress) -> FullAddress

function AArch64_S2SLTTEntryAddress (walkparams, ipa, tablebase) = {
    let 'startlevel = AArch64_S2StartLevel(walkparams);
    let 'iasize = AArch64_IASize(walkparams.txsz);
    let 'granulebits = TGxGranuleBits(walkparams.tgx);
    let 'descsizelog2 = if walkparams.d128 == 0b1 then 4 else 3;
    let 'stride = granulebits - descsizelog2;
    let 'levels = FINAL_LEVEL - startlevel;
    let 'lsb = levels * stride + granulebits;
    let 'msb = iasize - 1;
    assert(constraint((0 <= 'lsb & 'lsb <= 'msb & 'msb < 56)));
    assert(constraint(56 >= 'msb - 'lsb + 1 + 'descsizelog2));
    let index : bits(56) = ZeroExtend(ipa[msb .. lsb] @ Zeros(descsizelog2), 56);
    descaddress : FullAddress = undefined;
    descaddress.address = tablebase.address | index;
    descaddress.paspace = tablebase.paspace;
    return(descaddress)
}

val AArch64_SS2InitialTTWState : (S2TTWParams, PASpace) -> TTWState

function AArch64_SS2InitialTTWState (walkparams, ipaspace) = {
    walkstate : TTWState = undefined;
    tablebase : FullAddress = undefined;
    ttbr : bits(128) = undefined;
    if ipaspace == PAS_Secure then {
        ttbr = ZeroExtend(VSTTBR_EL2.bits, 128)
    } else {
        ttbr = ZeroExtend(VTTBR_EL2_read().bits, 128)
    };
    if ipaspace == PAS_Secure then {
        if walkparams.sw == 0b0 then {
            tablebase.paspace = PAS_Secure
        } else {
            tablebase.paspace = PAS_NonSecure
        }
    } else {
        if walkparams.nsw == 0b0 then {
            tablebase.paspace = PAS_Secure
        } else {
            tablebase.paspace = PAS_NonSecure
        }
    };
    tablebase.address = AArch64_S2TTBaseAddress(walkparams, tablebase.paspace, ttbr);
    walkstate.baseaddress = tablebase;
    walkstate.level = AArch64_S2StartLevel(walkparams);
    walkstate.istable = true;
    walkstate.memattrs = WalkMemAttrs(walkparams.sh, walkparams.irgn, walkparams.orgn);
    return(walkstate)
}

val AArch64_TTEntryAddress : forall 'level.
  (int('level), bits(1), bits(2), TGx, bits(6), bits(64), FullAddress) -> FullAddress

function AArch64_TTEntryAddress (level, d128, skl, tgx, txsz, ia, tablebase) = {
    let 'iasize = AArch64_IASize(txsz);
    let 'granulebits = TGxGranuleBits(tgx);
    let 'descsizelog2 = if d128 == 0b1 then 4 else 3;
    let 'stride = granulebits - descsizelog2;
    let 'levels = FINAL_LEVEL - level;
    msb : int = undefined;
    let 'lsb = levels * stride + granulebits;
    if d128 == 0b1 then {
        msb = lsb + stride * (1 + UInt(skl)) - 1
    } else {
        msb = lsb + stride - 1
    };
    let 'msb = msb;
    assert(constraint((0 <= 'lsb & 'lsb <= 'msb & 'msb < 64)));
    assert(constraint(56 >= 'msb - 'lsb + 1 + 'descsizelog2));
    let index : bits(56) = ZeroExtend(ia[msb .. lsb] @ Zeros(descsizelog2), 56);
    descaddress : FullAddress = undefined;
    descaddress.address = tablebase.address | index;
    descaddress.paspace = tablebase.paspace;
    return(descaddress)
}

val AArch64_TTWalkMECID : (bits(1), Regime, SecurityState) -> bits(16)

function AArch64_TTWalkMECID (emec, regime, ss) = {
    if emec == 0b0 then {
        return(DEFAULT_MECID)
    };
    if ss != SS_Realm then {
        return(DEFAULT_MECID)
    };
    match regime {
      Regime_EL2 => {
          return(MECID_P0_EL2[MECID])
      },
      Regime_EL20 => {
          if TCR_EL2[A1] == 0b0 then {
              return(MECID_P1_EL2[MECID])
          } else {
              return(MECID_P0_EL2[MECID])
          }
      },
      Regime_EL10 => {
          return(VMECID_P_EL2[MECID])
      },
      _ => {
          Unreachable();
          return(undefined : bits(16))
      }
    }
}

val S2TLBCache : TLBRecord -> unit

val S2TLBLookup : TLBContext -> TLBLine

val AArch64_S2Walk : forall 'N, 'N in {32, 64, 128}.
  (FaultRecord, AddressDescriptor, S2TTWParams, AccessDescriptor, option(int), int('N)) -> (FaultRecord, AddressDescriptor, TTWState, bits('N))

function AArch64_S2Walk (fault_in, ipa, walkparams, accdesc, s1level, N) = {
    fault : FaultRecord = fault_in;
    let ipa_64 : bits(64) = ZeroExtend(ipa.paddress.address, 64);
    tlbcontext : TLBContext = undefined;
    tlbrecord : TLBRecord = undefined;
    if __tlb_enabled then {
        tlbcontext = AArch64_GetS2TLBContext(accdesc.ss, ipa.paddress, walkparams.tgx);
        let tlbentry : TLBLine = S2TLBLookup(tlbcontext);
        tlbrecord = tlbentry.tlbrecord;
        let oa : FullAddress = StageOA(ipa_64, walkparams.d128, walkparams.tgx, tlbrecord.walkstate);
        if (tlbentry.valid_name & not_bool(AArch64_OAOutOfRange(oa.address, walkparams.d128, walkparams.ps, walkparams.tgx))) & not_bool(((((walkparams.ha @ walkparams.hd) == 0b11 & (walkparams.s2pie == 0b1 | [tlbrecord.s2descriptor[51]] == 0b1)) & [tlbrecord.s2descriptor[7]] == 0b0) & accdesc.write) & not_bool(accdesc.acctype == AccessType_AT | accdesc.acctype == AccessType_IC | accdesc.acctype == AccessType_DC)) then {
            if walkparams.fwb == 0b1 then {
                tlbrecord.walkstate.memattrs = AArch64_S2ApplyFWBMemAttrs(ipa.memattrs, walkparams, tlbrecord.s2descriptor);
                if tlbrecord.s2descriptor[5 .. 3] == 0b111 then {
                    tlbrecord.walkstate.permissions.s2tag_na = 0b1
                } else {
                    tlbrecord.walkstate.permissions.s2tag_na = 0b0
                }
            };
            fault.level = tlbrecord.walkstate.level;
            return((fault, __UNKNOWN_AddressDescriptor(), tlbrecord.walkstate, tlbrecord.s2descriptor[N - 1 .. 0]))
        };
        ()
    };
    walkstate : TTWState = undefined;
    if accdesc.ss == SS_Secure then {
        walkstate = AArch64_SS2InitialTTWState(walkparams, ipa.paddress.paspace)
    } else {
        walkstate = AArch64_S2InitialTTWState(accdesc.ss, walkparams)
    };
    let 'startlevel = walkstate.level;
    descriptor : bits('N) = undefined;
    let walkaccess : AccessDescriptor = CreateAccDescS2TTW(accdesc);
    walkaddress : AddressDescriptor = undefined;
    skl : bits(2) = 0b00;
    walkaddress.vaddress = ipa.vaddress;
    walkaddress.mecid = AArch64_TTWalkMECID(walkparams.emec, Regime_EL10, accdesc.ss);
    if HCR_EL2[CD] == 0b1 then {
        walkaddress.memattrs = NormalNCMemAttr();
        walkaddress.memattrs.xs = walkstate.memattrs.xs
    } else {
        walkaddress.memattrs = walkstate.memattrs
    };
    walkaddress.memattrs.shareability = EffectiveShareability(walkaddress.memattrs);
    walkaddress.tlbcontext = tlbcontext;
    desctype : DescriptorType = undefined;
    descaddress : FullAddress = AArch64_S2SLTTEntryAddress(walkparams, ipa.paddress.address, walkstate.baseaddress);
    if AArch64_OAOutOfRange(descaddress.address, walkparams.d128, walkparams.ps, walkparams.tgx) then {
        fault.statuscode = Fault_AddressSize;
        fault.level = 0;
        return((fault, __UNKNOWN_AddressDescriptor(), __UNKNOWN_TTWState(), __UNKNOWN_bits(N)))
    };
    repeat {
        fault.level = walkstate.level;
        walkaddress.paddress = descaddress;
        let translation_info : TranslationInfo = struct {
            regime = Regime_EL10,
            vmid = Some(VMID_read()), // TODO?
            asid = None(),
            va = walkaddress.vaddress,
            s1level = s1level,
            s2info = Some((ipa_64, walkstate.level)),
            s1params = None(),
            s2params = Some(walkparams),
            memattrs = walkaddress.memattrs
        };
        (fault, descriptor) = FetchDescriptor(walkparams.ee, walkaddress, walkaccess, fault, N, translation_info);
        if fault.statuscode != Fault_None then {
            return((fault, __UNKNOWN_AddressDescriptor(), __UNKNOWN_TTWState(), __UNKNOWN_bits(N)))
        };
        new_descriptor : bits('N) = undefined;
        repeat {
            new_descriptor = descriptor;
            desctype = AArch64_DecodeDescriptorType(descriptor, walkparams.d128, walkparams.ds, walkparams.tgx, walkstate.level);
            match desctype {
              DescriptorType_Table => {
                  walkstate = AArch64_S2NextWalkStateTable(walkstate, walkparams, descriptor);
                  skl = if walkparams.d128 == 0b1 then {
                      assert(constraint(110 < 'N));
                      descriptor[110 .. 109]
                  } else 0b00;
                  descaddress = AArch64_TTEntryAddress(walkstate.level, walkparams.d128, skl, walkparams.tgx, walkparams.txsz, ipa_64, walkstate.baseaddress);
                  if AArch64_OAOutOfRange(descaddress.address, walkparams.d128, walkparams.ps, walkparams.tgx) then {
                      fault.statuscode = Fault_AddressSize;
                      return((fault, __UNKNOWN_AddressDescriptor(), __UNKNOWN_TTWState(), __UNKNOWN_bits(N)))
                  };
                  if walkparams.haft == 0b1 then {
                      new_descriptor[10] = Bit(0b1)
                  };
                  if (walkparams.d128 == 0b1 & skl != 0b00) & AArch64_BlocknTFaults(walkparams.d128, descriptor) then {
                      fault.statuscode = Fault_Translation;
                      return((fault, __UNKNOWN_AddressDescriptor(), __UNKNOWN_TTWState(), __UNKNOWN_bits(N)))
                  };
                  ()
              },
              DescriptorType_Leaf => {
                  assert(constraint(52 < 'N));
                  walkstate = AArch64_S2NextWalkStateLeaf(walkstate, accdesc.ss, walkparams, ipa, descriptor)
              },
              DescriptorType_Invalid => {
                  fault.statuscode = Fault_Translation;
                  return((fault, __UNKNOWN_AddressDescriptor(), __UNKNOWN_TTWState(), __UNKNOWN_bits(N)))
              },
              _ => {
                  Unreachable()
              }
            };
            if new_descriptor != descriptor then {
                let descaccess : AccessDescriptor = CreateAccDescTTEUpdate(accdesc);
                assert(constraint('N in {64, 128}));
                (fault, descriptor) = AArch64_MemSwapTableDesc(fault, descriptor, new_descriptor, walkparams.ee, descaccess, walkaddress, translation_info);
                if fault.statuscode != Fault_None then {
                    return((fault, __UNKNOWN_AddressDescriptor(), __UNKNOWN_TTWState(), __UNKNOWN_bits(N)))
                };
                ()
            };
            ()
        } until new_descriptor == descriptor
    } until desctype == DescriptorType_Leaf;
    let oa : FullAddress = StageOA(ipa_64, walkparams.d128, walkparams.tgx, walkstate);
    if walkstate.contiguous == 0b1 & AArch64_ContiguousBitFaults(walkparams.d128, walkparams.txsz, walkparams.tgx, walkstate.level) then {
        fault.statuscode = Fault_Translation
    } else if (desctype == DescriptorType_Leaf & walkstate.level < FINAL_LEVEL) & AArch64_BlocknTFaults(walkparams.d128, descriptor) then {
        fault.statuscode = Fault_Translation
    } else if AArch64_OAOutOfRange(oa.address, walkparams.d128, walkparams.ps, walkparams.tgx) then {
        fault.statuscode = Fault_AddressSize
    } else if ([descriptor[10]] == 0b0 & walkparams.ha == 0b0) & not_bool((accdesc.acctype == AccessType_DC | accdesc.acctype == AccessType_IC) & not_bool(__IMPDEF_boolean("Generate access flag fault on IC/DC operations"))) then {
        fault.statuscode = Fault_AccessFlag
    } else ();
    if (__tlb_enabled & fault.statuscode == Fault_None) & [descriptor[10]] == 0b1 then {
        tlbcontext.xs = walkstate.memattrs.xs;
        tlbcontext.level = walkstate.level;
        tlbcontext.isd128 = walkparams.d128 == 0b1;
        tlbrecord.context = tlbcontext;
        tlbrecord.walkstate = walkstate;
        tlbrecord.blocksize = TranslationSize(walkparams.d128, walkparams.tgx, walkstate.level);
        if walkparams.d128 == 0b1 then {
            assert(constraint(127 < 'N));
            tlbrecord.s2descriptor = descriptor[127 .. 0]
        } else {
            assert(constraint(63 < 'N));
            tlbrecord.s2descriptor[63 .. 0] = descriptor[63 .. 0];
            tlbrecord.s2descriptor[127 .. 64] = Zeros(64)
        };
        if walkstate.contiguous == 0b1 then {
            tlbrecord.contigsize = ContiguousSize(walkparams.d128, walkparams.tgx, walkstate.level)
        } else {
            tlbrecord.contigsize = 0
        };
        S2TLBCache(tlbrecord)
    };
    return((fault, walkaddress, walkstate, descriptor))
}

val AArch64_SettingAccessFlagPermitted : FaultRecord -> bool

function AArch64_SettingAccessFlagPermitted fault = {
    if fault.statuscode == Fault_None then {
        return(true)
    } else if fault.statuscode == Fault_Alignment | fault.statuscode == Fault_Permission then {
        return(ConstrainUnpredictableBool(Unpredictable_AFUPDATE))
    } else {
        return(false)
    }
}

val AArch64_SettingDirtyStatePermitted : FaultRecord -> bool

function AArch64_SettingDirtyStatePermitted fault = {
    if fault.statuscode == Fault_None then {
        return(true)
    } else if fault.statuscode == Fault_Alignment then {
        return(ConstrainUnpredictableBool(Unpredictable_DBUPDATE))
    } else {
        return(false)
    }
}

val AArch64_S2Translate : forall ('aligned : Bool) ('s1aarch64 : Bool).
  (FaultRecord, AddressDescriptor, bool('s1aarch64), option(int), bool('aligned), AccessDescriptor) -> (FaultRecord, AddressDescriptor)

function AArch64_S2Translate (fault_in, ipa, s1aarch64, s1level, aligned, accdesc) = {
    walkparams : S2TTWParams = AArch64_GetS2TTWParams(accdesc.ss, ipa.paddress.paspace, s1aarch64);
    fault : FaultRecord = fault_in;
    s2fs1mro : bool = undefined;
    fault.statuscode = Fault_None;
    fault.secondstage = true;
    fault.s2fs1walk = accdesc.acctype == AccessType_TTW;
    fault.ipaddress = ipa.paddress;
    if walkparams.vm != 0b1 then {
        return((fault, ipa))
    };
    let 's2mintxsz = AArch64_S2MinTxSZ(walkparams.d128, walkparams.ds, walkparams.tgx, s1aarch64);
    let 's2maxtxsz = AArch64_MaxTxSZ(walkparams.tgx);
    if AArch64_S2TxSZFaults(walkparams, s1aarch64) then {
        fault.statuscode = Fault_Translation;
        fault.level = 0;
        return((fault, __UNKNOWN_AddressDescriptor()))
    } else if UInt(walkparams.txsz) < s2mintxsz then {
        walkparams.txsz = s2mintxsz[5 .. 0]
    } else if UInt(walkparams.txsz) > s2maxtxsz then {
        walkparams.txsz = s2maxtxsz[5 .. 0]
    } else ();
    if walkparams.d128 == 0b0 & (AArch64_S2InvalidSL(walkparams) | AArch64_S2InconsistentSL(walkparams)) then {
        fault.statuscode = Fault_Translation;
        fault.level = 0;
        return((fault, __UNKNOWN_AddressDescriptor()))
    };
    if AArch64_IPAIsOutOfRange(ipa.paddress.address, walkparams) then {
        fault.statuscode = Fault_Translation;
        fault.level = 0;
        return((fault, __UNKNOWN_AddressDescriptor()))
    };
    descpaddr : AddressDescriptor = undefined;
    walkstate : TTWState = undefined;
    descriptor : bits(128) = undefined;
    new_desc : bits(128) = undefined;
    mem_desc : bits(128) = undefined;
    repeat {
        if walkparams.d128 == 0b1 then {
            (fault, descpaddr, walkstate, descriptor) = AArch64_S2Walk(fault, ipa, walkparams, accdesc, s1level, 128)
        } else {
            (fault, descpaddr, walkstate, descriptor[63 .. 0]) = AArch64_S2Walk(fault, ipa, walkparams, accdesc, s1level, 64);
            descriptor[127 .. 64] = Zeros(64)
        };
        if fault.statuscode != Fault_None then {
            return((fault, __UNKNOWN_AddressDescriptor()))
        };
        if AArch64_S2HasAlignmentFault(accdesc, aligned, walkstate.memattrs) then {
            fault.statuscode = Fault_Alignment
        };
        if fault.statuscode == Fault_None then {
            (fault, s2fs1mro) = AArch64_S2CheckPermissions(fault, walkstate, walkparams, ipa, accdesc)
        };
        new_desc = descriptor;
        if walkparams.ha == 0b1 & AArch64_SettingAccessFlagPermitted(fault) then {
            new_desc[10] = Bit(0b1)
        };
        if ((((AArch64_SettingDirtyStatePermitted(fault) & walkparams.ha == 0b1) & walkparams.hd == 0b1) & (walkparams.s2pie == 0b1 | [descriptor[51]] == 0b1)) & accdesc.write) & not_bool(accdesc.acctype == AccessType_AT | accdesc.acctype == AccessType_IC | accdesc.acctype == AccessType_DC) then {
            new_desc[7] = Bit(0b1)
        };
        if new_desc != descriptor then {
            let descaccess : AccessDescriptor = CreateAccDescTTEUpdate(accdesc);
            let translation_info : TranslationInfo = struct {
                regime = Regime_EL10,
                vmid = Some(VMID_read()), // TODO?
                asid = None(),
                va = ipa.vaddress,
                s1level = s1level,
                s2info = Some((ZeroExtend(ipa.paddress.address, 64), walkstate.level)),
                s1params = None(),
                s2params = Some(walkparams),
                memattrs = walkstate.memattrs
            };
            if walkparams.d128 == 0b1 then {
                (fault, mem_desc) = AArch64_MemSwapTableDesc(fault, descriptor, new_desc, walkparams.ee, descaccess, descpaddr, translation_info)
            } else {
                (fault, mem_desc[63 .. 0]) = AArch64_MemSwapTableDesc(fault, descriptor[63 .. 0], new_desc[63 .. 0], walkparams.ee, descaccess, descpaddr, translation_info);
                mem_desc[127 .. 64] = Zeros(64)
            }
        };
        ()
    } until new_desc == descriptor | mem_desc == new_desc;
    if (__tlb_enabled & new_desc != descriptor) & [mem_desc[10]] == 0b1 then {
        tlbrecord : TLBRecord = undefined;
        if [descriptor[10]] == 0b1 then {
            let tlbentry : TLBLine = S2TLBLookup(descpaddr.tlbcontext);
            assert(tlbentry.valid_name);
            tlbrecord = tlbentry.tlbrecord
        } else {
            tlbrecord.context = descpaddr.tlbcontext;
            tlbrecord.context.xs = walkstate.memattrs.xs;
            tlbrecord.context.level = walkstate.level;
            tlbrecord.context.includes_s2_name = true;
            tlbrecord.context.isd128 = walkparams.d128 == 0b1;
            tlbrecord.walkstate = walkstate;
            tlbrecord.blocksize = TranslationSize(walkparams.d128, walkparams.tgx, walkstate.level);
            if walkstate.contiguous == 0b1 then {
                tlbrecord.contigsize = ContiguousSize(walkparams.d128, walkparams.tgx, walkstate.level)
            } else {
                tlbrecord.contigsize = 0
            }
        };
        if walkparams.d128 == 0b1 then {
            tlbrecord.s2descriptor = mem_desc
        } else {
            tlbrecord.s2descriptor[63 .. 0] = mem_desc[63 .. 0];
            tlbrecord.s2descriptor[127 .. 64] = Zeros(64)
        };
        S2TLBCache(tlbrecord)
    };
    if fault.statuscode != Fault_None then {
        return((fault, __UNKNOWN_AddressDescriptor()))
    };
    let ipa_64 : bits(64) = ZeroExtend(ipa.paddress.address, 64);
    let oa : FullAddress = StageOA(ipa_64, walkparams.d128, walkparams.tgx, walkstate);
    s2_memattrs : MemoryAttributes = undefined;
    if ((accdesc.acctype == AccessType_TTW & walkstate.memattrs.memtype == MemType_Device) & walkparams.ptw == 0b0 | accdesc.acctype == AccessType_IFETCH & (walkstate.memattrs.memtype == MemType_Device | HCR_EL2[ID] == 0b1)) | (accdesc.acctype != AccessType_IFETCH & walkstate.memattrs.memtype == MemType_Normal) & HCR_EL2[CD] == 0b1 then {
        s2_memattrs = NormalNCMemAttr();
        s2_memattrs.xs = walkstate.memattrs.xs
    } else {
        s2_memattrs = walkstate.memattrs
    };
    if accdesc.ls64 & s2_memattrs.memtype == MemType_Normal then {
        if s2_memattrs.inner.attrs != MemAttr_NC | s2_memattrs.outer.attrs != MemAttr_NC then {
            fault.statuscode = Fault_Exclusive;
            return((fault, __UNKNOWN_AddressDescriptor()))
        };
        ()
    };
    let s2aarch64 : bool = true;
    memattrs : MemoryAttributes = undefined;
    if walkparams.fwb == 0b0 then {
        memattrs = S2CombineS1MemAttrs(ipa.memattrs, s2_memattrs, s2aarch64)
    } else {
        memattrs = s2_memattrs
    };
    pa : AddressDescriptor = CreateAddressDescriptor(ipa.vaddress, oa, memattrs);
    pa.tlbcontext = descpaddr.tlbcontext;
    pa.s2fs1mro = s2fs1mro;
    pa.mecid = AArch64_S2OutputMECID(walkparams, pa.paddress.paspace, descriptor);
    return((fault, pa))
}

val S1TLBCache : TLBRecord -> unit

val S1TLBLookup : TLBContext -> TLBLine

val AArch64_S1Walk : forall 'N, 10 < 'N.
  (FaultRecord, S1TTWParams, bits(64), Regime, AccessDescriptor, int('N)) -> (FaultRecord, AddressDescriptor, TTWState, bits('N))

function AArch64_S1Walk (fault_in, walkparams, va, regime, accdesc, N) = {
    fault : FaultRecord = fault_in;
    s1aarch64 : bool = undefined;
    aligned : bool = undefined;
    tlbcontext : TLBContext = undefined;
    tlbrecord : TLBRecord = undefined;
    if __tlb_enabled then {
        tlbcontext = AArch64_GetS1TLBContext(regime, accdesc.ss, va, walkparams.tgx);
        let tlbentry : TLBLine = S1TLBLookup(tlbcontext);
        tlbrecord = tlbentry.tlbrecord;
        let oa : FullAddress = StageOA(va, walkparams.d128, walkparams.tgx, tlbrecord.walkstate);
        if (tlbentry.valid_name & not_bool(AArch64_OAOutOfRange(oa.address, walkparams.d128, walkparams.ps, walkparams.tgx))) & not_bool(((((walkparams.ha @ walkparams.hd) == 0b11 & (walkparams.pie == 0b1 | [tlbrecord.s1descriptor[51]] == 0b1)) & [tlbrecord.s1descriptor[7]] == 0b1) & accdesc.write) & not_bool(accdesc.acctype == AccessType_AT | accdesc.acctype == AccessType_IC | accdesc.acctype == AccessType_DC)) then {
            fault.level = tlbrecord.walkstate.level;
            assert(constraint((0 <= 'N - 1 & 'N - 1 < 128)));
            return((fault, __UNKNOWN_AddressDescriptor(), tlbrecord.walkstate, tlbrecord.s1descriptor[N - 1 .. 0]))
        };
        ()
    };
    if HasUnprivileged(regime) & AArch64_S1EPD(regime, va) == 0b1 then {
        fault.statuscode = Fault_Translation;
        fault.level = 0;
        return((fault, __UNKNOWN_AddressDescriptor(), __UNKNOWN_TTWState(), __UNKNOWN_bits(N)))
    };
    walkstate : TTWState = AArch64_S1InitialTTWState(walkparams, va, regime, accdesc.ss);
    let 'startlevel = walkstate.level;
    descriptor : bits('N) = undefined;
    walkaddress : AddressDescriptor = undefined;
    skl : bits(2) = 0b00;
    walkaddress.vaddress = va;
    walkaddress.mecid = AArch64_TTWalkMECID(walkparams.emec, regime, accdesc.ss);
    if not_bool(AArch64_S1DCacheEnabled(regime)) then {
        walkaddress.memattrs = NormalNCMemAttr();
        walkaddress.memattrs.xs = walkstate.memattrs.xs
    } else {
        walkaddress.memattrs = walkstate.memattrs
    };
    if ((regime == Regime_EL10 & EL2Enabled()) & HCR_EL2[VM] == 0b1) & not_bool(__IMPDEF_boolean("Apply effective shareability at stage 1")) then {
        walkaddress.memattrs.shareability = walkstate.memattrs.shareability
    } else {
        walkaddress.memattrs.shareability = EffectiveShareability(walkaddress.memattrs)
    };
    walkaddress.tlbcontext = tlbcontext;
    s2fs1mro : bool = false;
    desctype : DescriptorType = undefined;
    descaddress : FullAddress = AArch64_S1SLTTEntryAddress(walkstate.level, walkparams, va, walkstate.baseaddress);
    if AArch64_OAOutOfRange(descaddress.address, walkparams.d128, walkparams.ps, walkparams.tgx) then {
        fault.statuscode = Fault_AddressSize;
        fault.level = 0;
        return((fault, __UNKNOWN_AddressDescriptor(), __UNKNOWN_TTWState(), __UNKNOWN_bits(N)))
    };
    repeat {
        fault.level = walkstate.level;
        walkaddress.paddress = descaddress;
        let toplevel : bool = walkstate.level == startlevel;
        let varange : VARange = AArch64_GetVARange(va);
        let walkaccess : AccessDescriptor = CreateAccDescS1TTW(toplevel, varange, accdesc);
        let translation_info : TranslationInfo = struct {
            regime = regime,
            vmid = None(), // TODO: if regime == Regime_EL10 then Some(VMID_read()) else None(),
            asid = None(), // TODO
            va = walkaddress.vaddress,
            s1level = Some(walkstate.level),
            s2info = None(),
            s1params = Some(walkparams),
            s2params = None(),
            memattrs = walkaddress.memattrs
        };
        s2fault : FaultRecord = undefined;
        s2walkaddress : AddressDescriptor = undefined;
        if regime == Regime_EL10 & EL2Enabled() then {
            s1aarch64 = true;
            aligned = true;
            (s2fault, s2walkaddress) = AArch64_S2Translate(fault, walkaddress, s1aarch64, Some(walkstate.level), aligned, walkaccess);
            if s2fault.statuscode != Fault_None then {
                return((s2fault, __UNKNOWN_AddressDescriptor(), __UNKNOWN_TTWState(), __UNKNOWN_bits(N)))
            };
            s2fs1mro = s2walkaddress.s2fs1mro;
            assert(constraint('N in {32, 64, 128}));
            (fault, descriptor) = FetchDescriptor(walkparams.ee, s2walkaddress, walkaccess, fault, N, translation_info)
        } else {
            assert(constraint('N in {32, 64, 128}));
            (fault, descriptor) = FetchDescriptor(walkparams.ee, walkaddress, walkaccess, fault, N, translation_info)
        };
        if fault.statuscode != Fault_None then {
            return((fault, __UNKNOWN_AddressDescriptor(), __UNKNOWN_TTWState(), __UNKNOWN_bits(N)))
        };
        new_descriptor : bits('N) = undefined;
        repeat {
            new_descriptor = descriptor;
            desctype = AArch64_DecodeDescriptorType(descriptor, walkparams.d128, walkparams.ds, walkparams.tgx, walkstate.level);
            match desctype {
              DescriptorType_Table => {
                  walkstate = AArch64_S1NextWalkStateTable(walkstate, s2fs1mro, regime, walkparams, descriptor);
                  skl = if walkparams.d128 == 0b1 then {
                      assert(constraint(110 < 'N));
                      descriptor[110 .. 109]
                  } else 0b00;
                  descaddress = AArch64_TTEntryAddress(walkstate.level, walkparams.d128, skl, walkparams.tgx, walkparams.txsz, va, walkstate.baseaddress);
                  if AArch64_OAOutOfRange(descaddress.address, walkparams.d128, walkparams.ps, walkparams.tgx) then {
                      fault.statuscode = Fault_AddressSize;
                      return((fault, __UNKNOWN_AddressDescriptor(), __UNKNOWN_TTWState(), __UNKNOWN_bits(N)))
                  };
                  if walkparams.haft == 0b1 then {
                      assert(constraint(10 < 'N));
                      new_descriptor[10] = Bit(0b1)
                  };
                  if (walkparams.d128 == 0b1 & skl != 0b00) & AArch64_BlocknTFaults(walkparams.d128, descriptor) then {
                      fault.statuscode = Fault_Translation;
                      return((fault, __UNKNOWN_AddressDescriptor(), __UNKNOWN_TTWState(), __UNKNOWN_bits(N)))
                  };
                  ()
              },
              DescriptorType_Leaf => {
                  walkstate = AArch64_S1NextWalkStateLeaf(walkstate, s2fs1mro, regime, accdesc.ss, walkparams, descriptor)
              },
              DescriptorType_Invalid => {
                  fault.statuscode = Fault_Translation;
                  return((fault, __UNKNOWN_AddressDescriptor(), __UNKNOWN_TTWState(), __UNKNOWN_bits(N)))
              },
              _ => {
                  Unreachable()
              }
            };
            if new_descriptor != descriptor then {
                descpaddr : AddressDescriptor = undefined;
                let descaccess : AccessDescriptor = CreateAccDescTTEUpdate(accdesc);
                if regime == Regime_EL10 & EL2Enabled() then {
                    s1aarch64 = true;
                    aligned = true;
                    (s2fault, descpaddr) = AArch64_S2Translate(fault, walkaddress, s1aarch64, Some(walkstate.level), aligned, descaccess);
                    if s2fault.statuscode != Fault_None then {
                        return((s2fault, __UNKNOWN_AddressDescriptor(), __UNKNOWN_TTWState(), __UNKNOWN_bits(N)))
                    };
                    ()
                } else {
                    descpaddr = walkaddress
                };
                assert(constraint('N in {64, 128}));
                (fault, descriptor) = AArch64_MemSwapTableDesc(fault, descriptor, new_descriptor, walkparams.ee, descaccess, descpaddr, translation_info);
                if fault.statuscode != Fault_None then {
                    return((fault, __UNKNOWN_AddressDescriptor(), __UNKNOWN_TTWState(), __UNKNOWN_bits(N)))
                };
                ()
            };
            ()
        } until new_descriptor == descriptor
    } until desctype == DescriptorType_Leaf;
    let oa : FullAddress = StageOA(va, walkparams.d128, walkparams.tgx, walkstate);
    if walkstate.contiguous == 0b1 & AArch64_ContiguousBitFaults(walkparams.d128, walkparams.txsz, walkparams.tgx, walkstate.level) then {
        fault.statuscode = Fault_Translation
    } else if (desctype == DescriptorType_Leaf & walkstate.level < FINAL_LEVEL) & AArch64_BlocknTFaults(walkparams.d128, descriptor) then {
        fault.statuscode = Fault_Translation
    } else {
        assert(constraint('N in {64, 128}));
        if AArch64_S1AMECFault(walkparams, walkstate.baseaddress.paspace, regime, descriptor) then {
            fault.statuscode = Fault_Translation
        } else if AArch64_OAOutOfRange(oa.address, walkparams.d128, walkparams.ps, walkparams.tgx) then {
            fault.statuscode = Fault_AddressSize
        } else if ([descriptor[10]] == 0b0 & walkparams.ha == 0b0) & not_bool((accdesc.acctype == AccessType_DC | accdesc.acctype == AccessType_IC) & not_bool(__IMPDEF_boolean("Generate access flag fault on IC/DC operations"))) then {
            fault.statuscode = Fault_AccessFlag
        } else ()
    };
    if fault.statuscode != Fault_None then {
        return((fault, __UNKNOWN_AddressDescriptor(), __UNKNOWN_TTWState(), __UNKNOWN_bits(N)))
    };
    if (__tlb_enabled & fault.statuscode == Fault_None) & [descriptor[10]] == 0b1 then {
        tlbcontext.xs = walkstate.memattrs.xs;
        tlbcontext.level = walkstate.level;
        tlbcontext.nG = walkstate.nG;
        tlbcontext.isd128 = walkparams.d128 == 0b1;
        tlbrecord.context = tlbcontext;
        tlbrecord.walkstate = walkstate;
        tlbrecord.blocksize = TranslationSize(walkparams.d128, walkparams.tgx, walkstate.level);
        if walkparams.d128 == 0b1 then {
            assert(constraint(127 < 'N));
            tlbrecord.s1descriptor = descriptor[127 .. 0]
        } else {
            assert(constraint(63 < 'N));
            tlbrecord.s1descriptor[63 .. 0] = descriptor[63 .. 0];
            tlbrecord.s1descriptor[127 .. 64] = Zeros(64)
        };
        if walkstate.contiguous == 0b1 then {
            tlbrecord.contigsize = ContiguousSize(walkparams.d128, walkparams.tgx, walkstate.level)
        } else {
            tlbrecord.contigsize = 0
        };
        S1TLBCache(tlbrecord)
    };
    return((fault, walkaddress, walkstate, descriptor))
}

val AArch64_VAIsOutOfRange : (bits(64), AccessType, Regime, S1TTWParams) -> bool

function AArch64_VAIsOutOfRange (va_in, acctype, regime, walkparams) = {
    va : bits(64) = va_in;
    let 'addrtop = AArch64_AddrTop(walkparams.tbid, acctype, walkparams.tbi);
    if walkparams.mtx == 0b1 then {
        va[59 .. 56] = if AArch64_GetVARange(va) == VARange_UPPER then 0b1111
        else
          0b0000
    };
    let 'iasize = AArch64_IASize(walkparams.txsz);
    if addrtop < iasize then {
        return(false)
    };
    if HasUnprivileged(regime) then {
        if AArch64_GetVARange(va) == VARange_LOWER then {
            return(not_bool(is_zero_subrange(va, addrtop, iasize)))
        } else {
            return(not_bool(is_ones_subrange(va, addrtop, iasize)))
        }
    } else {
        return(not_bool(is_zero_subrange(va, addrtop, iasize)))
    }
}

val AArch64_S1Translate : forall ('aligned : Bool).
  (FaultRecord, Regime, bits(64), bool('aligned), AccessDescriptor) -> (FaultRecord, AddressDescriptor)

function AArch64_S1Translate (fault_in, regime, va, aligned, accdesc) = {
    descaccess : AccessDescriptor = undefined;
    s1aarch64 : bool = undefined;
    s2aligned : bool = undefined;
    tlbentry : TLBLine = undefined;
    fault : FaultRecord = fault_in;
    fault.secondstage = false;
    fault.s2fs1walk = false;
    if not_bool(AArch64_S1Enabled(regime, accdesc.acctype)) then {
        return(AArch64_S1DisabledOutput(fault, regime, va, accdesc, aligned))
    };
    walkparams : S1TTWParams = AArch64_GetS1TTWParams(regime, accdesc.ss, va);
    let 's1mintxsz = AArch64_S1MinTxSZ(regime, walkparams.d128, walkparams.ds, walkparams.tgx);
    let 's1maxtxsz = AArch64_MaxTxSZ(walkparams.tgx);
    if AArch64_S1TxSZFaults(regime, walkparams) then {
        fault.statuscode = Fault_Translation;
        fault.level = 0;
        return((fault, __UNKNOWN_AddressDescriptor()))
    } else if UInt(walkparams.txsz) < s1mintxsz then {
        walkparams.txsz = s1mintxsz[5 .. 0]
    } else if UInt(walkparams.txsz) > s1maxtxsz then {
        walkparams.txsz = s1maxtxsz[5 .. 0]
    } else ();
    if AArch64_VAIsOutOfRange(va, accdesc.acctype, regime, walkparams) then {
        fault.statuscode = Fault_Translation;
        fault.level = 0;
        return((fault, __UNKNOWN_AddressDescriptor()))
    };
    if accdesc.el == EL0 & walkparams.e0pd == 0b1 then {
        fault.statuscode = Fault_Translation;
        fault.level = 0;
        return((fault, __UNKNOWN_AddressDescriptor()))
    };
    if ((HaveTME() & accdesc.el == EL0) & walkparams.nfd == 0b1) & accdesc.transactional then {
        fault.statuscode = Fault_Translation;
        fault.level = 0;
        return((fault, __UNKNOWN_AddressDescriptor()))
    };
    if ((HaveSVE() & accdesc.el == EL0) & walkparams.nfd == 0b1) & (accdesc.nonfault & accdesc.contiguous | (accdesc.firstfault & not_bool(accdesc.first)) & not_bool(accdesc.contiguous)) then {
        fault.statuscode = Fault_Translation;
        fault.level = 0;
        return((fault, __UNKNOWN_AddressDescriptor()))
    };
    descipaddr : AddressDescriptor = undefined;
    walkstate : TTWState = undefined;
    descriptor : bits(128) = undefined;
    new_desc : bits(128) = undefined;
    mem_desc : bits(128) = undefined;
    repeat {
        if walkparams.d128 == 0b1 then {
            (fault, descipaddr, walkstate, descriptor) = AArch64_S1Walk(fault, walkparams, va, regime, accdesc, 128)
        } else {
            (fault, descipaddr, walkstate, descriptor[63 .. 0]) = AArch64_S1Walk(fault, walkparams, va, regime, accdesc, 64);
            descriptor[127 .. 64] = Zeros(64)
        };
        if fault.statuscode != Fault_None then {
            return((fault, __UNKNOWN_AddressDescriptor()))
        };
        if accdesc.acctype == AccessType_IFETCH then {
            SetInGuardedPage(walkstate.guardedpage == 0b1)
        };
        if AArch64_S1HasAlignmentFault(accdesc, aligned, walkparams.ntlsmd, walkstate.memattrs) then {
            fault.statuscode = Fault_Alignment
        };
        if fault.statuscode == Fault_None then {
            fault = AArch64_S1CheckPermissions(fault, regime, walkstate, walkparams, accdesc)
        };
        new_desc = descriptor;
        if walkparams.ha == 0b1 & AArch64_SettingAccessFlagPermitted(fault) then {
            new_desc[10] = Bit(0b1)
        };
        if ((((AArch64_SettingDirtyStatePermitted(fault) & walkparams.ha == 0b1) & walkparams.hd == 0b1) & (walkparams.pie == 0b1 | [descriptor[51]] == 0b1)) & accdesc.write) & not_bool(accdesc.acctype == AccessType_AT | accdesc.acctype == AccessType_IC | accdesc.acctype == AccessType_DC) then {
            new_desc[7] = Bit(0b0)
        };
        if new_desc != descriptor then {
            descpaddr : AddressDescriptor = undefined;
            descaccess = CreateAccDescTTEUpdate(accdesc);
            if regime == Regime_EL10 & EL2Enabled() then {
                s2fault : FaultRecord = undefined;
                s1aarch64 = true;
                s2aligned = true;
                (s2fault, descpaddr) = AArch64_S2Translate(fault, descipaddr, s1aarch64, None(), s2aligned, descaccess);
                if s2fault.statuscode != Fault_None then {
                    return((s2fault, __UNKNOWN_AddressDescriptor()))
                };
                ()
            } else {
                descpaddr = descipaddr
            };
            let translation_info : TranslationInfo = struct {
                regime = regime,
                vmid = None(), // TODO: if regime == Regime_EL10 then Some(VMID_read()) else None(),
                asid = None(), // TODO
                va = va,
                s1level = Some(walkstate.level),
                s2info = None(),
                s1params = Some(walkparams),
                s2params = None(),
                memattrs = walkstate.memattrs
            };
            if walkparams.d128 == 0b1 then {
                (fault, mem_desc) = AArch64_MemSwapTableDesc(fault, descriptor, new_desc, walkparams.ee, descaccess, descpaddr, translation_info)
            } else {
                (fault, mem_desc[63 .. 0]) = AArch64_MemSwapTableDesc(fault, descriptor[63 .. 0], new_desc[63 .. 0], walkparams.ee, descaccess, descpaddr, translation_info);
                mem_desc[127 .. 64] = Zeros(64)
            }
        };
        ()
    } until new_desc == descriptor | mem_desc == new_desc;
    if (__tlb_enabled & new_desc != descriptor) & [mem_desc[10]] == 0b1 then {
        tlbrecord : TLBRecord = undefined;
        if [descriptor[10]] == 0b1 then {
            let tlbentry : TLBLine = S1TLBLookup(descipaddr.tlbcontext);
            assert(tlbentry.valid_name);
            tlbrecord = tlbentry.tlbrecord
        } else {
            tlbrecord.context = descipaddr.tlbcontext;
            tlbrecord.context.xs = walkstate.memattrs.xs;
            tlbrecord.context.level = walkstate.level;
            tlbrecord.context.nG = walkstate.nG;
            tlbrecord.context.isd128 = walkparams.d128 == 0b1;
            tlbrecord.walkstate = walkstate;
            tlbrecord.blocksize = TranslationSize(walkparams.d128, walkparams.tgx, walkstate.level);
            if walkstate.contiguous == 0b1 then {
                tlbrecord.contigsize = ContiguousSize(walkparams.d128, walkparams.tgx, walkstate.level)
            } else {
                tlbrecord.contigsize = 0
            }
        };
        if walkparams.d128 == 0b1 then {
            tlbrecord.s1descriptor = mem_desc
        } else {
            tlbrecord.s1descriptor[63 .. 0] = mem_desc[63 .. 0];
            tlbrecord.s1descriptor[127 .. 64] = Zeros(64)
        };
        S1TLBCache(tlbrecord)
    };
    if fault.statuscode != Fault_None then {
        return((fault, __UNKNOWN_AddressDescriptor()))
    };
    let oa : FullAddress = StageOA(va, walkparams.d128, walkparams.tgx, walkstate);
    memattrs : MemoryAttributes = undefined;
    if accdesc.acctype == AccessType_IFETCH & (walkstate.memattrs.memtype == MemType_Device | not_bool(AArch64_S1ICacheEnabled(regime))) then {
        memattrs = NormalNCMemAttr();
        memattrs.xs = walkstate.memattrs.xs
    } else if (accdesc.acctype != AccessType_IFETCH & not_bool(AArch64_S1DCacheEnabled(regime))) & walkstate.memattrs.memtype == MemType_Normal then {
        memattrs = NormalNCMemAttr();
        memattrs.xs = walkstate.memattrs.xs;
        if (HaveMTE2Ext() & walkstate.memattrs.tags == MemTag_AllocationTagged) & not_bool(ConstrainUnpredictableBool(Unpredictable_S1CTAGGED)) then {
            memattrs.tags = MemTag_Untagged
        };
        ()
    } else {
        memattrs = walkstate.memattrs
    };
    if ((regime == Regime_EL10 & EL2Enabled()) & HCR_EL2[VM] == 0b1) & not_bool(__IMPDEF_boolean("Apply effective shareability at stage 1")) then {
        memattrs.shareability = walkstate.memattrs.shareability
    } else {
        memattrs.shareability = EffectiveShareability(memattrs)
    };
    if accdesc.ls64 & memattrs.memtype == MemType_Normal then {
        if memattrs.inner.attrs != MemAttr_NC | memattrs.outer.attrs != MemAttr_NC then {
            fault.statuscode = Fault_Exclusive;
            return((fault, __UNKNOWN_AddressDescriptor()))
        };
        ()
    };
    ipa : AddressDescriptor = CreateAddressDescriptor(va, oa, memattrs);
    ipa.tlbcontext = descipaddr.tlbcontext;
    ipa.s1assured = walkstate.s1assured;
    let varange : VARange = AArch64_GetVARange(va);
    ipa.mecid = AArch64_S1OutputMECID(walkparams, regime, varange, ipa.paddress.paspace, descriptor);
    return((fault, ipa))
}

val AArch64_FullTranslate : forall ('aligned : Bool).
  (bits(64), AccessDescriptor, bool('aligned)) -> AddressDescriptor

function AArch64_FullTranslate (va, accdesc, aligned) = {
    s1aarch64 : bool = undefined;
    let regime : Regime = TranslationRegime(accdesc.el);
    fault : FaultRecord = NoFault__1(accdesc);
    ipa : AddressDescriptor = undefined;
    (fault, ipa) = AArch64_S1Translate(fault, regime, va, aligned, accdesc);
    if fault.statuscode != Fault_None then {
        return(CreateFaultyAddressDescriptor(va, fault))
    };
    assert(((accdesc.ss == SS_Realm) --> EL2Enabled()));
    if regime == Regime_EL10 & EL2Enabled() then {
        let s1aarch64 : bool = true;
        pa : AddressDescriptor = undefined;
        (fault, pa) = AArch64_S2Translate(fault, ipa, s1aarch64, None(), aligned, accdesc);
        if fault.statuscode != Fault_None then {
            return(CreateFaultyAddressDescriptor(va, fault))
        } else {
            return(pa)
        }
    } else {
        return(ipa)
    }
}

register SPESampleCounterPending : vector(32, bool)

val SPEStartCounter : forall 'counter_index,
  (0 <= 'counter_index | not('counter_index < 32)).
  int('counter_index) -> unit

function SPEStartCounter counter_index = {
    assert(counter_index < SPEMaxCounters);
    SPESampleCounterPending[counter_index] = true
}

register SPESampleCounterValid : vector(32, bool)

val SPEStopCounter : forall 'counter_index,
  (0 <= 'counter_index & 'counter_index < 32).
  int('counter_index) -> unit

function SPEStopCounter counter_index = {
    SPESampleCounterValid[counter_index] = true;
    SPESampleCounterPending[counter_index] = false
}

val AArch64_TranslateAddress : forall ('aligned : Bool) 'size.
  (bits(64), AccessDescriptor, bool('aligned), int('size)) -> AddressDescriptor

function AArch64_TranslateAddress (va, accdesc, aligned, size) = {
    if SPESampleInFlight & not_bool(accdesc.acctype == AccessType_IFETCH | accdesc.acctype == AccessType_SPE) then {
        SPEStartCounter(SPECounterPosTranslationLatency)
    };
    result : AddressDescriptor = AArch64_FullTranslate(va, accdesc, aligned);
    if not_bool(IsFault(result)) & accdesc.acctype != AccessType_IFETCH then {
        result.fault = AArch64_CheckDebug(va, accdesc, size)
    };
    if (HaveRME() & not_bool(IsFault(result))) & (accdesc.acctype != AccessType_DC | __IMPDEF_boolean("GPC Fault on DC operations")) then {
        result.fault.gpcf = GranuleProtectionCheck(result, accdesc);
        if result.fault.gpcf.gpf != GPCF_None then {
            result.fault.statuscode = Fault_GPCFOnOutput;
            result.fault.paddress = result.paddress
        };
        ()
    };
    if not_bool(IsFault(result)) & accdesc.acctype == AccessType_IFETCH then {
        result.fault = AArch64_CheckDebug(va, accdesc, size)
    };
    if SPESampleInFlight & not_bool(accdesc.acctype == AccessType_IFETCH | accdesc.acctype == AccessType_SPE) then {
        SPEStopCounter(SPECounterPosTranslationLatency)
    };
    result.vaddress = ZeroExtend(va, 64);
    return(result)
}

val MemHasTransactionalAccess : MemoryAttributes -> bool

function MemHasTransactionalAccess memattrs = {
    if (((((((memattrs.shareability == Shareability_ISH | memattrs.shareability == Shareability_OSH) & memattrs.memtype == MemType_Normal) & memattrs.inner.attrs == MemAttr_WB) & memattrs.inner.hints == MemHint_RWA) & memattrs.inner.transient == false) & memattrs.outer.hints == MemHint_RWA) & memattrs.outer.attrs == MemAttr_WB) & memattrs.outer.transient == false then {
        return(true)
    } else {
        return(__IMPDEF_boolean("Memory Region does not support Transactional access"))
    }
}

val CollectPhysicalAddress : unit -> bool

function CollectPhysicalAddress () = {
    owning_el : bits(2) = undefined;
    owning_ss : SecurityState = undefined;
    if not_bool(StatisticalProfilingEnabled()) then {
        return(false)
    };
    (owning_ss, owning_el) = ProfilingBufferOwner();
    if HaveEL(EL2) & (owning_ss != SS_Secure | IsSecureEL2Enabled()) then {
        return(PMSCR_EL2[PA] == 0b1 & (owning_el == EL2 | PMSCR_EL1[PA] == 0b1))
    } else {
        return(PMSCR_EL1[PA] == 0b1)
    }
}

val SPESetDataPhysicalAddress : (AddressDescriptor, AccessDescriptor) -> unit

function SPESetDataPhysicalAddress (addrdesc, accdesc) = {
    ns : bits(1) = undefined;
    nse : bits(1) = undefined;
    match addrdesc.paddress.paspace {
      PAS_Secure => {
          ns = 0b0;
          nse = 0b0
      },
      PAS_NonSecure => {
          ns = 0b1;
          nse = 0b0
      },
      PAS_Realm => {
          ns = 0b1;
          nse = 0b1
      },
      _ => {
          Unreachable()
      }
    };
    if HaveMTE2Ext() then {
        pat : bits(4) = undefined;
        if accdesc.tagchecked then {
            SPESampleAddress[SPEAddrPosDataPhysical][62] = Bit(0b1);
            pat = AArch64_PhysicalTag(addrdesc.vaddress)
        } else {
            let zero_unchecked : bool = __IMPDEF_boolean("SPE PAT for tag unchecked access zero");
            if not_bool(zero_unchecked) then {
                pat = AArch64_PhysicalTag(addrdesc.vaddress)
            } else {
                pat = Zeros(4)
            }
        };
        SPESampleAddress[SPEAddrPosDataPhysical][59 .. 56] = pat
    };
    let paddr : bits(56) = addrdesc.paddress.address;
    SPESampleAddress[SPEAddrPosDataPhysical][56 - 1 .. 0] = paddr;
    SPESampleAddress[SPEAddrPosDataPhysical][63] = Bit(ns);
    SPESampleAddress[SPEAddrPosDataPhysical][60] = Bit(nse);
    SPESampleAddressValid[SPEAddrPosDataPhysical] = true
}

val SPESetDataVirtualAddress : bits(64) -> unit

function SPESetDataVirtualAddress vaddress = {
    let tbi : bits(1) = EffectiveTBI(vaddress, false, PSTATE.EL);
    let non_tbi_is_zeros : bool = __IMPDEF_boolean("SPE non-tbi tag is zero");
    if tbi == 0b1 | not_bool(non_tbi_is_zeros) then {
        SPESampleAddress[SPEAddrPosDataVirtual][63 .. 0] = vaddress[63 .. 0]
    } else {
        SPESampleAddress[SPEAddrPosDataVirtual][63 .. 56] = Zeros(8);
        SPESampleAddress[SPEAddrPosDataVirtual][55 .. 0] = vaddress[55 .. 0]
    };
    SPESampleAddressValid[SPEAddrPosDataVirtual] = true
}

val SPESampleLoadStore : forall ('is_load : Bool).
  (bool('is_load), AccessDescriptor, AddressDescriptor) -> unit

function SPESampleLoadStore (is_load, accdesc, addrdesc) = {
    if accdesc.acctype == AccessType_SPE | accdesc.acctype == AccessType_IFETCH | accdesc.acctype == AccessType_DC | accdesc.acctype == AccessType_TTW | accdesc.acctype == AccessType_AT then {
        return()
    };
    let sample_loads : bool = [SPESampleSubclass[0]] == 0b0 & SPESampleSubclassValid;
    let sample_stores : bool = [SPESampleSubclass[0]] == 0b1 & SPESampleSubclassValid;
    if (not_bool(SPESampleSubclassValid) | sample_loads & is_load) | sample_stores & not_bool(is_load) then {
        SPESetDataVirtualAddress(addrdesc.vaddress);
        if CollectPhysicalAddress() then {
            SPESetDataPhysicalAddress(addrdesc, accdesc)
        };
        ()
    };
    if not_bool(SPESampleSubclassValid) then {
        SPESampleClass = 0b01;
        SPESampleSubclassValid = true;
        SPESampleSubclass[7 .. 1] = 0b0001000;
        SPESampleSubclass[0] = Bit(if is_load then 0b0 else 0b1);
        SPESampleOpType = if is_load then OpType_Load else OpType_Store;
        if accdesc.acctype == AccessType_NV2 then {
            SPESampleSubclass[7 .. 1] = 0b0011000;
            SPESampleInstIsNV2 = true
        };
        ()
    };
    ()
}

val AArch64_MemSingle_read : forall ('aligned : Bool) 'size,
  'size in {1, 2, 4, 8, 16}.
  (bits(64), int('size), AccessDescriptor, bool('aligned)) -> bits('size * 8)

val AArch64_MemSingle_read__1 : forall ('aligned : Bool) ('ispair : Bool) 'size,
  'size in {1, 2, 4, 8, 16}.
  (bits(64), int('size), AccessDescriptor, bool('aligned), bool('ispair)) -> bits('size * 8)

function AArch64_MemSingle_read (address, size, accdesc, aligned) = {
    let ispair : bool = false;
    return(AArch64_MemSingle_read__1(address, size, accdesc, aligned, ispair))
}

function AArch64_MemSingle_read__1 (address, size, accdesc_in, aligned, ispair) = {
    assert(size == 1 | size == 2 | size == 4 | size == 8 | size == 16);
    value_name : bits('size * 8) = undefined;
    accdesc : AccessDescriptor = accdesc_in;
    if HaveLSE2Ext() then {
        assert(AllInAlignedQuantity(address, size, 16))
    } else {
        assert(IsAligned__1(address, size))
    };
    if HaveMTE2Ext() & accdesc.tagchecked then {
        accdesc.tagchecked = AArch64_AccessIsTagChecked(address, accdesc)
    };
    memaddrdesc : AddressDescriptor = AArch64_TranslateAddress(address, accdesc, aligned, size);
    if IsFault(memaddrdesc) then {
        AArch64_Abort(address, memaddrdesc.fault)
    };
    if HaveTME() then {
        if accdesc.transactional & not_bool(MemHasTransactionalAccess(memaddrdesc.memattrs)) then {
            FailTransaction(TMFailure_IMP, false)
        };
        ()
    };
    if HaveMTE2Ext() & accdesc.tagchecked then {
        let ptag : bits(4) = AArch64_PhysicalTag(address);
        if not_bool(AArch64_CheckTag(memaddrdesc, accdesc, ptag)) then {
            AArch64_TagCheckFault(address, accdesc)
        };
        ()
    };
    if SPESampleInFlight then {
        let is_load : bool = true;
        SPESampleLoadStore(is_load, accdesc, memaddrdesc)
    };
    atomic : bool = undefined;
    if (memaddrdesc.memattrs.memtype == MemType_Normal & memaddrdesc.memattrs.inner.attrs == MemAttr_WB) & memaddrdesc.memattrs.outer.attrs == MemAttr_WB then {
        atomic = true
    } else if (((accdesc.exclusive | accdesc.atomicop) | accdesc.acqsc) | accdesc.acqpc) | accdesc.relsc then {
        if not_bool(aligned) & not_bool(ConstrainUnpredictableBool(Unpredictable_MISALIGNEDATOMIC)) then {
            AArch64_Abort(address, AlignmentFault(accdesc))
        } else {
            atomic = true
        }
    } else if aligned then {
        atomic = not_bool(ispair)
    } else {
        atomic = __IMPDEF_boolean("FEAT_LSE2: access is atomic")
    };
    memstatus : PhysMemRetStatus = undefined;
    if atomic then {
        (memstatus, value_name) = PhysMemRead(memaddrdesc, size, accdesc, None()); // TODO: TranslationInfo
        if IsFault__2(memstatus) then {
            HandleExternalReadAbort(memstatus, memaddrdesc, size, accdesc)
        };
        ()
    } else if aligned & ispair then {
        assert(size == 8 | size == 16);
        let 'halfsize = DIV(size, 2);
        highhalf : bits('halfsize * 8) = undefined;
        lowhalf : bits('halfsize * 8) = undefined;
        (memstatus, lowhalf) = PhysMemRead(memaddrdesc, halfsize, accdesc, None());
        if IsFault__2(memstatus) then {
            HandleExternalReadAbort(memstatus, memaddrdesc, halfsize, accdesc)
        };
        memaddrdesc.paddress.address = memaddrdesc.paddress.address + halfsize;
        (memstatus, highhalf) = PhysMemRead(memaddrdesc, halfsize, accdesc, None());
        if IsFault__2(memstatus) then {
            HandleExternalReadAbort(memstatus, memaddrdesc, halfsize, accdesc)
        };
        value_name = highhalf @ lowhalf
    } else {
        foreach (i from 0 to (size - 1) by 1 in inc) {
            (memstatus, value_name[8 * i + 7 .. 8 * i]) = PhysMemRead(memaddrdesc, 1, accdesc, None());
            if IsFault__2(memstatus) then {
                HandleExternalReadAbort(memstatus, memaddrdesc, 1, accdesc)
            };
            memaddrdesc.paddress.address = memaddrdesc.paddress.address + 1
        }
    };
    return(value_name)
}

val AArch64_MemSingle_set : forall ('aligned : Bool) 'size,
  'size in {1, 2, 4, 8, 16}.
  (bits(64), int('size), AccessDescriptor, bool('aligned), bits('size * 8)) -> unit

val AArch64_MemSingle_set__1 : forall ('aligned : Bool) ('ispair : Bool) 'size,
  'size in {1, 2, 4, 8, 16}.
  (bits(64), int('size), AccessDescriptor, bool('aligned), bool('ispair), bits('size * 8)) -> unit

function AArch64_MemSingle_set (address, size, accdesc, aligned, value_name) = {
    let ispair : bool = false;
    AArch64_MemSingle_set__1(address, size, accdesc, aligned, ispair) = value_name;
    return()
}

function AArch64_MemSingle_set__1 (address, size, accdesc_in, aligned, ispair, value_name) = {
    assert(size == 1 | size == 2 | size == 4 | size == 8 | size == 16);
    accdesc : AccessDescriptor = accdesc_in;
    if HaveLSE2Ext() then {
        assert(AllInAlignedQuantity(address, size, 16))
    } else {
        assert(IsAligned__1(address, size))
    };
    if HaveMTE2Ext() & accdesc.tagchecked then {
        accdesc.tagchecked = AArch64_AccessIsTagChecked(address, accdesc)
    };
    memaddrdesc : AddressDescriptor = AArch64_TranslateAddress(address, accdesc, aligned, size);
    if IsFault(memaddrdesc) then {
        AArch64_Abort(address, memaddrdesc.fault)
    };
    if memaddrdesc.memattrs.shareability != Shareability_NSH then {
        ClearExclusiveByAddress(memaddrdesc.paddress, ProcessorID(), size)
    };
    if HaveTME() then {
        if accdesc.transactional & not_bool(MemHasTransactionalAccess(memaddrdesc.memattrs)) then {
            FailTransaction(TMFailure_IMP, false)
        };
        ()
    };
    if HaveMTE2Ext() & accdesc.tagchecked then {
        let ptag : bits(4) = AArch64_PhysicalTag(address);
        if not_bool(AArch64_CheckTag(memaddrdesc, accdesc, ptag)) then {
            AArch64_TagCheckFault(address, accdesc)
        };
        ()
    };
    if SPESampleInFlight then {
        let is_load : bool = false;
        SPESampleLoadStore(is_load, accdesc, memaddrdesc)
    };
    memstatus : PhysMemRetStatus = undefined;
    atomic : bool = undefined;
    if (memaddrdesc.memattrs.memtype == MemType_Normal & memaddrdesc.memattrs.inner.attrs == MemAttr_WB) & memaddrdesc.memattrs.outer.attrs == MemAttr_WB then {
        atomic = true
    } else if (((accdesc.exclusive | accdesc.atomicop) | accdesc.acqsc) | accdesc.acqpc) | accdesc.relsc then {
        if not_bool(aligned) & not_bool(ConstrainUnpredictableBool(Unpredictable_MISALIGNEDATOMIC)) then {
            AArch64_Abort(address, AlignmentFault(accdesc))
        } else {
            atomic = true
        }
    } else if aligned then {
        atomic = not_bool(ispair)
    } else {
        atomic = __IMPDEF_boolean("FEAT_LSE2: access is atomic")
    };
    if atomic then {
        let memstatus : PhysMemRetStatus = PhysMemWrite(memaddrdesc, size, accdesc, None(), value_name); // TODO: TranslationInfo
        if IsFault__2(memstatus) then {
            HandleExternalWriteAbort(memstatus, memaddrdesc, size, accdesc)
        };
        ()
    } else if aligned & ispair then {
        assert(size == 8 | size == 16);
        let 'halfsize = DIV(size, 2);
        highhalf : bits('halfsize * 8) = undefined;
        lowhalf : bits('halfsize * 8) = undefined;
        (highhalf @ lowhalf) = value_name;
        memstatus : PhysMemRetStatus = PhysMemWrite(memaddrdesc, halfsize, accdesc, None(), lowhalf);
        if IsFault__2(memstatus) then {
            HandleExternalWriteAbort(memstatus, memaddrdesc, halfsize, accdesc)
        };
        memaddrdesc.paddress.address = memaddrdesc.paddress.address + halfsize;
        let memstatus : PhysMemRetStatus = PhysMemWrite(memaddrdesc, halfsize, accdesc, None(), highhalf);
        if IsFault__2(memstatus) then {
            HandleExternalWriteAbort(memstatus, memaddrdesc, halfsize, accdesc)
        };
        ()
    } else {
        foreach (i from 0 to (size - 1) by 1 in inc) {
            memstatus = PhysMemWrite(memaddrdesc, 1, accdesc, None(), value_name[8 * i + 7 .. 8 * i]);
            if IsFault__2(memstatus) then {
                HandleExternalWriteAbort(memstatus, memaddrdesc, 1, accdesc)
            };
            memaddrdesc.paddress.address = memaddrdesc.paddress.address + 1
        }
    };
    return()
}

val Mem_read : forall 'size, 'size * 8 >= 0.
  (bits(64), int('size), AccessDescriptor) -> bits('size * 8)

val Mem_read__1 : forall ('ispair : Bool) 'size, 'size * 8 >= 0.
  (bits(64), int('size), AccessDescriptor, bool('ispair)) -> bits('size * 8)

val Mem_read__2 : forall ('highestAddressfirst : Bool) ('ispair : Bool) 'size,
  'size in {1, 2, 4, 8, 16}.
  (bits(64), int('size), AccessDescriptor, bool('ispair), bool('highestAddressfirst)) -> bits('size * 8)

function Mem_read (address, size, accdesc) = {
    let ispair : bool = false;
    let highestAddressfirst : bool = false;
    assert(constraint('size in {1, 2, 4, 8, 16}));
    return(Mem_read__2(address, size, accdesc, ispair, highestAddressfirst))
}

function Mem_read__1 (address, size, accdesc, ispair) = {
    let highestAddressfirst : bool = false;
    assert(constraint('size in {1, 2, 4, 8, 16}));
    return(Mem_read__2(address, size, accdesc, ispair, highestAddressfirst))
}

function Mem_read__2 (address, size, accdesc, ispair, highestAddressfirst) = {
    c : Constraint = undefined;
    let 'halfsize = DIV(size, 2);
    value_name : bits('size * 8) = undefined;
    let 'alignment = if ispair then halfsize else size;
    aligned : bool = IsAligned__1(address, alignment);
    if not_bool(aligned) & AArch64_UnalignedAccessFaults(accdesc, address, size) then {
        AArch64_Abort(address, AlignmentFault(accdesc))
    };
    if (accdesc.acctype == AccessType_ASIMD & size == 16) & IsAligned__1(address, 8) then {
        let lowhalf : bits('halfsize * 8) = AArch64_MemSingle_read__1(address, halfsize, accdesc, aligned, ispair);
        let highhalf : bits('halfsize * 8) = AArch64_MemSingle_read__1(address + halfsize, halfsize, accdesc, aligned, ispair);
        value_name = highhalf @ lowhalf
    } else if HaveLSE2Ext() & AllInAlignedQuantity(address, size, 16) then {
        value_name = AArch64_MemSingle_read__1(address, size, accdesc, aligned, ispair)
    } else if ispair & aligned then {
        assert(constraint('halfsize in {1, 2, 4, 8}));
        highhalf : bits('halfsize * 8) = undefined;
        lowhalf : bits('halfsize * 8) = undefined;
        if HaveLRCPC3Ext() & highestAddressfirst then {
            highhalf = AArch64_MemSingle_read(address + halfsize, halfsize, accdesc, aligned);
            lowhalf = AArch64_MemSingle_read(address, halfsize, accdesc, aligned)
        } else {
            lowhalf = AArch64_MemSingle_read(address, halfsize, accdesc, aligned);
            highhalf = AArch64_MemSingle_read(address + halfsize, halfsize, accdesc, aligned)
        };
        value_name = highhalf @ lowhalf
    } else if aligned then {
        value_name = AArch64_MemSingle_read__1(address, size, accdesc, aligned, ispair)
    } else {
        assert(size > 1);
        assert(constraint('halfsize in {1, 2, 4, 8}));
        highhalf : bits('halfsize * 8) = undefined;
        lowhalf : bits('halfsize * 8) = undefined;
        if (HaveLRCPC3Ext() & ispair) & highestAddressfirst then {
            foreach (i from 0 to (halfsize - 1) by 1 in inc) {
                highhalf[8 * i + 7 .. 8 * i] = AArch64_MemSingle_read(address + halfsize + i, 1, accdesc, aligned)
            };
            foreach (i from 0 to (halfsize - 1) by 1 in inc) {
                lowhalf[8 * i + 7 .. 8 * i] = AArch64_MemSingle_read(address + i, 1, accdesc, aligned)
            };
            value_name = highhalf @ lowhalf
        } else {
            value_name[7 .. 0] = AArch64_MemSingle_read(address, 1, accdesc, aligned);
            let c : Constraint = ConstrainUnpredictable(Unpredictable_DEVPAGE2);
            assert(c == Constraint_FAULT | c == Constraint_NONE);
            if c == Constraint_NONE then {
                aligned = true
            };
            foreach (i from 1 to (size - 1) by 1 in inc) {
                value_name[8 * i + 7 .. 8 * i] = AArch64_MemSingle_read(address + i, 1, accdesc, aligned)
            }
        }
    };
    if BigEndian(accdesc.acctype) then {
        value_name = BigEndianReverse(value_name)
    };
    let value_name = value_name;
    return(value_name)
}

val Mem_set : forall 'size, 'size * 8 >= 0.
  (bits(64), int('size), AccessDescriptor, bits('size * 8)) -> unit

val Mem_set__1 : forall ('ispair : Bool) 'size, 'size * 8 >= 0.
  (bits(64), int('size), AccessDescriptor, bool('ispair), bits('size * 8)) -> unit

val Mem_set__2 : forall ('highestAddressfirst : Bool) ('ispair : Bool) 'size,
  'size * 8 >= 0.
  (bits(64), int('size), AccessDescriptor, bool('ispair), bool('highestAddressfirst), bits('size * 8)) -> unit

function Mem_set (address, size, accdesc, value_in_name) = {
    let ispair : bool = false;
    let highestAddressfirst : bool = false;
    Mem_set__2(address, size, accdesc, ispair, highestAddressfirst) = value_in_name
}

function Mem_set__1 (address, size, accdesc, ispair, value_in_name) = {
    let highestAddressfirst : bool = false;
    Mem_set__2(address, size, accdesc, ispair, highestAddressfirst) = value_in_name
}

function Mem_set__2 (address, size, accdesc, ispair, highestAddressfirst, value_in_name) = {
    c : Constraint = undefined;
    joinedpair : bool = undefined;
    let 'halfsize = DIV(size, 2);
    value_name : bits('size * 8) = value_in_name;
    let 'alignment = if ispair then halfsize else size;
    aligned : bool = IsAligned__1(address, alignment);
    if not_bool(aligned) & AArch64_UnalignedAccessFaults(accdesc, address, size) then {
        AArch64_Abort(address, AlignmentFault(accdesc))
    };
    if BigEndian(accdesc.acctype) then {
        assert(constraint(('size * 8 == 8 | 'size * 8 == 16 | 'size * 8 == 32 | 'size * 8 == 64 | 'size * 8 == 128)));
        value_name = BigEndianReverse(value_name)
    };
    if (accdesc.acctype == AccessType_ASIMD & size == 16) & IsAligned__1(address, 8) then {
        assert(halfsize > 0);
        highhalf : bits('halfsize * 8) = undefined;
        lowhalf : bits('halfsize * 8) = undefined;
        (highhalf @ lowhalf) = value_name;
        AArch64_MemSingle_set__1(address, halfsize, accdesc, aligned, ispair) = lowhalf;
        AArch64_MemSingle_set__1(address + halfsize, halfsize, accdesc, aligned, ispair) = highhalf
    } else if HaveLSE2Ext() & AllInAlignedQuantity(address, size, 16) then {
        assert(constraint('size in {1, 2, 4, 8, 16}));
        AArch64_MemSingle_set__1(address, size, accdesc, aligned, ispair) = value_name
    } else if ispair & aligned then {
        let joinedpair : bool = false;
        assert(halfsize > 0);
        highhalf : bits('halfsize * 8) = undefined;
        lowhalf : bits('halfsize * 8) = undefined;
        assert(constraint('size * 8 == 'halfsize * 8 + 'halfsize * 8));
        (highhalf @ lowhalf) = value_name;
        if HaveLRCPC3Ext() & highestAddressfirst then {
            assert(constraint('halfsize in {1, 2, 4, 8, 16}));
            AArch64_MemSingle_set__1(address + halfsize, halfsize, accdesc, aligned, joinedpair) = highhalf;
            AArch64_MemSingle_set__1(address, halfsize, accdesc, aligned, joinedpair) = lowhalf
        } else {
            assert(constraint('halfsize in {1, 2, 4, 8, 16}));
            AArch64_MemSingle_set__1(address, halfsize, accdesc, aligned, joinedpair) = lowhalf;
            AArch64_MemSingle_set__1(address + halfsize, halfsize, accdesc, aligned, joinedpair) = highhalf
        }
    } else if aligned then {
        assert(constraint('size in {1, 2, 4, 8, 16}));
        AArch64_MemSingle_set__1(address, size, accdesc, aligned, ispair) = value_name
    } else {
        assert(size > 1);
        highhalf : bits('halfsize * 8) = undefined;
        lowhalf : bits('halfsize * 8) = undefined;
        if (HaveLRCPC3Ext() & ispair) & highestAddressfirst then {
            assert(constraint('size * 8 == 'halfsize * 8 + 'halfsize * 8));
            (highhalf @ lowhalf) = value_name;
            foreach (i from 0 to (halfsize - 1) by 1 in inc) {
                AArch64_MemSingle_set(address + halfsize + i, 1, accdesc, aligned) = highhalf[8 * i + 7 .. 8 * i]
            };
            foreach (i from 0 to (halfsize - 1) by 1 in inc) {
                AArch64_MemSingle_set(address + i, 1, accdesc, aligned) = lowhalf[8 * i + 7 .. 8 * i]
            }
        } else {
            AArch64_MemSingle_set(address, 1, accdesc, aligned) = value_name[7 .. 0];
            let c : Constraint = ConstrainUnpredictable(Unpredictable_DEVPAGE2);
            assert(c == Constraint_FAULT | c == Constraint_NONE);
            if c == Constraint_NONE then {
                aligned = true
            };
            foreach (i from 1 to (size - 1) by 1 in inc) {
                AArch64_MemSingle_set(address + i, 1, accdesc, aligned) = value_name[8 * i + 7 .. 8 * i]
            }
        }
    };
    return()
}

val MemAtomic : forall 'size, 'size >= 0.
  (bits(64), bits('size), bits('size), AccessDescriptor) -> bits('size)

function MemAtomic (address, cmpoperand, operand, accdesc_in) = {
    assert(accdesc_in.atomicop);
    let 'bytes = DIV('size, 8);
    assert(bytes == 1 | bytes == 2 | bytes == 4 | bytes == 8 | bytes == 16);
    newvalue : bits('size) = undefined;
    oldvalue : bits('size) = undefined;
    accdesc : AccessDescriptor = accdesc_in;
    let aligned : bool = IsAligned__1(address, bytes);
    if HaveMTE2Ext() & accdesc.tagchecked then {
        accdesc.tagchecked = AArch64_AccessIsTagChecked(address, accdesc)
    };
    if not_bool(aligned) & AArch64_UnalignedAccessFaults(accdesc, address, bytes) then {
        AArch64_Abort(address, AlignmentFault(accdesc))
    };
    let memaddrdesc : AddressDescriptor = AArch64_TranslateAddress(address, accdesc, aligned, 'size);
    if IsFault(memaddrdesc) then {
        AArch64_Abort(address, memaddrdesc.fault)
    };
    if memaddrdesc.memattrs.shareability != Shareability_NSH then {
        ClearExclusiveByAddress(memaddrdesc.paddress, ProcessorID(), 'size)
    };
    if (HaveMTE2Ext() & accdesc.tagchecked) & (not_bool(HaveMTEStoreOnlyExt()) | not_bool(StoreOnlyTagCheckingEnabled(accdesc.el))) then {
        let ptag : bits(4) = AArch64_PhysicalTag(address);
        if not_bool(AArch64_CheckTag(memaddrdesc, accdesc, ptag)) then {
            AArch64_TagCheckFault(address, accdesc)
        };
        ()
    };
    memstatus : PhysMemRetStatus = undefined;
    assert(constraint(8 * 'bytes == 'size));
    (memstatus, oldvalue) = PhysMemRead(memaddrdesc, bytes, accdesc, None()); // TODO: TranslationInfo
    if IsFault__2(memstatus) then {
        HandleExternalReadAbort(memstatus, memaddrdesc, bytes, accdesc)
    };
    if BigEndian(accdesc.acctype) then {
        oldvalue = BigEndianReverse(oldvalue)
    };
    let oldvalue = oldvalue;
    cmpfail : bool = false;
    match accdesc.modop {
      MemAtomicOp_ADD => {
          newvalue = oldvalue + operand
      },
      MemAtomicOp_BIC => {
          newvalue = oldvalue & not_vec(operand)
      },
      MemAtomicOp_EOR => {
          newvalue = EOR(oldvalue, operand)
      },
      MemAtomicOp_ORR => {
          newvalue = oldvalue | operand
      },
      MemAtomicOp_SMAX => {
          newvalue = Max(SInt(oldvalue), SInt(operand))['size - 1 .. 0]
      },
      MemAtomicOp_SMIN => {
          newvalue = Min(SInt(oldvalue), SInt(operand))['size - 1 .. 0]
      },
      MemAtomicOp_UMAX => {
          newvalue = Max(UInt(oldvalue), UInt(operand))['size - 1 .. 0]
      },
      MemAtomicOp_UMIN => {
          newvalue = Min(UInt(oldvalue), UInt(operand))['size - 1 .. 0]
      },
      MemAtomicOp_SWP => {
          newvalue = operand
      },
      MemAtomicOp_CAS => {
          newvalue = operand;
          cmpfail = cmpoperand != oldvalue
      },
      MemAtomicOp_GCSSS1 => {
          newvalue = operand;
          cmpfail = cmpoperand != oldvalue
      },
      _ => ()
    };
    if HaveMTEStoreOnlyExt() & StoreOnlyTagCheckingEnabled(accdesc.el) then {
        if accdesc.tagchecked & cmpfail then {
            accdesc.tagchecked = ConstrainUnpredictableBool(Unpredictable_STOREONLYTAGCHECKEDCAS)
        };
        if HaveMTE2Ext() & accdesc.tagchecked then {
            let ptag : bits(4) = AArch64_PhysicalTag(address);
            if not_bool(AArch64_CheckTag(memaddrdesc, accdesc, ptag)) then {
                accdesc.read = false;
                AArch64_TagCheckFault(address, accdesc)
            };
            ()
        };
        ()
    };
    if not_bool(cmpfail) then {
        if BigEndian(accdesc.acctype) then {
            newvalue = BigEndianReverse(newvalue)
        };
        let memstatus : PhysMemRetStatus = PhysMemWrite(memaddrdesc, bytes, accdesc, None(), newvalue); // TODO: TranslationInfo
        if IsFault__2(memstatus) then {
            HandleExternalWriteAbort(memstatus, memaddrdesc, bytes, accdesc)
        };
        ()
    };
    if SPESampleInFlight then {
        let is_load : bool = false;
        SPESampleLoadStore(is_load, accdesc, memaddrdesc)
    };
    return(oldvalue)
}

val IsD128Enabled : bits(2) -> bool

function IsD128Enabled el = {
    d128enabled : bool = undefined;
    if Have128BitDescriptorExt() then {
        match el {
          ? if ? == EL0 => {
              if not_bool(ELIsInHost(EL0)) then {
                  d128enabled = IsTCR2EL1Enabled() & TCR2_EL1[D128] == 0b1
              } else {
                  d128enabled = IsTCR2EL2Enabled() & TCR2_EL2[D128] == 0b1
              }
          },
          ? if ? == EL1 => {
              d128enabled = IsTCR2EL1Enabled() & TCR2_EL1[D128] == 0b1
          },
          ? if ? == EL2 => {
              d128enabled = (IsTCR2EL2Enabled() & HCR_EL2[E2H] == 0b1) & TCR2_EL2[D128] == 0b1
          },
          ? if ? == EL3 => {
              d128enabled = TCR_EL3[D128] == 0b1
          },
          _ => ()
        }
    } else {
        d128enabled = false
    };
    return(d128enabled)
}

val ProtectionEnabled : bits(2) -> bool

function ProtectionEnabled el = {
    assert(HaveEL(el));
    let regime : bits(2) = S1TranslationRegime(el);
    assert(not_bool(ELUsingAArch32(regime)));
    if not_bool(IsD128Enabled(el)) then {
        match regime {
          ? if ? == EL1 => {
              return(IsTCR2EL1Enabled() & TCR2_EL1[PnCH] == 0b1)
          },
          ? if ? == EL2 => {
              return(IsTCR2EL2Enabled() & TCR2_EL2[PnCH] == 0b1)
          },
          ? if ? == EL3 => {
              return(TCR_EL3[PnCH] == 0b1)
          },
          _ => ()
        }
    } else {
        return(true)
    };
    return(false)
}

bitfield RCWMASK_EL1_Type : bits(128) = {Mask : 127..0}

register RCWMASK_EL1 : RCWMASK_EL1_Type

bitfield RCWSMASK_EL1_Type : bits(128) = {Software_Mask : 127..0}

register RCWSMASK_EL1 : RCWSMASK_EL1_Type

val RCWCheck : forall 'N ('soft : Bool), 'N in {64, 128}.
  (bits('N), bits('N), bool('soft)) -> bits(4)

function RCWCheck (old, new, soft) = {
    assert('N == 64 | 'N == 128);
    let 'protectedbit = if 'N == 128 then RCW128_PROTECTED_BIT else
      RCW64_PROTECTED_BIT;
    rcw_fail : bool = false;
    rcws_fail : bool = false;
    rcw_state_fail : bool = false;
    rcws_state_fail : bool = false;
    rcw_mask_fail : bool = false;
    rcws_mask_fail : bool = false;
    rcwmask : bits('N) = RCWMASK_EL1.bits['N - 1 .. 0];
    if 'N == 64 then {
        rcwmask[49 .. 18] = Replicate([rcwmask[17]], 32);
        rcwmask[0] = Bit(0b0)
    } else {
        rcwmask[55 .. 17] = Replicate([rcwmask[16]], 39);
        (rcwmask[126 .. 125] @ rcwmask[120 .. 119] @ rcwmask[107 .. 101] @ rcwmask[90 .. 56] @ rcwmask[1 .. 0]) = Zeros(48)
    };
    rcwsoftmask : bits('N) = RCWSMASK_EL1.bits['N - 1 .. 0];
    if 'N == 64 then {
        rcwsoftmask[49 .. 18] = Replicate([rcwsoftmask[17]], 32);
        rcwsoftmask[0] = Bit(0b0);
        if ProtectionEnabled(PSTATE.EL) then {
            rcwsoftmask[52] = Bit(0b0)
        };
        ()
    } else {
        rcwsoftmask[55 .. 17] = Replicate([rcwsoftmask[16]], 39);
        (rcwsoftmask[126 .. 125] @ rcwsoftmask[120 .. 119] @ rcwsoftmask[107 .. 101] @ rcwsoftmask[90 .. 56] @ rcwsoftmask[1 .. 0]) = Zeros(48);
        rcwsoftmask[114] = Bit(0b0)
    };
    if ProtectionEnabled(PSTATE.EL) then {
        assert(constraint((0 <= 'protectedbit & 'protectedbit < 'N)));
        if [old[protectedbit]] == 0b1 then {
            rcw_state_fail = ([new[protectedbit]] @ [new[0]]) != ([old[protectedbit]] @ [old[0]])
        } else if [old[protectedbit]] == 0b0 then {
            rcw_state_fail = [new[protectedbit]] != [old[protectedbit]]
        } else ()
    };
    if ProtectionEnabled(PSTATE.EL) then {
        assert(constraint((0 <= 'protectedbit & 'protectedbit < 'N)));
        if ([old[protectedbit]] @ [old[0]]) == 0b11 then {
            rcw_mask_fail = not_bool(IsZero(EOR(new, old) & not_vec(rcwmask)))
        };
        ()
    };
    if soft then {
        if [old[0]] == 0b1 then {
            rcws_state_fail = [new[0]] != [old[0]]
        } else {
            assert(constraint((0 <= 'protectedbit & 'protectedbit < 'N)));
            if not_bool(ProtectionEnabled(PSTATE.EL)) | ProtectionEnabled(PSTATE.EL) & [old[protectedbit]] == 0b0 then {
                rcws_state_fail = [new[0]] != [old[0]]
            };
            ()
        };
        if [old[0]] == 0b1 then {
            rcws_mask_fail = not_bool(IsZero(EOR(new, old) & not_vec(rcwsoftmask)))
        };
        ()
    };
    let rcw_fail : bool = rcw_state_fail | rcw_mask_fail;
    let rcws_fail : bool = rcws_state_fail | rcws_mask_fail;
    let n : bits(1) = 0b0;
    let z : bits(1) = if rcw_fail then 0b1 else 0b0;
    let c : bits(1) = if rcws_fail then 0b0 else 0b1;
    let v : bits(1) = 0b0;
    return(((n @ z) @ c) @ v)
}

val MemAtomicRCW : forall 'size, 'size >= 0.
  (bits(64), bits('size), bits('size), AccessDescriptor) -> (bits(4), bits('size))

function MemAtomicRCW (address, cmpoperand, operand, accdesc_in) = {
    assert(accdesc_in.atomicop);
    assert(accdesc_in.rcw);
    let 'bytes = DIV('size, 8);
    assert(bytes == 8 | bytes == 16);
    nzcv : bits(4) = undefined;
    oldvalue : bits('size) = undefined;
    newvalue : bits('size) = undefined;
    accdesc : AccessDescriptor = accdesc_in;
    let aligned : bool = IsAligned__1(address, bytes);
    if HaveMTE2Ext() & accdesc.tagchecked then {
        accdesc.tagchecked = AArch64_AccessIsTagChecked(address, accdesc)
    };
    if not_bool(aligned) & AArch64_UnalignedAccessFaults(accdesc, address, bytes) then {
        AArch64_Abort(address, AlignmentFault(accdesc))
    };
    let memaddrdesc : AddressDescriptor = AArch64_TranslateAddress(address, accdesc, aligned, 'size);
    if IsFault(memaddrdesc) then {
        AArch64_Abort(address, memaddrdesc.fault)
    };
    if memaddrdesc.memattrs.shareability != Shareability_NSH then {
        ClearExclusiveByAddress(memaddrdesc.paddress, ProcessorID(), 'size)
    };
    if (HaveMTE2Ext() & accdesc.tagchecked) & (not_bool(HaveMTEStoreOnlyExt()) | not_bool(StoreOnlyTagCheckingEnabled(accdesc.el))) then {
        let ptag : bits(4) = AArch64_PhysicalTag(address);
        if not_bool(AArch64_CheckTag(memaddrdesc, accdesc, ptag)) then {
            AArch64_TagCheckFault(address, accdesc)
        };
        ()
    };
    memstatus : PhysMemRetStatus = undefined;
    assert(constraint(8 * 'bytes == 'size));
    (memstatus, oldvalue) = PhysMemRead(memaddrdesc, bytes, accdesc, None()); // TODO: TranslationInfo
    if IsFault__2(memstatus) then {
        HandleExternalReadAbort(memstatus, memaddrdesc, bytes, accdesc)
    };
    if BigEndian(accdesc.acctype) then {
        oldvalue = BigEndianReverse(oldvalue)
    };
    let oldvalue = oldvalue;
    cmpfail : bool = false;
    match accdesc.modop {
      MemAtomicOp_BIC => {
          newvalue = oldvalue & not_vec(operand)
      },
      MemAtomicOp_ORR => {
          newvalue = oldvalue | operand
      },
      MemAtomicOp_SWP => {
          newvalue = operand
      },
      MemAtomicOp_CAS => {
          newvalue = operand;
          cmpfail = oldvalue != cmpoperand
      },
      _ => ()
    };
    if cmpfail then {
        nzcv = 0b1010
    } else {
        nzcv = RCWCheck(oldvalue, newvalue, accdesc.rcws)
    };
    if HaveMTEStoreOnlyExt() & StoreOnlyTagCheckingEnabled(accdesc.el) then {
        if accdesc.tagchecked & cmpfail then {
            accdesc.tagchecked = ConstrainUnpredictableBool(Unpredictable_STOREONLYTAGCHECKEDCAS)
        };
        if HaveMTE2Ext() & accdesc.tagchecked then {
            let ptag : bits(4) = AArch64_PhysicalTag(address);
            if not_bool(AArch64_CheckTag(memaddrdesc, accdesc, ptag)) then {
                accdesc.read = false;
                AArch64_TagCheckFault(address, accdesc)
            };
            ()
        };
        ()
    };
    if nzcv == 0b0010 then {
        if BigEndian(accdesc.acctype) then {
            newvalue = BigEndianReverse(newvalue)
        };
        let memstatus : PhysMemRetStatus = PhysMemWrite(memaddrdesc, bytes, accdesc, None(), newvalue);
        if IsFault__2(memstatus) then {
            HandleExternalWriteAbort(memstatus, memaddrdesc, bytes, accdesc)
        };
        ()
    };
    return((nzcv, oldvalue))
}

val AArch64_AddressWithAllocationTag : (bits(64), bits(4)) -> bits(64)

function AArch64_AddressWithAllocationTag (address, allocation_tag) = {
    result : bits(64) = address;
    tag : bits(4) = undefined;
    if AArch64_AllocationTagAccessIsEnabled(PSTATE.EL) then {
        tag = allocation_tag
    } else {
        tag = 0b0000
    };
    result[59 .. 56] = tag;
    return(result)
}

val AArch64_AllocationTagFromAddress : bits(64) -> bits(4)

function AArch64_AllocationTagFromAddress tagged_address = {
    return(tagged_address[59 .. 56])
}

val AArch64_MemTag_read : (bits(64), AccessDescriptor) -> bits(4)

function AArch64_MemTag_read (address, accdesc_in) = {
    memstatus : PhysMemRetStatus = undefined;
    tag : bits(4) = undefined;
    assert(accdesc_in.tagaccess & not_bool(accdesc_in.tagchecked));
    accdesc : AccessDescriptor = accdesc_in;
    let aligned : bool = true;
    if HaveMTE2Ext() then {
        accdesc.tagaccess = AArch64_AllocationTagAccessIsEnabled(accdesc.el)
    };
    let memaddrdesc : AddressDescriptor = AArch64_TranslateAddress(address, accdesc, aligned, TAG_GRANULE);
    if IsFault(memaddrdesc) then {
        AArch64_Abort(address, memaddrdesc.fault)
    };
    if accdesc.tagaccess & memaddrdesc.memattrs.tags == MemTag_AllocationTagged then {
        (memstatus, tag) = PhysMemTagRead(memaddrdesc, accdesc);
        if IsFault__2(memstatus) then {
            HandleExternalReadAbort(memstatus, memaddrdesc, 1, accdesc)
        };
        return(tag)
    } else if (HaveMTECanonicalTagCheckingExt() & accdesc.tagaccess) & memaddrdesc.memattrs.tags == MemTag_CanonicallyTagged then {
        return(if [address[55]] == 0b0 then 0b0000 else 0b1111)
    } else {
        return(0b0000)
    }
}

val PhysMemTagWrite : (AddressDescriptor, AccessDescriptor, bits(4)) -> PhysMemRetStatus

val AArch64_MemTag_set : (bits(64), AccessDescriptor, bits(4)) -> unit

function AArch64_MemTag_set (address, accdesc_in, value_name) = {
    memstatus : PhysMemRetStatus = undefined;
    assert(accdesc_in.tagaccess & not_bool(accdesc_in.tagchecked));
    accdesc : AccessDescriptor = accdesc_in;
    let aligned : bool = IsAligned__1(address, TAG_GRANULE);
    if not_bool(aligned) then {
        AArch64_Abort(address, AlignmentFault(accdesc))
    };
    if HaveMTE2Ext() then {
        accdesc.tagaccess = AArch64_AllocationTagAccessIsEnabled(accdesc.el)
    };
    let memaddrdesc : AddressDescriptor = AArch64_TranslateAddress(address, accdesc, aligned, TAG_GRANULE);
    if IsFault(memaddrdesc) then {
        AArch64_Abort(address, memaddrdesc.fault)
    };
    if accdesc.tagaccess & memaddrdesc.memattrs.tags == MemTag_AllocationTagged then {
        let memstatus : PhysMemRetStatus = PhysMemTagWrite(memaddrdesc, accdesc, value_name);
        if IsFault__2(memstatus) then {
            HandleExternalWriteAbort(memstatus, memaddrdesc, 1, accdesc)
        };
        ()
    };
    ()
}

bitfield VNCR_EL2_Type : bits(64) = {RESS : 63..57, BADDR : 56..12}

register VNCR_EL2 : VNCR_EL2_Type

val NVMem_read : forall 'offset. int('offset) -> bits(64)

val NVMem_read__1 : forall 'N 'offset, 'N in {64, 128}.
  (int('offset), int('N)) -> bits('N)

function NVMem_read offset = {
    assert(offset > 0);
    let 'size = 64;
    return(NVMem_read__1(offset, size))
}

function NVMem_read__1 (offset, N) = {
    assert(offset > 0);
    assert(N == 64 | N == 128);
    let address : bits(64) = SignExtend(VNCR_EL2[BADDR] @ offset[11 .. 0], 64);
    let accdesc : AccessDescriptor = CreateAccDescNV2(MemOp_LOAD);
    return(Mem_read(address, DIV(N, 8), accdesc))
}

val NVMem_set : forall 'offset. (int('offset), bits(64)) -> unit

val NVMem_set__1 : forall 'N 'offset, 'N in {64, 128}.
  (int('offset), int('N), bits('N)) -> unit

function NVMem_set (offset, value_name) = {
    assert(offset > 0);
    let 'size = 64;
    NVMem_set__1(offset, size) = value_name;
    return()
}

function NVMem_set__1 (offset, N, value_name) = {
    assert(offset > 0);
    assert(N == 64 | N == 128);
    let address : bits(64) = SignExtend(VNCR_EL2[BADDR] @ offset[11 .. 0], 64);
    let accdesc : AccessDescriptor = CreateAccDescNV2(MemOp_STORE);
    Mem_set(address, DIV(N, 8), accdesc) = value_name;
    return()
}

val AddressSupportsLS64 : bits(56) -> bool

val MemStore64B : (bits(64), bits(512), AccessDescriptor) -> unit

function MemStore64B (address, value_name, accdesc_in) = {
    c : Constraint = undefined;
    let 'size = 64;
    accdesc : AccessDescriptor = accdesc_in;
    let aligned : bool = IsAligned__1(address, size);
    if not_bool(aligned) & AArch64_UnalignedAccessFaults(accdesc, address, size) then {
        AArch64_Abort(address, AlignmentFault(accdesc))
    };
    if HaveMTE2Ext() & accdesc.tagchecked then {
        accdesc.tagchecked = AArch64_AccessIsTagChecked(address, accdesc)
    };
    memaddrdesc : AddressDescriptor = AArch64_TranslateAddress(address, accdesc, aligned, size);
    if IsFault(memaddrdesc) then {
        AArch64_Abort(address, memaddrdesc.fault)
    };
    if memaddrdesc.memattrs.shareability != Shareability_NSH then {
        ClearExclusiveByAddress(memaddrdesc.paddress, ProcessorID(), 64)
    };
    if HaveMTE2Ext() & accdesc.tagchecked then {
        let ptag : bits(4) = AArch64_PhysicalTag(address);
        if not_bool(AArch64_CheckTag(memaddrdesc, accdesc, ptag)) then {
            AArch64_TagCheckFault(address, accdesc)
        };
        ()
    };
    memstatus : PhysMemRetStatus = undefined;
    if not_bool(AddressSupportsLS64(memaddrdesc.paddress.address)) then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_LS64UNSUPPORTED);
        assert(c == Constraint_LIMITED_ATOMICITY | c == Constraint_FAULT);
        if c == Constraint_FAULT then {
            AArch64_Abort(address, ExclusiveFault(accdesc))
        } else {
            foreach (i from 0 to (size - 1) by 1 in inc) {
                memstatus = PhysMemWrite(memaddrdesc, 1, accdesc, None(), value_name[8 * i + 7 .. 8 * i]); // TODO: TranslationInfo
                if IsFault__2(memstatus) then {
                    HandleExternalWriteAbort(memstatus, memaddrdesc, 1, accdesc)
                };
                memaddrdesc.paddress.address = memaddrdesc.paddress.address + 1
            }
        }
    } else {
        let memstatus : PhysMemRetStatus = PhysMemWrite(memaddrdesc, size, accdesc, None(), value_name);
        if IsFault__2(memstatus) then {
            HandleExternalWriteAbort(memstatus, memaddrdesc, size, accdesc)
        };
        ()
    };
    return()
}

val MemStore64BWithRet : (bits(64), bits(512), AccessDescriptor) -> bits(64)

function MemStore64BWithRet (address, value_name, accdesc_in) = {
    let 'size = 64;
    accdesc : AccessDescriptor = accdesc_in;
    let aligned : bool = IsAligned__1(address, size);
    if not_bool(aligned) & AArch64_UnalignedAccessFaults(accdesc, address, size) then {
        AArch64_Abort(address, AlignmentFault(accdesc))
    };
    if HaveMTE2Ext() & accdesc.tagchecked then {
        accdesc.tagchecked = AArch64_AccessIsTagChecked(address, accdesc)
    };
    let memaddrdesc : AddressDescriptor = AArch64_TranslateAddress(address, accdesc, aligned, size);
    if IsFault(memaddrdesc) then {
        AArch64_Abort(address, memaddrdesc.fault);
        return(ZeroExtend(0b1, 64))
    };
    if memaddrdesc.memattrs.shareability != Shareability_NSH then {
        ClearExclusiveByAddress(memaddrdesc.paddress, ProcessorID(), 64)
    };
    if HaveMTE2Ext() & accdesc.tagchecked then {
        let ptag : bits(4) = AArch64_PhysicalTag(address);
        if not_bool(AArch64_CheckTag(memaddrdesc, accdesc, ptag)) then {
            AArch64_TagCheckFault(address, accdesc);
            return(ZeroExtend(0b1, 64))
        };
        ()
    };
    let memstatus : PhysMemRetStatus = PhysMemWrite(memaddrdesc, size, accdesc, None(), value_name);
    if IsFault__2(memstatus) then {
        HandleExternalWriteAbort(memstatus, memaddrdesc, size, accdesc)
    };
    return(memstatus.store64bstatus)
}

val MemLoad64B : (bits(64), AccessDescriptor) -> bits(512)

function MemLoad64B (address, accdesc_in) = {
    c : Constraint = undefined;
    data : bits(512) = undefined;
    let 'size = 64;
    accdesc : AccessDescriptor = accdesc_in;
    let aligned : bool = IsAligned__1(address, size);
    if not_bool(aligned) & AArch64_UnalignedAccessFaults(accdesc, address, size) then {
        AArch64_Abort(address, AlignmentFault(accdesc))
    };
    if HaveMTE2Ext() & accdesc.tagchecked then {
        accdesc.tagchecked = AArch64_AccessIsTagChecked(address, accdesc)
    };
    memaddrdesc : AddressDescriptor = AArch64_TranslateAddress(address, accdesc, aligned, size);
    if IsFault(memaddrdesc) then {
        AArch64_Abort(address, memaddrdesc.fault)
    };
    if memaddrdesc.memattrs.shareability != Shareability_NSH then {
        ClearExclusiveByAddress(memaddrdesc.paddress, ProcessorID(), size)
    };
    if HaveMTE2Ext() & accdesc.tagchecked then {
        let ptag : bits(4) = AArch64_PhysicalTag(address);
        if not_bool(AArch64_CheckTag(memaddrdesc, accdesc, ptag)) then {
            AArch64_TagCheckFault(address, accdesc)
        };
        ()
    };
    if not_bool(AddressSupportsLS64(memaddrdesc.paddress.address)) then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_LS64UNSUPPORTED);
        assert(c == Constraint_LIMITED_ATOMICITY | c == Constraint_FAULT);
        if c == Constraint_FAULT then {
            AArch64_Abort(address, ExclusiveFault(accdesc))
        } else {
            foreach (i from 0 to (size - 1) by 1 in inc) {
                memstatus : PhysMemRetStatus = undefined;
                (memstatus, data[8 * i + 7 .. 8 * i]) = PhysMemRead(memaddrdesc, 1, accdesc, None()); // TODO: TranslationInfo
                if IsFault__2(memstatus) then {
                    HandleExternalReadAbort(memstatus, memaddrdesc, 1, accdesc)
                };
                memaddrdesc.paddress.address = memaddrdesc.paddress.address + 1
            }
        }
    } else {
        memstatus : PhysMemRetStatus = undefined;
        (memstatus, data) = PhysMemRead(memaddrdesc, size, accdesc, None());
        if IsFault__2(memstatus) then {
            HandleExternalReadAbort(memstatus, memaddrdesc, size, accdesc)
        };
        ()
    };
    return(data)
}

val AArch64_IsUnprivAccessPriv : unit -> bool

function AArch64_IsUnprivAccessPriv () = {
    privileged : bool = undefined;
    match PSTATE.EL {
      ? if ? == EL0 => {
          privileged = false
      },
      ? if ? == EL1 => {
          privileged = (EL2Enabled() & HaveNVExt()) & (HCR_EL2[NV] @ HCR_EL2[NV1]) == 0b11
      },
      ? if ? == EL2 => {
          privileged = not_bool(HaveVirtHostExt() & (HCR_EL2[E2H] @ HCR_EL2[TGE]) == 0b11)
      },
      ? if ? == EL3 => {
          privileged = true
      },
      _ => ()
    };
    if HaveUAOExt() & PSTATE.UAO == 0b1 then {
        privileged = PSTATE.EL != EL0
    };
    let privileged = privileged;
    return(privileged)
}

val AArch64_DataMemZero : forall 'size.
  (bits(64), bits(64), AccessDescriptor, int('size)) -> unit

function AArch64_DataMemZero (regval, vaddress, accdesc_in, size) = {
    memstatus : PhysMemRetStatus = undefined;
    accdesc : AccessDescriptor = accdesc_in;
    if HaveMTE2Ext() & accdesc.tagaccess then {
        accdesc.tagaccess = AArch64_AllocationTagAccessIsEnabled(accdesc.el)
    };
    if HaveMTE2Ext() & accdesc.tagchecked then {
        accdesc.tagchecked = AArch64_AccessIsTagChecked(vaddress, accdesc)
    };
    let aligned : bool = true;
    memaddrdesc : AddressDescriptor = AArch64_TranslateAddress(vaddress, accdesc, aligned, size);
    if IsFault(memaddrdesc) then {
        if IsDebugException(memaddrdesc.fault) then {
            AArch64_Abort(vaddress, memaddrdesc.fault)
        } else {
            AArch64_Abort(regval, memaddrdesc.fault)
        }
    };
    if HaveTME() then {
        if accdesc.transactional & not_bool(MemHasTransactionalAccess(memaddrdesc.memattrs)) then {
            FailTransaction(TMFailure_IMP, false)
        };
        ()
    };
    foreach (i from 0 to (size - 1) by 1 in inc) {
        if HaveMTE2Ext() & accdesc.tagchecked then {
            let ptag : bits(4) = AArch64_PhysicalTag(vaddress);
            if not_bool(AArch64_CheckTag(memaddrdesc, accdesc, ptag)) then {
                if __IMPDEF_boolean("DC_ZVA tag fault reported with lowest faulting address") then {
                    AArch64_TagCheckFault(vaddress, accdesc)
                } else {
                    AArch64_TagCheckFault(regval, accdesc)
                }
            };
            ()
        };
        memstatus = PhysMemWrite(memaddrdesc, 1, accdesc, None(), Zeros(8));
        if IsFault__2(memstatus) then {
            HandleExternalWriteAbort(memstatus, memaddrdesc, 1, accdesc)
        };
        memaddrdesc.paddress.address = memaddrdesc.paddress.address + 1
    };
    return()
}

val AArch64_TagMemZero : forall 'size.
  (bits(64), bits(64), AccessDescriptor, int('size)) -> unit

function AArch64_TagMemZero (regval, vaddress, accdesc_in, size) = {
    memstatus : PhysMemRetStatus = undefined;
    assert(accdesc_in.tagaccess & not_bool(accdesc_in.tagchecked));
    accdesc : AccessDescriptor = accdesc_in;
    let 'count = (size >> LOG2_TAG_GRANULE);
    let tag : bits(4) = AArch64_AllocationTagFromAddress(vaddress);
    let aligned : bool = IsAligned__1(vaddress, TAG_GRANULE);
    if not_bool(aligned) then {
        AArch64_Abort(vaddress, AlignmentFault(accdesc))
    };
    if HaveMTE2Ext() then {
        accdesc.tagaccess = AArch64_AllocationTagAccessIsEnabled(accdesc.el)
    };
    memaddrdesc : AddressDescriptor = AArch64_TranslateAddress(vaddress, accdesc, aligned, size);
    if IsFault(memaddrdesc) then {
        if IsDebugException(memaddrdesc.fault) then {
            AArch64_Abort(vaddress, memaddrdesc.fault)
        } else {
            AArch64_Abort(regval, memaddrdesc.fault)
        }
    };
    if not_bool(accdesc.tagaccess) | memaddrdesc.memattrs.tags != MemTag_AllocationTagged then {
        return()
    };
    foreach (i from 0 to (count - 1) by 1 in inc) {
        memstatus = PhysMemTagWrite(memaddrdesc, accdesc, tag);
        if IsFault__2(memstatus) then {
            HandleExternalWriteAbort(memstatus, memaddrdesc, 1, accdesc)
        };
        memaddrdesc.paddress.address = memaddrdesc.paddress.address + TAG_GRANULE
    };
    return()
}

val AArch64_IsExclusiveVA : forall 'processorid 'size.
  (bits(64), int('processorid), int('size)) -> bool

val AArch64_MarkExclusiveVA : forall 'processorid 'size.
  (bits(64), int('processorid), int('size)) -> unit

val AArch64_SetExclusiveMonitors : forall 'size. (bits(64), int('size)) -> unit

function AArch64_SetExclusiveMonitors (address, size) = {
    __ExclusiveMonitorSet = true;
    let acqrel : bool = false;
    let tagchecked : bool = false;
    let accdesc : AccessDescriptor = CreateAccDescExLDST(MemOp_LOAD, acqrel, tagchecked);
    let aligned : bool = IsAligned__1(address, size);
    if not_bool(aligned) & AArch64_UnalignedAccessFaults(accdesc, address, size) then {
        AArch64_Abort(address, AlignmentFault(accdesc))
    };
    let memaddrdesc : AddressDescriptor = AArch64_TranslateAddress(address, accdesc, aligned, size);
    if IsFault(memaddrdesc) then {
        return()
    };
    if memaddrdesc.memattrs.shareability != Shareability_NSH then {
        MarkExclusiveGlobal(memaddrdesc.paddress, ProcessorID(), size)
    };
    MarkExclusiveLocal(memaddrdesc.paddress, ProcessorID(), size);
    AArch64_MarkExclusiveVA(address, ProcessorID(), size)
}

val AArch64_ExclusiveMonitorsPass : forall 'size. (bits(64), int('size)) -> bool
register __exclusive_always_succeeds: bool = false

function AArch64_ExclusiveMonitorsPass (address, size) = {
    let acqrel : bool = false;
    let tagchecked : bool = false;
    let accdesc : AccessDescriptor = CreateAccDescExLDST(MemOp_STORE, acqrel, tagchecked);
    let aligned : bool = IsAligned__1(address, size);

    if not_bool(__exclusive_always_succeeds) then {
        return(undefined);
    };

    if not_bool(aligned) & AArch64_UnalignedAccessFaults(accdesc, address, size) then {
        AArch64_Abort(address, AlignmentFault(accdesc))
    };
    if not_bool(AArch64_IsExclusiveVA(address, ProcessorID(), size)) then {
        return(false)
    };
    let memaddrdesc : AddressDescriptor = AArch64_TranslateAddress(address, accdesc, aligned, size);
    if IsFault(memaddrdesc) then {
        AArch64_Abort(address, memaddrdesc.fault)
    };
    passed : bool = IsExclusiveLocal(memaddrdesc.paddress, ProcessorID(), size);
    ClearExclusiveLocal(ProcessorID());
    if passed & memaddrdesc.memattrs.shareability != Shareability_NSH then {
        passed = IsExclusiveGlobal(memaddrdesc.paddress, ProcessorID(), size)
    };
    return(passed)
}

val FPRecipStepFused : forall 'N, 'N in {16, 32, 64}.
  (bits('N), bits('N)) -> bits('N)

function FPRecipStepFused (op1_in, op2) = {
    inf1 : bool = undefined;
    inf2 : bool = undefined;
    result_value : real = undefined;
    sign : bits(1) = undefined;
    sign1 : bits(1) = undefined;
    sign2 : bits(1) = undefined;
    type1 : FPType = undefined;
    type2 : FPType = undefined;
    value1_name : real = undefined;
    value2_name : real = undefined;
    zero1 : bool = undefined;
    zero2 : bool = undefined;
    assert('N == 16 | 'N == 32 | 'N == 64);
    op1 : bits('N) = op1_in;
    result : bits('N) = undefined;
    done : bool = undefined;
    fpcr : FPCRType = FPCR_read();
    let op1 : bits('N) = FPNeg(op1);
    let altfp : bool = HaveAltFP() & fpcr[AH] == 0b1;
    let fpexc : bool = not_bool(altfp);
    if altfp then {
        (fpcr[FIZ] @ fpcr[FZ]) = 0b11
    };
    if altfp then {
        fpcr[RMode] = 0b00
    };
    (type1, sign1, value1_name) = FPUnpack__1(op1, fpcr, fpexc);
    (type2, sign2, value2_name) = FPUnpack__1(op2, fpcr, fpexc);
    (done, result) = FPProcessNaNs__1(type1, type2, op1, op2, fpcr, fpexc);
    let rounding : FPRounding = FPRoundingMode(fpcr);
    if not_bool(done) then {
        let inf1 : bool = type1 == FPType_Infinity;
        let inf2 : bool = type2 == FPType_Infinity;
        let zero1 : bool = type1 == FPType_Zero;
        let zero2 : bool = type2 == FPType_Zero;
        if inf1 & zero2 | zero1 & inf2 then {
            result = FPTwo(0b0, 'N)
        } else if inf1 | inf2 then {
            result = FPInfinity(EOR(sign1, sign2), 'N)
        } else {
            let result_value : real = 2.0 + value1_name * value2_name;
            if result_value == 0.0 then {
                let sign : bits(1) = if rounding == FPRounding_NEGINF then 0b1
                else
                  0b0;
                result = FPZero(sign, 'N)
            } else {
                result = FPRound__2(result_value, fpcr, rounding, fpexc, 'N)
            }
        }
    };
    return(result)
}

val FPRSqrtStepFused : forall 'N, 'N in {16, 32, 64}.
  (bits('N), bits('N)) -> bits('N)

function FPRSqrtStepFused (op1_in, op2) = {
    inf1 : bool = undefined;
    inf2 : bool = undefined;
    result_value : real = undefined;
    sign : bits(1) = undefined;
    sign1 : bits(1) = undefined;
    sign2 : bits(1) = undefined;
    type1 : FPType = undefined;
    type2 : FPType = undefined;
    value1_name : real = undefined;
    value2_name : real = undefined;
    zero1 : bool = undefined;
    zero2 : bool = undefined;
    assert('N == 16 | 'N == 32 | 'N == 64);
    result : bits('N) = undefined;
    op1 : bits('N) = op1_in;
    done : bool = undefined;
    fpcr : FPCRType = FPCR_read();
    let op1 : bits('N) = FPNeg(op1);
    let altfp : bool = HaveAltFP() & fpcr[AH] == 0b1;
    let fpexc : bool = not_bool(altfp);
    if altfp then {
        (fpcr[FIZ] @ fpcr[FZ]) = 0b11
    };
    if altfp then {
        fpcr[RMode] = 0b00
    };
    (type1, sign1, value1_name) = FPUnpack__1(op1, fpcr, fpexc);
    (type2, sign2, value2_name) = FPUnpack__1(op2, fpcr, fpexc);
    (done, result) = FPProcessNaNs__1(type1, type2, op1, op2, fpcr, fpexc);
    let rounding : FPRounding = FPRoundingMode(fpcr);
    if not_bool(done) then {
        let inf1 : bool = type1 == FPType_Infinity;
        let inf2 : bool = type2 == FPType_Infinity;
        let zero1 : bool = type1 == FPType_Zero;
        let zero2 : bool = type2 == FPType_Zero;
        if inf1 & zero2 | zero1 & inf2 then {
            result = FPOnePointFive(0b0, 'N)
        } else if inf1 | inf2 then {
            result = FPInfinity(EOR(sign1, sign2), 'N)
        } else {
            let result_value : real = (3.0 + value1_name * value2_name) / 2.0;
            if result_value == 0.0 then {
                let sign : bits(1) = if rounding == FPRounding_NEGINF then 0b1
                else
                  0b0;
                result = FPZero(sign, 'N)
            } else {
                result = FPRound__2(result_value, fpcr, rounding, fpexc, 'N)
            }
        }
    };
    return(result)
}

val AArch64_AdvSIMDFPAccessTrap : bits(2) -> unit

function AArch64_AdvSIMDFPAccessTrap target_el = {
    let preferred_exception_return : bits(64) = ThisInstrAddr(64);
    except : ExceptionRecord = undefined;
    let 'vect_offset = UInt(0x0);
    let route_to_el2 : bool = (target_el == EL1 & EL2Enabled()) & HCR_EL2[TGE] == 0b1;
    sail_take_exception(None());
    if route_to_el2 then {
        let except : ExceptionRecord = ExceptionSyndrome(Exception_Uncategorized);
        AArch64_TakeException(EL2, except, preferred_exception_return, vect_offset)
    } else {
        except : ExceptionRecord = ExceptionSyndrome(Exception_AdvSIMDFPAccessTrap);
        except.syndrome[24 .. 20] = ConditionSyndrome();
        AArch64_TakeException(target_el, except, preferred_exception_return, vect_offset)
    };
    return()
}

val SVEAccessTrap : bits(2) -> unit

function SVEAccessTrap target_el = {
    assert((UInt(target_el) >= UInt(PSTATE.EL) & target_el != EL0) & HaveEL(target_el));
    let route_to_el2 : bool = (target_el == EL1 & EL2Enabled()) & HCR_EL2[TGE] == 0b1;
    let except : ExceptionRecord = ExceptionSyndrome(Exception_SVEAccessTrap);
    let preferred_exception_return : bits(64) = ThisInstrAddr(64);
    let 'vect_offset = UInt(0x0);
    sail_take_exception(None());
    if route_to_el2 then {
        AArch64_TakeException(EL2, except, preferred_exception_return, vect_offset)
    } else {
        AArch64_TakeException(target_el, except, preferred_exception_return, vect_offset)
    }
}

val CheckOriginalSVEEnabled : unit -> unit

function CheckOriginalSVEEnabled () = {
    assert(HaveSVE());
    disabled : bool = undefined;
    if (HaveEL(EL3) & (CPTR_EL3[EZ] == 0b0 | CPTR_EL3[TFP] == 0b1)) & EL3SDDUndefPriority() then {
        throw(Error_Undefined())
    };
    if (PSTATE.EL == EL0 | PSTATE.EL == EL1) & not_bool(IsInHost()) then {
        match CPACR_EL1[ZEN] {
          [_, bitzero] => {
              disabled = true
          },
          0b01 => {
              disabled = PSTATE.EL == EL0
          },
          0b11 => {
              disabled = false
          }
        };
        if disabled then {
            SVEAccessTrap(EL1)
        };
        match CPACR_EL1[FPEN] {
          [_, bitzero] => {
              disabled = true
          },
          0b01 => {
              disabled = PSTATE.EL == EL0
          },
          0b11 => {
              disabled = false
          }
        };
        if disabled then {
            AArch64_AdvSIMDFPAccessTrap(EL1)
        };
        ()
    };
    if (PSTATE.EL == EL0 | PSTATE.EL == EL1 | PSTATE.EL == EL2) & EL2Enabled() then {
        if HaveVirtHostExt() & HCR_EL2[E2H] == 0b1 then {
            match CPTR_EL2[ZEN] {
              [_, bitzero] => {
                  disabled = true
              },
              0b01 => {
                  disabled = PSTATE.EL == EL0 & HCR_EL2[TGE] == 0b1
              },
              0b11 => {
                  disabled = false
              }
            };
            if disabled then {
                SVEAccessTrap(EL2)
            };
            match CPTR_EL2[FPEN] {
              [_, bitzero] => {
                  disabled = true
              },
              0b01 => {
                  disabled = PSTATE.EL == EL0 & HCR_EL2[TGE] == 0b1
              },
              0b11 => {
                  disabled = false
              }
            };
            if disabled then {
                AArch64_AdvSIMDFPAccessTrap(EL2)
            };
            ()
        } else {
            if CPTR_EL2[TZ] == 0b1 then {
                SVEAccessTrap(EL2)
            };
            if CPTR_EL2[TFP] == 0b1 then {
                AArch64_AdvSIMDFPAccessTrap(EL2)
            };
            ()
        }
    };
    if HaveEL(EL3) then {
        if CPTR_EL3[EZ] == 0b0 then {
            if EL3SDDUndef() then {
                throw(Error_Undefined())
            } else {
                SVEAccessTrap(EL3)
            }
        };
        if CPTR_EL3[TFP] == 0b1 then {
            if EL3SDDUndef() then {
                throw(Error_Undefined())
            } else {
                AArch64_AdvSIMDFPAccessTrap(EL3)
            }
        };
        ()
    };
    ()
}

val SMEAccessTrap : (SMEExceptionType, bits(2)) -> unit

function SMEAccessTrap (etype, target_el_in) = {
    target_el : bits(2) = target_el_in;
    assert(UInt(target_el) >= UInt(PSTATE.EL));
    if target_el == EL0 then {
        target_el = EL1
    };
    let route_to_el2 : bool = ((PSTATE.EL == EL0 & target_el == EL1) & EL2Enabled()) & HCR_EL2[TGE] == 0b1;
    except : ExceptionRecord = ExceptionSyndrome(Exception_SMEAccessTrap);
    let preferred_exception_return : bits(64) = ThisInstrAddr(64);
    let 'vect_offset = UInt(0x0);
    match etype {
      SMEExceptionType_AccessTrap => {
          except.syndrome[2 .. 0] = 0b000
      },
      SMEExceptionType_Streaming => {
          except.syndrome[2 .. 0] = 0b001
      },
      SMEExceptionType_NotStreaming => {
          except.syndrome[2 .. 0] = 0b010
      },
      SMEExceptionType_InactiveZA => {
          except.syndrome[2 .. 0] = 0b011
      },
      SMEExceptionType_InaccessibleZT0 => {
          except.syndrome[2 .. 0] = 0b100
      }
    };
    sail_take_exception(None());
    if route_to_el2 then {
        AArch64_TakeException(EL2, except, preferred_exception_return, vect_offset)
    } else {
        AArch64_TakeException(target_el, except, preferred_exception_return, vect_offset)
    }
}

val CheckSMEEnabled : unit -> unit

function CheckSMEEnabled () = {
    disabled : bool = undefined;
    if (PSTATE.EL == EL0 | PSTATE.EL == EL1) & not_bool(IsInHost()) then {
        match CPACR_EL1[SMEN] {
          [_, bitzero] => {
              disabled = true
          },
          0b01 => {
              disabled = PSTATE.EL == EL0
          },
          0b11 => {
              disabled = false
          }
        };
        if disabled then {
            SMEAccessTrap(SMEExceptionType_AccessTrap, EL1)
        };
        match CPACR_EL1[FPEN] {
          [_, bitzero] => {
              disabled = true
          },
          0b01 => {
              disabled = PSTATE.EL == EL0
          },
          0b11 => {
              disabled = false
          }
        };
        if disabled then {
            AArch64_AdvSIMDFPAccessTrap(EL1)
        };
        ()
    };
    if (PSTATE.EL == EL0 | PSTATE.EL == EL1 | PSTATE.EL == EL2) & EL2Enabled() then {
        if HaveVirtHostExt() & HCR_EL2[E2H] == 0b1 then {
            match CPTR_EL2[SMEN] {
              [_, bitzero] => {
                  disabled = true
              },
              0b01 => {
                  disabled = PSTATE.EL == EL0 & HCR_EL2[TGE] == 0b1
              },
              0b11 => {
                  disabled = false
              }
            };
            if disabled then {
                SMEAccessTrap(SMEExceptionType_AccessTrap, EL2)
            };
            match CPTR_EL2[FPEN] {
              [_, bitzero] => {
                  disabled = true
              },
              0b01 => {
                  disabled = PSTATE.EL == EL0 & HCR_EL2[TGE] == 0b1
              },
              0b11 => {
                  disabled = false
              }
            };
            if disabled then {
                AArch64_AdvSIMDFPAccessTrap(EL2)
            };
            ()
        } else {
            if CPTR_EL2[TSM] == 0b1 then {
                SMEAccessTrap(SMEExceptionType_AccessTrap, EL2)
            };
            if CPTR_EL2[TFP] == 0b1 then {
                AArch64_AdvSIMDFPAccessTrap(EL2)
            };
            ()
        }
    };
    if HaveEL(EL3) then {
        if CPTR_EL3[ESM] == 0b0 then {
            SMEAccessTrap(SMEExceptionType_AccessTrap, EL3)
        };
        if CPTR_EL3[TFP] == 0b1 then {
            AArch64_AdvSIMDFPAccessTrap(EL3)
        };
        ()
    };
    ()
}

val CheckStreamingSVEEnabled : unit -> unit

function CheckStreamingSVEEnabled () = {
    CheckSMEEnabled();
    if PSTATE.SM == 0b0 then {
        SMEAccessTrap(SMEExceptionType_NotStreaming, PSTATE.EL)
    };
    ()
}

val CheckSVEEnabled : unit -> unit

function CheckSVEEnabled () = {
    if HaveSME() & PSTATE.SM == 0b1 then {
        CheckSMEEnabled()
    } else if HaveSME() & not_bool(HaveSVE()) then {
        CheckStreamingSVEEnabled()
    } else {
        CheckOriginalSVEEnabled()
    }
}

val CheckSMEAndZAEnabled : unit -> unit

function CheckSMEAndZAEnabled () = {
    CheckSMEEnabled();
    if PSTATE.ZA == 0b0 then {
        SMEAccessTrap(SMEExceptionType_InactiveZA, PSTATE.EL)
    };
    ()
}

val CheckNonStreamingSVEEnabled : unit -> unit

function CheckNonStreamingSVEEnabled () = {
    CheckSVEEnabled();
    if (HaveSME() & PSTATE.SM == 0b1) & not_bool(IsFullA64Enabled()) then {
        SMEAccessTrap(SMEExceptionType_Streaming, PSTATE.EL)
    };
    ()
}

val CheckStreamingSVEAndZAEnabled : unit -> unit

function CheckStreamingSVEAndZAEnabled () = {
    CheckStreamingSVEEnabled();
    if PSTATE.ZA == 0b0 then {
        SMEAccessTrap(SMEExceptionType_InactiveZA, PSTATE.EL)
    };
    ()
}

val CheckSMEZT0Enabled : unit -> unit

function CheckSMEZT0Enabled () = {
    if PSTATE.ZA == 0b0 then {
        SMEAccessTrap(SMEExceptionType_InactiveZA, PSTATE.EL)
    };
    if (PSTATE.EL == EL0 | PSTATE.EL == EL1) & not_bool(IsInHost()) then {
        if SMCR_EL1[EZT0] == 0b0 then {
            SMEAccessTrap(SMEExceptionType_InaccessibleZT0, EL1)
        };
        ()
    };
    if (PSTATE.EL == EL0 | PSTATE.EL == EL1 | PSTATE.EL == EL2) & EL2Enabled() then {
        if SMCR_EL2[EZT0] == 0b0 then {
            SMEAccessTrap(SMEExceptionType_InaccessibleZT0, EL2)
        };
        ()
    };
    if HaveEL(EL3) then {
        if SMCR_EL3[EZT0] == 0b0 then {
            SMEAccessTrap(SMEExceptionType_InaccessibleZT0, EL3)
        };
        ()
    };
    ()
}

val CheckSMEAccess : unit -> unit

function CheckSMEAccess () = {
    disabled : bool = undefined;
    if (PSTATE.EL == EL0 | PSTATE.EL == EL1) & not_bool(IsInHost()) then {
        match CPACR_EL1[SMEN] {
          [_, bitzero] => {
              disabled = true
          },
          0b01 => {
              disabled = PSTATE.EL == EL0
          },
          0b11 => {
              disabled = false
          }
        };
        if disabled then {
            SMEAccessTrap(SMEExceptionType_AccessTrap, EL1)
        };
        ()
    };
    if (PSTATE.EL == EL0 | PSTATE.EL == EL1 | PSTATE.EL == EL2) & EL2Enabled() then {
        if HaveVirtHostExt() & HCR_EL2[E2H] == 0b1 then {
            match CPTR_EL2[SMEN] {
              [_, bitzero] => {
                  disabled = true
              },
              0b01 => {
                  disabled = PSTATE.EL == EL0 & HCR_EL2[TGE] == 0b1
              },
              0b11 => {
                  disabled = false
              }
            };
            if disabled then {
                SMEAccessTrap(SMEExceptionType_AccessTrap, EL2)
            };
            ()
        } else {
            if CPTR_EL2[TSM] == 0b1 then {
                SMEAccessTrap(SMEExceptionType_AccessTrap, EL2)
            };
            ()
        }
    };
    if HaveEL(EL3) then {
        if CPTR_EL3[ESM] == 0b0 then {
            SMEAccessTrap(SMEExceptionType_AccessTrap, EL3)
        };
        ()
    };
    ()
}

val ResetSMEState : unit -> unit

function ResetSMEState () = {
    let 'vectors_name = DIV(MAX_VL, 8);
    foreach (n from 0 to (vectors_name - 1) by 1 in inc) {
        _ZA[n] = Zeros(MAX_VL)
    };
    _ZT0 = Zeros(ZT0_LEN)
}

val SetPSTATE_SM : bits(1) -> unit

function SetPSTATE_SM value_name = {
    if PSTATE.SM != value_name then {
        ResetSVEState();
        PSTATE.SM = value_name
    };
    ()
}

val SetPSTATE_ZA : bits(1) -> unit

function SetPSTATE_ZA value_name = {
    if PSTATE.ZA != value_name then {
        ResetSMEState();
        PSTATE.ZA = value_name
    };
    ()
}

val SetPSTATE_SVCR : bits(32) -> unit

function SetPSTATE_SVCR svcr = {
    SetPSTATE_SM([svcr[0]]);
    SetPSTATE_ZA([svcr[1]])
}

val Z_read : forall 'n 'width, 'width >= 0.
  (int('n), int('width)) -> bits('width)

function Z_read (n, width) = {
    let 'VL = CurrentVL_read();
    assert(n >= 0 & n <= 31);
    assert(width == VL);
    return(_Z[n][width - 1 .. 0])
}

val P_read : forall 'n 'width,
  'width >= 0 & ('n < 16 | not(('n >= 0 & 'n <= 31))).
  (int('n), int('width)) -> bits('width)

function P_read (n, width) = {
    let 'VL = CurrentVL_read();
    assert(n >= 0 & n <= 31);
    assert(width == DIV(VL, 8));
    return(_P[n][width - 1 .. 0])
}

val FFR_read : forall 'width, 'width >= 0. int('width) -> bits('width)

function FFR_read width = {
    let 'VL = CurrentVL_read();
    assert(width == DIV(VL, 8));
    return(_FFR[width - 1 .. 0])
}

val MemSingleNF_read : forall ('aligned : Bool) 'size, 'size > 0.
  (bits(64), int('size), AccessDescriptor, bool('aligned)) -> (bits(8 * 'size), bool)

function MemSingleNF_read (address, size, accdesc_in, aligned) = {
    assert(accdesc_in.acctype == AccessType_SVE);
    assert(accdesc_in.nonfault | accdesc_in.firstfault & not_bool(accdesc_in.first));
    value_name : bits(8 * 'size) = undefined;
    memstatus : PhysMemRetStatus = undefined;
    accdesc : AccessDescriptor = accdesc_in;
    fault : FaultRecord = NoFault__1(accdesc);
    if ConstrainUnpredictableBool(Unpredictable_NONFAULT) then {
        return((__UNKNOWN_bits(8 * size), true))
    };
    if HaveMTE2Ext() & accdesc.tagchecked then {
        accdesc.tagchecked = AArch64_AccessIsTagChecked(address, accdesc)
    };
    let memaddrdesc : AddressDescriptor = AArch64_TranslateAddress(address, accdesc, aligned, size);
    if memaddrdesc.memattrs.memtype == MemType_Device then {
        return((__UNKNOWN_bits(8 * size), true))
    };
    if IsFault(memaddrdesc) then {
        return((__UNKNOWN_bits(8 * size), true))
    };
    if HaveMTE2Ext() & accdesc.tagchecked then {
        let ptag : bits(4) = AArch64_PhysicalTag(address);
        if not_bool(AArch64_CheckTag(memaddrdesc, accdesc, ptag)) then {
            return((__UNKNOWN_bits(8 * size), true))
        };
        ()
    };
    (memstatus, value_name) = PhysMemRead(memaddrdesc, size, accdesc, None()); // TODO: TranslationInfo
    if IsFault__2(memstatus) then {
        let iswrite : bool = false;
        if IsExternalAbortTakenSynchronously(memstatus, iswrite, memaddrdesc, size, accdesc) then {
            return((__UNKNOWN_bits(8 * size), true))
        };
        fault.merrorstate = memstatus.merrorstate;
        fault.extflag = memstatus.extflag;
        fault.statuscode = memstatus.statuscode;
        PendSErrorInterrupt(fault)
    };
    return((value_name, false))
}

val MemNF_read : forall 'size,
  'size in {1, 2, 4, 8, 16}.
  (bits(64), int('size), AccessDescriptor) -> (bits(8 * 'size), bool)

function MemNF_read (address, size, accdesc) = {
    c : Constraint = undefined;
    assert(size == 1 | size == 2 | size == 4 | size == 8 | size == 16);
    value_name : bits(8 * 'size) = undefined;
    bad : bool = undefined;
    aligned : bool = IsAligned__1(address, size);
    if not_bool(aligned) & AlignmentEnforced() then {
        return((__UNKNOWN_bits(8 * size), true))
    };
    let atomic : bool = aligned | size == 1;
    if not_bool(atomic) then {
        (value_name[7 .. 0], bad) = MemSingleNF_read(address, 1, accdesc, aligned);
        if bad then {
            return((__UNKNOWN_bits(8 * size), true))
        };
        if not_bool(aligned) then {
            let c : Constraint = ConstrainUnpredictable(Unpredictable_DEVPAGE2);
            assert(c == Constraint_FAULT | c == Constraint_NONE);
            if c == Constraint_NONE then {
                aligned = true
            };
            ()
        };
        foreach (i from 1 to (size - 1) by 1 in inc) {
            (value_name[8 * i + 7 .. 8 * i], bad) = MemSingleNF_read(address + i, 1, accdesc, aligned);
            if bad then {
                return((__UNKNOWN_bits(8 * size), true))
            };
            ()
        }
    } else {
        (value_name, bad) = MemSingleNF_read(address, size, accdesc, aligned);
        if bad then {
            return((__UNKNOWN_bits(8 * size), true))
        };
        ()
    };
    if BigEndian(accdesc.acctype) then {
        value_name = BigEndianReverse(value_name)
    };
    let value_name = value_name;
    return((value_name, false))
}

val ActivePredicateElement : forall 'N 'e 'esize, 'N >= 0.
  (bits('N), int('e), int('esize)) -> bool

function ActivePredicateElement (pred, e, esize) = {
    assert(esize == 8 | esize == 16 | esize == 32 | esize == 64 | esize == 128);
    let 'n = e * DIV(esize, 8);
    assert(n >= 0 & n < 'N);
    return([pred[n]] == 0b1)
}

val PredicateElement : forall 'N 'e 'esize, 'N >= 0.
  (bits('N), int('e), int('esize)) -> bits(1)

function PredicateElement (pred, e, esize) = {
    assert(esize == 8 | esize == 16 | esize == 32 | esize == 64 | esize == 128);
    let 'n = e * DIV(esize, 8);
    assert(n >= 0 & n < 'N);
    return([pred[n]])
}

val FirstActive : forall 'N 'esize, 'N >= 0.
  (bits('N), bits('N), int('esize)) -> bits(1)

function FirstActive (mask, x, esize) = {
    let 'elements = DIV('N, DIV(esize, 8));
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        if ActivePredicateElement(mask, e, esize) then {
            return(PredicateElement(x, e, esize))
        };
        ()
    };
    return(0b0)
}

val LastActive : forall 'N 'esize, 'N >= 0.
  (bits('N), bits('N), int('esize)) -> bits(1)

function LastActive (mask, x, esize) = {
    let 'elements = DIV('N, DIV(esize, 8));
    foreach (e from (elements - 1) to 0 by 1 in dec) {
        if ActivePredicateElement(mask, e, esize) then {
            return(PredicateElement(x, e, esize))
        };
        ()
    };
    return(0b0)
}

val NoneActive : forall 'N 'esize, 'N >= 0.
  (bits('N), bits('N), int('esize)) -> bits(1)

function NoneActive (mask, x, esize) = {
    let 'elements = DIV('N, DIV(esize, 8));
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        if ActivePredicateElement(mask, e, esize) & ActivePredicateElement(x, e, esize) then {
            return(0b0)
        };
        ()
    };
    return(0b1)
}

val ElemFFR_read : forall 'e 'esize. (int('e), int('esize)) -> bits(1)

function ElemFFR_read (e, esize) = {
    return(PredicateElement(_FFR, e, esize))
}

val ElemFFR_set : forall 'e 'esize. (int('e), int('esize), bits(1)) -> unit

function ElemFFR_set (e, esize, value_name) = {
    let 'VL = CurrentVL_read();
    let 'psize = DIV(esize, 8);
    let 'n = e * psize;
    assert(n >= 0 & n + psize <= DIV(VL, 8));
    assert(constraint('n <= 'n + 'psize - 1));
    _FFR[n + psize - 1 .. n] = ZeroExtend(value_name, psize);
    return()
}

val LastActiveElement : forall 'N 'esize, 'N >= 0.
  (bits('N), int('esize)) -> int

function LastActiveElement (mask, esize) = {
    let 'elements = DIV('N, DIV(esize, 8));
    foreach (e from (elements - 1) to 0 by 1 in dec) {
        if ActivePredicateElement(mask, e, esize) then {
            return(e)
        };
        ()
    };
    return(negate(1))
}

val AnyActiveElement : forall 'N 'esize, 'N >= 0.
  (bits('N), int('esize)) -> bool

function AnyActiveElement (mask, esize) = {
    return(LastActiveElement(mask, esize) >= 0)
}

val FPCompareUN : forall 'N, 'N in {16, 32, 64}.
  (bits('N), bits('N), FPCRType) -> bool

function FPCompareUN (op1, op2, fpcr) = {
    sign1 : bits(1) = undefined;
    sign2 : bits(1) = undefined;
    type1 : FPType = undefined;
    type2 : FPType = undefined;
    value1_name : real = undefined;
    value2_name : real = undefined;
    assert('N == 16 | 'N == 32 | 'N == 64);
    (type1, sign1, value1_name) = FPUnpack(op1, fpcr);
    (type2, sign2, value2_name) = FPUnpack(op2, fpcr);
    if type1 == FPType_SNaN | type2 == FPType_SNaN then {
        FPProcessException(FPExc_InvalidOp, fpcr)
    };
    let result : bool = (type1 == FPType_SNaN | type1 == FPType_QNaN) | type2 == FPType_SNaN | type2 == FPType_QNaN;
    if not_bool(result) then {
        FPProcessDenorms(type1, type2, 'N, fpcr)
    };
    return(result)
}

val FPCompareNE : forall 'N, 'N in {16, 32, 64}.
  (bits('N), bits('N), FPCRType) -> bool

function FPCompareNE (op1, op2, fpcr) = {
    sign1 : bits(1) = undefined;
    sign2 : bits(1) = undefined;
    type1 : FPType = undefined;
    type2 : FPType = undefined;
    value1_name : real = undefined;
    value2_name : real = undefined;
    assert('N == 16 | 'N == 32 | 'N == 64);
    result : bool = undefined;
    (type1, sign1, value1_name) = FPUnpack(op1, fpcr);
    (type2, sign2, value2_name) = FPUnpack(op2, fpcr);
    let op1_nan : bool = type1 == FPType_SNaN | type1 == FPType_QNaN;
    let op2_nan : bool = type2 == FPType_SNaN | type2 == FPType_QNaN;
    if op1_nan | op2_nan then {
        result = true;
        if type1 == FPType_SNaN | type2 == FPType_SNaN then {
            FPProcessException(FPExc_InvalidOp, fpcr)
        };
        ()
    } else {
        result = value1_name != value2_name;
        FPProcessDenorms(type1, type2, 'N, fpcr)
    };
    return(result)
}

val FPOne : forall 'N, 'N in {16, 32, 64}. (bits(1), int('N)) -> bits('N)

function FPOne (sign, N) = {
    assert(N == 16 | N == 32 | N == 64);
    let 'E = if N == 16 then 5 else if N == 32 then 8 else 11;
    let 'F = N - (E + 1);
    let exp : bits(1 + ('E - 1)) = 0b0 @ Ones(E - 1);
    let frac : bits('F) = Zeros(F);
    return((sign @ exp) @ frac)
}

val FPPointFive : forall 'N, 'N in {16, 32, 64}. (bits(1), int('N)) -> bits('N)

function FPPointFive (sign, N) = {
    assert(N == 16 | N == 32 | N == 64);
    let 'E = if N == 16 then 5 else if N == 32 then 8 else 11;
    let 'F = N - (E + 1);
    let exp : bits(1 + ('E - 2) + 1) = (0b0 @ Ones(E - 2)) @ 0b0;
    let frac : bits('F) = Zeros(F);
    return((sign @ exp) @ frac)
}

val GetOptimizedScale : forall 'N 'scale_in, 'N >= 0.
  (bits('N), int('scale_in), int('N)) -> int

function GetOptimizedScale (op, scale_in, N) = {
    scale : int = scale_in;
    if N == 16 then {
        let 'exp16 = UInt(op[14 .. 10]);
        scale = if scale + exp16 < negate(11) then negate(11) - exp16 else scale;
        scale = if scale + exp16 > 43 then 43 - exp16 else scale
    } else if N == 32 then {
        let 'exp32 = UInt(op[30 .. 23]);
        scale = if scale + exp32 < negate(24) then negate(24) - exp32 else scale;
        scale = if scale + exp32 > 280 then 280 - exp32 else scale
    } else if N == 64 then {
        let 'exp64 = UInt(op[62 .. 52]);
        scale = if scale + exp64 < negate(53) then negate(53) - exp64 else scale;
        scale = if scale + exp64 > 2101 then 2101 - exp64 else scale
    } else ();
    let 'scale = scale;
    return(scale)
}

val FPScale : forall 'N 'scale,
  'N in {16, 32, 64}.
  (bits('N), int('scale), FPCRType) -> bits('N)

function FPScale (op, scale, fpcr) = {
    fptype : FPType = undefined;
    sign : bits(1) = undefined;
    value_name : real = undefined;
    assert('N == 16 | 'N == 32 | 'N == 64);
    result : bits('N) = undefined;
    (fptype, sign, value_name) = FPUnpack(op, fpcr);
    if fptype == FPType_SNaN | fptype == FPType_QNaN then {
        result = FPProcessNaN(fptype, op, fpcr)
    } else if fptype == FPType_Zero then {
        result = FPZero(sign, 'N)
    } else if fptype == FPType_Infinity then {
        result = FPInfinity(sign, 'N)
    } else {
        let 'scale_opt = GetOptimizedScale(op, scale, 'N);
        result = FPRound(value_name * 2.0 ^ scale_opt, fpcr, 'N);
        FPProcessDenorm(fptype, 'N, fpcr)
    };
    return(result)
}

val Reverse : forall 'M 'N, 'N >= 0. (bits('N), int('M)) -> bits('N)

function Reverse (word, M) = {
    result : bits('N) = undefined;
    let 'sw = DIV('N, M);
    assert('N == sw * M);
    foreach (s from 0 to (sw - 1) by 1 in inc) {
        assert(constraint(('loop_s * 'M <= 'loop_s * 'M + 'M - 1 | not(('loop_s >= 0 & ('loop_s + 1) * 'M <= 'N)))));
        result = Elem_set(result, sw - 1 - s, M, Elem_read(word, s, M))
    };
    return(result)
}

val FPTrigSMul : forall 'N, 'N in {16, 32, 64}.
  (bits('N), bits('N), FPCRType) -> bits('N)

function FPTrigSMul (op1, op2, fpcr) = {
    fptype : FPType = undefined;
    sign : bits(1) = undefined;
    value_name : real = undefined;
    assert('N == 16 | 'N == 32 | 'N == 64);
    result : bits('N) = FPMul(op1, op1, fpcr);
    let fpexc : bool = false;
    (fptype, sign, value_name) = FPUnpack__1(result, fpcr, fpexc);
    if not_bool(fptype == FPType_QNaN | fptype == FPType_SNaN) then {
        result['N - 1] = Bit([op2[0]])
    };
    return(result)
}

val FPTrigSSel : forall 'N, 'N in {16, 32, 64}. (bits('N), bits('N)) -> bits('N)

function FPTrigSSel (op1, op2) = {
    assert('N == 16 | 'N == 32 | 'N == 64);
    result : bits('N) = undefined;
    if [op2[0]] == 0b1 then {
        result = FPOne([op2[1]], 'N)
    } else if [op2[1]] == 0b1 then {
        result = FPNeg(op1)
    } else {
        result = op1
    };
    return(result)
}

val FPTrigMAddCoefficient_read : forall 'N 'index,
  'N in {16, 32, 64}.
  (int('index), int('N)) -> bits('N)

function FPTrigMAddCoefficient_read (index, N) = {
    assert(N == 16 | N == 32 | N == 64);
    result : int = undefined;
    if N == 16 then {
        match index {
          0 => {
              result = UInt(0x3c00)
          },
          1 => {
              result = UInt(0xb155)
          },
          2 => {
              result = UInt(0x2030)
          },
          3 => {
              result = UInt(0x0000)
          },
          4 => {
              result = UInt(0x0000)
          },
          5 => {
              result = UInt(0x0000)
          },
          6 => {
              result = UInt(0x0000)
          },
          7 => {
              result = UInt(0x0000)
          },
          8 => {
              result = UInt(0x3c00)
          },
          9 => {
              result = UInt(0xb800)
          },
          10 => {
              result = UInt(0x293a)
          },
          11 => {
              result = UInt(0x0000)
          },
          12 => {
              result = UInt(0x0000)
          },
          13 => {
              result = UInt(0x0000)
          },
          14 => {
              result = UInt(0x0000)
          },
          15 => {
              result = UInt(0x0000)
          },
          _ => ()
        }
    } else if N == 32 then {
        match index {
          0 => {
              result = UInt(0x3f800000)
          },
          1 => {
              result = UInt(0xbe2aaaab)
          },
          2 => {
              result = UInt(0x3c088886)
          },
          3 => {
              result = UInt(0xb95008b9)
          },
          4 => {
              result = UInt(0x36369d6d)
          },
          5 => {
              result = UInt(0x00000000)
          },
          6 => {
              result = UInt(0x00000000)
          },
          7 => {
              result = UInt(0x00000000)
          },
          8 => {
              result = UInt(0x3f800000)
          },
          9 => {
              result = UInt(0xbf000000)
          },
          10 => {
              result = UInt(0x3d2aaaa6)
          },
          11 => {
              result = UInt(0xbab60705)
          },
          12 => {
              result = UInt(0x37cd37cc)
          },
          13 => {
              result = UInt(0x00000000)
          },
          14 => {
              result = UInt(0x00000000)
          },
          15 => {
              result = UInt(0x00000000)
          },
          _ => ()
        }
    } else {
        match index {
          0 => {
              result = UInt(0x3ff0000000000000)
          },
          1 => {
              result = UInt(0xbfc5555555555543)
          },
          2 => {
              result = UInt(0x3f8111111110f30c)
          },
          3 => {
              result = UInt(0xbf2a01a019b92fc6)
          },
          4 => {
              result = UInt(0x3ec71de351f3d22b)
          },
          5 => {
              result = UInt(0xbe5ae5e2b60f7b91)
          },
          6 => {
              result = UInt(0x3de5d8408868552f)
          },
          7 => {
              result = UInt(0x0000000000000000)
          },
          8 => {
              result = UInt(0x3ff0000000000000)
          },
          9 => {
              result = UInt(0xbfe0000000000000)
          },
          10 => {
              result = UInt(0x3fa5555555555536)
          },
          11 => {
              result = UInt(0xbf56c16c16c13a0b)
          },
          12 => {
              result = UInt(0x3efa01a019b1e8d8)
          },
          13 => {
              result = UInt(0xbe927e4f7282f468)
          },
          14 => {
              result = UInt(0x3e21ee96d2641b13)
          },
          15 => {
              result = UInt(0xbda8f76380fbb401)
          },
          _ => ()
        }
    };
    let 'result = result;
    return(result[N - 1 .. 0])
}

val FPTrigMAdd : forall 'N 'x_in,
  'N in {16, 32, 64}.
  (int('x_in), bits('N), bits('N), FPCRType) -> bits('N)

function FPTrigMAdd (x_in, op1, op2_in, fpcr) = {
    assert('N == 16 | 'N == 32 | 'N == 64);
    op2 : bits('N) = op2_in;
    x : int = x_in;
    assert(x >= 0);
    assert(x < 8);
    if [op2['N - 1]] == 0b1 then {
        x = x + 8
    };
    let 'x = x;
    let coeff : bits('N) = FPTrigMAddCoefficient_read(x, 'N);
    let op2 : bits('N) = FPAbs(op2);
    let result : bits('N) = FPMulAdd(coeff, op1, op2, fpcr);
    return(result)
}

val FPExpCoefficient_read : forall 'N 'index,
  'N in {16, 32, 64}.
  (int('index), int('N)) -> bits('N)

function FPExpCoefficient_read (index, N) = {
    assert(N == 16 | N == 32 | N == 64);
    result : int = undefined;
    if N == 16 then {
        match index {
          0 => {
              result = UInt(0x0000)
          },
          1 => {
              result = UInt(0x0016)
          },
          2 => {
              result = UInt(0x002d)
          },
          3 => {
              result = UInt(0x0045)
          },
          4 => {
              result = UInt(0x005d)
          },
          5 => {
              result = UInt(0x0075)
          },
          6 => {
              result = UInt(0x008e)
          },
          7 => {
              result = UInt(0x00a8)
          },
          8 => {
              result = UInt(0x00c2)
          },
          9 => {
              result = UInt(0x00dc)
          },
          10 => {
              result = UInt(0x00f8)
          },
          11 => {
              result = UInt(0x0114)
          },
          12 => {
              result = UInt(0x0130)
          },
          13 => {
              result = UInt(0x014d)
          },
          14 => {
              result = UInt(0x016b)
          },
          15 => {
              result = UInt(0x0189)
          },
          16 => {
              result = UInt(0x01a8)
          },
          17 => {
              result = UInt(0x01c8)
          },
          18 => {
              result = UInt(0x01e8)
          },
          19 => {
              result = UInt(0x0209)
          },
          20 => {
              result = UInt(0x022b)
          },
          21 => {
              result = UInt(0x024e)
          },
          22 => {
              result = UInt(0x0271)
          },
          23 => {
              result = UInt(0x0295)
          },
          24 => {
              result = UInt(0x02ba)
          },
          25 => {
              result = UInt(0x02e0)
          },
          26 => {
              result = UInt(0x0306)
          },
          27 => {
              result = UInt(0x032e)
          },
          28 => {
              result = UInt(0x0356)
          },
          29 => {
              result = UInt(0x037f)
          },
          30 => {
              result = UInt(0x03a9)
          },
          31 => {
              result = UInt(0x03d4)
          },
          _ => ()
        }
    } else if N == 32 then {
        match index {
          0 => {
              result = UInt(0x000000)
          },
          1 => {
              result = UInt(0x0164d2)
          },
          2 => {
              result = UInt(0x02cd87)
          },
          3 => {
              result = UInt(0x043a29)
          },
          4 => {
              result = UInt(0x05aac3)
          },
          5 => {
              result = UInt(0x071f62)
          },
          6 => {
              result = UInt(0x08980f)
          },
          7 => {
              result = UInt(0x0a14d5)
          },
          8 => {
              result = UInt(0x0b95c2)
          },
          9 => {
              result = UInt(0x0d1adf)
          },
          10 => {
              result = UInt(0x0ea43a)
          },
          11 => {
              result = UInt(0x1031dc)
          },
          12 => {
              result = UInt(0x11c3d3)
          },
          13 => {
              result = UInt(0x135a2b)
          },
          14 => {
              result = UInt(0x14f4f0)
          },
          15 => {
              result = UInt(0x16942d)
          },
          16 => {
              result = UInt(0x1837f0)
          },
          17 => {
              result = UInt(0x19e046)
          },
          18 => {
              result = UInt(0x1b8d3a)
          },
          19 => {
              result = UInt(0x1d3eda)
          },
          20 => {
              result = UInt(0x1ef532)
          },
          21 => {
              result = UInt(0x20b051)
          },
          22 => {
              result = UInt(0x227043)
          },
          23 => {
              result = UInt(0x243516)
          },
          24 => {
              result = UInt(0x25fed7)
          },
          25 => {
              result = UInt(0x27cd94)
          },
          26 => {
              result = UInt(0x29a15b)
          },
          27 => {
              result = UInt(0x2b7a3a)
          },
          28 => {
              result = UInt(0x2d583f)
          },
          29 => {
              result = UInt(0x2f3b79)
          },
          30 => {
              result = UInt(0x3123f6)
          },
          31 => {
              result = UInt(0x3311c4)
          },
          32 => {
              result = UInt(0x3504f3)
          },
          33 => {
              result = UInt(0x36fd92)
          },
          34 => {
              result = UInt(0x38fbaf)
          },
          35 => {
              result = UInt(0x3aff5b)
          },
          36 => {
              result = UInt(0x3d08a4)
          },
          37 => {
              result = UInt(0x3f179a)
          },
          38 => {
              result = UInt(0x412c4d)
          },
          39 => {
              result = UInt(0x4346cd)
          },
          40 => {
              result = UInt(0x45672a)
          },
          41 => {
              result = UInt(0x478d75)
          },
          42 => {
              result = UInt(0x49b9be)
          },
          43 => {
              result = UInt(0x4bec15)
          },
          44 => {
              result = UInt(0x4e248c)
          },
          45 => {
              result = UInt(0x506334)
          },
          46 => {
              result = UInt(0x52a81e)
          },
          47 => {
              result = UInt(0x54f35b)
          },
          48 => {
              result = UInt(0x5744fd)
          },
          49 => {
              result = UInt(0x599d16)
          },
          50 => {
              result = UInt(0x5bfbb8)
          },
          51 => {
              result = UInt(0x5e60f5)
          },
          52 => {
              result = UInt(0x60ccdf)
          },
          53 => {
              result = UInt(0x633f89)
          },
          54 => {
              result = UInt(0x65b907)
          },
          55 => {
              result = UInt(0x68396a)
          },
          56 => {
              result = UInt(0x6ac0c7)
          },
          57 => {
              result = UInt(0x6d4f30)
          },
          58 => {
              result = UInt(0x6fe4ba)
          },
          59 => {
              result = UInt(0x728177)
          },
          60 => {
              result = UInt(0x75257d)
          },
          61 => {
              result = UInt(0x77d0df)
          },
          62 => {
              result = UInt(0x7a83b3)
          },
          63 => {
              result = UInt(0x7d3e0c)
          },
          _ => ()
        }
    } else {
        match index {
          0 => {
              result = UInt(0x0000000000000)
          },
          1 => {
              result = UInt(0x02C9A3E778061)
          },
          2 => {
              result = UInt(0x059B0D3158574)
          },
          3 => {
              result = UInt(0x0874518759BC8)
          },
          4 => {
              result = UInt(0x0B5586CF9890F)
          },
          5 => {
              result = UInt(0x0E3EC32D3D1A2)
          },
          6 => {
              result = UInt(0x11301D0125B51)
          },
          7 => {
              result = UInt(0x1429AAEA92DE0)
          },
          8 => {
              result = UInt(0x172B83C7D517B)
          },
          9 => {
              result = UInt(0x1A35BEB6FCB75)
          },
          10 => {
              result = UInt(0x1D4873168B9AA)
          },
          11 => {
              result = UInt(0x2063B88628CD6)
          },
          12 => {
              result = UInt(0x2387A6E756238)
          },
          13 => {
              result = UInt(0x26B4565E27CDD)
          },
          14 => {
              result = UInt(0x29E9DF51FDEE1)
          },
          15 => {
              result = UInt(0x2D285A6E4030B)
          },
          16 => {
              result = UInt(0x306FE0A31B715)
          },
          17 => {
              result = UInt(0x33C08B26416FF)
          },
          18 => {
              result = UInt(0x371A7373AA9CB)
          },
          19 => {
              result = UInt(0x3A7DB34E59FF7)
          },
          20 => {
              result = UInt(0x3DEA64C123422)
          },
          21 => {
              result = UInt(0x4160A21F72E2A)
          },
          22 => {
              result = UInt(0x44E086061892D)
          },
          23 => {
              result = UInt(0x486A2B5C13CD0)
          },
          24 => {
              result = UInt(0x4BFDAD5362A27)
          },
          25 => {
              result = UInt(0x4F9B2769D2CA7)
          },
          26 => {
              result = UInt(0x5342B569D4F82)
          },
          27 => {
              result = UInt(0x56F4736B527DA)
          },
          28 => {
              result = UInt(0x5AB07DD485429)
          },
          29 => {
              result = UInt(0x5E76F15AD2148)
          },
          30 => {
              result = UInt(0x6247EB03A5585)
          },
          31 => {
              result = UInt(0x6623882552225)
          },
          32 => {
              result = UInt(0x6A09E667F3BCD)
          },
          33 => {
              result = UInt(0x6DFB23C651A2F)
          },
          34 => {
              result = UInt(0x71F75E8EC5F74)
          },
          35 => {
              result = UInt(0x75FEB564267C9)
          },
          36 => {
              result = UInt(0x7A11473EB0187)
          },
          37 => {
              result = UInt(0x7E2F336CF4E62)
          },
          38 => {
              result = UInt(0x82589994CCE13)
          },
          39 => {
              result = UInt(0x868D99B4492ED)
          },
          40 => {
              result = UInt(0x8ACE5422AA0DB)
          },
          41 => {
              result = UInt(0x8F1AE99157736)
          },
          42 => {
              result = UInt(0x93737B0CDC5E5)
          },
          43 => {
              result = UInt(0x97D829FDE4E50)
          },
          44 => {
              result = UInt(0x9C49182A3F090)
          },
          45 => {
              result = UInt(0xA0C667B5DE565)
          },
          46 => {
              result = UInt(0xA5503B23E255D)
          },
          47 => {
              result = UInt(0xA9E6B5579FDBF)
          },
          48 => {
              result = UInt(0xAE89F995AD3AD)
          },
          49 => {
              result = UInt(0xB33A2B84F15FB)
          },
          50 => {
              result = UInt(0xB7F76F2FB5E47)
          },
          51 => {
              result = UInt(0xBCC1E904BC1D2)
          },
          52 => {
              result = UInt(0xC199BDD85529C)
          },
          53 => {
              result = UInt(0xC67F12E57D14B)
          },
          54 => {
              result = UInt(0xCB720DCEF9069)
          },
          55 => {
              result = UInt(0xD072D4A07897C)
          },
          56 => {
              result = UInt(0xD5818DCFBA487)
          },
          57 => {
              result = UInt(0xDA9E603DB3285)
          },
          58 => {
              result = UInt(0xDFC97337B9B5F)
          },
          59 => {
              result = UInt(0xE502EE78B3FF6)
          },
          60 => {
              result = UInt(0xEA4AFA2A490DA)
          },
          61 => {
              result = UInt(0xEFA1BEE615A27)
          },
          62 => {
              result = UInt(0xF50765B6E4540)
          },
          63 => {
              result = UInt(0xFA7C1819E90D8)
          },
          _ => ()
        }
    };
    let 'result = result;
    return(result[N - 1 .. 0])
}

val FPExpA : forall 'N, 'N in {16, 32, 64}. bits('N) -> bits('N)

function FPExpA op = {
    assert('N == 16 | 'N == 32 | 'N == 64);
    result : bits('N) = undefined;
    let 'idx = if 'N == 16 then UInt(op[4 .. 0]) else UInt(op[5 .. 0]);
    let coeff : bits('N) = FPExpCoefficient_read(idx, 'N);
    if 'N == 16 then {
        result[15 .. 0] = (0b0 @ op[9 .. 5]) @ coeff[9 .. 0]
    } else if 'N == 32 then {
        result[31 .. 0] = (0b0 @ op[13 .. 6]) @ coeff[22 .. 0]
    } else {
        result[63 .. 0] = (0b0 @ op[16 .. 6]) @ coeff[51 .. 0]
    };
    return(result)
}

val PredTest : forall 'N 'esize, 'N >= 0.
  (bits('N), bits('N), int('esize)) -> bits(4)

function PredTest (mask, result, esize) = {
    let n : bits(1) = FirstActive(mask, result, esize);
    let z : bits(1) = NoneActive(mask, result, esize);
    let c : bits(1) = not_vec(LastActive(mask, result, esize));
    let v : bits(1) = 0b0;
    return(((n @ z) @ c) @ v)
}

val DecodePredCount : forall 'esize. (bits(5), int('esize)) -> int

function DecodePredCount (pattern, esize) = {
    let 'VL = CurrentVL_read();
    let 'elements = DIV(VL, esize);
    numElem : int = undefined;
    match pattern {
      0b00000 => {
          numElem = FloorPow2(elements)
      },
      0b00001 => {
          numElem = if elements >= 1 then 1 else 0
      },
      0b00010 => {
          numElem = if elements >= 2 then 2 else 0
      },
      0b00011 => {
          numElem = if elements >= 3 then 3 else 0
      },
      0b00100 => {
          numElem = if elements >= 4 then 4 else 0
      },
      0b00101 => {
          numElem = if elements >= 5 then 5 else 0
      },
      0b00110 => {
          numElem = if elements >= 6 then 6 else 0
      },
      0b00111 => {
          numElem = if elements >= 7 then 7 else 0
      },
      0b01000 => {
          numElem = if elements >= 8 then 8 else 0
      },
      0b01001 => {
          numElem = if elements >= 16 then 16 else 0
      },
      0b01010 => {
          numElem = if elements >= 32 then 32 else 0
      },
      0b01011 => {
          numElem = if elements >= 64 then 64 else 0
      },
      0b01100 => {
          numElem = if elements >= 128 then 128 else 0
      },
      0b01101 => {
          numElem = if elements >= 256 then 256 else 0
      },
      0b11101 => {
          numElem = elements - MOD(elements, 4)
      },
      0b11110 => {
          numElem = elements - MOD(elements, 3)
      },
      0b11111 => {
          numElem = elements
      },
      _ => {
          numElem = 0
      }
    };
    let 'numElem = numElem;
    return(numElem)
}

val Reduce : forall 'N 'esize,
  ('N in {16, 32, 64, 128, 256, 512, 1024, 2048} & 'esize in {8, 16, 32, 64} & 'N >= 'esize).
  (ReduceOp, bits('N), int('esize)) -> bits('esize)

val Reduce__1 : forall 'N 'esize,
  ('N in {16, 32, 64, 128, 256, 512, 1024, 2048} & 'esize in {8, 16, 32, 64} & 'N >= 'esize).
  (ReduceOp, bits('N), int('esize), bool) -> bits('esize)

function Reduce (op, input, esize) = {
    let altfp : bool = (HaveAltFP() & not_bool(UsingAArch32())) & FPCR[AH] == 0b1;
    return(Reduce__1(op, input, esize, altfp))
}

function Reduce__1 (op, input, esize, altfp) = {
    assert(esize == 8 | esize == 16 | esize == 32 | esize == 64);
    result : bits('esize) = undefined;
    if 'N == esize then {
        return(input[esize - 1 .. 0])
    };
    let 'half = DIV('N, 2);
    assert(constraint((('N - 1 - 'half + 1 == 16 | 'N - 1 - 'half + 1 == 32 | 'N - 1 - 'half + 1 == 64 | 'N - 1 - 'half + 1 == 128 | 'N - 1 - 'half + 1 == 256 | 'N - 1 - 'half + 1 == 512 | 'N - 1 - 'half + 1 == 1024 | 'N - 1 - 'half + 1 == 2048) & 'esize in {8, 16, 32, 64} & 'N - 1 - 'half + 1 >= 'esize)));
    let hi : bits('esize) = Reduce__1(op, input['N - 1 .. half], esize, altfp);
    let lo : bits('esize) = Reduce__1(op, input[half - 1 .. 0], esize, altfp);
    match op {
      ReduceOp_FMINNUM => {
          assert(constraint('esize in {16, 32, 64}));
          result = FPMinNum(lo, hi, FPCR_read())
      },
      ReduceOp_FMAXNUM => {
          assert(constraint('esize in {16, 32, 64}));
          result = FPMaxNum(lo, hi, FPCR_read())
      },
      ReduceOp_FMIN => {
          assert(constraint('esize in {16, 32, 64}));
          result = FPMin__1(lo, hi, FPCR_read(), altfp)
      },
      ReduceOp_FMAX => {
          assert(constraint('esize in {16, 32, 64}));
          result = FPMax__1(lo, hi, FPCR_read(), altfp)
      },
      ReduceOp_FADD => {
          assert(constraint('esize in {16, 32, 64}));
          result = FPAdd(lo, hi, FPCR_read())
      },
      ReduceOp_ADD => {
          result = lo + hi
      }
    };
    let result = result;
    return(result)
}

val ReducePredicated : forall 'M 'N 'esize,
  ('N >= 0 & 'M >= 0 & 'esize >= 0).
  (ReduceOp, bits('N), bits('M), bits('esize)) -> bits('esize)

function ReducePredicated (op, input, mask, identity) = {
    assert('N == 'M * 8);
    let 'p2bits = CeilPow2('N);
    operand : bits('p2bits) = undefined;
    let 'elements = DIV(p2bits, 'esize);
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        if e * 'esize < 'N & ActivePredicateElement(mask, e, 'esize) then {
            assert(constraint('N >= 0));
            assert(constraint('esize >= 0));
            assert(constraint(('loop_e * 'esize <= 'loop_e * 'esize + 'esize - 1 | not(('loop_e >= 0 & ('loop_e + 1) * 'esize <= 'N)))));
            operand = Elem_set(operand, e, 'esize, Elem_read(input, e, 'esize))
        } else {
            assert(constraint('p2bits >= 0));
            assert(constraint('esize >= 0));
            assert(constraint(('loop_e * 'esize <= ('loop_e + 1) * 'esize - 1 | not(('loop_e >= 0 & ('loop_e + 1) * 'esize <= 'p2bits)))));
            operand = Elem_set(operand, e, 'esize, identity)
        }
    };
    assert(constraint(('p2bits in {16, 32, 64, 128, 256, 512, 1024, 2048} & 'esize in {8, 16, 32, 64} & 'p2bits >= 'esize | not('N == 'M * 8))));
    return(Reduce(op, operand, 'esize))
}

val DecodeBitMasks : forall 'M ('immediate : Bool), 'M >= 0.
  (bits(1), bits(6), bits(6), bool('immediate), int('M)) -> (bits('M), bits('M))

function DecodeBitMasks (immN, imms, immr, immediate, M) = {
    let 'len = HighestSetBit(immN @ not_vec(imms));
    if len < 1 then {
        throw(Error_Undefined())
    };
    assert(M >= (1 << len));
    assert(constraint(6 >= 'len));
    let levels : bits(6) = ZeroExtend(Ones(len), 6);
    if immediate & (imms & levels) == levels then {
        throw(Error_Undefined())
    };
    let 's = UInt(imms & levels);
    let 'r = UInt(immr & levels);
    let 'diff = s - r;
    let 'esize = (1 << len);
    let 'd = UInt(diff[len - 1 .. 0]);
    assert(constraint('esize >= 's + 1));
    let welem : bits('esize) = ZeroExtend(Ones(s + 1), esize);
    assert(constraint('esize >= 'd + 1));
    let telem : bits('esize) = ZeroExtend(Ones(d + 1), esize);
    assert(constraint('esize * div('M, 'esize) == 'M));
    let wmask : bits('M) = Replicate(ROR(welem, r), DIV(M, esize));
    let tmask : bits('M) = Replicate(telem, DIV(M, esize));
    return((wmask, tmask))
}

val FPConvertSVE : forall 'M 'N,
  ('M in {16, 32, 64} & 'N in {16, 32, 64}).
  (bits('N), FPCRType, FPRounding, int('M)) -> bits('M)

val FPConvertSVE__1 : forall 'M 'N,
  ('M in {16, 32, 64} & 'N in {16, 32, 64}).
  (bits('N), FPCRType, int('M)) -> bits('M)

function FPConvertSVE (op, fpcr_in, rounding, M) = {
    fpcr : FPCRType = fpcr_in;
    fpcr[AHP] = 0b0;
    return(FPConvert(op, fpcr, rounding, M))
}

function FPConvertSVE__1 (op, fpcr_in, M) = {
    fpcr : FPCRType = fpcr_in;
    fpcr[AHP] = 0b0;
    return(FPConvert(op, fpcr, FPRoundingMode(fpcr), M))
}

val IsEven : forall 'val_name. int('val_name) -> bool

function IsEven val_name = {
    return(MOD(val_name, 2) == 0)
}

val HaveSVEFP32MatMulExt : unit -> bool

function HaveSVEFP32MatMulExt () = {
    return(IsFeatureImplemented(FEAT_F32MM))
}

val HaveSVEFP64MatMulExt : unit -> bool

function HaveSVEFP64MatMulExt () = {
    return(IsFeatureImplemented(FEAT_F64MM))
}

val HaveSVE2 : unit -> bool

function HaveSVE2 () = {
    return(IsFeatureImplemented(FEAT_SVE2))
}

val HaveSVE2AES : unit -> bool

function HaveSVE2AES () = {
    return(IsFeatureImplemented(FEAT_SVE_AES))
}

val HaveSVE2PMULL128 : unit -> bool

function HaveSVE2PMULL128 () = {
    return(IsFeatureImplemented(FEAT_SVE_PMULL128))
}

val HaveSVE2SHA3 : unit -> bool

function HaveSVE2SHA3 () = {
    return(IsFeatureImplemented(FEAT_SVE_SHA3))
}

val HaveSVE2SM4 : unit -> bool

function HaveSVE2SM4 () = {
    return(IsFeatureImplemented(FEAT_SVE_SM4))
}

val HaveSVE2BitPerm : unit -> bool

function HaveSVE2BitPerm () = {
    return(IsFeatureImplemented(FEAT_SVE_BitPerm))
}

val HaveSVE2p1 : unit -> bool

function HaveSVE2p1 () = {
    return(IsFeatureImplemented(FEAT_SVE2p1))
}

val HaveSVEB16B16 : unit -> bool

function HaveSVEB16B16 () = {
    return(IsFeatureImplemented(FEAT_SVE_B16B16))
}

val ShiftSat : forall 'esize 'shift. (int('shift), int('esize)) -> int

function ShiftSat (shift, esize) = {
    if shift > esize + 1 then {
        return(esize + 1)
    } else if shift < negate(esize + 1) then {
        return(negate(esize + 1))
    } else ();
    return(shift)
}

val BitDeposit : forall 'N, 'N >= 0. (bits('N), bits('N)) -> bits('N)

function BitDeposit (data, mask) = {
    res : bits('N) = Zeros('N);
    db : int = 0;
    foreach (rb from 0 to ('N - 1) by 1 in inc) {
        if [mask[rb]] == 0b1 then {
            let 'db = db in
              {
                  assert(constraint((0 <= 'db & 'db < 'N)));
                  res[rb] = Bit([data[db]])
              };
            db = db + 1
        };
        ()
    };
    return(res)
}

val BitExtract : forall 'N, 'N >= 0. (bits('N), bits('N)) -> bits('N)

function BitExtract (data, mask) = {
    res : bits('N) = Zeros('N);
    rb : int = 0;
    foreach (db from 0 to ('N - 1) by 1 in inc) {
        if [mask[db]] == 0b1 then {
            let 'rb = rb in
              {
                  assert(constraint((0 <= 'rb & 'rb < 'N)));
                  res[rb] = Bit([data[db]])
              };
            rb = rb + 1
        };
        ()
    };
    return(res)
}

val BitGroup : forall 'N, 'N >= 0. (bits('N), bits('N)) -> bits('N)

function BitGroup (data, mask) = {
    res : bits('N) = undefined;
    rb : int = 0;
    foreach (db from 0 to ('N - 1) by 1 in inc) {
        if [mask[db]] == 0b1 then {
            let 'rb = rb in
              {
                  assert(constraint((0 <= 'rb & 'rb < 'N)));
                  res[rb] = Bit([data[db]])
              };
            rb = rb + 1
        };
        ()
    };
    foreach (db from 0 to ('N - 1) by 1 in inc) {
        if [mask[db]] == 0b0 then {
            let 'rb = rb in
              {
                  assert(constraint((0 <= 'rb & 'rb < 'N)));
                  res[rb] = Bit([data[db]])
              };
            rb = rb + 1
        };
        ()
    };
    return(res)
}

val FPLogB : forall 'N, 'N in {16, 32, 64}. (bits('N), FPCRType) -> bits('N)

function FPLogB (op, fpcr) = {
    fptype : FPType = undefined;
    sign : bits(1) = undefined;
    value_name : real = undefined;
    assert('N == 16 | 'N == 32 | 'N == 64);
    result : int = undefined;
    (fptype, sign, value_name) = FPUnpack(op, fpcr);
    if (fptype == FPType_SNaN | fptype == FPType_QNaN) | fptype == FPType_Zero then {
        FPProcessException(FPExc_InvalidOp, fpcr);
        result = negate(2 ^ ('N - 1))
    } else if fptype == FPType_Infinity then {
        result = pow2('N - 1) - 1
    } else {
        value_name : real = Abs(value_name);
        result = 0;
        while value_name < 1.0 do {
            value_name = value_name * 2.0;
            result = result - 1
        };
        while value_name >= 2.0 do {
            value_name = value_name / 2.0;
            result = result + 1
        };
        FPProcessDenorm(fptype, 'N, fpcr)
    };
    let 'result = result;
    return(result['N - 1 .. 0])
}

val HaveSMEF64F64 : unit -> bool

function HaveSMEF64F64 () = {
    return(IsFeatureImplemented(FEAT_SME_F64F64))
}

val HaveSMEI16I64 : unit -> bool

function HaveSMEI16I64 () = {
    return(IsFeatureImplemented(FEAT_SME_I16I64))
}

val ZAvector_read : forall 'index 'width, 'width >= 0.
  (int('index), int('width)) -> bits('width)

function ZAvector_read (index, width) = {
    let 'SVL = CurrentSVL_read();
    assert(width == SVL);
    assert(index >= 0 & index < DIV(width, 8));
    return(_ZA[index][width - 1 .. 0])
}

val ZAvector_set : forall 'index 'width, 'width >= 0.
  (int('index), int('width), bits('width)) -> unit

function ZAvector_set (index, width, value_name) = {
    let 'SVL = CurrentSVL_read();
    assert(width == SVL);
    assert(index >= 0 & index < DIV(width, 8));
    if ConstrainUnpredictableBool(Unpredictable_SMEZEROUPPER) then {
        _ZA[index] = ZeroExtend(value_name, MAX_VL)
    } else {
        _ZA[index][width - 1 .. 0] = value_name
    }
}

val ZAhslice_read : forall 'esize 'slice_name 'tile 'width,
  'width >= 0.
  (int('tile), int('esize), int('slice_name), int('width)) -> bits('width)

function ZAhslice_read (tile, esize, slice_name, width) = {
    let 'SVL = CurrentSVL_read();
    assert(esize == 8 | esize == 16 | esize == 32 | esize == 64 | esize == 128);
    let 'tiles = DIV(esize, 8);
    assert(tile >= 0 & tile < tiles);
    let 'slices = DIV(SVL, esize);
    assert(slice_name >= 0 & slice_name < slices);
    return(ZAvector_read(tile + slice_name * tiles, width))
}

val ZAhslice_set : forall 'esize 'slice_name 'tile 'width,
  'width >= 0.
  (int('tile), int('esize), int('slice_name), int('width), bits('width)) -> unit

function ZAhslice_set (tile, esize, slice_name, width, value_name) = {
    let 'SVL = CurrentSVL_read();
    assert(esize == 8 | esize == 16 | esize == 32 | esize == 64 | esize == 128);
    let 'tiles = DIV(esize, 8);
    assert(tile >= 0 & tile < tiles);
    let 'slices = DIV(SVL, esize);
    assert(slice_name >= 0 & slice_name < slices);
    ZAvector_set(tile + slice_name * tiles, width) = value_name
}

val ZAvslice_read : forall 'esize 'slice_name 'tile 'width,
  'width >= 0 & 'esize >= 0 & ('slice_name * 'esize <= 'slice_name * 'esize + 'esize - 1 | not(('slice_name >= 0 & ('slice_name + 1) * 'esize <= 'width))).
  (int('tile), int('esize), int('slice_name), int('width)) -> bits('width)

function ZAvslice_read (tile, esize, slice_name, width) = {
    let 'SVL = CurrentSVL_read();
    let 'slices = DIV(SVL, esize);
    result : bits('width) = undefined;
    foreach (s from 0 to (slices - 1) by 1 in inc) {
        let hslice : bits('width) = ZAhslice_read(tile, esize, s, width);
        assert(constraint(('loop_s * 'esize <= ('loop_s + 1) * 'esize - 1 | not(('loop_s >= 0 & ('loop_s + 1) * 'esize <= 'width)))));
        result = Elem_set(result, s, esize, Elem_read(hslice, slice_name, esize))
    };
    return(result)
}

val ZAvslice_set : forall 'esize 'slice_name 'tile 'width,
  'width >= 0 & 'esize >= 0.
  (int('tile), int('esize), int('slice_name), int('width), bits('width)) -> unit

function ZAvslice_set (tile, esize, slice_name, width, value_name) = {
    let 'SVL = CurrentSVL_read();
    let 'slices = DIV(SVL, esize);
    foreach (s from 0 to (slices - 1) by 1 in inc) {
        hslice : bits('width) = ZAhslice_read(tile, esize, s, width);
        assert(constraint(('loop_s * 'esize <= 'loop_s * 'esize + 'esize - 1 | not(('loop_s >= 0 & ('loop_s + 1) * 'esize <= 'width)))));
        hslice = Elem_set(hslice, slice_name, esize, Elem_read(value_name, s, esize));
        ZAhslice_set(tile, esize, s, width) = hslice
    }
}

val ZAslice_read : forall 'esize 'slice_name 'tile ('vertical : Bool) 'width,
  'width >= 0.
  (int('tile), int('esize), bool('vertical), int('slice_name), int('width)) -> bits('width)

function ZAslice_read (tile, esize, vertical, slice_name, width) = {
    result : bits('width) = undefined;
    if vertical then {
        assert(constraint('width >= 0));
        assert(constraint('esize >= 0));
        assert(constraint(('slice_name * 'esize <= 'slice_name * 'esize + 'esize - 1 | not(('slice_name >= 0 & ('slice_name + 1) * 'esize <= 'width)))));
        result = ZAvslice_read(tile, esize, slice_name, width)
    } else {
        result = ZAhslice_read(tile, esize, slice_name, width)
    };
    return(result)
}

val ZAslice_set : forall 'esize 'slice_name 'tile ('vertical : Bool) 'width,
  'width >= 0.
  (int('tile), int('esize), bool('vertical), int('slice_name), int('width), bits('width)) -> unit

function ZAslice_set (tile, esize, vertical, slice_name, width, value_name) = {
    if vertical then {
        assert(constraint('width >= 0));
        assert(constraint('esize >= 0));
        ZAvslice_set(tile, esize, slice_name, width) = value_name
    } else {
        ZAhslice_set(tile, esize, slice_name, width) = value_name
    }
}

val ZAtile_read : forall 'SVL 'esize 'tile 'width,
  'width >= 0.
  (int('SVL), int('tile), int('esize), int('width)) -> bits('width)

function ZAtile_read (SVL, tile, esize, width) = {
    let 'slices = DIV(SVL, esize);
    assert(width == SVL * slices);
    result : bits('width) = undefined;
    foreach (slice_name from 0 to (slices - 1) by 1 in inc) {
        assert(constraint(('loop_slice_name * 'SVL <= ('loop_slice_name + 1) * 'SVL - 1 | not(('loop_slice_name >= 0 & ('loop_slice_name + 1) * 'SVL <= 'width)))));
        result = Elem_set(result, slice_name, SVL, ZAhslice_read(tile, esize, slice_name, SVL))
    };
    return(result)
}

val ZAtile_set : forall 'SVL 'esize 'tile 'width,
  'width >= 0.
  (int('SVL), int('tile), int('esize), int('width), bits('width)) -> unit

function ZAtile_set (SVL, tile, esize, width, value_name) = {
    let 'slices = DIV(SVL, esize);
    assert(width == SVL * slices);
    foreach (slice_name from 0 to (slices - 1) by 1 in inc) {
        assert(constraint(('loop_slice_name * 'SVL <= 'loop_slice_name * 'SVL + 'SVL - 1 | not(('loop_slice_name >= 0 & ('loop_slice_name + 1) * 'SVL <= 'width)))));
        ZAhslice_set(tile, esize, slice_name, SVL) = Elem_read(value_name, slice_name, SVL)
    }
}

val HaveSME2 : unit -> bool

function HaveSME2 () = {
    return(IsFeatureImplemented(FEAT_SME2))
}

val HaveSME2p1 : unit -> bool

function HaveSME2p1 () = {
    return(IsFeatureImplemented(FEAT_SME2p1))
}

val HaveSMEB16B16 : unit -> bool

function HaveSMEB16B16 () = {
    return(IsFeatureImplemented(FEAT_SVE_B16B16))
}

val HaveSMEF16F16 : unit -> bool

function HaveSMEF16F16 () = {
    return(IsFeatureImplemented(FEAT_SME_F16F16))
}

val ZT0_read : forall 'width, 'width == 512. int('width) -> bits('width)

function ZT0_read width = {
    assert(width == 512);
    return(_ZT0[width - 1 .. 0])
}

val ZT0_set : forall 'width, 'width == 512. (int('width), bits('width)) -> unit

function ZT0_set (width, value_name) = {
    assert(width == 512);
    _ZT0[width - 1 .. 0] = value_name
}

val CounterToPredicate : forall 'width, 'width >= 0.
  (bits(16), int('width)) -> bits('width)

function CounterToPredicate (pred, width) = {
    let 'VL = CurrentVL_read();
    count : int = undefined;
    esize : {8, 16, 32, 64} = 8;
    let 'VL = VL;
    let 'PL = DIV(VL, 8);
    let 'maxbit = HighestSetBit(CeilPow2(PL * 4)[15 .. 0]);
    assert(maxbit <= 14);
    let invert : bool = [pred[15]] == 0b1;
    assert(((width == PL | width == PL * 2) | width == PL * 3) | width == PL * 4);
    if IsZero(pred[3 .. 0]) then {
        return(Zeros(width))
    };
    match pred[3 .. 0] {
      [_, _, _, bitone] => {
          assert(constraint((1 <= 'maxbit & 'maxbit < 16)));
          count = UInt(pred[maxbit .. 1]);
          esize = 8
      },
      [_, _, bitone, bitzero] => {
          assert(constraint((2 <= 'maxbit & 'maxbit < 16)));
          count = UInt(pred[maxbit .. 2]);
          esize = 16
      },
      [_, bitone, bitzero, bitzero] => {
          assert(constraint((3 <= 'maxbit & 'maxbit < 16)));
          count = UInt(pred[maxbit .. 3]);
          esize = 32
      },
      0b1000 => {
          assert(constraint((4 <= 'maxbit & 'maxbit < 16)));
          count = UInt(pred[maxbit .. 4]);
          esize = 64
      },
      _ => ()
    };
    let 'esize = esize;
    let 'count = count;
    let 'elements = DIV(VL * 4, esize);
    result : bits('PL * 4) = Zeros(PL * 4);
    let 'psize = DIV(esize, 8);
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        pbit : bits(1) = if e < count then 0b1 else 0b0;
        if invert then {
            pbit = not_vec(pbit)
        };
        result = Elem_set(result, e, psize, ZeroExtend(pbit, psize))
    };
    return(result[width - 1 .. 0])
}

val EncodePredCount : forall 'count_in 'elements 'esize ('invert_in : Bool) 'width,
  'width >= 0.
  (int('esize), int('elements), int('count_in), bool('invert_in), int('width)) -> bits('width)

function EncodePredCount (esize, elements, count_in, invert_in, width) = {
    let 'VL = CurrentVL_read();
    count : int = count_in;
    invert : bool = invert_in;
    let 'PL = DIV(VL, 8);
    assert(width == PL);
    assert(esize == 8 | esize == 16 | esize == 32 | esize == 64);
    assert(count >= 0 & count <= elements);
    pred : bits(16) = undefined;
    if count == 0 then {
        return(Zeros(width))
    };
    if invert then {
        count = elements - count
    } else if count == elements then {
        count = 0;
        invert = true
    } else ();
    let 'count = count;
    let inv : bits(1) = if invert then 0b1 else 0b0;
    match esize {
      8 => {
          pred = (inv @ count[13 .. 0]) @ 0b1
      },
      16 => {
          pred = (inv @ count[12 .. 0]) @ 0b10
      },
      32 => {
          pred = (inv @ count[11 .. 0]) @ 0b100
      },
      64 => {
          pred = (inv @ count[10 .. 0]) @ 0b1000
      },
      _ => ()
    };
    return(ZeroExtend(pred, width))
}

val PredCountTest : forall 'count 'elements ('invert : Bool).
  (int('elements), int('count), bool('invert)) -> bits(4)

function PredCountTest (elements, count, invert) = {
    c : bits(1) = undefined;
    n : bits(1) = undefined;
    let z : bits(1) = if count == 0 then 0b1 else 0b0;
    if not_bool(invert) then {
        n = if count != 0 then 0b1 else 0b0;
        c = if count == elements then 0b0 else 0b1
    } else {
        n = if count == elements then 0b1 else 0b0;
        c = if count != 0 then 0b0 else 0b1
    };
    let v : bits(1) = 0b0;
    return(((n @ z) @ c) @ v)
}

val GCSSynchronizationBarrier : unit -> unit

function GCSSynchronizationBarrier () = {
    return()
}

val GCSPCREnabled : bits(2) -> bool

function GCSPCREnabled el = {
    return(GCSPCRSelected(el) & GCSEnabled(el))
}

val GCSReturnValueCheckEnabled : bits(2) -> bool

function GCSReturnValueCheckEnabled el = {
    if UsingAArch32() then {
        return(false)
    };
    match el {
      ? if ? == EL0 => {
          return(GCSCRE0_EL1[RVCHKEN] == 0b1)
      },
      ? if ? == EL1 => {
          return(GCSCR_EL1[RVCHKEN] == 0b1)
      },
      ? if ? == EL2 => {
          return(GCSCR_EL2[RVCHKEN] == 0b1)
      },
      ? if ? == EL3 => {
          return(GCSCR_EL3[RVCHKEN] == 0b1)
      },
      _ => {
          return(undefined : bool)
      }
    }
}

val GetCurrentGCSPointer : unit -> bits(64)

function GetCurrentGCSPointer () = {
    ptr : bits(64) = undefined;
    match PSTATE.EL {
      ? if ? == EL0 => {
          ptr = GCSPR_EL0[PTR] @ 0b000
      },
      ? if ? == EL1 => {
          ptr = GCSPR_EL1[PTR] @ 0b000
      },
      ? if ? == EL2 => {
          ptr = GCSPR_EL2[PTR] @ 0b000
      },
      ? if ? == EL3 => {
          ptr = GCSPR_EL3[PTR] @ 0b000
      },
      _ => ()
    };
    return(ptr)
}

val SetCurrentGCSPointer : bits(64) -> unit

function SetCurrentGCSPointer ptr = {
    match PSTATE.EL {
      ? if ? == EL0 => {
          GCSPR_EL0[PTR] = ptr[63 .. 3]
      },
      ? if ? == EL1 => {
          GCSPR_EL1[PTR] = ptr[63 .. 3]
      },
      ? if ? == EL2 => {
          GCSPR_EL2[PTR] = ptr[63 .. 3]
      },
      ? if ? == EL3 => {
          GCSPR_EL3[PTR] = ptr[63 .. 3]
      },
      _ => ()
    };
    return()
}

val AddGCSRecord : bits(64) -> unit

function AddGCSRecord vaddress = {
    let accdesc : AccessDescriptor = CreateAccDescGCS(PSTATE.EL, MemOp_STORE);
    ptr : bits(64) = GetCurrentGCSPointer();
    Mem_set(ptr - 8, 8, accdesc) = vaddress;
    let ptr : bits(64) = ptr - 8;
    SetCurrentGCSPointer(ptr);
    return()
}

val AddGCSExRecord : (bits(64), bits(64), bits(64)) -> unit

function AddGCSExRecord (elr, spsr, lr) = {
    let accdesc : AccessDescriptor = CreateAccDescGCS(PSTATE.EL, MemOp_STORE);
    ptr : bits(64) = GetCurrentGCSPointer();
    Mem_set(ptr - 8, 8, accdesc) = lr;
    Mem_set(ptr - 16, 8, accdesc) = spsr;
    Mem_set(ptr - 24, 8, accdesc) = elr;
    Mem_set(ptr - 32, 8, accdesc) = Zeros(60) @ 0b1001;
    let ptr : bits(64) = ptr - 32;
    SetCurrentGCSPointer(ptr);
    return()
}

val GCSDataCheckException : GCSInstruction -> unit

function GCSDataCheckException gcsinst_type = {
    target_el : bits(2) = undefined;
    let preferred_exception_return : bits(64) = ThisInstrAddr(64);
    let 'vect_offset = UInt(0x0);
    rn_unknown : bool = false;
    is_ret : bool = false;
    if PSTATE.EL == EL0 then {
        target_el = if HCR_EL2[TGE] == 0b0 then EL1 else EL2
    } else {
        target_el = PSTATE.EL
    };
    except : ExceptionRecord = ExceptionSyndrome(Exception_GCSFail);
    match gcsinst_type {
      GCSInstType_PRET => {
          except.syndrome[4 .. 0] = 0b00000;
          is_ret = true
      },
      GCSInstType_POPM => {
          except.syndrome[4 .. 0] = 0b00001
      },
      GCSInstType_PRETAA => {
          except.syndrome[4 .. 0] = 0b00010;
          is_ret = true
      },
      GCSInstType_PRETAB => {
          except.syndrome[4 .. 0] = 0b00011;
          is_ret = true
      },
      GCSInstType_SS1 => {
          except.syndrome[4 .. 0] = 0b00100
      },
      GCSInstType_SS2 => {
          except.syndrome[4 .. 0] = 0b00101;
          rn_unknown = true
      },
      GCSInstType_POPCX => {
          rn_unknown = true;
          except.syndrome[4 .. 0] = 0b01000
      },
      GCSInstType_POPX => {
          except.syndrome[4 .. 0] = 0b01001
      }
    };
    if rn_unknown == true then {
        except.syndrome[9 .. 5] = __UNKNOWN_bits(5)
    } else if is_ret == true then {
        except.syndrome[9 .. 5] = ThisInstr()[9 .. 5]
    } else {
        except.syndrome[9 .. 5] = ThisInstr()[4 .. 0]
    };
    except.syndrome[24 .. 10] = Zeros();
    except.vaddress = __UNKNOWN_bits(64);
    sail_take_exception(None());
    AArch64_TakeException(target_el, except, preferred_exception_return, vect_offset)
}

val LoadCheckGCSRecord : (bits(64), GCSInstruction) -> bits(64)

function LoadCheckGCSRecord (vaddress, gcsinst_type) = {
    let accdesc : AccessDescriptor = CreateAccDescGCS(PSTATE.EL, MemOp_LOAD);
    let ptr : bits(64) = GetCurrentGCSPointer();
    let recorded_va : bits(64) = Mem_read(ptr, 8, accdesc);
    if GCSReturnValueCheckEnabled(PSTATE.EL) & recorded_va != vaddress then {
        GCSDataCheckException(gcsinst_type)
    };
    return(recorded_va)
}

val CheckGCSExRecord : (bits(64), bits(64), bits(64), GCSInstruction) -> unit

function CheckGCSExRecord (elr, spsr, lr, gcsinst_type) = {
    let accdesc : AccessDescriptor = CreateAccDescGCS(PSTATE.EL, MemOp_LOAD);
    ptr : bits(64) = GetCurrentGCSPointer();
    let recorded_first_dword : bits(64) = Mem_read(ptr, 8, accdesc);
    if recorded_first_dword != (Zeros(60) @ 0b1001) then {
        GCSDataCheckException(gcsinst_type)
    };
    let recorded_elr : bits(64) = Mem_read(ptr + 8, 8, accdesc);
    if recorded_elr != elr then {
        GCSDataCheckException(gcsinst_type)
    };
    let recorded_spsr : bits(64) = Mem_read(ptr + 16, 8, accdesc);
    if recorded_spsr != spsr then {
        GCSDataCheckException(gcsinst_type)
    };
    let recorded_lr : bits(64) = Mem_read(ptr + 24, 8, accdesc);
    if recorded_lr != lr then {
        GCSDataCheckException(gcsinst_type)
    };
    let ptr : bits(64) = ptr + 32;
    SetCurrentGCSPointer(ptr);
    return()
}

val EXLOCKException : unit -> unit

function EXLOCKException () = {
    let preferred_exception_return : bits(64) = ThisInstrAddr(64);
    let 'vect_offset = UInt(0x0);
    except : ExceptionRecord = ExceptionSyndrome(Exception_GCSFail);
    except.syndrome[24] = Bit(Zeros());
    except.syndrome[23 .. 20] = 0b0001;
    except.syndrome[19 .. 0] = Zeros();
    sail_take_exception(None());
    AArch64_TakeException(PSTATE.EL, except, preferred_exception_return, vect_offset)
}

val GCSSTRTrapException : bits(2) -> unit

function GCSSTRTrapException target_el = {
    let preferred_exception_return : bits(64) = ThisInstrAddr(64);
    let 'vect_offset = UInt(0x0);
    except : ExceptionRecord = ExceptionSyndrome(Exception_GCSFail);
    except.syndrome[24] = Bit(Zeros());
    except.syndrome[23 .. 20] = 0b0010;
    except.syndrome[19 .. 15] = Zeros();
    except.syndrome[14 .. 10] = ThisInstr()[9 .. 5];
    except.syndrome[9 .. 5] = ThisInstr()[4 .. 0];
    except.syndrome[4 .. 0] = Zeros();
    sail_take_exception(None());
    AArch64_TakeException(target_el, except, preferred_exception_return, vect_offset)
}

val GCSSS1 : bits(64) -> unit

function GCSSS1 incoming_pointer_name = {
    if not_bool(GCSEnabled(PSTATE.EL)) then {
        EndOfInstruction()
    };
    let accdesc : AccessDescriptor = CreateAccDescGCSSS1(PSTATE.EL);
    let outgoing_pointer : bits(64) = GetCurrentGCSPointer();
    let cmpoperand : bits(64) = incoming_pointer_name[63 .. 12] @ 0b000000000001;
    let operand : bits(64) = outgoing_pointer[63 .. 3] @ 0b101;
    let data : bits(64) = MemAtomic(incoming_pointer_name, cmpoperand, operand, accdesc);
    if data == cmpoperand then {
        SetCurrentGCSPointer(incoming_pointer_name[63 .. 3] @ 0b000)
    } else {
        GCSDataCheckException(GCSInstType_SS1)
    };
    return()
}

val GCSSS2 : unit -> bits(64)

function GCSSS2 () = {
    outgoing_pointer : bits(64) = undefined;
    let accdesc_ld : AccessDescriptor = CreateAccDescGCS(PSTATE.EL, MemOp_LOAD);
    let accdesc_st : AccessDescriptor = CreateAccDescGCS(PSTATE.EL, MemOp_STORE);
    if not_bool(GCSEnabled(PSTATE.EL)) then {
        EndOfInstruction()
    };
    let incoming_pointer_name : bits(64) = GetCurrentGCSPointer();
    outgoing_value : bits(64) = Mem_read(incoming_pointer_name, 8, accdesc_ld);
    if outgoing_value[2 .. 0] == 0b101 then {
        outgoing_pointer[63 .. 3] = outgoing_value[63 .. 3] - 1;
        outgoing_pointer[2 .. 0] = 0b000;
        let outgoing_value : bits(64) = outgoing_pointer[63 .. 12] @ 0b000000000001;
        Mem_set(outgoing_pointer, 8, accdesc_st) = outgoing_value;
        SetCurrentGCSPointer(incoming_pointer_name + 8);
        GCSSynchronizationBarrier()
    } else {
        GCSDataCheckException(GCSInstType_SS2)
    };
    return(outgoing_pointer)
}

val GCSPUSHM : bits(64) -> unit

function GCSPUSHM value_name = {
    if not_bool(GCSEnabled(PSTATE.EL)) then {
        EndOfInstruction()
    };
    AddGCSRecord(value_name);
    return()
}

val GCSPOPM : unit -> bits(64)

function GCSPOPM () = {
    let accdesc : AccessDescriptor = CreateAccDescGCS(PSTATE.EL, MemOp_LOAD);
    if not_bool(GCSEnabled(PSTATE.EL)) then {
        EndOfInstruction()
    };
    ptr : bits(64) = GetCurrentGCSPointer();
    let entry : bits(64) = Mem_read(ptr, 8, accdesc);
    if entry[1 .. 0] != 0b00 then {
        GCSDataCheckException(GCSInstType_POPM)
    };
    let ptr : bits(64) = ptr + 8;
    SetCurrentGCSPointer(ptr);
    return(entry)
}

val GCSPUSHX : unit -> unit

function GCSPUSHX () = {
    let spsr : bits(64) = SPSR_read(64);
    if not_bool(GCSEnabled(PSTATE.EL)) then {
        EndOfInstruction()
    };
    AddGCSExRecord(ELR_read__1(), spsr, X_read(30, 64));
    PSTATE.EXLOCK = 0b0;
    return()
}

val GCSPOPCX : unit -> unit

function GCSPOPCX () = {
    let spsr : bits(64) = SPSR_read(64);
    if not_bool(GCSEnabled(PSTATE.EL)) then {
        EndOfInstruction()
    };
    CheckGCSExRecord(ELR_read__1(), spsr, X_read(30, 64), GCSInstType_POPCX);
    PSTATE.EXLOCK = if GetCurrentEXLOCKEN() then 0b1 else 0b0;
    return()
}

val GCSPOPX : unit -> unit

function GCSPOPX () = {
    if not_bool(GCSEnabled(PSTATE.EL)) then {
        EndOfInstruction()
    };
    let accdesc : AccessDescriptor = CreateAccDescGCS(PSTATE.EL, MemOp_LOAD);
    ptr : bits(64) = GetCurrentGCSPointer();
    let recorded_first_dword : bits(64) = Mem_read(ptr, 8, accdesc);
    if recorded_first_dword != (Zeros(60) @ 0b1001) then {
        GCSDataCheckException(GCSInstType_POPX)
    };
    let recorded_elr : bits(64) = Mem_read(ptr + 8, 8, accdesc);
    let recorded_spsr : bits(64) = Mem_read(ptr + 16, 8, accdesc);
    let recorded_lr : bits(64) = Mem_read(ptr + 24, 8, accdesc);
    let ptr : bits(64) = ptr + 32;
    SetCurrentGCSPointer(ptr);
    return()
}

bitfield HFGITR_EL2_Type : bits(64) =
  {
    COSPRCTX : 60..60,
    nGCSEPP : 59..59,
    nGCSSTR_EL1 : 58..58,
    nGCSPUSHM_EL1 : 57..57,
    nBRBIALL : 56..56,
    nBRBINJ : 55..55,
    DCCVAC : 54..54,
    SVC_EL1 : 53..53,
    SVC_EL0 : 52..52,
    ERET : 51..51,
    CPPRCTX : 50..50,
    DVPRCTX : 49..49,
    CFPRCTX : 48..48,
    TLBIVAALE1 : 47..47,
    TLBIVALE1 : 46..46,
    TLBIVAAE1 : 45..45,
    TLBIASIDE1 : 44..44,
    TLBIVAE1 : 43..43,
    TLBIVMALLE1 : 42..42,
    TLBIRVAALE1 : 41..41,
    TLBIRVALE1 : 40..40,
    TLBIRVAAE1 : 39..39,
    TLBIRVAE1 : 38..38,
    TLBIRVAALE1IS : 37..37,
    TLBIRVALE1IS : 36..36,
    TLBIRVAAE1IS : 35..35,
    TLBIRVAE1IS : 34..34,
    TLBIVAALE1IS : 33..33,
    TLBIVALE1IS : 32..32,
    TLBIVAAE1IS : 31..31,
    TLBIASIDE1IS : 30..30,
    TLBIVAE1IS : 29..29,
    TLBIVMALLE1IS : 28..28,
    TLBIRVAALE1OS : 27..27,
    TLBIRVALE1OS : 26..26,
    TLBIRVAAE1OS : 25..25,
    TLBIRVAE1OS : 24..24,
    TLBIVAALE1OS : 23..23,
    TLBIVALE1OS : 22..22,
    TLBIVAAE1OS : 21..21,
    TLBIASIDE1OS : 20..20,
    TLBIVAE1OS : 19..19,
    TLBIVMALLE1OS : 18..18,
    ATS1E1WP : 17..17,
    ATS1E1RP : 16..16,
    ATS1E0W : 15..15,
    ATS1E0R : 14..14,
    ATS1E1W : 13..13,
    ATS1E1R : 12..12,
    DCZVA : 11..11,
    DCCIVAC : 10..10,
    DCCVADP : 9..9,
    DCCVAP : 8..8,
    DCCVAU : 7..7,
    DCCISW : 6..6,
    DCCSW : 5..5,
    DCISW : 4..4,
    DCIVAC : 3..3,
    ICIVAU : 2..2,
    ICIALLU : 1..1,
    ICIALLUIS : 0..0
  }

register HFGITR_EL2 : HFGITR_EL2_Type

val CheckGCSSTREnabled : unit -> unit

function CheckGCSSTREnabled () = {
    match PSTATE.EL {
      ? if ? == EL0 => {
          if GCSCRE0_EL1[STREn] == 0b0 then {
              if HCR_EL2[TGE] == 0b0 then {
                  GCSSTRTrapException(EL1)
              } else {
                  GCSSTRTrapException(EL2)
              }
          };
          ()
      },
      ? if ? == EL1 => {
          if GCSCR_EL1[STREn] == 0b0 then {
              GCSSTRTrapException(EL1)
          } else if (EL2Enabled() & (not_bool(HaveEL(EL3)) | SCR_EL3[FGTEn] == 0b1)) & HFGITR_EL2[nGCSSTR_EL1] == 0b0 then {
              GCSSTRTrapException(EL2)
          } else ()
      },
      ? if ? == EL2 => {
          if GCSCR_EL2[STREn] == 0b0 then {
              GCSSTRTrapException(EL2)
          };
          ()
      },
      ? if ? == EL3 => {
          if GCSCR_EL3[STREn] == 0b0 then {
              GCSSTRTrapException(EL3)
          };
          ()
      },
      _ => ()
    };
    return()
}

val CheckMOPSEnabled : unit -> unit

function CheckMOPSEnabled () = {
    if (((PSTATE.EL == EL0 | PSTATE.EL == EL1) & EL2Enabled()) & (HCR_EL2[TGE] == 0b0 | HCR_EL2[E2H] == 0b0)) & (not_bool(IsHCRXEL2Enabled()) | HCRX_EL2[MSCEn] == 0b0) then {
        throw(Error_Undefined())
    };
    if (PSTATE.EL == EL0 & SCTLR_EL1[MSCEn] == 0b0) & ((not_bool(EL2Enabled()) | HCR_EL2[TGE] == 0b0) | HCR_EL2[E2H] == 0b0) then {
        throw(Error_Undefined())
    };
    if (PSTATE.EL == EL0 & IsInHost()) & SCTLR_EL2[MSCEn] == 0b0 then {
        throw(Error_Undefined())
    };
    ()
}

val MismatchedCpySetTargetEL : unit -> bits(2)

function MismatchedCpySetTargetEL () = {
    target_el : bits(2) = undefined;
    if UInt(PSTATE.EL) > UInt(EL1) then {
        target_el = PSTATE.EL
    } else if (PSTATE.EL == EL0 & EL2Enabled()) & HCR_EL2[TGE] == 0b1 then {
        target_el = EL2
    } else if ((PSTATE.EL == EL1 & EL2Enabled()) & IsHCRXEL2Enabled()) & HCRX_EL2[MCE2] == 0b1 then {
        target_el = EL2
    } else {
        target_el = EL1
    };
    return(target_el)
}

val MismatchedMemCpyException : forall 'destreg ('from_epilogue : Bool) ('option_a_name : Bool) 'sizereg 'srcreg ('wrong_option : Bool).
  (bool('option_a_name), int('destreg), int('srcreg), int('sizereg), bool('wrong_option), bool('from_epilogue), bits(4)) -> unit

function MismatchedMemCpyException (option_a_name, destreg, srcreg, sizereg, wrong_option, from_epilogue, options_name) = {
    let preferred_exception_return : bits(64) = ThisInstrAddr(64);
    let 'vect_offset = UInt(0x0);
    let target_el : bits(2) = MismatchedCpySetTargetEL();
    except : ExceptionRecord = ExceptionSyndrome(Exception_MemCpyMemSet);
    except.syndrome[24] = Bit(0b0);
    except.syndrome[23] = Bit(0b0);
    except.syndrome[22 .. 19] = options_name;
    except.syndrome[18] = Bit(if from_epilogue then 0b1 else 0b0);
    except.syndrome[17] = Bit(if wrong_option then 0b1 else 0b0);
    except.syndrome[16] = Bit(if option_a_name then 0b1 else 0b0);
    except.syndrome[14 .. 10] = destreg[4 .. 0];
    except.syndrome[9 .. 5] = srcreg[4 .. 0];
    except.syndrome[4 .. 0] = sizereg[4 .. 0];
    sail_take_exception(None());
    AArch64_TakeException(target_el, except, preferred_exception_return, vect_offset)
}

val MismatchedMemSetException : forall 'datareg 'destreg ('from_epilogue : Bool) ('is_SETG : Bool) ('option_a_name : Bool) 'sizereg ('wrong_option : Bool).
  (bool('option_a_name), int('destreg), int('datareg), int('sizereg), bool('wrong_option), bool('from_epilogue), bits(2), bool('is_SETG)) -> unit

function MismatchedMemSetException (option_a_name, destreg, datareg, sizereg, wrong_option, from_epilogue, options_name, is_SETG) = {
    let preferred_exception_return : bits(64) = ThisInstrAddr(64);
    let 'vect_offset = UInt(0x0);
    let target_el : bits(2) = MismatchedCpySetTargetEL();
    except : ExceptionRecord = ExceptionSyndrome(Exception_MemCpyMemSet);
    except.syndrome[24] = Bit(0b1);
    except.syndrome[23] = Bit(if is_SETG then 0b1 else 0b0);
    except.syndrome[20 .. 19] = options_name;
    except.syndrome[18] = Bit(if from_epilogue then 0b1 else 0b0);
    except.syndrome[17] = Bit(if wrong_option then 0b1 else 0b0);
    except.syndrome[16] = Bit(if option_a_name then 0b1 else 0b0);
    except.syndrome[14 .. 10] = destreg[4 .. 0];
    except.syndrome[9 .. 5] = datareg[4 .. 0];
    except.syndrome[4 .. 0] = sizereg[4 .. 0];
    sail_take_exception(None());
    AArch64_TakeException(target_el, except, preferred_exception_return, vect_offset)
}

val CPYOptionA : unit -> bool

function CPYOptionA () = {
    return(__IMPDEF_boolean("CPY* instructions use Option A"))
}

val CPYFOptionA : unit -> bool

function CPYFOptionA () = {
    return(__IMPDEF_boolean("CPYF* instructions use Option A"))
}

val SETOptionA : unit -> bool

function SETOptionA () = {
    return(__IMPDEF_boolean("SET* instructions use Option A"))
}

val SETGOptionA : unit -> bool

function SETGOptionA () = {
    return(__IMPDEF_boolean("SETG* instructions use Option A"))
}

val MaxBlockSizeCopiedBytes : unit -> nat

function MaxBlockSizeCopiedBytes () = {
    let 'nbytes = __IMPDEF_integer("Maximum bytes used in a single block of a copy");
    assert(nbytes >= 0);
    return(nbytes)
}

val CPYPreSizeChoice : (bits(64), bits(64), bits(64)) -> bits(64)

val CPYPostSizeChoice : (bits(64), bits(64), bits(64)) -> bits(64)

val CPYSizeChoice : (bits(64), bits(64), bits(64)) -> int

val MemCpyParametersIllformedM : (bits(64), bits(64), bits(64)) -> bool

val MemCpyParametersIllformedE : (bits(64), bits(64), bits(64)) -> bool

val SETPreSizeChoice : forall ('IsSETGP : Bool).
  (bits(64), bits(64), bool('IsSETGP)) -> bits(64)

val SETPostSizeChoice : forall ('IsSETGE : Bool).
  (bits(64), bits(64), bool('IsSETGE)) -> bits(64)

val SETSizeChoice : forall 'AlignSize.
  (bits(64), bits(64), int('AlignSize)) -> int

val MemSetParametersIllformedM : forall ('IsSETGM : Bool).
  (bits(64), bits(64), bool('IsSETGM)) -> bool

val MemSetParametersIllformedE : forall ('IsSETGE : Bool).
  (bits(64), bits(64), bool('IsSETGE)) -> bool

val MemCpyDirectionChoice : (bits(64), bits(64), bits(64)) -> bool

val MemCpyZeroSizeCheck : unit -> bool

val MemSetZeroSizeCheck : unit -> bool

val BFRound : forall 'N, 'N == 32. (real, int('N)) -> bits('N)

function BFRound (op, N) = {
    assert(N == 32);
    assert(op != 0.0);
    result : bits('N) = undefined;
    let 'minimum_exp = negate(126);
    let 'E = 8;
    let 'F = 23;
    sign : bits(1) = undefined;
    mantissa : real = undefined;
    if op < 0.0 then {
        sign = 0b1;
        mantissa = neg_real(op)
    } else {
        sign = 0b0;
        mantissa = op
    };
    exponent : int = 0;
    while mantissa < 1.0 do {
        mantissa = mantissa * 2.0;
        exponent = exponent - 1
    };
    while mantissa >= 2.0 do {
        mantissa = mantissa / 2.0;
        exponent = exponent + 1
    };
    let 'exponent = exponent;
    if exponent < minimum_exp then {
        return(FPZero(sign, N))
    };
    let 'biased_exp = Max(exponent - minimum_exp + 1, 0);
    if biased_exp == 0 then {
        mantissa = mantissa / 2.0 ^ (minimum_exp - exponent)
    };
    let mantissa = mantissa;
    int_mant : int = RoundDown(mantissa * 2.0 ^ F);
    let error : real = mantissa * 2.0 ^ F - Real(int_mant);
    if error != 0.0 then {
        int_mant = [int_mant with 0 .. 0 = 0b1]
    };
    let 'int_mant = int_mant;
    if biased_exp >= pow2(E) - 1 then {
        result = FPInfinity(sign, N)
    } else {
        result = (sign @ biased_exp[N - 2 - F .. 0]) @ int_mant[F - 1 .. 0]
    };
    return(result)
}

val BFUnpack : forall 'N, 'N in {16, 32}. bits('N) -> (FPType, bits(1), real)

function BFUnpack fpval = {
    assert('N == 16 | 'N == 32);
    sign : bits(1) = undefined;
    exp : bits(8) = undefined;
    frac : bits(23) = undefined;
    if 'N == 16 then {
        sign = [fpval[15]];
        exp = fpval[14 .. 7];
        frac = fpval[6 .. 0] @ Zeros(16)
    } else {
        sign = [fpval[31]];
        exp = fpval[30 .. 23];
        frac = fpval[22 .. 0]
    };
    fptype : FPType = undefined;
    value_name : real = undefined;
    if IsZero(exp) then {
        fptype = FPType_Zero;
        value_name = 0.0
    } else if IsOnes(exp) then {
        if IsZero(frac) then {
            fptype = FPType_Infinity;
            value_name = 2.0 ^ 1000000
        } else {
            fptype = FPType_QNaN;
            value_name = 0.0
        }
    } else {
        fptype = FPType_Nonzero;
        value_name = 2.0 ^ (UInt(exp) - 127) * (1.0 + Real(UInt(frac)) * 2.0 ^ negate(23))
    };
    if sign == 0b1 then {
        value_name = neg_real(value_name)
    };
    let value_name = value_name;
    return((fptype, sign, value_name))
}

val BFMulH : forall 'N, 'N == 16. (bits('N), bits('N)) -> bits(2 * 'N)

function BFMulH (op1, op2) = {
    inf1 : bool = undefined;
    inf2 : bool = undefined;
    sign1 : bits(1) = undefined;
    sign2 : bits(1) = undefined;
    type1 : FPType = undefined;
    type2 : FPType = undefined;
    value1_name : real = undefined;
    value2_name : real = undefined;
    zero1 : bool = undefined;
    zero2 : bool = undefined;
    assert('N == 16);
    result : bits(2 * 'N) = undefined;
    let fpcr : FPCRType = FPCR_read();
    (type1, sign1, value1_name) = BFUnpack(op1);
    (type2, sign2, value2_name) = BFUnpack(op2);
    if type1 == FPType_QNaN | type2 == FPType_QNaN then {
        result = FPDefaultNaN__1(fpcr, 2 * 'N)
    } else {
        let inf1 : bool = type1 == FPType_Infinity;
        let inf2 : bool = type2 == FPType_Infinity;
        let zero1 : bool = type1 == FPType_Zero;
        let zero2 : bool = type2 == FPType_Zero;
        if inf1 & zero2 | zero1 & inf2 then {
            result = FPDefaultNaN__1(fpcr, 2 * 'N)
        } else if inf1 | inf2 then {
            result = FPInfinity(EOR(sign1, sign2), 2 * 'N)
        } else if zero1 | zero2 then {
            result = FPZero(EOR(sign1, sign2), 2 * 'N)
        } else {
            result = BFRound(value1_name * value2_name, 2 * 'N)
        }
    };
    return(result)
}

val FPAdd_BF16 : forall 'N, 'N == 32. (bits('N), bits('N)) -> bits('N)

function FPAdd_BF16 (op1, op2) = {
    inf1 : bool = undefined;
    inf2 : bool = undefined;
    result_value : real = undefined;
    sign1 : bits(1) = undefined;
    sign2 : bits(1) = undefined;
    type1 : FPType = undefined;
    type2 : FPType = undefined;
    value1_name : real = undefined;
    value2_name : real = undefined;
    zero1 : bool = undefined;
    zero2 : bool = undefined;
    assert('N == 32);
    result : bits('N) = undefined;
    let fpcr : FPCRType = FPCR_read();
    (type1, sign1, value1_name) = BFUnpack(op1);
    (type2, sign2, value2_name) = BFUnpack(op2);
    if type1 == FPType_QNaN | type2 == FPType_QNaN then {
        result = FPDefaultNaN__1(fpcr, 'N)
    } else {
        let inf1 : bool = type1 == FPType_Infinity;
        let inf2 : bool = type2 == FPType_Infinity;
        let zero1 : bool = type1 == FPType_Zero;
        let zero2 : bool = type2 == FPType_Zero;
        if (inf1 & inf2) & sign1 == not_vec(sign2) then {
            result = FPDefaultNaN__1(fpcr, 'N)
        } else if inf1 & sign1 == 0b0 | inf2 & sign2 == 0b0 then {
            result = FPInfinity(0b0, 'N)
        } else if inf1 & sign1 == 0b1 | inf2 & sign2 == 0b1 then {
            result = FPInfinity(0b1, 'N)
        } else if (zero1 & zero2) & sign1 == sign2 then {
            result = FPZero(sign1, 'N)
        } else {
            let result_value : real = value1_name + value2_name;
            if result_value == 0.0 then {
                result = FPZero(0b0, 'N)
            } else {
                result = BFRound(result_value, 'N)
            }
        }
    };
    return(result)
}

val BFMulAddH : forall 'N, 'N == 32.
  (bits('N), bits(div('N, 2)), bits(div('N, 2)), FPCRType) -> bits('N)

function BFMulAddH (addend, op1, op2, fpcr_in) = {
    assert('N == 32);
    let value1_name : bits('N) = op1 @ Zeros(DIV('N, 2));
    let value2_name : bits('N) = op2 @ Zeros(DIV('N, 2));
    fpcr : FPCRType = fpcr_in;
    let altfp : bool = HaveAltFP() & fpcr[AH] == 0b1;
    let fpexc : bool = not_bool(altfp);
    if altfp then {
        (fpcr[FIZ] @ fpcr[FZ]) = 0b11
    };
    if altfp then {
        fpcr[RMode] = 0b00
    };
    return(FPMulAdd__1(addend, value1_name, value2_name, fpcr, fpexc))
}

val BFMulAddH_ZA : forall 'N, 'N == 32.
  (bits('N), bits(div('N, 2)), bits(div('N, 2)), FPCRType) -> bits('N)

function BFMulAddH_ZA (addend, op1, op2, fpcr) = {
    assert('N == 32);
    let value1_name : bits('N) = op1 @ Zeros(DIV('N, 2));
    let value2_name : bits('N) = op2 @ Zeros(DIV('N, 2));
    return(FPMulAdd_ZA(addend, value1_name, value2_name, fpcr))
}

val FPRoundBF : forall 'N ('fpexc : Bool), 'N == 32.
  (real, FPCRType, FPRounding, bool('fpexc), int('N)) -> bits('N)

function FPRoundBF (op, fpcr, rounding, fpexc, N) = {
    assert(N == 32);
    let isbfloat16 : bool = true;
    return(FPRoundBase__1(op, fpcr, rounding, isbfloat16, fpexc, N))
}

val FPConvertBF : forall 'N, 'N == 32.
  (bits('N), FPCRType, FPRounding) -> bits(div('N, 2))

val FPConvertBF__1 : forall 'N, 'N == 32.
  (bits('N), FPCRType) -> bits(div('N, 2))

function FPConvertBF (op, fpcr_in, rounding_in) = {
    fptype : FPType = undefined;
    sign : bits(1) = undefined;
    value_name : real = undefined;
    assert('N == 32);
    let 'halfsize = DIV('N, 2);
    fpcr : FPCRType = fpcr_in;
    rounding : FPRounding = rounding_in;
    result : bits('N) = undefined;
    let altfp : bool = (HaveAltFP() & not_bool(UsingAArch32())) & fpcr[AH] == 0b1;
    let fpexc : bool = not_bool(altfp);
    if altfp then {
        (fpcr[FIZ] @ fpcr[FZ]) = 0b11
    };
    if altfp then {
        rounding = FPRounding_TIEEVEN
    };
    (fptype, sign, value_name) = FPUnpack__1(op, fpcr, fpexc);
    if fptype == FPType_SNaN | fptype == FPType_QNaN then {
        if fpcr[DN] == 0b1 then {
            result = FPDefaultNaN__1(fpcr, 'N)
        } else {
            result = FPConvertNaN(op, 'N)
        };
        if fptype == FPType_SNaN then {
            if fpexc then {
                FPProcessException(FPExc_InvalidOp, fpcr)
            };
            ()
        };
        ()
    } else if fptype == FPType_Infinity then {
        result = FPInfinity(sign, 'N)
    } else if fptype == FPType_Zero then {
        result = FPZero(sign, 'N)
    } else {
        result = FPRoundBF(value_name, fpcr, rounding, fpexc, 'N)
    };
    return(result[2 * halfsize - 1 .. halfsize])
}

function FPConvertBF__1 (op, fpcr) = {
    return(FPConvertBF(op, fpcr, FPRoundingMode(fpcr)))
}

val FPProcessNaNs4 : forall 'N ('fpexc : Bool), 'N == 32.
  (FPType, FPType, FPType, FPType, bits(div('N, 2)), bits(div('N, 2)), bits(div('N, 2)), bits(div('N, 2)), FPCRType, bool('fpexc)) -> (bool, bits('N))

function FPProcessNaNs4 (type1, type2, type3, type4, op1, op2, op3, op4, fpcr, fpexc) = {
    assert('N == 32);
    result : bits('N) = undefined;
    done : bool = undefined;
    if type1 == FPType_SNaN then {
        done = true;
        result = FPConvertNaN(FPProcessNaN__1(type1, op1, fpcr, fpexc), 'N)
    } else if type2 == FPType_SNaN then {
        done = true;
        result = FPConvertNaN(FPProcessNaN__1(type2, op2, fpcr, fpexc), 'N)
    } else if type3 == FPType_SNaN then {
        done = true;
        result = FPConvertNaN(FPProcessNaN__1(type3, op3, fpcr, fpexc), 'N)
    } else if type4 == FPType_SNaN then {
        done = true;
        result = FPConvertNaN(FPProcessNaN__1(type4, op4, fpcr, fpexc), 'N)
    } else if type1 == FPType_QNaN then {
        done = true;
        result = FPConvertNaN(FPProcessNaN__1(type1, op1, fpcr, fpexc), 'N)
    } else if type2 == FPType_QNaN then {
        done = true;
        result = FPConvertNaN(FPProcessNaN__1(type2, op2, fpcr, fpexc), 'N)
    } else if type3 == FPType_QNaN then {
        done = true;
        result = FPConvertNaN(FPProcessNaN__1(type3, op3, fpcr, fpexc), 'N)
    } else if type4 == FPType_QNaN then {
        done = true;
        result = FPConvertNaN(FPProcessNaN__1(type4, op4, fpcr, fpexc), 'N)
    } else {
        done = false;
        result = Zeros('N)
    };
    return((done, result))
}

val FPDot__1 : forall 'N ('fpexc : Bool) ('isbfloat16 : Bool),
  'N == 32.
  (bits(div('N, 2)), bits(div('N, 2)), bits(div('N, 2)), bits(div('N, 2)), FPCRType, bool('isbfloat16), bool('fpexc)) -> bits('N)

function FPDot__1 (op1_a, op1_b, op2_a, op2_b, fpcr_in, isbfloat16, fpexc) = {
    infPa : bool = undefined;
    infPb : bool = undefined;
    invalidop : bool = undefined;
    result_sign : bits(1) = undefined;
    result_value : real = undefined;
    sign1_a : bits(1) = undefined;
    sign1_b : bits(1) = undefined;
    sign2_a : bits(1) = undefined;
    sign2_b : bits(1) = undefined;
    signPa : bits(1) = undefined;
    signPb : bits(1) = undefined;
    type1_a : FPType = undefined;
    type1_b : FPType = undefined;
    type2_a : FPType = undefined;
    type2_b : FPType = undefined;
    value1_a_name : real = undefined;
    value1_b_name : real = undefined;
    value2_a_name : real = undefined;
    value2_b_name : real = undefined;
    zeroPa : bool = undefined;
    zeroPb : bool = undefined;
    fpcr : FPCRType = fpcr_in;
    assert('N == 32);
    result : bits('N) = undefined;
    done : bool = undefined;
    fpcr[AHP] = 0b0;
    let rounding : FPRounding = FPRoundingMode(fpcr);
    (type1_a, sign1_a, value1_a_name) = FPUnpackBase__1(op1_a, fpcr, fpexc, isbfloat16);
    (type1_b, sign1_b, value1_b_name) = FPUnpackBase__1(op1_b, fpcr, fpexc, isbfloat16);
    (type2_a, sign2_a, value2_a_name) = FPUnpackBase__1(op2_a, fpcr, fpexc, isbfloat16);
    (type2_b, sign2_b, value2_b_name) = FPUnpackBase__1(op2_b, fpcr, fpexc, isbfloat16);
    let inf1_a : bool = type1_a == FPType_Infinity;
    let zero1_a : bool = type1_a == FPType_Zero;
    let inf1_b : bool = type1_b == FPType_Infinity;
    let zero1_b : bool = type1_b == FPType_Zero;
    let inf2_a : bool = type2_a == FPType_Infinity;
    let zero2_a : bool = type2_a == FPType_Zero;
    let inf2_b : bool = type2_b == FPType_Infinity;
    let zero2_b : bool = type2_b == FPType_Zero;
    (done, result) = FPProcessNaNs4(type1_a, type1_b, type2_a, type2_b, op1_a, op1_b, op2_a, op2_b, fpcr, fpexc);
    if (inf1_a & zero2_a | zero1_a & inf2_a) & (inf1_b & zero2_b | zero1_b & inf2_b) then {
        result = FPDefaultNaN__1(fpcr, 'N);
        if fpexc then {
            FPProcessException(FPExc_InvalidOp, fpcr)
        };
        ()
    };
    if not_bool(done) then {
        let signPa : bits(1) = EOR(sign1_a, sign2_a);
        let signPb : bits(1) = EOR(sign1_b, sign2_b);
        let infPa : bool = inf1_a | inf2_a;
        let infPb : bool = inf1_b | inf2_b;
        let zeroPa : bool = zero1_a | zero2_a;
        let zeroPb : bool = zero1_b | zero2_b;
        let invalidop : bool = (((inf1_a & zero2_a | zero1_a & inf2_a) | inf1_b & zero2_b) | zero1_b & inf2_b) | (infPa & infPb) & signPa != signPb;
        if invalidop then {
            result = FPDefaultNaN__1(fpcr, 'N);
            if fpexc then {
                FPProcessException(FPExc_InvalidOp, fpcr)
            };
            ()
        } else if infPa & signPa == 0b0 | infPb & signPb == 0b0 then {
            result = FPInfinity(0b0, 'N)
        } else if infPa & signPa == 0b1 | infPb & signPb == 0b1 then {
            result = FPInfinity(0b1, 'N)
        } else if (zeroPa & zeroPb) & signPa == signPb then {
            result = FPZero(signPa, 'N)
        } else {
            let result_value : real = value1_a_name * value2_a_name + value1_b_name * value2_b_name;
            if result_value == 0.0 then {
                let result_sign : bits(1) = if rounding == FPRounding_NEGINF then
                  0b1
                else
                  0b0;
                result = FPZero(result_sign, 'N)
            } else {
                result = FPRound__2(result_value, fpcr, rounding, fpexc, 'N)
            }
        }
    };
    return(result)
}

val BFDotAdd : forall 'N, 'N == 32.
  (bits('N), bits(div('N, 2)), bits(div('N, 2)), bits(div('N, 2)), bits(div('N, 2)), FPCRType) -> bits('N)

function BFDotAdd (addend, op1_a, op1_b, op2_a, op2_b, fpcr_in) = {
    assert('N == 32);
    fpcr : FPCRType = fpcr_in;
    prod : bits('N) = undefined;
    result : bits('N) = undefined;
    if not_bool(HaveEBF16()) | fpcr[EBF] == 0b0 then {
        let prod : bits('N) = FPAdd_BF16(BFMulH(op1_a, op2_a), BFMulH(op1_b, op2_b));
        result = FPAdd_BF16(addend, prod)
    } else {
        let isbfloat16 : bool = true;
        let fpexc : bool = false;
        fpcr[DN] = 0b1;
        let prod : bits('N) = FPDot__1(op1_a, op1_b, op2_a, op2_b, fpcr, isbfloat16, fpexc);
        result = FPAdd__1(addend, prod, fpcr, fpexc)
    };
    return(result)
}

val BFMatMulAdd : forall 'N, 'N == 128.
  (bits('N), bits('N), bits('N)) -> bits('N)

function BFMatMulAdd (addend, op1, op2) = {
    assert('N == 128);
    result : bits('N) = undefined;
    sum : bits(32) = undefined;
    foreach (i from 0 to 1 by 1 in inc) {
        foreach (j from 0 to 1 by 1 in inc) {
            sum = Elem_read(addend, 2 * i + j, 32);
            foreach (k from 0 to 1 by 1 in inc) {
                let elt1_a : bits(16) = Elem_read(op1, 4 * i + 2 * k + 0, 16);
                let elt1_b : bits(16) = Elem_read(op1, 4 * i + 2 * k + 1, 16);
                let elt2_a : bits(16) = Elem_read(op2, 4 * j + 2 * k + 0, 16);
                let elt2_b : bits(16) = Elem_read(op2, 4 * j + 2 * k + 1, 16);
                sum = BFDotAdd(sum, elt1_a, elt1_b, elt2_a, elt2_b, FPCR_read())
            };
            result = Elem_set(result, 2 * i + j, 32, sum)
        }
    };
    return(result)
}

val BFNeg : forall 'N, 'N == 16. bits('N) -> bits('N)

val BFNeg__1 : forall 'N ('honor_altfp : Bool), 'N == 16.
  (bits('N), bool('honor_altfp)) -> bits('N)

function BFNeg op = {
    assert('N == 16);
    let honor_altfp : bool = true;
    return(BFNeg__1(op, honor_altfp))
}

function BFNeg__1 (op, honor_altfp) = {
    fptype : FPType = undefined;
    assert('N == 16);
    if (honor_altfp & not_bool(UsingAArch32())) & HaveAltFP() then {
        let fpcr : FPCRType = FPCR_read();
        if fpcr[AH] == 0b1 then {
            let fpexc : bool = false;
            let isbfloat16 : bool = true;
            let (__tup_0 : FPType, _, _) =
              FPUnpackBase__1(op, fpcr, fpexc, isbfloat16)
            in
              {
                  fptype = __tup_0
              };
            if fptype == FPType_SNaN | fptype == FPType_QNaN then {
                return(op)
            };
            ()
        };
        ()
    };
    return(not_vec([op['N - 1]]) @ op['N - 2 .. 0])
}

val BFInfinity : forall 'N, 'N == 16. (bits(1), int('N)) -> bits('N)

function BFInfinity (sign, N) = {
    assert(N == 16);
    let 'E = 8;
    let 'F = N - (E + 1);
    return((sign @ Ones(E)) @ Zeros(F))
}

val BFZero : forall 'N, 'N == 16. (bits(1), int('N)) -> bits('N)

function BFZero (sign, N) = {
    assert(N == 16);
    let 'E = 8;
    let 'F = N - (E + 1);
    return((sign @ Zeros(E)) @ Zeros(F))
}

val BFAdd : forall 'N, 'N == 16. (bits('N), bits('N), FPCRType) -> bits('N)

val BFAdd__1 : forall 'N ('fpexc : Bool), 'N == 16.
  (bits('N), bits('N), FPCRType, bool('fpexc)) -> bits('N)

function BFAdd (op1, op2, fpcr) = {
    let fpexc : bool = true;
    return(BFAdd__1(op1, op2, fpcr, fpexc))
}

function BFAdd__1 (op1, op2, fpcr, fpexc) = {
    inf1 : bool = undefined;
    inf2 : bool = undefined;
    result_sign : bits(1) = undefined;
    result_value : real = undefined;
    sign1 : bits(1) = undefined;
    sign2 : bits(1) = undefined;
    type1 : FPType = undefined;
    type2 : FPType = undefined;
    value1_name : real = undefined;
    value2_name : real = undefined;
    zero1 : bool = undefined;
    zero2 : bool = undefined;
    assert('N == 16);
    let rounding : FPRounding = FPRoundingMode(fpcr);
    done : bool = undefined;
    result : bits(2 * 'N) = undefined;
    let op1_s : bits(2 * 'N) = op1 @ Zeros('N);
    let op2_s : bits(2 * 'N) = op2 @ Zeros('N);
    (type1, sign1, value1_name) = FPUnpack__1(op1_s, fpcr, fpexc);
    (type2, sign2, value2_name) = FPUnpack__1(op2_s, fpcr, fpexc);
    (done, result) = FPProcessNaNs__1(type1, type2, op1_s, op2_s, fpcr, fpexc);
    if not_bool(done) then {
        let inf1 : bool = type1 == FPType_Infinity;
        let inf2 : bool = type2 == FPType_Infinity;
        let zero1 : bool = type1 == FPType_Zero;
        let zero2 : bool = type2 == FPType_Zero;
        if (inf1 & inf2) & sign1 == not_vec(sign2) then {
            result = FPDefaultNaN__1(fpcr, 2 * 'N);
            if fpexc then {
                FPProcessException(FPExc_InvalidOp, fpcr)
            };
            ()
        } else if inf1 & sign1 == 0b0 | inf2 & sign2 == 0b0 then {
            result = FPInfinity(0b0, 2 * 'N)
        } else if inf1 & sign1 == 0b1 | inf2 & sign2 == 0b1 then {
            result = FPInfinity(0b1, 2 * 'N)
        } else if (zero1 & zero2) & sign1 == sign2 then {
            result = FPZero(sign1, 2 * 'N)
        } else {
            let result_value : real = value1_name + value2_name;
            if result_value == 0.0 then {
                let result_sign : bits(1) = if rounding == FPRounding_NEGINF then
                  0b1
                else
                  0b0;
                result = FPZero(result_sign, 2 * 'N)
            } else {
                result = FPRoundBF(result_value, fpcr, rounding, fpexc, 2 * 'N)
            }
        };
        if fpexc then {
            FPProcessDenorms(type1, type2, 2 * 'N, fpcr)
        };
        ()
    };
    return(result[2 * 'N - 1 .. 'N])
}

val BFAdd_ZA : forall 'N, 'N == 16. (bits('N), bits('N), FPCRType) -> bits('N)

function BFAdd_ZA (op1, op2, fpcr_in) = {
    let fpexc : bool = false;
    fpcr : FPCRType = fpcr_in;
    fpcr[DN] = 0b1;
    return(BFAdd__1(op1, op2, fpcr, fpexc))
}

val BFSub : forall 'N, 'N == 16. (bits('N), bits('N), FPCRType) -> bits('N)

val BFSub__1 : forall 'N ('fpexc : Bool), 'N == 16.
  (bits('N), bits('N), FPCRType, bool('fpexc)) -> bits('N)

function BFSub (op1, op2, fpcr) = {
    let fpexc : bool = true;
    return(BFSub__1(op1, op2, fpcr, fpexc))
}

function BFSub__1 (op1, op2, fpcr, fpexc) = {
    inf1 : bool = undefined;
    inf2 : bool = undefined;
    result_sign : bits(1) = undefined;
    result_value : real = undefined;
    sign1 : bits(1) = undefined;
    sign2 : bits(1) = undefined;
    type1 : FPType = undefined;
    type2 : FPType = undefined;
    value1_name : real = undefined;
    value2_name : real = undefined;
    zero1 : bool = undefined;
    zero2 : bool = undefined;
    assert('N == 16);
    let rounding : FPRounding = FPRoundingMode(fpcr);
    done : bool = undefined;
    result : bits(2 * 'N) = undefined;
    let op1_s : bits(2 * 'N) = op1 @ Zeros('N);
    let op2_s : bits(2 * 'N) = op2 @ Zeros('N);
    (type1, sign1, value1_name) = FPUnpack__1(op1_s, fpcr, fpexc);
    (type2, sign2, value2_name) = FPUnpack__1(op2_s, fpcr, fpexc);
    (done, result) = FPProcessNaNs__1(type1, type2, op1_s, op2_s, fpcr, fpexc);
    if not_bool(done) then {
        let inf1 : bool = type1 == FPType_Infinity;
        let inf2 : bool = type2 == FPType_Infinity;
        let zero1 : bool = type1 == FPType_Zero;
        let zero2 : bool = type2 == FPType_Zero;
        if (inf1 & inf2) & sign1 == sign2 then {
            result = FPDefaultNaN__1(fpcr, 2 * 'N);
            if fpexc then {
                FPProcessException(FPExc_InvalidOp, fpcr)
            };
            ()
        } else if inf1 & sign1 == 0b0 | inf2 & sign2 == 0b1 then {
            result = FPInfinity(0b0, 2 * 'N)
        } else if inf1 & sign1 == 0b1 | inf2 & sign2 == 0b0 then {
            result = FPInfinity(0b1, 2 * 'N)
        } else if (zero1 & zero2) & sign1 == not_vec(sign2) then {
            result = FPZero(sign1, 2 * 'N)
        } else {
            let result_value : real = value1_name - value2_name;
            if result_value == 0.0 then {
                let result_sign : bits(1) = if rounding == FPRounding_NEGINF then
                  0b1
                else
                  0b0;
                result = FPZero(result_sign, 2 * 'N)
            } else {
                result = FPRoundBF(result_value, fpcr, rounding, fpexc, 2 * 'N)
            }
        };
        if fpexc then {
            FPProcessDenorms(type1, type2, 2 * 'N, fpcr)
        };
        ()
    };
    return(result[2 * 'N - 1 .. 'N])
}

val BFSub_ZA : forall 'N, 'N == 16. (bits('N), bits('N), FPCRType) -> bits('N)

function BFSub_ZA (op1, op2, fpcr_in) = {
    let fpexc : bool = false;
    fpcr : FPCRType = fpcr_in;
    fpcr[DN] = 0b1;
    return(BFSub__1(op1, op2, fpcr, fpexc))
}

val BFMulAdd : forall 'N, 'N == 16.
  (bits('N), bits('N), bits('N), FPCRType) -> bits('N)

val BFMulAdd__1 : forall 'N ('fpexc : Bool), 'N == 16.
  (bits('N), bits('N), bits('N), FPCRType, bool('fpexc)) -> bits('N)

function BFMulAdd (addend, op1, op2, fpcr) = {
    let fpexc : bool = true;
    return(BFMulAdd__1(addend, op1, op2, fpcr, fpexc))
}

function BFMulAdd__1 (addend, op1, op2, fpcr, fpexc) = {
    infA : bool = undefined;
    infP : bool = undefined;
    invalidop : bool = undefined;
    result_sign : bits(1) = undefined;
    result_value : real = undefined;
    sign1 : bits(1) = undefined;
    sign2 : bits(1) = undefined;
    signA : bits(1) = undefined;
    signP : bits(1) = undefined;
    type1 : FPType = undefined;
    type2 : FPType = undefined;
    typeA : FPType = undefined;
    value1_name : real = undefined;
    value2_name : real = undefined;
    valueA_name : real = undefined;
    zeroA : bool = undefined;
    zeroP : bool = undefined;
    assert('N == 16);
    let rounding : FPRounding = FPRoundingMode(fpcr);
    done : bool = undefined;
    result : bits(2 * 'N) = undefined;
    let addend_s : bits(2 * 'N) = addend @ Zeros('N);
    let op1_s : bits(2 * 'N) = op1 @ Zeros('N);
    let op2_s : bits(2 * 'N) = op2 @ Zeros('N);
    (typeA, signA, valueA_name) = FPUnpack__1(addend_s, fpcr, fpexc);
    (type1, sign1, value1_name) = FPUnpack__1(op1_s, fpcr, fpexc);
    (type2, sign2, value2_name) = FPUnpack__1(op2_s, fpcr, fpexc);
    let inf1 : bool = type1 == FPType_Infinity;
    let inf2 : bool = type2 == FPType_Infinity;
    let zero1 : bool = type1 == FPType_Zero;
    let zero2 : bool = type2 == FPType_Zero;
    (done, result) = FPProcessNaNs3__1(typeA, type1, type2, addend_s, op1_s, op2_s, fpcr, fpexc);
    if not_bool((HaveAltFP() & not_bool(UsingAArch32())) & fpcr[AH] == 0b1) then {
        if typeA == FPType_QNaN & (inf1 & zero2 | zero1 & inf2) then {
            result = FPDefaultNaN__1(fpcr, 2 * 'N);
            if fpexc then {
                FPProcessException(FPExc_InvalidOp, fpcr)
            };
            ()
        };
        ()
    };
    if not_bool(done) then {
        let infA : bool = typeA == FPType_Infinity;
        let zeroA : bool = typeA == FPType_Zero;
        let signP : bits(1) = EOR(sign1, sign2);
        let infP : bool = inf1 | inf2;
        let zeroP : bool = zero1 | zero2;
        let invalidop : bool = (inf1 & zero2 | zero1 & inf2) | (infA & infP) & signA != signP;
        if invalidop then {
            result = FPDefaultNaN__1(fpcr, 2 * 'N);
            if fpexc then {
                FPProcessException(FPExc_InvalidOp, fpcr)
            };
            ()
        } else if infA & signA == 0b0 | infP & signP == 0b0 then {
            result = FPInfinity(0b0, 2 * 'N)
        } else if infA & signA == 0b1 | infP & signP == 0b1 then {
            result = FPInfinity(0b1, 2 * 'N)
        } else if (zeroA & zeroP) & signA == signP then {
            result = FPZero(signA, 2 * 'N)
        } else {
            let result_value : real = valueA_name + value1_name * value2_name;
            if result_value == 0.0 then {
                let result_sign : bits(1) = if rounding == FPRounding_NEGINF then
                  0b1
                else
                  0b0;
                result = FPZero(result_sign, 2 * 'N)
            } else {
                result = FPRoundBF(result_value, fpcr, rounding, fpexc, 2 * 'N)
            }
        };
        if not_bool(invalidop) & fpexc then {
            FPProcessDenorms3(typeA, type1, type2, 2 * 'N, fpcr)
        };
        ()
    };
    return(result[2 * 'N - 1 .. 'N])
}

val BFMulAdd_ZA : forall 'N, 'N == 16.
  (bits('N), bits('N), bits('N), FPCRType) -> bits('N)

function BFMulAdd_ZA (addend, op1, op2, fpcr_in) = {
    let fpexc : bool = false;
    fpcr : FPCRType = fpcr_in;
    fpcr[DN] = 0b1;
    return(BFMulAdd__1(addend, op1, op2, fpcr, fpexc))
}

val BFMul : forall 'N, 'N == 16. (bits('N), bits('N), FPCRType) -> bits('N)

val BFMul__1 : forall 'N ('fpexc : Bool), 'N == 16.
  (bits('N), bits('N), FPCRType, bool('fpexc)) -> bits('N)

function BFMul (op1, op2, fpcr) = {
    let fpexc : bool = true;
    return(BFMul__1(op1, op2, fpcr, fpexc))
}

function BFMul__1 (op1, op2, fpcr, fpexc) = {
    inf1 : bool = undefined;
    inf2 : bool = undefined;
    sign1 : bits(1) = undefined;
    sign2 : bits(1) = undefined;
    type1 : FPType = undefined;
    type2 : FPType = undefined;
    value1_name : real = undefined;
    value2_name : real = undefined;
    zero1 : bool = undefined;
    zero2 : bool = undefined;
    assert('N == 16);
    let rounding : FPRounding = FPRoundingMode(fpcr);
    done : bool = undefined;
    result : bits(2 * 'N) = undefined;
    let op1_s : bits(2 * 'N) = op1 @ Zeros('N);
    let op2_s : bits(2 * 'N) = op2 @ Zeros('N);
    (type1, sign1, value1_name) = FPUnpack__1(op1_s, fpcr, fpexc);
    (type2, sign2, value2_name) = FPUnpack__1(op2_s, fpcr, fpexc);
    (done, result) = FPProcessNaNs__1(type1, type2, op1_s, op2_s, fpcr, fpexc);
    if not_bool(done) then {
        let inf1 : bool = type1 == FPType_Infinity;
        let inf2 : bool = type2 == FPType_Infinity;
        let zero1 : bool = type1 == FPType_Zero;
        let zero2 : bool = type2 == FPType_Zero;
        if inf1 & zero2 | zero1 & inf2 then {
            result = FPDefaultNaN__1(fpcr, 2 * 'N);
            if fpexc then {
                FPProcessException(FPExc_InvalidOp, fpcr)
            };
            ()
        } else if inf1 | inf2 then {
            result = FPInfinity(EOR(sign1, sign2), 2 * 'N)
        } else if zero1 | zero2 then {
            result = FPZero(EOR(sign1, sign2), 2 * 'N)
        } else {
            result = FPRoundBF(value1_name * value2_name, fpcr, rounding, fpexc, 2 * 'N)
        };
        if fpexc then {
            FPProcessDenorms(type1, type2, 2 * 'N, fpcr)
        };
        ()
    };
    return(result[2 * 'N - 1 .. 'N])
}

val BFMin : forall 'N, 'N == 16. (bits('N), bits('N), FPCRType) -> bits('N)

val BFMin__1 : forall 'N ('altfp : Bool), 'N == 16.
  (bits('N), bits('N), FPCRType, bool('altfp)) -> bits('N)

function BFMin (op1, op2, fpcr) = {
    let altfp : bool = (HaveAltFP() & not_bool(UsingAArch32())) & fpcr[AH] == 0b1;
    return(BFMin__1(op1, op2, fpcr, altfp))
}

function BFMin__1 (op1, op2, fpcr_in, altfp) = {
    sign1 : bits(1) = undefined;
    sign2 : bits(1) = undefined;
    type1 : FPType = undefined;
    type2 : FPType = undefined;
    value1_name : real = undefined;
    value2_name : real = undefined;
    assert('N == 16);
    fpcr : FPCRType = fpcr_in;
    let fpexc : bool = true;
    let rounding : FPRounding = FPRoundingMode(fpcr);
    done : bool = undefined;
    result : bits(2 * 'N) = undefined;
    let op1_s : bits(2 * 'N) = op1 @ Zeros('N);
    let op2_s : bits(2 * 'N) = op2 @ Zeros('N);
    (type1, sign1, value1_name) = FPUnpack__1(op1_s, fpcr, fpexc);
    (type2, sign2, value2_name) = FPUnpack__1(op2_s, fpcr, fpexc);
    if ((altfp & type1 == FPType_Zero) & type2 == FPType_Zero) & sign1 != sign2 then {
        return(BFZero(sign2, 'N))
    } else if altfp & ((type1 == FPType_SNaN | type1 == FPType_QNaN) | type2 == FPType_SNaN | type2 == FPType_QNaN) then {
        FPProcessException(FPExc_InvalidOp, fpcr);
        return(if type2 == FPType_Zero then BFZero(sign2, 'N) else op2)
    } else ();
    (done, result) = FPProcessNaNs(type1, type2, op1_s, op2_s, fpcr);
    if not_bool(done) then {
        fptype : FPType = undefined;
        sign : bits(1) = undefined;
        value_name : real = undefined;
        if value1_name < value2_name then {
            (fptype, sign, value_name) = (type1, sign1, value1_name)
        } else {
            (fptype, sign, value_name) = (type2, sign2, value2_name)
        };
        if fptype == FPType_Infinity then {
            result = FPInfinity(sign, 2 * 'N)
        } else if fptype == FPType_Zero then {
            let sign : bits(1) = sign1 | sign2;
            result = FPZero(sign, 2 * 'N)
        } else {
            if altfp then {
                fpcr[FZ] = 0b0
            };
            result = FPRoundBF(value_name, fpcr, rounding, fpexc, 2 * 'N)
        };
        if fpexc then {
            FPProcessDenorms(type1, type2, 2 * 'N, fpcr)
        };
        ()
    };
    return(result[2 * 'N - 1 .. 'N])
}

val BFMinNum : forall 'N, 'N == 16. (bits('N), bits('N), FPCRType) -> bits('N)

function BFMinNum (op1_in, op2_in, fpcr) = {
    type1 : FPType = undefined;
    type2 : FPType = undefined;
    assert('N == 16);
    let fpexc : bool = true;
    let isbfloat16 : bool = true;
    op1 : bits('N) = op1_in;
    op2 : bits('N) = op2_in;
    let altfp : bool = (HaveAltFP() & not_bool(UsingAArch32())) & fpcr[AH] == 0b1;
    let (__tup_0 : FPType, _, _) = FPUnpackBase__1(op1, fpcr, fpexc, isbfloat16)
    in
      {
          type1 = __tup_0
      };
    let (__tup_0 : FPType, _, _) = FPUnpackBase__1(op2, fpcr, fpexc, isbfloat16)
    in
      {
          type2 = __tup_0
      };
    let type1_nan : bool = type1 == FPType_QNaN | type1 == FPType_SNaN;
    let type2_nan : bool = type2 == FPType_QNaN | type2 == FPType_SNaN;
    if not_bool((altfp & type1_nan) & type2_nan) then {
        if type1 == FPType_QNaN & type2 != FPType_QNaN then {
            op1 = BFInfinity(0b0, 'N)
        } else if type1 != FPType_QNaN & type2 == FPType_QNaN then {
            op2 = BFInfinity(0b0, 'N)
        } else ()
    };
    let altfmaxfmin : bool = false;
    let result : bits('N) = BFMin__1(op1, op2, fpcr, altfmaxfmin);
    return(result)
}

val BFMax : forall 'N, 'N == 16. (bits('N), bits('N), FPCRType) -> bits('N)

val BFMax__1 : forall 'N ('altfp : Bool), 'N == 16.
  (bits('N), bits('N), FPCRType, bool('altfp)) -> bits('N)

function BFMax (op1, op2, fpcr) = {
    let altfp : bool = (HaveAltFP() & not_bool(UsingAArch32())) & fpcr[AH] == 0b1;
    return(BFMax__1(op1, op2, fpcr, altfp))
}

function BFMax__1 (op1, op2, fpcr_in, altfp) = {
    sign1 : bits(1) = undefined;
    sign2 : bits(1) = undefined;
    type1 : FPType = undefined;
    type2 : FPType = undefined;
    value1_name : real = undefined;
    value2_name : real = undefined;
    assert('N == 16);
    fpcr : FPCRType = fpcr_in;
    let fpexc : bool = true;
    let rounding : FPRounding = FPRoundingMode(fpcr);
    done : bool = undefined;
    result : bits(2 * 'N) = undefined;
    let op1_s : bits(2 * 'N) = op1 @ Zeros('N);
    let op2_s : bits(2 * 'N) = op2 @ Zeros('N);
    (type1, sign1, value1_name) = FPUnpack__1(op1_s, fpcr, fpexc);
    (type2, sign2, value2_name) = FPUnpack__1(op2_s, fpcr, fpexc);
    if ((altfp & type1 == FPType_Zero) & type2 == FPType_Zero) & sign1 != sign2 then {
        return(BFZero(sign2, 'N))
    } else if altfp & ((type1 == FPType_SNaN | type1 == FPType_QNaN) | type2 == FPType_SNaN | type2 == FPType_QNaN) then {
        FPProcessException(FPExc_InvalidOp, fpcr);
        return(if type2 == FPType_Zero then BFZero(sign2, 'N) else op2)
    } else ();
    (done, result) = FPProcessNaNs(type1, type2, op1_s, op2_s, fpcr);
    if not_bool(done) then {
        fptype : FPType = undefined;
        sign : bits(1) = undefined;
        value_name : real = undefined;
        if value1_name > value2_name then {
            (fptype, sign, value_name) = (type1, sign1, value1_name)
        } else {
            (fptype, sign, value_name) = (type2, sign2, value2_name)
        };
        if fptype == FPType_Infinity then {
            result = FPInfinity(sign, 2 * 'N)
        } else if fptype == FPType_Zero then {
            let sign : bits(1) = sign1 & sign2;
            result = FPZero(sign, 2 * 'N)
        } else {
            if altfp then {
                fpcr[FZ] = 0b0
            };
            result = FPRoundBF(value_name, fpcr, rounding, fpexc, 2 * 'N)
        };
        if fpexc then {
            FPProcessDenorms(type1, type2, 2 * 'N, fpcr)
        };
        ()
    };
    return(result[2 * 'N - 1 .. 'N])
}

val BFMaxNum : forall 'N, 'N == 16. (bits('N), bits('N), FPCRType) -> bits('N)

function BFMaxNum (op1_in, op2_in, fpcr) = {
    type1 : FPType = undefined;
    type2 : FPType = undefined;
    assert('N == 16);
    let fpexc : bool = true;
    let isbfloat16 : bool = true;
    op1 : bits('N) = op1_in;
    op2 : bits('N) = op2_in;
    let altfp : bool = (HaveAltFP() & not_bool(UsingAArch32())) & fpcr[AH] == 0b1;
    let (__tup_0 : FPType, _, _) = FPUnpackBase__1(op1, fpcr, fpexc, isbfloat16)
    in
      {
          type1 = __tup_0
      };
    let (__tup_0 : FPType, _, _) = FPUnpackBase__1(op2, fpcr, fpexc, isbfloat16)
    in
      {
          type2 = __tup_0
      };
    let type1_nan : bool = type1 == FPType_QNaN | type1 == FPType_SNaN;
    let type2_nan : bool = type2 == FPType_QNaN | type2 == FPType_SNaN;
    if not_bool((altfp & type1_nan) & type2_nan) then {
        if type1 == FPType_QNaN & type2 != FPType_QNaN then {
            op1 = BFInfinity(0b1, 'N)
        } else if type1 != FPType_QNaN & type2 == FPType_QNaN then {
            op2 = BFInfinity(0b1, 'N)
        } else ()
    };
    let altfmaxfmin : bool = false;
    let result : bits('N) = BFMax__1(op1, op2, fpcr, altfmaxfmin);
    return(result)
}

val FPMatMulAdd : forall 'N 'esize,
  'N >= 0 & ('esize == 16 | 'esize == 32 | 'esize == 64 | not('N == 'esize * 2 * 2)).
  (bits('N), bits('N), bits('N), int('esize), FPCRType) -> bits('N)

function FPMatMulAdd (addend, op1, op2, esize, fpcr) = {
    assert('N == esize * 2 * 2);
    result : bits('N) = undefined;
    prod0 : bits('esize) = undefined;
    prod1 : bits('esize) = undefined;
    sum : bits('esize) = undefined;
    foreach (i from 0 to 1 by 1 in inc) {
        foreach (j from 0 to 1 by 1 in inc) {
            assert(constraint(((2 * 'loop_i + 'loop_j) * 'esize <= (2 * 'loop_i + 'loop_j) * 'esize + 'esize - 1 | not((2 * 'loop_i + 'loop_j >= 0 & (2 * 'loop_i + 'loop_j + 1) * 'esize <= 'N)) | not('N == 'esize * 2 * 2))));
            sum = Elem_read(addend, 2 * i + j, esize);
            prod0 = FPMul(Elem_read(op1, 2 * i + 0, esize), Elem_read(op2, 2 * j + 0, esize), fpcr);
            prod1 = FPMul(Elem_read(op1, 2 * i + 1, esize), Elem_read(op2, 2 * j + 1, esize), fpcr);
            sum = FPAdd(sum, FPAdd(prod0, prod1, fpcr), fpcr);
            result = Elem_set(result, 2 * i + j, esize, sum)
        }
    };
    return(result)
}

val FPDotAdd : forall 'N, 'N == 32.
  (bits('N), bits(div('N, 2)), bits(div('N, 2)), bits(div('N, 2)), bits(div('N, 2)), FPCRType) -> bits('N)

function FPDotAdd (addend, op1_a, op1_b, op2_a, op2_b, fpcr) = {
    assert('N == 32);
    let isbfloat16 : bool = false;
    let fpexc : bool = true;
    let prod : bits('N) = FPDot__1(op1_a, op1_b, op2_a, op2_b, fpcr, isbfloat16, fpexc);
    let result : bits('N) = FPAdd__1(addend, prod, fpcr, fpexc);
    return(result)
}

val FPDotAdd_ZA : forall 'N, 'N == 32.
  (bits('N), bits(div('N, 2)), bits(div('N, 2)), bits(div('N, 2)), bits(div('N, 2)), FPCRType) -> bits('N)

function FPDotAdd_ZA (addend, op1_a, op1_b, op2_a, op2_b, fpcr_in) = {
    fpcr : FPCRType = fpcr_in;
    assert('N == 32);
    let isbfloat16 : bool = false;
    let fpexc : bool = false;
    fpcr[DN] = 0b1;
    let prod : bits('N) = FPDot__1(op1_a, op1_b, op2_a, op2_b, fpcr, isbfloat16, fpexc);
    let result : bits('N) = FPAdd__1(addend, prod, fpcr, fpexc);
    return(result)
}

val AArch32_PhysicalSErrorSyndrome : unit -> bits(16)

function AArch32_PhysicalSErrorSyndrome () = {
    syndrome : bits(32) = Zeros(32);
    let fault : FaultRecord = GetPendingPhysicalSError();
    if PSTATE.EL == EL2 then {
        let errstate : ErrorState = AArch32_PEErrorState(fault);
        syndrome[11 .. 10] = AArch32_EncodeAsyncErrorSyndrome(errstate);
        syndrome[9] = Bit(fault.extflag);
        syndrome[5 .. 0] = 0b010001
    } else {
        let long_format : bool = TTBCR_read()[EAE] == 0b1;
        syndrome = AArch32_CommonFaultStatus(fault, long_format)
    };
    return(syndrome[15 .. 0])
}

val AArch64_EncodeAsyncErrorSyndrome : ErrorState -> bits(3)

function AArch64_EncodeAsyncErrorSyndrome errorstate = {
    match errorstate {
      ErrorState_UC => {
          return(0b000)
      },
      ErrorState_UEU => {
          return(0b001)
      },
      ErrorState_UEO => {
          return(0b010)
      },
      ErrorState_UER => {
          return(0b011)
      },
      ErrorState_CE => {
          return(0b110)
      },
      _ => {
          Unreachable();
          return(undefined : bits(3))
      }
    }
}

val AArch64_PhysicalSErrorSyndrome : forall ('implicit_esb : Bool).
  bool('implicit_esb) -> bits(25)

function AArch64_PhysicalSErrorSyndrome implicit_esb = {
    syndrome : bits(25) = Zeros(25);
    let fault : FaultRecord = GetPendingPhysicalSError();
    let errorstate : ErrorState = AArch64_PEErrorState(fault);
    if errorstate == ErrorState_Uncategorized then {
        syndrome = Zeros(25)
    } else if errorstate == ErrorState_IMPDEF then {
        syndrome[24] = Bit(0b1);
        syndrome[23 .. 0] = __IMPDEF_bits(24, "IMPDEF ErrorState")
    } else {
        syndrome[24] = Bit(0b0);
        syndrome[13] = Bit(if implicit_esb then 0b1 else 0b0);
        syndrome[12 .. 10] = AArch64_EncodeAsyncErrorSyndrome(errorstate);
        syndrome[9] = Bit(fault.extflag);
        syndrome[5 .. 0] = 0b010001
    };
    return(syndrome)
}

val AArch64_PhysicalSErrorTarget : unit -> (bool, bits(2))

function AArch64_PhysicalSErrorTarget () = {
    route_to_el3 : bool = undefined;
    route_to_el2 : bool = undefined;
    if PSTATE.EL != EL3 then {
        route_to_el3 = HaveEL(EL3) & EffectiveEA() == 0b1
    } else {
        route_to_el3 = false
    };
    if (not_bool(route_to_el3) & EL2Enabled()) & PSTATE.EL == EL1 then {
        route_to_el2 = HCR_EL2[AMO] == 0b1
    } else if (not_bool(route_to_el3) & EL2Enabled()) & PSTATE.EL == EL0 then {
        route_to_el2 = not_bool(IsInHost()) & (HCR_EL2[TGE] @ HCR_EL2[AMO]) != 0b00
    } else {
        route_to_el2 = false
    };
    masked : bool = undefined;
    match PSTATE.EL {
      ? if ? == EL3 => {
          masked = EffectiveEA() == 0b0 | PSTATE.A == 0b1
      },
      ? if ? == EL2 => {
          masked = not_bool(route_to_el3) & ((HCR_EL2[TGE] @ HCR_EL2[AMO]) == 0b00 | PSTATE.A == 0b1)
      },
      ? if ? == EL1 => {
          masked = (not_bool(route_to_el3) & not_bool(route_to_el2)) & PSTATE.A == 0b1
      },
      ? if ? == EL0 => {
          masked = (not_bool(route_to_el3) & not_bool(route_to_el2)) & PSTATE.A == 0b1
      },
      _ => ()
    };
    if HaveDoubleFault2Ext() then {
        nmea_bit : bits(1) = undefined;
        match PSTATE.EL {
          ? if ? == EL3 => {
              nmea_bit = SCR_EL3[NMEA]
          },
          ? if ? == EL2 => {
              nmea_bit = if IsSCTLR2EL2Enabled() then SCTLR2_EL2[NMEA] else 0b0
          },
          ? if ? == EL1 => {
              nmea_bit = if IsSCTLR2EL1Enabled() then SCTLR2_EL1[NMEA] else 0b0
          },
          ? if ? == EL0 => {
              if IsInHost() then {
                  nmea_bit = if IsSCTLR2EL2Enabled() then SCTLR2_EL2[NMEA] else
                    0b0
              } else {
                  nmea_bit = if IsSCTLR2EL1Enabled() then SCTLR2_EL1[NMEA] else
                    0b0
              }
          },
          _ => ()
        };
        masked = masked & nmea_bit == 0b0
    } else if HaveDoubleFaultExt() & PSTATE.EL == EL3 then {
        let nmea_bit : bits(1) = SCR_EL3[NMEA] & EffectiveEA();
        masked = masked & nmea_bit == 0b0
    } else ();
    route_masked_to_el3 : bool = undefined;
    route_masked_to_el2 : bool = undefined;
    if HaveDoubleFault2Ext() then {
        route_masked_to_el2 = (((EL2Enabled() & not_bool(route_to_el3)) & IsHCRXEL2Enabled()) & HCRX_EL2[TMEA] == 0b1) & (PSTATE.EL == EL1 & (PSTATE.A == 0b1 | masked) | (PSTATE.EL == EL0 & masked) & not_bool(IsInHost()));
        route_masked_to_el3 = ((HaveEL(EL3) & SCR_EL3[TMEA] == 0b1) & not_bool(route_to_el2 | route_masked_to_el2)) & ((PSTATE.EL == EL2 | PSTATE.EL == EL1) & (PSTATE.A == 0b1 | masked) | PSTATE.EL == EL0 & masked)
    } else {
        route_masked_to_el2 = false;
        route_masked_to_el3 = false
    };
    let take_in_el3 : bool = PSTATE.EL == EL3 & not_bool(masked);
    let take_in_el2_0 : bool = ((PSTATE.EL == EL2 | IsInHost()) & not_bool(route_to_el3 | route_masked_to_el3)) & not_bool(masked);
    let take_in_el1_0 : bool = (((PSTATE.EL == EL1 | PSTATE.EL == EL0 & not_bool(IsInHost())) & not_bool(route_to_el2 | route_masked_to_el2)) & not_bool(route_to_el3 | route_masked_to_el3)) & not_bool(masked);
    target_el : bits(2) = undefined;
    if (take_in_el3 | route_to_el3) | route_masked_to_el3 then {
        masked = false;
        target_el = EL3
    } else if (take_in_el2_0 | route_to_el2) | route_masked_to_el2 then {
        masked = false;
        target_el = EL2
    } else if take_in_el1_0 then {
        masked = false;
        target_el = EL1
    } else {
        masked = true;
        target_el = __UNKNOWN_bits(2)
    };
    return((masked, target_el))
}

bitfield DISR_EL1_Type : bits(64) =
  {A : 31..31, IDS : 24..24, AET : 12..10, EA : 9..9, ISS : 23..0, DFSC : 5..0}

register DISR_EL1 : DISR_EL1_Type

bitfield DISR_Type : bits(32) =
  {
    A : 31..31,
    ExT : 12..12,
    FS : (10..10 @ 3..0),
    LPAE : 9..9,
    EA : 9..9,
    STATUS : 5..0,
    DFSC : 5..0
  }

register _DISR : DISR_Type

val DISR_write : DISR_Type -> unit

function DISR_write value_name = {
    let r : DISR_Type = value_name;
    DISR_EL1.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _DISR = r;
    return()
}

val ExternalDebugInterruptsDisabled : bits(2) -> bool

function ExternalDebugInterruptsDisabled target = {
    int_dis : bool = undefined;
    let ss : SecurityState = SecurityStateAtEL(target);
    if Havev8p4Debug() then {
        if [EDSCR_read()[INTdis][0]] == 0b1 then {
            match ss {
              SS_NonSecure => {
                  int_dis = ExternalInvasiveDebugEnabled()
              },
              SS_Secure => {
                  int_dis = ExternalSecureInvasiveDebugEnabled()
              },
              SS_Realm => {
                  int_dis = ExternalRealmInvasiveDebugEnabled()
              },
              SS_Root => {
                  int_dis = ExternalRootInvasiveDebugEnabled()
              }
            }
        } else {
            int_dis = false
        }
    } else {
        match target {
          ? if ? == EL3 => {
              int_dis = EDSCR_read()[INTdis] == 0b11 & ExternalSecureInvasiveDebugEnabled()
          },
          ? if ? == EL2 => {
              int_dis = (match EDSCR_read()[INTdis] {
                [bitone, _] => true,
                _ => false
              }) : bool & ExternalInvasiveDebugEnabled()
          },
          ? if ? == EL1 => {
              if ss == SS_Secure then {
                  int_dis = (match EDSCR_read()[INTdis] {
                    [bitone, _] => true,
                    _ => false
                  }) : bool & ExternalSecureInvasiveDebugEnabled()
              } else {
                  int_dis = EDSCR_read()[INTdis] != 0b00 & ExternalInvasiveDebugEnabled()
              }
          },
          _ => ()
        }
    };
    return(int_dis)
}

val AArch64_ESBOperation : unit -> unit

function AArch64_ESBOperation () = {
    implicit_esb : bool = undefined;
    target_el : bits(2) = undefined;
    masked : bool = undefined;
    (masked, target_el) = AArch64_PhysicalSErrorTarget();
    let intdis : bool = Halted() | ExternalDebugInterruptsDisabled(target_el);
    let masked : bool = masked | intdis;
    if masked & IsSynchronizablePhysicalSErrorPending() then {
        if ELUsingAArch32(S1TranslationRegime__1()) then {
            syndrome : bits(32) = Zeros(32);
            syndrome[31] = Bit(0b1);
            syndrome[15 .. 0] = AArch32_PhysicalSErrorSyndrome();
            DISR_write() = Mk_DISR_Type(syndrome)
        } else {
            let implicit_esb : bool = false;
            syndrome : bits(64) = Zeros(64);
            syndrome[31] = Bit(0b1);
            syndrome[24 .. 0] = AArch64_PhysicalSErrorSyndrome(implicit_esb);
            DISR_EL1 = Mk_DISR_EL1_Type(syndrome)
        };
        ClearPendingPhysicalSError()
    };
    return()
}

bitfield VDFSR_Type : bits(32) = {AET : 15..14, ExT : 12..12}

bitfield VSESR_EL2_Type : bits(64) =
  {IDS : 24..24, AET : 15..14, ExT : 12..12, ISS : 23..0}

register VSESR_EL2 : VSESR_EL2_Type

register _VDFSR : VDFSR_Type

val VDFSR_read : unit -> VDFSR_Type

function VDFSR_read () = {
    r : VDFSR_Type = _VDFSR;
    r.bits[31 .. 0] = Slice(VSESR_EL2.bits, 0, 32);
    return(r)
}

bitfield VDISR_EL2_Type : bits(64) =
  {
    A : 31..31,
    IDS : 24..24,
    AET : 15..14,
    ExT : 12..12,
    FS : (10..10 @ 3..0),
    LPAE : 9..9,
    STATUS : 5..0,
    ISS : 23..0
  }

register VDISR_EL2 : VDISR_EL2_Type

bitfield VDISR_Type : bits(32) =
  {
    A : 31..31,
    AET : 15..14,
    ExT : 12..12,
    FS : (10..10 @ 3..0),
    LPAE : 9..9,
    STATUS : 5..0
  }

register _VDISR : VDISR_Type

val VDISR_write : VDISR_Type -> unit

function VDISR_write value_name = {
    let r : VDISR_Type = value_name;
    VDISR_EL2.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _VDISR = r;
    return()
}

val AArch64_vESBOperation : unit -> unit

function AArch64_vESBOperation () = {
    assert((PSTATE.EL == EL0 | PSTATE.EL == EL1) & EL2Enabled());
    let vSEI_enabled : bool = HCR_EL2[TGE] == 0b0 & HCR_EL2[AMO] == 0b1;
    let vSEI_pending : bool = vSEI_enabled & HCR_EL2[VSE] == 0b1;
    let vintdis : bool = Halted() | ExternalDebugInterruptsDisabled(EL1);
    let vmasked : bool = vintdis | PSTATE.A == 0b1;
    if vSEI_pending & vmasked then {
        if ELUsingAArch32(EL1) then {
            target : bits(32) = Zeros(32);
            target[31] = Bit(0b1);
            target[15 .. 14] = VDFSR_read().bits[15 .. 14];
            target[12] = Bit([VDFSR_read().bits[12]]);
            target[9] = Bit(TTBCR_read()[EAE]);
            if TTBCR_read()[EAE] == 0b1 then {
                target[5 .. 0] = 0b010001
            } else {
                (target[10 .. 10] @ target[3 .. 0]) = 0b10110
            };
            VDISR_write() = Mk_VDISR_Type(target)
        } else {
            target : bits(64) = Zeros(64);
            target[31] = Bit(0b1);
            target[24 .. 0] = VSESR_EL2.bits[24 .. 0];
            VDISR_EL2 = Mk_VDISR_EL2_Type(target)
        };
        HCR_EL2[VSE] = 0b0
    };
    return()
}

val StartTrackingTransactionalReadsWrites : unit -> unit

val CommitTransactionalWrites : unit -> unit

val TakeTransactionCheckpoint : forall 'pl 'vl. (int('vl), int('pl)) -> unit

function TakeTransactionCheckpoint (vl, pl) = {
    TSTATE.SP = SP_read();
    TSTATE.ICC_PMR_EL1 = ICC_PMR_EL1.bits;
    TSTATE.nzcv = PSTATE.N @ (PSTATE.Z @ (PSTATE.C @ PSTATE.V));
    (TSTATE.D @ TSTATE.A @ TSTATE.I @ TSTATE.F) = PSTATE.D @ (PSTATE.A @ (PSTATE.I @ PSTATE.F));
    foreach (n from 0 to 30 by 1 in inc) {
        TSTATE.X[n] = X_read(n, 64)
    };
    if IsFPEnabled(PSTATE.EL) then {
        if IsSVEEnabled(PSTATE.EL) then {
            foreach (n from 0 to 31 by 1 in inc) {
                assert(constraint((0 <= 'vl - 1 & 'vl - 1 < 2048)));
                TSTATE.Z[n][vl - 1 .. 0] = Z_read(n, vl)
            };
            foreach (n from 0 to 15 by 1 in inc) {
                assert(constraint((0 <= 'pl - 1 & 'pl - 1 < 256)));
                TSTATE.P[n][pl - 1 .. 0] = P_read(n, pl)
            };
            assert(constraint((0 <= 'pl - 1 & 'pl - 1 < 256)));
            TSTATE.FFR[pl - 1 .. 0] = FFR_read(pl)
        } else {
            foreach (n from 0 to 31 by 1 in inc) {
                TSTATE.Z[n][127 .. 0] = V_read(n, 128)
            }
        };
        TSTATE.FPCR = FPCR.bits;
        TSTATE.FPSR = FPSR.bits
    };
    if HaveGCS() then {
        match PSTATE.EL {
          ? if ? == EL0 => {
              TSTATE.GCSPR_ELx = GCSPR_EL0.bits
          },
          ? if ? == EL1 => {
              TSTATE.GCSPR_ELx = GCSPR_EL1.bits
          },
          ? if ? == EL2 => {
              TSTATE.GCSPR_ELx = GCSPR_EL2.bits
          },
          ? if ? == EL3 => {
              TSTATE.GCSPR_ELx = GCSPR_EL3.bits
          },
          _ => ()
        }
    };
    return()
}

val IsTMEEnabled : unit -> bool

function IsTMEEnabled () = {
    if (PSTATE.EL == EL0 | PSTATE.EL == EL1 | PSTATE.EL == EL2) & HaveEL(EL3) then {
        if SCR_EL3[TME] == 0b0 then {
            return(false)
        };
        ()
    };
    if (PSTATE.EL == EL0 | PSTATE.EL == EL1) & EL2Enabled() then {
        if HCR_EL2[TME] == 0b0 then {
            return(false)
        };
        ()
    };
    return(true)
}

val TransactionStartTrap : forall 'dreg. int('dreg) -> unit

function TransactionStartTrap dreg = {
    targetEL : bits(2) = undefined;
    let preferred_exception_return : bits(64) = ThisInstrAddr(64);
    let 'vect_offset = UInt(0x0);
    except : ExceptionRecord = ExceptionSyndrome(Exception_TSTARTAccessTrap);
    except.syndrome[9 .. 5] = dreg[4 .. 0];
    if UInt(PSTATE.EL) > UInt(EL1) then {
        targetEL = PSTATE.EL
    } else if EL2Enabled() & HCR_EL2[TGE] == 0b1 then {
        targetEL = EL2
    } else {
        targetEL = EL1
    };
    sail_take_exception(None());
    AArch64_TakeException(targetEL, except, preferred_exception_return, vect_offset)
}

val AArch64_ResetControlRegisters : forall ('cold_reset : Bool).
  bool('cold_reset) -> unit

bitfield RVBAR_EL1_Type : bits(64) = {ResetAddress : 63..0}

register RVBAR_EL1 : RVBAR_EL1_Type

bitfield RVBAR_EL2_Type : bits(64) = {ResetAddress : 63..0}

register RVBAR_EL2 : RVBAR_EL2_Type

bitfield RVBAR_EL3_Type : bits(64) = {ResetAddress : 63..0}

register RVBAR_EL3 : RVBAR_EL3_Type

val AArch64_TakeReset : forall ('cold_reset : Bool). bool('cold_reset) -> unit

function AArch64_TakeReset cold_reset = {
    assert(HaveAArch64());
    PSTATE.nRW = 0b0;
    if HaveEL(EL3) then {
        PSTATE.EL = EL3
    } else if HaveEL(EL2) then {
        PSTATE.EL = EL2
    } else {
        PSTATE.EL = EL1
    };
    AArch64_ResetControlRegisters(cold_reset);
    PSTATE.SP = 0b1;
    (PSTATE.D @ PSTATE.A @ PSTATE.I @ PSTATE.F) = 0b1111;
    PSTATE.SS = 0b0;
    PSTATE.DIT = 0b0;
    PSTATE.IL = 0b0;
    if HaveTME() then {
        TSTATE.depth = 0
    };
    // AArch64_ResetGeneralRegisters();
    AArch64_ResetSIMDFPRegisters();
    AArch64_ResetSpecialRegisters();
    ResetExternalDebugRegisters(cold_reset);
    rv : bits(64) = undefined;
    if HaveEL(EL3) then {
        rv = RVBAR_EL3.bits
    } else if HaveEL(EL2) then {
        rv = RVBAR_EL2.bits
    } else {
        rv = RVBAR_EL1.bits
    };
    assert(is_zero_subrange(rv, 63, AArch64_PAMax()) & IsZero(rv[1 .. 0]));
    let branch_conditional : bool = false;
    BranchTo(rv, BranchType_RESET, branch_conditional)
}

val AArch32_ITAdvance : unit -> unit

function AArch32_ITAdvance () = {
    if PSTATE.IT[2 .. 0] == 0b000 then {
        PSTATE.IT = 0b00000000
    } else {
        PSTATE.IT[4 .. 0] = LSL(PSTATE.IT[4 .. 0], 1)
    };
    return()
}

val DebugTarget : unit -> bits(2)

function DebugTarget () = {
    let ss : SecurityState = CurrentSecurityState();
    return(DebugTargetFrom(ss))
}

val SSAdvance : unit -> unit

function SSAdvance () = {
    let target : bits(2) = DebugTarget();
    let step_enabled : bool = not_bool(ELUsingAArch32(target)) & MDSCR_EL1[SS] == 0b1;
    let active_not_pending : bool = step_enabled & PSTATE.SS == 0b1;
    if active_not_pending then {
        PSTATE.SS = 0b0
    };
    return()
}

val AArch64_CallSecureMonitor : bits(16) -> unit

function AArch64_CallSecureMonitor immediate = {
    assert(HaveEL(EL3) & not_bool(ELUsingAArch32(EL3)));
    if UsingAArch32() then {
        AArch32_ITAdvance()
    };
    SSAdvance();
    let preferred_exception_return : bits(64) = NextInstrAddr(64);
    let 'vect_offset = UInt(0x0);
    except : ExceptionRecord = ExceptionSyndrome(Exception_MonitorCall);
    except.syndrome[15 .. 0] = immediate;
    sail_take_exception(None());
    AArch64_TakeException(EL3, except, preferred_exception_return, vect_offset)
}

val AArch64_CallHypervisor : bits(16) -> unit

function AArch64_CallHypervisor immediate = {
    assert(HaveEL(EL2));
    if UsingAArch32() then {
        AArch32_ITAdvance()
    };
    SSAdvance();
    let preferred_exception_return : bits(64) = NextInstrAddr(64);
    let 'vect_offset = UInt(0x0);
    except : ExceptionRecord = ExceptionSyndrome(Exception_HypervisorCall);
    except.syndrome[15 .. 0] = immediate;
    sail_take_exception(None());
    if PSTATE.EL == EL3 then {
        AArch64_TakeException(EL3, except, preferred_exception_return, vect_offset)
    } else {
        AArch64_TakeException(EL2, except, preferred_exception_return, vect_offset)
    }
}

val AArch64_CallSupervisor : bits(16) -> unit

function AArch64_CallSupervisor immediate_in = {
    let immediate : bits(16) = immediate_in;
    if UsingAArch32() then {
        AArch32_ITAdvance()
    };
    SSAdvance();
    let route_to_el2 : bool = (PSTATE.EL == EL0 & EL2Enabled()) & HCR_EL2[TGE] == 0b1;
    let preferred_exception_return : bits(64) = NextInstrAddr(64);
    let 'vect_offset = UInt(0x0);
    except : ExceptionRecord = ExceptionSyndrome(Exception_SupervisorCall);
    except.syndrome[15 .. 0] = immediate;
    sail_take_exception(None());
    if UInt(PSTATE.EL) > UInt(EL1) then {
        AArch64_TakeException(PSTATE.EL, except, preferred_exception_return, vect_offset)
    } else if route_to_el2 then {
        AArch64_TakeException(EL2, except, preferred_exception_return, vect_offset)
    } else {
        AArch64_TakeException(EL1, except, preferred_exception_return, vect_offset)
    }
}

val AArch64_UndefinedFault : unit -> unit

function AArch64_UndefinedFault () = {
    let route_to_el2 : bool = (PSTATE.EL == EL0 & EL2Enabled()) & HCR_EL2[TGE] == 0b1;
    let preferred_exception_return : bits(64) = ThisInstrAddr(64);
    let 'vect_offset = UInt(0x0);
    let except : ExceptionRecord = ExceptionSyndrome(Exception_Uncategorized);
    sail_take_exception(None());
    if UInt(PSTATE.EL) > UInt(EL1) then {
        AArch64_TakeException(PSTATE.EL, except, preferred_exception_return, vect_offset)
    } else if route_to_el2 then {
        AArch64_TakeException(EL2, except, preferred_exception_return, vect_offset)
    } else {
        AArch64_TakeException(EL1, except, preferred_exception_return, vect_offset)
    }
}

val AArch64_CheckIllegalState : unit -> unit

function AArch64_CheckIllegalState () = {
    except : ExceptionRecord = undefined;
    route_to_el2 : bool = undefined;
    vect_offset : int = undefined;
    if PSTATE.IL == 0b1 then {
        let route_to_el2 : bool = (PSTATE.EL == EL0 & EL2Enabled()) & HCR_EL2[TGE] == 0b1;
        let preferred_exception_return : bits(64) = ThisInstrAddr(64);
        let 'vect_offset = UInt(0x0);
        let except : ExceptionRecord = ExceptionSyndrome(Exception_IllegalState);
        sail_take_exception(None());
        if UInt(PSTATE.EL) > UInt(EL1) then {
            AArch64_TakeException(PSTATE.EL, except, preferred_exception_return, vect_offset)
        } else if route_to_el2 then {
            AArch64_TakeException(EL2, except, preferred_exception_return, vect_offset)
        } else {
            AArch64_TakeException(EL1, except, preferred_exception_return, vect_offset)
        }
    };
    ()
}

val LDST64BTrap : (bits(2), bits(25)) -> unit

function LDST64BTrap (target_el, iss) = {
    let preferred_exception_return : bits(64) = ThisInstrAddr(64);
    let 'vect_offset = UInt(0x0);
    except : ExceptionRecord = ExceptionSyndrome(Exception_LDST64BTrap);
    except.syndrome = iss;
    sail_take_exception(None());
    AArch64_TakeException(target_el, except, preferred_exception_return, vect_offset);
    return()
}

val CheckLDST64BEnabled : unit -> unit

function CheckLDST64BEnabled () = {
    trap : bool = false;
    let iss : bits(25) = ZeroExtend(0b10, 25);
    target_el : bits(2) = undefined;
    if PSTATE.EL == EL0 then {
        if not_bool(IsInHost()) then {
            trap = SCTLR_EL1[EnALS] == 0b0;
            target_el = if EL2Enabled() & HCR_EL2[TGE] == 0b1 then EL2 else EL1
        } else {
            trap = SCTLR_EL2[EnALS] == 0b0;
            target_el = EL2
        }
    } else {
        target_el = EL1
    };
    if (not_bool(trap) & EL2Enabled()) & (PSTATE.EL == EL0 & not_bool(IsInHost()) | PSTATE.EL == EL1) then {
        trap = not_bool(IsHCRXEL2Enabled()) | HCRX_EL2[EnALS] == 0b0;
        target_el = EL2
    };
    let target_el = target_el;
    if trap then {
        LDST64BTrap(target_el, iss)
    };
    ()
}

val CheckST64BVEnabled : unit -> unit

function CheckST64BVEnabled () = {
    trap : bool = false;
    let iss : bits(25) = Zeros(25);
    target_el : bits(2) = undefined;
    if PSTATE.EL == EL0 then {
        if not_bool(IsInHost()) then {
            trap = SCTLR_EL1[EnASR] == 0b0;
            target_el = if EL2Enabled() & HCR_EL2[TGE] == 0b1 then EL2 else EL1
        } else {
            trap = SCTLR_EL2[EnASR] == 0b0;
            target_el = EL2
        }
    };
    if (not_bool(trap) & EL2Enabled()) & (PSTATE.EL == EL0 & not_bool(IsInHost()) | PSTATE.EL == EL1) then {
        trap = not_bool(IsHCRXEL2Enabled()) | HCRX_EL2[EnASR] == 0b0;
        target_el = EL2
    };
    let target_el = target_el;
    if trap then {
        LDST64BTrap(target_el, iss)
    };
    ()
}

val CheckST64BV0Enabled : unit -> unit

function CheckST64BV0Enabled () = {
    trap : bool = false;
    let iss : bits(25) = ZeroExtend(0b1, 25);
    target_el : bits(2) = undefined;
    if ((PSTATE.EL != EL3 & HaveEL(EL3)) & SCR_EL3[EnAS0] == 0b0) & EL3SDDUndefPriority() then {
        throw(Error_Undefined())
    };
    if PSTATE.EL == EL0 then {
        if not_bool(IsInHost()) then {
            trap = SCTLR_EL1[EnAS0] == 0b0;
            target_el = if EL2Enabled() & HCR_EL2[TGE] == 0b1 then EL2 else EL1
        } else {
            trap = SCTLR_EL2[EnAS0] == 0b0;
            target_el = EL2
        }
    };
    if (not_bool(trap) & EL2Enabled()) & (PSTATE.EL == EL0 & not_bool(IsInHost()) | PSTATE.EL == EL1) then {
        trap = not_bool(IsHCRXEL2Enabled()) | HCRX_EL2[EnAS0] == 0b0;
        target_el = EL2
    };
    if not_bool(trap) & PSTATE.EL != EL3 then {
        trap = HaveEL(EL3) & SCR_EL3[EnAS0] == 0b0;
        target_el = EL3
    };
    if trap then {
        if target_el == EL3 & EL3SDDUndef() then {
            throw(Error_Undefined())
        } else {
            LDST64BTrap(target_el, iss)
        }
    };
    ()
}

val AArch64_CheckForERetTrap : forall ('eret_with_pac : Bool) ('pac_uses_key_a : Bool).
  (bool('eret_with_pac), bool('pac_uses_key_a)) -> unit

function AArch64_CheckForERetTrap (eret_with_pac, pac_uses_key_a) = {
    vect_offset : int = undefined;
    route_to_el2 : bool = false;
    let route_to_el2 : bool = (PSTATE.EL == EL1 & EL2Enabled()) & (HaveNVExt() & HCR_EL2[NV] == 0b1 | (HaveFGTExt() & (not_bool(HaveEL(EL3)) | SCR_EL3[FGTEn] == 0b1)) & HFGITR_EL2[ERET] == 0b1);
    if route_to_el2 then {
        let preferred_exception_return : bits(64) = ThisInstrAddr(64);
        let 'vect_offset = UInt(0x0);
        except : ExceptionRecord = ExceptionSyndrome(Exception_ERetTrap);
        if not_bool(eret_with_pac) then {
            except.syndrome[1] = Bit(0b0);
            except.syndrome[0] = Bit(0b0)
        } else {
            except.syndrome[1] = Bit(0b1);
            if pac_uses_key_a then {
                except.syndrome[0] = Bit(0b0)
            } else {
                except.syndrome[0] = Bit(0b1)
            }
        };
        sail_take_exception(None());
        AArch64_TakeException(EL2, except, preferred_exception_return, vect_offset)
    };
    ()
}

val AArch64_CheckForSVCTrap : bits(16) -> unit

function AArch64_CheckForSVCTrap immediate = {
    except : ExceptionRecord = undefined;
    route_to_el2 : bool = undefined;
    vect_offset : int = undefined;
    if HaveFGTExt() then {
        route_to_el2 : bool = false;
        if PSTATE.EL == EL0 then {
            route_to_el2 = (((not_bool(UsingAArch32()) & not_bool(ELUsingAArch32(EL1))) & EL2Enabled()) & HFGITR_EL2[SVC_EL0] == 0b1) & (HCR_EL2[E2H] @ HCR_EL2[TGE]) != 0b11 & (not_bool(HaveEL(EL3)) | SCR_EL3[FGTEn] == 0b1)
        } else if PSTATE.EL == EL1 then {
            route_to_el2 = (EL2Enabled() & HFGITR_EL2[SVC_EL1] == 0b1) & (not_bool(HaveEL(EL3)) | SCR_EL3[FGTEn] == 0b1)
        } else ();
        if route_to_el2 then {
            except : ExceptionRecord = ExceptionSyndrome(Exception_SupervisorCall);
            except.syndrome[15 .. 0] = immediate;
            except.trappedsyscallinst = true;
            let preferred_exception_return : bits(64) = ThisInstrAddr(64);
            let 'vect_offset = UInt(0x0);
            sail_take_exception(None());
            AArch64_TakeException(EL2, except, preferred_exception_return, vect_offset)
        };
        ()
    };
    let route_to_el2 = route_to_el2;
    ()
}

val AArch64_CheckForSMCUndefOrTrap : bits(16) -> unit

function AArch64_CheckForSMCUndefOrTrap imm = {
    except : ExceptionRecord = undefined;
    vect_offset : int = undefined;
    if PSTATE.EL == EL0 then {
        throw(Error_Undefined())
    };
    if (not_bool((PSTATE.EL == EL1 & EL2Enabled()) & HCR_EL2[TSC] == 0b1) & HaveEL(EL3)) & SCR_EL3[SMD] == 0b1 then {
        throw(Error_Undefined())
    };
    route_to_el2 : bool = false;
    if not_bool(HaveEL(EL3)) then {
        if PSTATE.EL == EL1 & EL2Enabled() then {
            if (HaveNVExt() & HCR_EL2[NV] == 0b1) & HCR_EL2[TSC] == 0b1 then {
                route_to_el2 = true
            } else {
                throw(Error_Undefined())
            }
        } else {
            throw(Error_Undefined())
        }
    } else {
        route_to_el2 = (PSTATE.EL == EL1 & EL2Enabled()) & HCR_EL2[TSC] == 0b1
    };
    if route_to_el2 then {
        let preferred_exception_return : bits(64) = ThisInstrAddr(64);
        let 'vect_offset = UInt(0x0);
        except : ExceptionRecord = ExceptionSyndrome(Exception_MonitorCall);
        except.syndrome[15 .. 0] = imm;
        except.trappedsyscallinst = true;
        sail_take_exception(None());
        AArch64_TakeException(EL2, except, preferred_exception_return, vect_offset)
    };
    ()
}

val AArch64_MonitorModeTrap : unit -> unit

function AArch64_MonitorModeTrap () = {
    let preferred_exception_return : bits(64) = ThisInstrAddr(64);
    let 'vect_offset = UInt(0x0);
    let except : ExceptionRecord = ExceptionSyndrome(Exception_Uncategorized);
    sail_take_exception(None());
    if IsSecureEL2Enabled() then {
        AArch64_TakeException(EL2, except, preferred_exception_return, vect_offset)
    };
    AArch64_TakeException(EL3, except, preferred_exception_return, vect_offset)
}

val AArch64_SystemAccessTrapSyndrome : forall 'ec.
  (bits(32), int('ec)) -> ExceptionRecord

function AArch64_SystemAccessTrapSyndrome (instr_in, ec) = {
    except : ExceptionRecord = undefined;
    instr : bits(32) = instr_in;
    match ec {
      0 => {
          except = ExceptionSyndrome(Exception_Uncategorized)
      },
      7 => {
          except = ExceptionSyndrome(Exception_AdvSIMDFPAccessTrap);
          except.syndrome[24 .. 20] = ConditionSyndrome()
      },
      20 => {
          except = ExceptionSyndrome(Exception_SystemRegister128Trap);
          let instr : bits(32) = ThisInstr();
          except.syndrome[21 .. 20] = instr[20 .. 19];
          except.syndrome[19 .. 17] = instr[7 .. 5];
          except.syndrome[16 .. 14] = instr[18 .. 16];
          except.syndrome[13 .. 10] = instr[15 .. 12];
          except.syndrome[9 .. 6] = instr[4 .. 1];
          except.syndrome[4 .. 1] = instr[11 .. 8];
          except.syndrome[0] = Bit([instr[21]])
      },
      24 => {
          except = ExceptionSyndrome(Exception_SystemRegisterTrap);
          let instr : bits(32) = ThisInstr();
          except.syndrome[21 .. 20] = instr[20 .. 19];
          except.syndrome[19 .. 17] = instr[7 .. 5];
          except.syndrome[16 .. 14] = instr[18 .. 16];
          except.syndrome[13 .. 10] = instr[15 .. 12];
          except.syndrome[9 .. 5] = instr[4 .. 0];
          except.syndrome[4 .. 1] = instr[11 .. 8];
          except.syndrome[0] = Bit([instr[21]])
      },
      25 => {
          except = ExceptionSyndrome(Exception_SVEAccessTrap)
      },
      29 => {
          except = ExceptionSyndrome(Exception_SMEAccessTrap)
      },
      _ => {
          Unreachable()
      }
    };
    return(except)
}

val AArch64_SystemAccessTrap : forall 'ec. (bits(2), int('ec)) -> unit

function AArch64_SystemAccessTrap (target_el, ec) = {
    assert((HaveEL(target_el) & target_el != EL0) & UInt(target_el) >= UInt(PSTATE.EL));
    let preferred_exception_return : bits(64) = ThisInstrAddr(64);
    let 'vect_offset = UInt(0x0);
    let except : ExceptionRecord = AArch64_SystemAccessTrapSyndrome(ThisInstr(), ec);
    sail_take_exception(None());
    AArch64_TakeException(target_el, except, preferred_exception_return, vect_offset)
}

val AArch64_AArch32SystemAccessTrapSyndrome : forall 'ec.
  (bits(32), int('ec)) -> ExceptionRecord

function AArch64_AArch32SystemAccessTrapSyndrome (instr, ec) = {
    except : ExceptionRecord = undefined;
    match ec {
      0 => {
          except = ExceptionSyndrome(Exception_Uncategorized)
      },
      3 => {
          except = ExceptionSyndrome(Exception_CP15RTTrap)
      },
      4 => {
          except = ExceptionSyndrome(Exception_CP15RRTTrap)
      },
      5 => {
          except = ExceptionSyndrome(Exception_CP14RTTrap)
      },
      6 => {
          except = ExceptionSyndrome(Exception_CP14DTTrap)
      },
      7 => {
          except = ExceptionSyndrome(Exception_AdvSIMDFPAccessTrap)
      },
      8 => {
          except = ExceptionSyndrome(Exception_FPIDTrap)
      },
      12 => {
          except = ExceptionSyndrome(Exception_CP14RRTTrap)
      },
      _ => {
          Unreachable()
      }
    };
    iss : bits(20) = Zeros(20);
    if except.exceptype == Exception_Uncategorized then {
        return(except)
    } else if except.exceptype == Exception_FPIDTrap | except.exceptype == Exception_CP14RTTrap | except.exceptype == Exception_CP15RTTrap then {
        if except.exceptype != Exception_FPIDTrap then {
            iss[19 .. 17] = instr[7 .. 5];
            iss[16 .. 14] = instr[23 .. 21];
            iss[13 .. 10] = instr[19 .. 16];
            iss[4 .. 1] = instr[3 .. 0]
        } else {
            iss[19 .. 17] = 0b000;
            iss[16 .. 14] = 0b111;
            iss[13 .. 10] = instr[19 .. 16];
            iss[4 .. 1] = 0b0000
        };
        if [instr[20]] == 0b1 & instr[15 .. 12] == 0b1111 then {
            iss[9 .. 5] = 0b11111
        } else if [instr[20]] == 0b0 & instr[15 .. 12] == 0b1111 then {
            iss[9 .. 5] = __UNKNOWN_bits(5)
        } else {
            iss[9 .. 5] = LookUpRIndex(UInt(instr[15 .. 12]), PSTATE.M)[4 .. 0]
        }
    } else if except.exceptype == Exception_CP14RRTTrap | except.exceptype == Exception_AdvSIMDFPAccessTrap | except.exceptype == Exception_CP15RRTTrap then {
        iss[19 .. 16] = instr[7 .. 4];
        if instr[19 .. 16] == 0b1111 then {
            iss[14 .. 10] = __UNKNOWN_bits(5)
        } else {
            iss[14 .. 10] = LookUpRIndex(UInt(instr[19 .. 16]), PSTATE.M)[4 .. 0]
        };
        if instr[15 .. 12] == 0b1111 then {
            iss[9 .. 5] = __UNKNOWN_bits(5)
        } else {
            iss[9 .. 5] = LookUpRIndex(UInt(instr[15 .. 12]), PSTATE.M)[4 .. 0]
        };
        iss[4 .. 1] = instr[3 .. 0]
    } else if except.exceptype == Exception_CP14DTTrap then {
        iss[19 .. 12] = instr[7 .. 0];
        iss[4] = Bit([instr[23]]);
        iss[2 .. 1] = [instr[24]] @ [instr[21]];
        if instr[19 .. 16] == 0b1111 then {
            iss[9 .. 5] = __UNKNOWN_bits(5);
            iss[3] = Bit(0b1)
        };
        ()
    } else ();
    iss[0] = Bit([instr[20]]);
    except.syndrome[24 .. 20] = ConditionSyndrome();
    except.syndrome[19 .. 0] = iss;
    return(except)
}

val AArch64_AArch32SystemAccessTrap : forall 'ec. (bits(2), int('ec)) -> unit

function AArch64_AArch32SystemAccessTrap (target_el, ec) = {
    assert((HaveEL(target_el) & target_el != EL0) & UInt(target_el) >= UInt(PSTATE.EL));
    let preferred_exception_return : bits(64) = ThisInstrAddr(64);
    let 'vect_offset = UInt(0x0);
    let except : ExceptionRecord = AArch64_AArch32SystemAccessTrapSyndrome(ThisInstr(), ec);
    sail_take_exception(None());
    AArch64_TakeException(target_el, except, preferred_exception_return, vect_offset)
}

val AArch64_CheckFPAdvSIMDTrap : unit -> unit

function AArch64_CheckFPAdvSIMDTrap () = {
    if (HaveEL(EL3) & CPTR_EL3[TFP] == 0b1) & EL3SDDUndefPriority() then {
        throw(Error_Undefined())
    };
    if (PSTATE.EL == EL0 | PSTATE.EL == EL1 | PSTATE.EL == EL2) & EL2Enabled() then {
        if HaveVirtHostExt() & HCR_EL2[E2H] == 0b1 then {
            disabled : bool = undefined;
            match CPTR_EL2[FPEN] {
              [_, bitzero] => {
                  disabled = true
              },
              0b01 => {
                  disabled = PSTATE.EL == EL0 & HCR_EL2[TGE] == 0b1
              },
              0b11 => {
                  disabled = false
              }
            };
            let disabled = disabled;
            if disabled then {
                AArch64_AdvSIMDFPAccessTrap(EL2)
            };
            ()
        } else {
            if CPTR_EL2[TFP] == 0b1 then {
                AArch64_AdvSIMDFPAccessTrap(EL2)
            };
            ()
        }
    };
    if HaveEL(EL3) then {
        if CPTR_EL3[TFP] == 0b1 then {
            if EL3SDDUndef() then {
                throw(Error_Undefined())
            } else {
                AArch64_AdvSIMDFPAccessTrap(EL3)
            }
        };
        ()
    };
    ()
}

val AArch64_CheckFPEnabled : unit -> unit

function AArch64_CheckFPEnabled () = {
    if (PSTATE.EL == EL0 | PSTATE.EL == EL1) & not_bool(IsInHost()) then {
        disabled : bool = undefined;
        match CPACR_EL1[FPEN] {
          [_, bitzero] => {
              disabled = true
          },
          0b01 => {
              disabled = PSTATE.EL == EL0
          },
          0b11 => {
              disabled = false
          }
        };
        let disabled = disabled;
        if disabled then {
            AArch64_AdvSIMDFPAccessTrap(EL1)
        };
        ()
    };
    AArch64_CheckFPAdvSIMDTrap()
}

val AArch64_CheckFPAdvSIMDEnabled : unit -> unit

function AArch64_CheckFPAdvSIMDEnabled () = {
    AArch64_CheckFPEnabled();
    if (HaveSME() & PSTATE.SM == 0b1) & not_bool(IsFullA64Enabled()) then {
        SMEAccessTrap(SMEExceptionType_Streaming, PSTATE.EL)
    };
    ()
}

bitfield HSTR_EL2_Type : bits(64) =
  {
    T15 : 15..15,
    T13 : 13..13,
    T12 : 12..12,
    T11 : 11..11,
    T10 : 10..10,
    T9 : 9..9,
    T8 : 8..8,
    T7 : 7..7,
    T6 : 6..6,
    T5 : 5..5,
    T3 : 3..3,
    T2 : 2..2,
    T1 : 1..1,
    T0 : 0..0
  }

register HSTR_EL2 : HSTR_EL2_Type

val AArch64_CheckCP15InstrCoarseTraps : forall 'CRm 'CRn 'nreg.
  (int('CRn), int('nreg), int('CRm)) -> unit

function AArch64_CheckCP15InstrCoarseTraps (CRn, nreg, CRm) = {
    major : int = undefined;
    let trapped_encoding : bool = (CRn == 9 & (CRm == 0 | CRm == 1 | CRm == 2 | CRm == 5 | CRm == 6 | CRm == 7 | CRm == 8) | CRn == 10 & (CRm == 0 | CRm == 1 | CRm == 4 | CRm == 8)) | CRn == 11 & (CRm == 0 | CRm == 1 | CRm == 2 | CRm == 3 | CRm == 4 | CRm == 5 | CRm == 6 | CRm == 7 | CRm == 8 | CRm == 15);
    if ((((HaveFeatTIDCP1() & PSTATE.EL == EL0) & not_bool(IsInHost())) & not_bool(ELUsingAArch32(EL1))) & SCTLR_EL1[TIDCP] == 0b1) & trapped_encoding then {
        if EL2Enabled() & HCR_EL2[TGE] == 0b1 then {
            AArch64_AArch32SystemAccessTrap(EL2, UInt(0x3))
        } else {
            AArch64_AArch32SystemAccessTrap(EL1, UInt(0x3))
        }
    };
    if (PSTATE.EL == EL0 | PSTATE.EL == EL1) & EL2Enabled() then {
        if (((HaveFeatTIDCP1() & PSTATE.EL == EL0) & IsInHost()) & SCTLR_EL2[TIDCP] == 0b1) & trapped_encoding then {
            AArch64_AArch32SystemAccessTrap(EL2, UInt(0x3))
        };
        let 'major = if nreg == 1 then CRn else CRm;
        assert(constraint((0 <= 'major & 'major < 64)));
        if (not_bool(IsInHost()) & not_bool(major == 4 | major == 14)) & [HSTR_EL2.bits[major]] == 0b1 | (HCR_EL2[TIDCP] == 0b1 & nreg == 1) & trapped_encoding then {
            if PSTATE.EL == EL0 & __IMPDEF_boolean("UNDEF unallocated CP15 access at EL0") then {
                throw(Error_Undefined())
            };
            AArch64_AArch32SystemAccessTrap(EL2, UInt(0x3))
        };
        ()
    };
    ()
}

val CheckFPEnabled64 : unit -> unit

function CheckFPEnabled64 () = {
    AArch64_CheckFPEnabled()
}

val CheckFPAdvSIMDEnabled64 : unit -> unit

function CheckFPAdvSIMDEnabled64 () = {
    AArch64_CheckFPAdvSIMDEnabled()
}

val AArch64_TakePhysicalSErrorException : forall ('implicit_esb : Bool).
  bool('implicit_esb) -> unit

function AArch64_TakePhysicalSErrorException implicit_esb = {
    let route_to_el3 : bool = HaveEL(EL3) & SCR_EL3[EA] == 0b1;
    let route_to_el2 : bool = ((PSTATE.EL == EL0 | PSTATE.EL == EL1) & EL2Enabled()) & (HCR_EL2[TGE] == 0b1 | not_bool(IsInHost()) & HCR_EL2[AMO] == 0b1);
    let preferred_exception_return : bits(64) = ThisInstrAddr(64);
    let 'vect_offset = UInt(0x180);
    target_el : bits(2) = undefined;
    if PSTATE.EL == EL3 | route_to_el3 then {
        target_el = EL3
    } else if PSTATE.EL == EL2 | route_to_el2 then {
        target_el = EL2
    } else {
        target_el = EL1
    };
    except : ExceptionRecord = ExceptionSyndrome(Exception_SError);
    let syndrome : bits(25) = AArch64_PhysicalSErrorSyndrome(implicit_esb);
    if IsSErrorEdgeTriggered() then {
        ClearPendingPhysicalSError()
    };
    except.syndrome = syndrome;
    sail_take_exception(None());
    AArch64_TakeException(target_el, except, preferred_exception_return, vect_offset)
}

val AArch64_TakeVirtualSErrorException : unit -> unit

function AArch64_TakeVirtualSErrorException () = {
    impdef_syndrome : bool = undefined;
    assert((PSTATE.EL == EL0 | PSTATE.EL == EL1) & EL2Enabled());
    assert(HCR_EL2[TGE] == 0b0 & HCR_EL2[AMO] == 0b1);
    let preferred_exception_return : bits(64) = ThisInstrAddr(64);
    let 'vect_offset = UInt(0x180);
    except : ExceptionRecord = ExceptionSyndrome(Exception_SError);
    if HaveRASExt() then {
        except.syndrome[24] = Bit(VSESR_EL2[IDS]);
        except.syndrome[23 .. 0] = VSESR_EL2[ISS]
    } else {
        let syndrome : bits(25) = __IMPDEF_bits(25, "Virtual SError syndrome");
        let impdef_syndrome : bool = [syndrome[24]] == 0b1;
        if impdef_syndrome then {
            except.syndrome = syndrome
        };
        ()
    };
    ClearPendingVirtualSError();
    sail_take_exception(None());
    AArch64_TakeException(EL1, except, preferred_exception_return, vect_offset)
}

val AArch64_TakePhysicalIRQException : unit -> unit

function AArch64_TakePhysicalIRQException () = {
    let route_to_el3 : bool = HaveEL(EL3) & SCR_EL3[IRQ] == 0b1;
    let route_to_el2 : bool = ((PSTATE.EL == EL0 | PSTATE.EL == EL1) & EL2Enabled()) & (HCR_EL2[TGE] == 0b1 | HCR_EL2[IMO] == 0b1);
    let preferred_exception_return : bits(64) = ThisInstrAddr(64);
    let 'vect_offset = UInt(0x80);
    let except : ExceptionRecord = ExceptionSyndrome(Exception_IRQ);
    sail_take_exception(None());
    if route_to_el3 then {
        AArch64_TakeException(EL3, except, preferred_exception_return, vect_offset)
    } else if PSTATE.EL == EL2 | route_to_el2 then {
        assert(PSTATE.EL != EL3);
        AArch64_TakeException(EL2, except, preferred_exception_return, vect_offset)
    } else {
        assert(PSTATE.EL == EL0 | PSTATE.EL == EL1);
        AArch64_TakeException(EL1, except, preferred_exception_return, vect_offset)
    }
}

val AArch64_TakeVirtualIRQException : unit -> unit

function AArch64_TakeVirtualIRQException () = {
    assert((PSTATE.EL == EL0 | PSTATE.EL == EL1) & EL2Enabled());
    assert(HCR_EL2[TGE] == 0b0 & HCR_EL2[IMO] == 0b1);
    let preferred_exception_return : bits(64) = ThisInstrAddr(64);
    let 'vect_offset = UInt(0x80);
    let except : ExceptionRecord = ExceptionSyndrome(Exception_IRQ);
    sail_take_exception(None());
    AArch64_TakeException(EL1, except, preferred_exception_return, vect_offset)
}

val AArch64_TakePhysicalFIQException : unit -> unit

function AArch64_TakePhysicalFIQException () = {
    let route_to_el3 : bool = HaveEL(EL3) & SCR_EL3[FIQ] == 0b1;
    let route_to_el2 : bool = ((PSTATE.EL == EL0 | PSTATE.EL == EL1) & EL2Enabled()) & (HCR_EL2[TGE] == 0b1 | HCR_EL2[FMO] == 0b1);
    let preferred_exception_return : bits(64) = ThisInstrAddr(64);
    let 'vect_offset = UInt(0x100);
    let except : ExceptionRecord = ExceptionSyndrome(Exception_FIQ);
    sail_take_exception(None());
    if route_to_el3 then {
        AArch64_TakeException(EL3, except, preferred_exception_return, vect_offset)
    } else if PSTATE.EL == EL2 | route_to_el2 then {
        assert(PSTATE.EL != EL3);
        AArch64_TakeException(EL2, except, preferred_exception_return, vect_offset)
    } else {
        assert(PSTATE.EL == EL0 | PSTATE.EL == EL1);
        AArch64_TakeException(EL1, except, preferred_exception_return, vect_offset)
    }
}

val AArch64_TakeVirtualFIQException : unit -> unit

function AArch64_TakeVirtualFIQException () = {
    assert((PSTATE.EL == EL0 | PSTATE.EL == EL1) & EL2Enabled());
    assert(HCR_EL2[TGE] == 0b0 & HCR_EL2[FMO] == 0b1);
    let preferred_exception_return : bits(64) = ThisInstrAddr(64);
    let 'vect_offset = UInt(0x100);
    let except : ExceptionRecord = ExceptionSyndrome(Exception_FIQ);
    sail_take_exception(None());
    AArch64_TakeException(EL1, except, preferred_exception_return, vect_offset)
}

val AArch64_SoftwareBreakpoint : bits(16) -> unit

function AArch64_SoftwareBreakpoint immediate = {
    let route_to_el2 : bool = ((PSTATE.EL == EL0 | PSTATE.EL == EL1) & EL2Enabled()) & (HCR_EL2[TGE] == 0b1 | MDCR_EL2[TDE] == 0b1);
    let preferred_exception_return : bits(64) = ThisInstrAddr(64);
    let 'vect_offset = UInt(0x0);
    except : ExceptionRecord = ExceptionSyndrome(Exception_SoftwareBreakpoint);
    except.syndrome[15 .. 0] = immediate;
    sail_take_exception(None());
    if UInt(PSTATE.EL) > UInt(EL1) then {
        AArch64_TakeException(PSTATE.EL, except, preferred_exception_return, vect_offset)
    } else if route_to_el2 then {
        AArch64_TakeException(EL2, except, preferred_exception_return, vect_offset)
    } else {
        AArch64_TakeException(EL1, except, preferred_exception_return, vect_offset)
    }
}

val SoftwareStep_DidNotStep : unit -> bool

val SoftwareStep_SteppedEX : unit -> bool

val AArch64_SoftwareStepException : unit -> unit

function AArch64_SoftwareStepException () = {
    assert(PSTATE.EL != EL3);
    let route_to_el2 : bool = ((PSTATE.EL == EL0 | PSTATE.EL == EL1) & EL2Enabled()) & (HCR_EL2[TGE] == 0b1 | MDCR_EL2[TDE] == 0b1);
    let preferred_exception_return : bits(64) = ThisInstrAddr(64);
    let 'vect_offset = UInt(0x0);
    except : ExceptionRecord = ExceptionSyndrome(Exception_SoftwareStep);
    if SoftwareStep_DidNotStep() then {
        except.syndrome[24] = Bit(0b0)
    } else {
        except.syndrome[24] = Bit(0b1);
        except.syndrome[6] = Bit(if SoftwareStep_SteppedEX() then 0b1 else 0b0)
    };
    except.syndrome[5 .. 0] = 0b100010;
    sail_take_exception(None());
    if PSTATE.EL == EL2 | route_to_el2 then {
        AArch64_TakeException(EL2, except, preferred_exception_return, vect_offset)
    } else {
        AArch64_TakeException(EL1, except, preferred_exception_return, vect_offset)
    }
}

val AArch64_PCAlignmentFault : unit -> unit

function AArch64_PCAlignmentFault () = {
    let preferred_exception_return : bits(64) = ThisInstrAddr(64);
    let 'vect_offset = UInt(0x0);
    except : ExceptionRecord = ExceptionSyndrome(Exception_PCAlignment);
    except.vaddress = ThisInstrAddr(64);
    target_el : bits(2) = EL1;
    if UInt(PSTATE.EL) > UInt(EL1) then {
        target_el = PSTATE.EL
    } else if EL2Enabled() & HCR_EL2[TGE] == 0b1 then {
        target_el = EL2
    } else ();
    sail_take_exception(None());
    AArch64_TakeException(target_el, except, preferred_exception_return, vect_offset)
}

val AArch64_CheckPCAlignment : unit -> unit

function AArch64_CheckPCAlignment () = {
    let pc : bits(64) = ThisInstrAddr(64);
    if pc[1 .. 0] != 0b00 then {
        AArch64_PCAlignmentFault()
    };
    ()
}

bitfield MDSELR_EL1_Type : bits(64) = {BANK : 5..4}

register MDSELR_EL1 : MDSELR_EL1_Type

val EffectiveMDSELR_EL1_BANK : unit -> bits(2)

function EffectiveMDSELR_EL1_BANK () = {
    let 'num_bp = NumBreakpointsImplemented();
    let 'num_wp = NumWatchpointsImplemented();
    if num_bp <= 16 & num_wp <= 16 then {
        return(0b00)
    };
    if (HaveEL(EL3) & MDCR_EL3[EBWE] == 0b0 | (PSTATE.EL != EL3 & EL2Enabled()) & MDCR_EL2[EBWE] == 0b0) | PSTATE.EL == EL1 & MDSCR_EL1[EMBWE] == 0b0 then {
        return(0b00)
    };
    bank : bits(2) = MDSELR_EL1[BANK];
    if (bank == 0b11 & num_bp <= 48) & num_wp <= 48 | (bank == 0b10 & num_bp <= 32) & num_wp <= 32 then {
        let (_, __tup_1 : bits(2)) = ConstrainUnpredictableBits(Unpredictable_RESMDSELR, 2);
        bank = __tup_1
    };
    return(bank)
}

type PMEVCNTR_EL0_Type = bits(64)

register PMEVCNTR_EL0 : vector(32, PMEVCNTR_EL0_Type)

val AArch64_IncrementEventCounter : forall 'idx 'increment_name,
  0 <= 'idx & 'idx < 31.
  (int('idx), int('increment_name)) -> unit

function AArch64_IncrementEventCounter (idx, increment_name) = {
    ovflw : {32, 64} = 32;
    let 'old_value = UInt(PMEVCNTR_EL0[idx]);
    let 'new_value = old_value + PMUCountValue(idx, increment_name);
    lp : bits(1) = undefined;
    if HavePMUv3p5() then {
        PMEVCNTR_EL0[idx] = new_value[63 .. 0];
        lp = if PMUCounterIsHyp(idx) then MDCR_EL2[HLP] else PMCR_EL0[LP];
        ovflw = if lp == 0b1 then 64 else 32
    } else {
        PMEVCNTR_EL0[idx] = ZeroExtend(new_value[31 .. 0], 64);
        ovflw = 32
    };
    let 'ovflw = ovflw;
    if old_value[64 .. ovflw] != new_value[64 .. ovflw] then {
        PMOVSSET_EL0.bits[idx] = Bit(0b1);
        PMOVSCLR_EL0.bits[idx] = Bit(0b1);
        if ([idx[0]] == 0b0 & idx + 1 < GetNumEventCounters()) & (not_bool(HavePMUv3p5()) | lp == 0b0) then {
            PMUEvent__2(PMU_EVENT_CHAIN, 1, idx + 1)
        };
        ()
    };
    ()
}

val AArch64_ClearEventCounters : unit -> unit

function AArch64_ClearEventCounters () = {
    let 'counters = AArch64_GetNumEventCountersAccessible();
    if counters != 0 then {
        foreach (idx from 0 to (counters - 1) by 1 in inc) {
            assert(constraint((0 <= 'loop_idx & 'loop_idx < 32)));
            PMEVCNTR_EL0[idx] = Zeros(64)
        }
    };
    ()
}

val AArch64_PMUSwIncrement : bits(32) -> unit

function AArch64_PMUSwIncrement sw_incr = {
    if PMCR_EL0[E] == 0b0 & MDCR_EL2[HPME] == 0b0 then {
        return()
    };
    let 'counters = AArch64_GetNumEventCountersAccessible();
    if counters != 0 then {
        foreach (idx from 0 to (counters - 1) by 1 in inc) {
            assert(constraint((0 <= 'loop_idx & 'loop_idx < 32)));
            if [sw_incr[idx]] == 0b1 then {
                PMUEvent__2(PMU_EVENT_SW_INCR, 1, idx)
            };
            ()
        }
    };
    ()
}

bitfield PMCCNTR_EL0_Type : bits(64) = {CCNT : 63..0}

register PMCCNTR_EL0 : PMCCNTR_EL0_Type

val AArch64_IncrementCycleCounter : unit -> unit

function AArch64_IncrementCycleCounter () = {
    if CountPMUEvents(CYCLE_COUNTER_ID) & (((not_bool(HaveAArch32()) | PMCR_EL0[LC] == 0b1) | PMCR_EL0[D] == 0b0) | HasElapsed64Cycles()) then {
        let 'old_value = UInt(PMCCNTR_EL0.bits);
        let 'new_value = old_value + 1;
        PMCCNTR_EL0 = Mk_PMCCNTR_EL0_Type(new_value[63 .. 0]);
        ovflw : {32, 64} = 32;
        if HaveAArch32() then {
            ovflw = if PMCR_EL0[LC] == 0b1 then 64 else 32
        } else {
            ovflw = 64
        };
        let 'ovflw = ovflw;
        if old_value[64 .. ovflw] != new_value[64 .. ovflw] then {
            PMOVSSET_EL0[C] = 0b1;
            PMOVSCLR_EL0[C] = 0b1
        };
        ()
    };
    ()
}

val AArch64_PMUCycle : unit -> unit

function AArch64_PMUCycle () = {
    if PMCR_EL0[E] == 0b0 & MDCR_EL2[HPME] == 0b0 then {
        if ShouldBRBEFreeze() then {
            BRBEFreeze()
        };
        return()
    };
    if not_bool(HavePMUv3()) then {
        return()
    };
    PMUEvent(PMU_EVENT_CPU_CYCLES);
    let 'counters = GetNumEventCounters();
    if counters != 0 then {
        foreach (idx from 0 to (counters - 1) by 1 in inc) {
            assert(constraint((0 <= 'loop_idx & 'loop_idx <= 32)));
            if CountPMUEvents(idx) then {
                assert(constraint((0 <= 'loop_idx & 'loop_idx < 31)));
                let 'accumulated = PMUEventAccumulator[idx];
                AArch64_IncrementEventCounter(idx, accumulated)
            };
            assert(constraint((0 <= 'loop_idx & 'loop_idx < 31)));
            PMUEventAccumulator[idx] = 0
        }
    };
    AArch64_IncrementCycleCounter();
    CheckForPMUOverflow()
}

val ProfilingSynchronizationBarrier : unit -> unit

val SPESampleAddAddressPCVirtual : unit -> unit

function SPESampleAddAddressPCVirtual () = {
    let this_address : bits(64) = ThisInstrAddr(64);
    SPESampleAddress[SPEAddrPosPCVirtual][55 .. 0] = this_address[55 .. 0];
    ns : bits(1) = undefined;
    nse : bits(1) = undefined;
    match CurrentSecurityState() {
      SS_Secure => {
          ns = 0b0;
          nse = 0b0
      },
      SS_NonSecure => {
          ns = 0b1;
          nse = 0b0
      },
      SS_Realm => {
          ns = 0b1;
          nse = 0b1
      },
      _ => {
          Unreachable()
      }
    };
    let el : bits(2) = PSTATE.EL;
    SPESampleAddress[SPEAddrPosPCVirtual][63 .. 56] = ((ns @ el) @ nse) @ Zeros(4);
    SPESampleAddressValid[SPEAddrPosPCVirtual] = true
}

val CollectContextIDR1 : unit -> bool

function CollectContextIDR1 () = {
    if not_bool(StatisticalProfilingEnabled()) then {
        return(false)
    };
    if PSTATE.EL == EL2 then {
        return(false)
    };
    if EL2Enabled() & HCR_EL2[TGE] == 0b1 then {
        return(false)
    };
    return(PMSCR_EL1[CX] == 0b1)
}

val CollectContextIDR2 : unit -> bool

function CollectContextIDR2 () = {
    if not_bool(StatisticalProfilingEnabled()) then {
        return(false)
    };
    if not_bool(EL2Enabled()) then {
        return(false)
    };
    return(PMSCR_EL2[CX] == 0b1)
}

val SPESampleAddContext : unit -> unit

function SPESampleAddContext () = {
    if CollectContextIDR1() then {
        SPESampleContextEL1 = CONTEXTIDR_EL1.bits[31 .. 0];
        SPESampleContextEL1Valid = true
    };
    if CollectContextIDR2() then {
        SPESampleContextEL2 = CONTEXTIDR_EL2.bits[31 .. 0];
        SPESampleContextEL2Valid = true
    };
    ()
}

val SPESampleAddOpOther : forall ('conditional : Bool) ('taken : Bool).
  (bool('conditional), bool('taken)) -> unit

val SPESampleAddOpOther__1 : forall ('conditional : Bool).
  bool('conditional) -> unit

function SPESampleAddOpOther (conditional, taken) = {
    SPESampleEvents[6] = Bit(if conditional & not_bool(taken) then 0b1 else 0b0);
    SPESampleAddOpOther__1(conditional)
}

function SPESampleAddOpOther__1 conditional = {
    SPESampleClass = 0b00;
    SPESampleSubclass[0] = Bit(if conditional then 0b1 else 0b0);
    SPESampleOpType = OpType_Other
}

val CollectTimeStamp : unit -> TimeStamp

function CollectTimeStamp () = {
    owning_el : bits(2) = undefined;
    if not_bool(StatisticalProfilingEnabled()) then {
        return(TimeStamp_None)
    };
    let (_, __tup_1 : bits(2)) = ProfilingBufferOwner() in
      {
          owning_el = __tup_1
      };
    if owning_el == EL2 then {
        if PMSCR_EL2[TS] == 0b0 then {
            return(TimeStamp_None)
        };
        ()
    } else {
        if PMSCR_EL1[TS] == 0b0 then {
            return(TimeStamp_None)
        };
        ()
    };
    PCT_el1 : bits(2) = undefined;
    if not_bool(HaveECVExt()) then {
        PCT_el1 = 0b0 @ [PMSCR_EL1[PCT][0]]
    } else {
        PCT_el1 = PMSCR_EL1[PCT];
        if PCT_el1 == 0b10 then {
            let (_, __tup_1 : bits(2)) = ConstrainUnpredictableBits(Unpredictable_PMSCR_PCT, 2);
            PCT_el1 = __tup_1
        };
        ()
    };
    if EL2Enabled() then {
        PCT_el2 : bits(2) = undefined;
        if not_bool(HaveECVExt()) then {
            PCT_el2 = 0b0 @ [PMSCR_EL2[PCT][0]]
        } else {
            PCT_el2 = PMSCR_EL2[PCT];
            if PCT_el2 == 0b10 then {
                let (_, __tup_1 : bits(2)) = ConstrainUnpredictableBits(Unpredictable_PMSCR_PCT, 2);
                PCT_el2 = __tup_1
            };
            ()
        };
        match PCT_el2 {
          0b00 => {
              return(if IsInHost() then TimeStamp_Physical else
                TimeStamp_Virtual)
          },
          0b01 => {
              if owning_el == EL2 then {
                  return(TimeStamp_Physical)
              };
              ()
          },
          0b11 => {
              assert(HaveECVExt());
              if owning_el == EL1 & PCT_el1 == 0b00 then {
                  return(if IsInHost() then TimeStamp_Physical else
                    TimeStamp_Virtual)
              } else {
                  return(TimeStamp_OffsetPhysical)
              }
          },
          _ => {
              Unreachable()
          }
        }
    };
    match PCT_el1 {
      0b00 => {
          return(if IsInHost() then TimeStamp_Physical else TimeStamp_Virtual)
      },
      0b01 => {
          return(TimeStamp_Physical)
      },
      0b11 => {
          assert(HaveECVExt());
          return(TimeStamp_OffsetPhysical)
      },
      _ => {
          Unreachable();
          return(undefined : TimeStamp)
      }
    }
}

val SPESampleAddTimeStamp : unit -> unit

function SPESampleAddTimeStamp () = {
    let timestamp : TimeStamp = CollectTimeStamp();
    match timestamp {
      TimeStamp_None => {
          SPESampleTimestampValid = false
      },
      _ => {
          SPESampleTimestampValid = true;
          SPESampleTimestamp = GetTimestamp(timestamp)
      }
    }
}

bitfield PMSICR_EL1_Type : bits(64) = {ECOUNT : 63..56, COUNT : 31..0}

register PMSICR_EL1 : PMSICR_EL1_Type

bitfield PMSIRR_EL1_Type : bits(64) = {INTERVAL : 31..8, RND : 0..0}

register PMSIRR_EL1 : PMSIRR_EL1_Type

val SPEGetRandomInterval : unit -> bits(8)

function SPEGetRandomInterval () = {
    new_byte : bits(8) = undefined;
    if not_bool(__SPE_LFSR_initialized) then {
        __SPE_LFSR_initialized = true;
        __SPE_LFSR = PC_read__1()[23 .. 0];
        foreach (i from 7 to 0 by 1 in dec) {
            new_byte = EOR(EOR(__SPE_LFSR[16 .. 9], __SPE_LFSR[21 .. 14]), __SPE_LFSR[22 .. 15]);
            new_byte = EOR(new_byte, __SPE_LFSR[23 .. 16]);
            __SPE_LFSR = __SPE_LFSR[15 .. 0] @ new_byte
        }
    } else {
        new_byte : bits(8) = EOR(EOR(__SPE_LFSR[16 .. 9], __SPE_LFSR[21 .. 14]), __SPE_LFSR[22 .. 15]);
        let new_byte : bits(8) = EOR(new_byte, __SPE_LFSR[23 .. 16]);
        __SPE_LFSR = __SPE_LFSR[15 .. 0] @ new_byte
    };
    return(__SPE_LFSR[23 .. 16])
}

val SPEResetSampleCounter : unit -> unit

function SPEResetSampleCounter () = {
    PMSICR_EL1[COUNT][31 .. 8] = PMSIRR_EL1[INTERVAL];
    if PMSIRR_EL1[RND] == 0b1 & PMSIDR_EL1[ERnd] == 0b0 then {
        PMSICR_EL1[COUNT][7 .. 0] = SPEGetRandomInterval()
    } else {
        PMSICR_EL1[COUNT][7 .. 0] = Zeros(8)
    }
}

val SPEToCollectSample : unit -> bool

function SPEToCollectSample () = {
    if IsZero(PMSICR_EL1[COUNT]) then {
        SPEResetSampleCounter()
    } else {
        PMSICR_EL1[COUNT] = PMSICR_EL1[COUNT] - 1;
        if IsZero(PMSICR_EL1[COUNT]) then {
            if PMSIRR_EL1[RND] == 0b1 & PMSIDR_EL1[ERnd] == 0b1 then {
                PMSICR_EL1[ECOUNT] = SPEGetRandomInterval()
            } else {
                return(true)
            }
        };
        ()
    };
    if UInt(PMSICR_EL1[ECOUNT]) != 0 then {
        PMSICR_EL1[ECOUNT] = PMSICR_EL1[ECOUNT] - 1;
        if IsZero(PMSICR_EL1[ECOUNT]) then {
            return(true)
        };
        ()
    };
    return(false)
}

val SPEPreExecution : unit -> unit

function SPEPreExecution () = {
    if StatisticalProfilingEnabled() then {
        PMUEvent(PMU_EVENT_SAMPLE_POP);
        if SPEToCollectSample() then {
            if not_bool(SPESampleInFlight) then {
                SPESampleInFlight = true;
                SPEStartCounter(SPECounterPosTotalLatency);
                SPEStartCounter(SPECounterPosIssueLatency);
                SPESampleAddContext();
                SPESampleAddAddressPCVirtual();
                SPESampleAddTimeStamp()
            } else {
                PMUEvent(PMU_EVENT_SAMPLE_COLLISION);
                PMBSR_EL1[COLL] = 0b1
            };
            SPESampleAddOpOther__1(false)
        };
        ()
    };
    ()
}

val SPEBufferFilled : unit -> unit

function SPEBufferFilled () = {
    if IsZero(PMBSR_EL1[S]) then {
        PMBSR_EL1[S] = 0b1;
        PMBSR_EL1[EC] = 0b000000;
        PMBSR_EL1[MSS] = ZeroExtend(0b000001, 16)
    };
    PMUEvent(PMU_EVENT_SAMPLE_WRAP)
}

bitfield PMBPTR_EL1_Type : bits(64) = {PTR : 63..0}

register PMBPTR_EL1 : PMBPTR_EL1_Type

val SPEBufferIsFull : unit -> bool

function SPEBufferIsFull () = {
    let 'write_pointer_limit = UInt(PMBLIMITR_EL1[LIMIT] @ Zeros(12));
    let 'current_write_pointer = UInt(PMBPTR_EL1.bits);
    let 'record_max_size = (1 << UInt(PMSIDR_EL1[MaxSize]));
    return(current_write_pointer > write_pointer_limit - record_max_size)
}

bitfield PMSDSFR_EL1_Type : bits(64) =
  {
    S63 : 63..63,
    S62 : 62..62,
    S61 : 61..61,
    S60 : 60..60,
    S59 : 59..59,
    S58 : 58..58,
    S57 : 57..57,
    S56 : 56..56,
    S55 : 55..55,
    S54 : 54..54,
    S53 : 53..53,
    S52 : 52..52,
    S51 : 51..51,
    S50 : 50..50,
    S49 : 49..49,
    S48 : 48..48,
    S47 : 47..47,
    S46 : 46..46,
    S45 : 45..45,
    S44 : 44..44,
    S43 : 43..43,
    S42 : 42..42,
    S41 : 41..41,
    S40 : 40..40,
    S39 : 39..39,
    S38 : 38..38,
    S37 : 37..37,
    S36 : 36..36,
    S35 : 35..35,
    S34 : 34..34,
    S33 : 33..33,
    S32 : 32..32,
    S31 : 31..31,
    S30 : 30..30,
    S29 : 29..29,
    S28 : 28..28,
    S27 : 27..27,
    S26 : 26..26,
    S25 : 25..25,
    S24 : 24..24,
    S23 : 23..23,
    S22 : 22..22,
    S21 : 21..21,
    S20 : 20..20,
    S19 : 19..19,
    S18 : 18..18,
    S17 : 17..17,
    S16 : 16..16,
    S15 : 15..15,
    S14 : 14..14,
    S13 : 13..13,
    S12 : 12..12,
    S11 : 11..11,
    S10 : 10..10,
    S9 : 9..9,
    S8 : 8..8,
    S7 : 7..7,
    S6 : 6..6,
    S5 : 5..5,
    S4 : 4..4,
    S3 : 3..3,
    S2 : 2..2,
    S1 : 1..1,
    S0 : 0..0
  }

register PMSDSFR_EL1 : PMSDSFR_EL1_Type

bitfield PMSEVFR_EL1_Type : bits(64) =
  {
    E63 : 63..63,
    E62 : 62..62,
    E61 : 61..61,
    E60 : 60..60,
    E59 : 59..59,
    E58 : 58..58,
    E57 : 57..57,
    E56 : 56..56,
    E55 : 55..55,
    E54 : 54..54,
    E53 : 53..53,
    E52 : 52..52,
    E51 : 51..51,
    E50 : 50..50,
    E49 : 49..49,
    E48 : 48..48,
    E31 : 31..31,
    E30 : 30..30,
    E29 : 29..29,
    E28 : 28..28,
    E27 : 27..27,
    E26 : 26..26,
    E25 : 25..25,
    E24 : 24..24,
    E23 : 23..23,
    E22 : 22..22,
    E21 : 21..21,
    E20 : 20..20,
    E19 : 19..19,
    E18 : 18..18,
    E17 : 17..17,
    E16 : 16..16,
    E15 : 15..15,
    E14 : 14..14,
    E13 : 13..13,
    E12 : 12..12,
    E11 : 11..11,
    E10 : 10..10,
    E9 : 9..9,
    E8 : 8..8,
    E7 : 7..7,
    E6 : 6..6,
    E5 : 5..5,
    E4 : 4..4,
    E3 : 3..3,
    E2 : 2..2,
    E1 : 1..1
  }

register PMSEVFR_EL1 : PMSEVFR_EL1_Type

bitfield PMSFCR_EL1_Type : bits(64) =
  {
    ST : 18..18,
    LD : 17..17,
    B : 16..16,
    FDS : 4..4,
    FnE : 3..3,
    FL : 2..2,
    FT : 1..1,
    FE : 0..0
  }

register PMSFCR_EL1 : PMSFCR_EL1_Type

bitfield PMSLATFR_EL1_Type : bits(64) = {MINLAT : 15..0}

register PMSLATFR_EL1 : PMSLATFR_EL1_Type

bitfield PMSNEVFR_EL1_Type : bits(64) =
  {
    E63 : 63..63,
    E62 : 62..62,
    E61 : 61..61,
    E60 : 60..60,
    E59 : 59..59,
    E58 : 58..58,
    E57 : 57..57,
    E56 : 56..56,
    E55 : 55..55,
    E54 : 54..54,
    E53 : 53..53,
    E52 : 52..52,
    E51 : 51..51,
    E50 : 50..50,
    E49 : 49..49,
    E48 : 48..48,
    E31 : 31..31,
    E30 : 30..30,
    E29 : 29..29,
    E28 : 28..28,
    E27 : 27..27,
    E26 : 26..26,
    E25 : 25..25,
    E24 : 24..24,
    E23 : 23..23,
    E22 : 22..22,
    E21 : 21..21,
    E20 : 20..20,
    E19 : 19..19,
    E18 : 18..18,
    E17 : 17..17,
    E16 : 16..16,
    E15 : 15..15,
    E14 : 14..14,
    E13 : 13..13,
    E12 : 12..12,
    E11 : 11..11,
    E10 : 10..10,
    E9 : 9..9,
    E8 : 8..8,
    E7 : 7..7,
    E6 : 6..6,
    E5 : 5..5,
    E4 : 4..4,
    E3 : 3..3,
    E2 : 2..2,
    E1 : 1..1
  }

register PMSNEVFR_EL1 : PMSNEVFR_EL1_Type

val SPECollectRecord : forall 'total_latency.
  (bits(64), int('total_latency), OpType) -> bool

function SPECollectRecord (events, total_latency, optype) = {
    assert(StatisticalProfilingEnabled());
    mask : bits(64) = ZeroExtend(0xAA, 64);
    m : bits(64) = undefined;
    if HaveSVE() then {
        mask[18 .. 17] = 0b11
    };
    if HaveTME() then {
        mask[16] = Bit(0b1)
    };
    if HaveStatisticalProfilingv1p1() then {
        mask[11] = Bit(0b1)
    };
    if HaveStatisticalProfilingv1p2() then {
        mask[6] = Bit(0b1)
    };
    if HaveStatisticalProfilingv1p4() then {
        (mask[10 .. 8] @ mask[4 .. 4] @ mask[2 .. 2]) = 0b11111
    } else {
        let impdef_mask : bits(5) = __IMPDEF_bits(5, "SPE mask 10:8,4,2");
        (mask[10 .. 8] @ mask[4 .. 4] @ mask[2 .. 2]) = impdef_mask
    };
    mask[63 .. 48] = __IMPDEF_bits(16, "SPE mask 63:48");
    mask[31 .. 24] = __IMPDEF_bits(8, "SPE mask 31:24");
    mask[15 .. 12] = __IMPDEF_bits(4, "SPE mask 15:12");
    let e : bits(64) = events & mask;
    is_rejected_nevent : bool = false;
    is_nevt : bool = undefined;
    if HaveStatisticalProfilingv1p2() then {
        m = PMSNEVFR_EL1.bits & mask;
        is_nevt = IsZero(e & m);
        if PMSFCR_EL1[FnE] == 0b1 then {
            if not_bool(IsZero(m)) then {
                is_rejected_nevent = not_bool(is_nevt)
            } else {
                is_rejected_nevent = ConstrainUnpredictableBool(Unpredictable_BADPMSFCR)
            }
        };
        ()
    } else {
        is_nevt = true
    };
    is_rejected_event : bool = false;
    let m : bits(64) = PMSEVFR_EL1.bits & mask;
    let is_evt : bool = IsZero(not_vec(e) & m);
    if PMSFCR_EL1[FE] == 0b1 then {
        if not_bool(IsZero(m)) then {
            is_rejected_event = not_bool(is_evt)
        } else {
            is_rejected_event = ConstrainUnpredictableBool(Unpredictable_BADPMSFCR)
        }
    };
    if (HaveStatisticalProfilingv1p2() & (PMSFCR_EL1[FnE] @ PMSFCR_EL1[FE]) == 0b11) & not_bool(IsZero((PMSEVFR_EL1.bits & PMSNEVFR_EL1.bits) & mask)) then {
        is_rejected_nevent = ConstrainUnpredictableBool(Unpredictable_BADPMSFCR);
        is_rejected_event = ConstrainUnpredictableBool(Unpredictable_BADPMSFCR)
    };
    if is_evt & is_nevt then {
        PMUEvent(PMU_EVENT_SAMPLE_FEED_EVENT)
    };
    is_op_br : bool = false;
    is_op_ld : bool = false;
    is_op_st : bool = false;
    let is_op_br : bool = optype == OpType_Branch;
    let is_op_ld : bool = optype == OpType_Load | optype == OpType_LoadAtomic;
    let is_op_st : bool = optype == OpType_Store | optype == OpType_LoadAtomic;
    if is_op_br then {
        PMUEvent(PMU_EVENT_SAMPLE_FEED_BR)
    };
    if is_op_ld then {
        PMUEvent(PMU_EVENT_SAMPLE_FEED_LD)
    };
    if is_op_st then {
        PMUEvent(PMU_EVENT_SAMPLE_FEED_ST)
    };
    let is_op : bool = (is_op_br & PMSFCR_EL1[B] == 0b1 | is_op_ld & PMSFCR_EL1[LD] == 0b1) | is_op_st & PMSFCR_EL1[ST] == 0b1;
    if is_op then {
        PMUEvent(PMU_EVENT_SAMPLE_FEED_OP)
    };
    is_rejected_type : bool = false;
    if PMSFCR_EL1[FT] == 0b1 then {
        if not_bool(IsZero(PMSFCR_EL1[B] @ (PMSFCR_EL1[LD] @ PMSFCR_EL1[ST]))) then {
            is_rejected_type = not_bool(is_op)
        } else {
            is_rejected_type = ConstrainUnpredictableBool(Unpredictable_BADPMSFCR)
        }
    };
    is_rejected_latency : bool = false;
    let is_lat : bool = total_latency < UInt(PMSLATFR_EL1[MINLAT]);
    if is_lat then {
        PMUEvent(PMU_EVENT_SAMPLE_FEED_LAT)
    };
    if PMSFCR_EL1[FL] == 0b1 then {
        if not_bool(IsZero(PMSLATFR_EL1[MINLAT])) then {
            is_rejected_latency = not_bool(is_lat)
        } else {
            is_rejected_latency = ConstrainUnpredictableBool(Unpredictable_BADPMSFCR)
        }
    };
    is_rejected_data_source : bool = undefined;
    if ((HaveStatisticalProfilingFDS() & PMSFCR_EL1[FDS] == 0b1) & is_op_ld) & SPESampleDataSourceValid then {
        let data_source : bits(16) = SPESampleDataSource;
        let 'index = UInt(data_source[5 .. 0]);
        is_rejected_data_source = [PMSDSFR_EL1.bits[index]] == 0b0
    } else {
        is_rejected_data_source = false
    };
    let return_value : bool = not_bool(((is_rejected_nevent | is_rejected_event) | is_rejected_type) | is_rejected_latency);
    if return_value then {
        PMUEvent(PMU_EVENT_SAMPLE_FILTRATE)
    };
    return(return_value)
}

bitfield PMBIDR_EL1_Type : bits(64) =
  {EA : 11..8, F : 5..5, P : 4..4, Align : 3..0}

register PMBIDR_EL1 : PMBIDR_EL1_Type

register SPERecordData : vector(64, bits(8))

val SPEAddByteToRecord : bits(8) -> unit

function SPEAddByteToRecord b = {
    let size = SPERecordSize;
    assert(0 <= size & size < SPEMaxRecordSize);
    SPERecordData[size] = b;
    SPERecordSize = size + 1
}

val SPEAddPacketToRecord : forall 'N, 'N in {8, 16, 32, 64}.
  (bits(2), bits(4), bits('N)) -> unit

function SPEAddPacketToRecord (header_hi, header_lo, payload) = {
    assert(MOD('N, 8) == 0);
    sz : bits(2) = undefined;
    match 'N {
      8 => {
          sz = 0b00
      },
      16 => {
          sz = 0b01
      },
      32 => {
          sz = 0b10
      },
      64 => {
          sz = 0b11
      },
      _ => {
          Unreachable()
      }
    };
    let header : bits(8) = (header_hi @ sz) @ header_lo;
    SPEAddByteToRecord(header);
    foreach (i from 0 to (DIV('N, 8) - 1) by 1 in inc) {
        SPEAddByteToRecord(payload[i * 8 + 7 .. i * 8])
    }
}

val SPEEmptyRecord : unit -> unit

function SPEEmptyRecord () = {
    SPERecordSize = 0;
    foreach (i from 0 to (SPEMaxRecordSize - 1) by 1 in inc) {
        SPERecordData[i] = Zeros(8)
    }
}

val SPEGetDataSourcePayloadSize : unit -> int

function SPEGetDataSourcePayloadSize () = {
    return(__IMPDEF_integer("SPE Data Source packet payload size"))
}

val SPEGetEventsPayloadSize : unit -> int

function SPEGetEventsPayloadSize () = {
    let 'size = __IMPDEF_integer("SPE Events packet payload size");
    return(size)
}

register SPESampleCounter : vector(32, int)

val DebugMemWrite : forall ('aligned : Bool).
  (bits(64), AccessDescriptor, bool('aligned), bits(8)) -> (PhysMemRetStatus, AddressDescriptor)

function DebugMemWrite (vaddress, accdesc, aligned, data) = {
    memstatus : PhysMemRetStatus = __UNKNOWN_PhysMemRetStatus();
    let 'size = 1;
    let addrdesc : AddressDescriptor = AArch64_TranslateAddress(vaddress, accdesc, aligned, size);
    if IsFault(addrdesc) then {
        return((memstatus, addrdesc))
    };
    let memstatus : PhysMemRetStatus = PhysMemWrite(addrdesc, 1, accdesc, None(), data); // TODO: TranslationInfo
    return((memstatus, addrdesc))
}

val DebugWriteExternalAbort : (PhysMemRetStatus, AddressDescriptor, bits(64)) -> unit

function DebugWriteExternalAbort (memstatus, addrdesc, start_vaddr) = {
    let iswrite : bool = true;
    handle_as_SError : bool = false;
    async_external_abort : bool = false;
    syndrome : bits(64) = undefined;
    match addrdesc.fault.access.acctype {
      AccessType_SPE => {
          handle_as_SError = __IMPDEF_boolean("SPE SyncExternal as SError");
          async_external_abort = __IMPDEF_boolean("SPE async External abort");
          syndrome = PMBSR_EL1.bits[63 .. 0]
      },
      _ => {
          Unreachable()
      }
    };
    let ttw_abort : bool = addrdesc.fault.statuscode == Fault_SyncExternalOnWalk | addrdesc.fault.statuscode == Fault_SyncParityOnWalk;
    let statuscode : Fault = if ttw_abort then addrdesc.fault.statuscode else
      memstatus.statuscode;
    let extflag : bits(1) = if ttw_abort then addrdesc.fault.extflag else
      memstatus.extflag;
    if (statuscode == Fault_AsyncExternal | statuscode == Fault_AsyncParity) | handle_as_SError then {
        fault : FaultRecord = NoFault();
        let parity : bool = statuscode == Fault_SyncParity | statuscode == Fault_AsyncParity | statuscode == Fault_SyncParityOnWalk;
        fault.statuscode = if parity then Fault_AsyncParity else
          Fault_AsyncExternal;
        if HaveRASExt() then {
            fault.merrorstate = memstatus.merrorstate
        };
        fault.extflag = extflag;
        fault.access.acctype = addrdesc.fault.access.acctype;
        PendSErrorInterrupt(fault)
    } else {
        syndrome[18] = Bit(0b1);
        if addrdesc.fault.access.acctype == AccessType_SPE & (async_external_abort | start_vaddr != addrdesc.vaddress) then {
            syndrome[19] = Bit(0b1)
        };
        if IsZero([syndrome[17]]) then {
            syndrome[17] = Bit(0b1);
            ec : bits(6) = undefined;
            if (HaveRME() & addrdesc.fault.gpcf.gpf != GPCF_None) & addrdesc.fault.gpcf.gpf != GPCF_Fail then {
                ec = 0b011110
            } else {
                ec = if addrdesc.fault.secondstage then 0b100101 else 0b100100
            };
            syndrome[31 .. 26] = ec;
            if async_external_abort then {
                syndrome[15 .. 0] = Zeros(10) @ 0b010001
            } else {
                syndrome[15 .. 0] = Zeros(10) @ EncodeLDFSC(statuscode, addrdesc.fault.level)
            }
        };
        match addrdesc.fault.access.acctype {
          AccessType_SPE => {
              PMBSR_EL1.bits[63 .. 0] = syndrome
          },
          _ => {
              Unreachable()
          }
        }
    }
}

val DebugWriteFault : (bits(64), FaultRecord) -> unit

function DebugWriteFault (vaddress, fault) = {
    syndrome : bits(64) = undefined;
    match fault.access.acctype {
      AccessType_SPE => {
          syndrome = PMBSR_EL1.bits[63 .. 0]
      },
      _ => {
          Unreachable()
      }
    };
    syndrome[15 .. 0] = Zeros(10) @ EncodeLDFSC(fault.statuscode, fault.level);
    syndrome[55 .. 32] = Zeros(24);
    ec : bits(6) = undefined;
    if (HaveRME() & fault.gpcf.gpf != GPCF_None) & fault.gpcf.gpf != GPCF_Fail then {
        ec = 0b011110
    } else {
        ec = if fault.secondstage then 0b100101 else 0b100100
    };
    syndrome[31 .. 26] = ec;
    syndrome[17] = Bit(0b1);
    if fault.statuscode == Fault_Permission then {
        syndrome[39] = Bit(if fault.assuredonly then 0b1 else 0b0);
        syndrome[38] = Bit(if fault.overlay then 0b1 else 0b0);
        syndrome[37] = Bit(if fault.dirtybit then 0b1 else 0b0)
    };
    match fault.access.acctype {
      AccessType_SPE => {
          PMBSR_EL1.bits[63 .. 0] = syndrome
      },
      _ => {
          Unreachable()
      }
    };
    return()
}

val SPEWriteToBuffer : unit -> unit

function SPEWriteToBuffer () = {
    assert(ProfilingBufferEnabled());
    let aligned : bool = is_zero_subrange(PMBPTR_EL1[PTR], UInt(PMBIDR_EL1[Align]) - 1, 0);
    let ttw_fault_as_external_abort : bool = __IMPDEF_boolean("SPE TTW fault External abort");
    fault : FaultRecord = undefined;
    memstatus : PhysMemRetStatus = undefined;
    addrdesc : AddressDescriptor = undefined;
    owning_ss : SecurityState = undefined;
    owning_el : bits(2) = undefined;
    (owning_ss, owning_el) = ProfilingBufferOwner();
    let accdesc : AccessDescriptor = CreateAccDescSPE(owning_ss, owning_el);
    let start_vaddr : bits(64) = PMBPTR_EL1.bits[63 .. 0];
    foreach (i from 0 to (SPERecordSize - 1) by 1 in inc) {
        if PMBSR_EL1[S] == 0b0 then {
            assert(constraint((0 <= 'loop_i & 'loop_i < 64)));
            (memstatus, addrdesc) = DebugMemWrite(PMBPTR_EL1.bits[63 .. 0], accdesc, aligned, SPERecordData[i]);
            fault = addrdesc.fault;
            let ttw_fault : bool = fault.statuscode == Fault_SyncExternalOnWalk | fault.statuscode == Fault_SyncParityOnWalk;
            if IsFault__1(fault.statuscode) & not_bool(ttw_fault & ttw_fault_as_external_abort) then {
                DebugWriteFault(PMBPTR_EL1.bits[63 .. 0], fault)
            } else if IsFault__2(memstatus) | ttw_fault & ttw_fault_as_external_abort then {
                DebugWriteExternalAbort(memstatus, addrdesc, start_vaddr)
            } else ();
            if IsZero(PMBSR_EL1[S]) then {
                PMBPTR_EL1 = Mk_PMBPTR_EL1_Type(PMBPTR_EL1.bits + 1)
            };
            ()
        };
        ()
    };
    return()
}

val SPEConstructRecord : unit -> unit

function SPEConstructRecord () = {
    payload_size : int = undefined;
    SPEEmptyRecord();
    if SPESampleContextEL1Valid then {
        SPEAddPacketToRecord(0b01, 0b0100, SPESampleContextEL1)
    };
    if SPESampleContextEL2Valid then {
        SPEAddPacketToRecord(0b01, 0b0101, SPESampleContextEL2)
    };
    foreach (counter_index from 0 to (SPEMaxCounters - 1) by 1 in inc) {
        if SPESampleCounterValid[counter_index] then {
            if counter_index >= 8 then {
                SPEAddByteToRecord(0b001000 @ counter_index[4 .. 3])
            };
            let large_counters : bool = __IMPDEF_boolean("SPE 16bit counters");
            if SPESampleCounter[counter_index] > UInt(0xFFFF) & large_counters then {
                SPESampleCounter[counter_index] = UInt(0xFFFF)
            } else if SPESampleCounter[counter_index] > UInt(0xFFF) then {
                SPESampleCounter[counter_index] = UInt(0xFFF)
            } else ();
            SPEAddPacketToRecord(0b10, 0b1 @ counter_index[2 .. 0], SPESampleCounter[counter_index][15 .. 0])
        };
        ()
    };
    if HaveStatisticalProfilingv1p2() then {
        let include_prev_br_name : bool = __IMPDEF_boolean("SPE get prev br if not br");
        if SPESampleOpType != OpType_Branch & not_bool(include_prev_br_name) then {
            SPESampleAddressValid[SPEAddrPosPrevBranchTarget] = false
        };
        ()
    };
    if not_bool(StatisticalProfilingEnabled__1(EL2)) & SPESampleInstIsNV2 then {
        SPESampleAddressValid[SPEAddrPosDataVirtual] = false
    };
    foreach (address_index from 0 to (SPEMaxAddrs - 1) by 1 in inc) {
        if SPESampleAddressValid[address_index] then {
            if address_index >= 8 then {
                SPEAddByteToRecord(0b001000 @ address_index[4 .. 3])
            };
            SPEAddPacketToRecord(0b10, 0b0 @ address_index[2 .. 0], SPESampleAddress[address_index])
        };
        ()
    };
    if SPESampleDataSourceValid then {
        payload_size = SPEGetDataSourcePayloadSize();
        let 'payload_size = payload_size;
        assert(constraint((0 <= 8 * 'payload_size - 1 & 8 * 'payload_size - 1 < 16)));
        SPEAddPacketToRecord(0b01, 0b0011, SPESampleDataSource[8 * payload_size - 1 .. 0])
    };
    SPEAddPacketToRecord(0b01, 0b10 @ SPESampleClass, SPESampleSubclass);
    let 'payload_size = SPEGetEventsPayloadSize();
    assert(constraint((0 <= 8 * 'payload_size - 1 & 8 * 'payload_size - 1 < 64)));
    assert(constraint((8 * 'payload_size - 1 - 0 + 1 == 8 | 8 * 'payload_size - 1 - 0 + 1 == 16 | 8 * 'payload_size - 1 - 0 + 1 == 32 | 8 * 'payload_size - 1 - 0 + 1 == 64)));
    SPEAddPacketToRecord(0b01, 0b0010, SPESampleEvents[8 * payload_size - 1 .. 0]);
    if SPESampleTimestampValid then {
        SPEAddPacketToRecord(0b01, 0b0001, SPESampleTimestamp)
    } else {
        SPEAddByteToRecord(0b00000001)
    };
    while MOD(SPERecordSize, (1 << UInt(PMBIDR_EL1[Align]))) != 0 do {
        SPEAddByteToRecord(Zeros(8))
    };
    SPEWriteToBuffer()
}

val SPEResetSampleStorage : unit -> unit

function SPEResetSampleStorage () = {
    SPESampleContextEL1 = Zeros(32);
    SPESampleContextEL1Valid = false;
    SPESampleContextEL2 = Zeros(32);
    SPESampleContextEL2Valid = false;
    foreach (i from 0 to (SPEMaxCounters - 1) by 1 in inc) {
        SPESampleCounter[i] = 0;
        SPESampleCounterValid[i] = false;
        SPESampleCounterPending[i] = false
    };
    foreach (i from 0 to (SPEMaxAddrs - 1) by 1 in inc) {
        SPESampleAddressValid[i] = false;
        SPESampleAddress[i] = Zeros(64)
    };
    SPESampleDataSource = Zeros(16);
    SPESampleDataSourceValid = false;
    SPESampleClass = Zeros(2);
    SPESampleSubclass = Zeros(8);
    SPESampleSubclassValid = false;
    SPESampleTimestamp = Zeros(64);
    SPESampleTimestampValid = false;
    SPESampleEvents[63 .. 48] = __IMPDEF_bits(16, "SPE EVENTS 63_48");
    SPESampleEvents[47 .. 32] = Zeros(16);
    SPESampleEvents[31 .. 24] = __IMPDEF_bits(8, "SPE EVENTS 31_24");
    SPESampleEvents[23 .. 16] = Zeros(8);
    SPESampleEvents[15 .. 12] = __IMPDEF_bits(4, "SPE EVENTS 15_12");
    SPESampleEvents[11 .. 0] = Zeros(12);
    SPESampleInstIsNV2 = false
}

val SPEPostExecution : unit -> unit

function SPEPostExecution () = {
    if SPESampleInFlight then {
        SPESampleInFlight = false;
        PMUEvent(PMU_EVENT_SAMPLE_FEED);
        foreach (counter_index from 0 to (SPEMaxCounters - 1) by 1 in inc) {
            if SPESampleCounterPending[counter_index] then {
                SPEStopCounter(counter_index)
            };
            ()
        };
        discard : bool = false;
        if HaveStatisticalProfilingv1p2() then {
            discard = PMBLIMITR_EL1[FM] == 0b10
        };
        if SPECollectRecord(SPESampleEvents, SPESampleCounter[SPECounterPosTotalLatency], SPESampleOpType) & not_bool(discard) then {
            SPEConstructRecord();
            if SPEBufferIsFull() then {
                SPEBufferFilled()
            };
            ()
        };
        SPEResetSampleStorage()
    };
    ()
}

val SPECycle : unit -> unit

function SPECycle () = {
    if not_bool(HaveStatisticalProfiling()) then {
        return()
    };
    if SPESampleInFlight then {
        foreach (i from 0 to (SPEMaxCounters - 1) by 1 in inc) {
            if SPESampleCounterPending[i] then {
                SPESampleCounter[i] = SPESampleCounter[i] + 1
            };
            ()
        }
    };
    SetInterruptRequestLevel(InterruptID_PMBIRQ, if PMBSR_EL1[S] == 0b1 then
      Signal_High
    else
      Signal_Low)
}

val SPEGetRandomBoolean : unit -> bool

function SPEGetRandomBoolean () = {
    return([SPEGetRandomInterval()[0]] == 0b1)
}

val SPE_PMBIDR_P_Read : unit -> bits(1)

function SPE_PMBIDR_P_Read () = {
    owning_ss : SecurityState = undefined;
    owning_el : bits(2) = undefined;
    (owning_ss, owning_el) = ProfilingBufferOwner();
    if UInt(owning_el) > UInt(PSTATE.EL) | PSTATE.EL != EL3 & owning_ss != CurrentSecurityState() then {
        return(0b1)
    } else {
        return(0b0)
    }
}

val SPESampleExtendedLoadStore : forall ('is_load : Bool).
  (bits(1), bits(1), bits(1), bool('is_load)) -> unit

function SPESampleExtendedLoadStore (ar, excl, at, is_load) = {
    SPESampleClass = 0b01;
    let ldst : bits(1) = if is_load then 0b0 else 0b1;
    SPESampleSubclass = ((((0b000 @ ar) @ excl) @ at) @ 0b1) @ ldst;
    SPESampleSubclassValid = true;
    if is_load then {
        if at == 0b1 then {
            SPESampleOpType = OpType_LoadAtomic
        } else {
            SPESampleOpType = OpType_Load
        }
    } else {
        SPESampleOpType = OpType_Store
    }
}

val SPESampleGeneralPurposeLoadStore : unit -> unit

function SPESampleGeneralPurposeLoadStore () = {
    SPESampleClass = 0b01;
    SPESampleSubclass[7 .. 1] = Zeros(7);
    SPESampleSubclassValid = true
}

val SPESampleSIMDFPLoadStore : unit -> unit

function SPESampleSIMDFPLoadStore () = {
    SPESampleClass = 0b01;
    SPESampleSubclass[7 .. 1] = 0b0000010;
    SPESampleSubclassValid = true
}

val SPESampleMemCopy : unit -> unit

function SPESampleMemCopy () = {
    let loads_pass_filter : bool = PMSFCR_EL1[FT] == 0b1 & PMSFCR_EL1[LD] == 0b1;
    let stores_pass_filter : bool = PMSFCR_EL1[FT] == 0b1 & PMSFCR_EL1[ST] == 0b1;
    record_load : bool = undefined;
    if loads_pass_filter & not_bool(stores_pass_filter) then {
        record_load = true
    } else if not_bool(loads_pass_filter) & stores_pass_filter then {
        record_load = false
    } else {
        record_load = SPEGetRandomBoolean()
    };
    SPESampleClass = 0b01;
    let ldst : bits(1) = if record_load then 0b0 else 0b1;
    SPESampleSubclass[7 .. 0] = 0b0010000 @ ldst;
    SPESampleSubclassValid = true;
    SPESampleOpType = if record_load then OpType_Load else OpType_Store
}

val SPESampleMemSet : unit -> unit

function SPESampleMemSet () = {
    SPESampleClass = 0b01;
    SPESampleSubclass[7 .. 0] = 0b00100101;
    SPESampleSubclassValid = true;
    SPESampleOpType = OpType_Store
}

val SPEISB : unit -> unit

function SPEISB () = {
    let address : bits(64) = PC_read() + 4;
    let branch_type : BranchType = BranchType_DIR;
    let branch_conditional : bool = false;
    let taken : bool = false;
    let is_isb : bool = true;
    SPEBranch__1(address, branch_type, branch_conditional, taken, is_isb)
}

val BRBEExceptionReturn : (bits(64), bits(2)) -> unit

function BRBEExceptionReturn (target_address_in, source_el) = {
    target_address : bits(64) = target_address_in;
    match source_el {
      ? if ? == EL3 => {
          if not_bool(HaveBRBEv1p1()) | MDCR_EL3[E3BREC] == MDCR_EL3[E3BREW] then {
              return()
          };
          ()
      },
      ? if ? == EL2 => {
          if BRBCR_EL2[ERTN] == 0b0 then {
              return()
          };
          ()
      },
      ? if ? == EL1 => {
          if BRBCR_EL1[ERTN] == 0b0 then {
              return()
          };
          ()
      },
      _ => ()
    };
    let source_valid : bool = BranchRecordAllowed(source_el);
    let target_valid : bool = BranchRecordAllowed(PSTATE.EL);
    let branch_valid : bool = source_valid | target_valid;
    if branch_valid then {
        let branch_type : bits(6) = 0b000111;
        ccu : bits(1) = undefined;
        cc : bits(14) = undefined;
        (ccu, cc) = BranchEncCycleCount();
        let lastfailed : bits(1) = if HaveTME() then BRBFCR_EL1[LASTFAILED] else
          0b0;
        let transactional : bits(1) = if (source_valid & HaveTME()) & TSTATE.depth > 0 then
          0b1
        else
          0b0;
        let el : bits(2) = if target_valid then PSTATE.EL else 0b00;
        let mispredict : bits(1) = if (source_valid & BRBEMispredictAllowed()) & BranchMispredict() then
          0b1
        else
          0b0;
        let sv : bits(1) = if source_valid then 0b1 else 0b0;
        let tv : bits(1) = if target_valid then 0b1 else 0b0;
        let source_address : bits(64) = if source_valid then PC_read() else
          Zeros(64);
        if not_bool(target_valid) then {
            target_address = Zeros(64)
        };
        UpdateBranchRecordBuffer(ccu, cc, lastfailed, transactional, branch_type, el, mispredict, sv @ tv, source_address, target_address);
        BRBFCR_EL1[LASTFAILED] = 0b0;
        PMUEvent(PMU_EVENT_BRB_FILTRATE)
    };
    __last_branch_valid = branch_valid;
    return()
}

bitfield BRBINFINJ_EL1_Type : bits(64) =
  {
    CCU : 46..46,
    CC : 45..32,
    LASTFAILED : 17..17,
    T : 16..16,
    TYPE : 13..8,
    EL : 7..6,
    MPRED : 5..5,
    VALID : 1..0
  }

register BRBINFINJ_EL1 : BRBINFINJ_EL1_Type

bitfield BRBSRCINJ_EL1_Type : bits(64) = {ADDRESS : 63..0}

register BRBSRCINJ_EL1 : BRBSRCINJ_EL1_Type

bitfield BRBTGTINJ_EL1_Type : bits(64) = {ADDRESS : 63..0}

register BRBTGTINJ_EL1 : BRBTGTINJ_EL1_Type

val BRB_INJ : unit -> unit

function BRB_INJ () = {
    UpdateBranchRecordBuffer(BRBINFINJ_EL1[CCU], BRBINFINJ_EL1[CC], BRBINFINJ_EL1[LASTFAILED], BRBINFINJ_EL1[T], BRBINFINJ_EL1[TYPE], BRBINFINJ_EL1[EL], BRBINFINJ_EL1[MPRED], BRBINFINJ_EL1[VALID], BRBSRCINJ_EL1[ADDRESS], BRBTGTINJ_EL1[ADDRESS]);
    BRBINFINJ_EL1 = Mk_BRBINFINJ_EL1_Type(__UNKNOWN_bits(64));
    BRBSRCINJ_EL1 = Mk_BRBSRCINJ_EL1_Type(__UNKNOWN_bits(64));
    BRBTGTINJ_EL1 = Mk_BRBTGTINJ_EL1_Type(__UNKNOWN_bits(64));
    if ConstrainUnpredictableBool(Unpredictable_BRBFILTRATE) then {
        PMUEvent(PMU_EVENT_BRB_FILTRATE)
    };
    ()
}

val BRB_IALL : unit -> unit

function BRB_IALL () = {
    foreach (i from 0 to (GetBRBENumRecords() - 1) by 1 in inc) {
        assert(constraint('loop_i < 64));
        Records_SRC[i] = Mk_BRBSRCType(Zeros(64));
        Records_TGT[i] = Mk_BRBTGTType(Zeros(64));
        Records_INF[i] = Mk_BRBINFType(Zeros(64))
    }
}

val BRBEBranchOnISB : unit -> bool

function BRBEBranchOnISB () = {
    return(__IMPDEF_boolean("ISB generates Branch records"))
}

val BRBEISB : unit -> unit

function BRBEISB () = {
    let branch_conditional : bool = false;
    BRBEBranch(BranchType_DIR, branch_conditional, PC_read() + 4)
}

val BranchNotTaken : forall ('branch_conditional : Bool).
  (BranchType, bool('branch_conditional)) -> unit

function BranchNotTaken (branchtype, branch_conditional) = {
    let branchtaken : bool = false;
    if HaveStatisticalProfiling() then {
        SPEBranch(__UNKNOWN_bits(64), branchtype, branch_conditional, branchtaken)
    };
    return()
}

val AArch64_ExceptionReturn : (bits(64), bits(64)) -> unit

function AArch64_ExceptionReturn (new_pc_in, spsr) = {
    iesb_req : bool = undefined;
    sync_errors : bool = undefined;
    new_pc : bits(64) = new_pc_in;
    if HaveTME() & TSTATE.depth > 0 then {
        FailTransaction(TMFailure_ERR, false)
    };
    if HaveIESB() then {
        sync_errors : bool = SCTLR_read__1()[IESB] == 0b1;
        if HaveDoubleFaultExt() then {
            sync_errors = sync_errors | (SCR_EL3[EA] @ SCR_EL3[NMEA]) == 0b11 & PSTATE.EL == EL3
        };
        if sync_errors then {
            SynchronizeErrors();
            let iesb_req : bool = true;
            TakeUnmaskedPhysicalSErrorInterrupts(iesb_req)
        };
        ()
    };
    let sync_errors = sync_errors;
    SynchronizeContext();
    __InstructionStep = false;
    let source_el : bits(2) = PSTATE.EL;
    let illegal_psr_state : bool = IllegalExceptionReturn(spsr);
    SetPSTATEFromPSR__1(spsr, illegal_psr_state);
    ClearExclusiveLocal(ProcessorID());
    SendEventLocal();
    if illegal_psr_state & [spsr[4]] == 0b1 then {
        new_pc[63 .. 32] = __UNKNOWN_bits(32);
        new_pc[1 .. 0] = __UNKNOWN_bits(2)
    } else if UsingAArch32() then {
        if PSTATE.T == 0b1 then {
            new_pc[0] = Bit(0b0)
        } else {
            new_pc[1 .. 0] = 0b00
        }
    } else {
        new_pc = AArch64_BranchAddr(new_pc, PSTATE.EL)
    };
    if HaveBRBExt() then {
        BRBEExceptionReturn(new_pc, source_el)
    };
    sail_return_exception(new_pc[55 .. 0]);
    if UsingAArch32() then {
        if HaveSME() & PSTATE.SM == 0b1 then {
            ResetSVEState()
        };
        let branch_conditional : bool = false;
        BranchTo(new_pc[31 .. 0], BranchType_ERET, branch_conditional)
    } else {
        BranchToAddr(new_pc, BranchType_ERET)
    };
    CheckExceptionCatch(false)
}

val DecodeRegExtend : bits(3) -> ExtendType

function DecodeRegExtend op = {
    match op {
      0b000 => {
          return(ExtendType_UXTB)
      },
      0b001 => {
          return(ExtendType_UXTH)
      },
      0b010 => {
          return(ExtendType_UXTW)
      },
      0b011 => {
          return(ExtendType_UXTX)
      },
      0b100 => {
          return(ExtendType_SXTB)
      },
      0b101 => {
          return(ExtendType_SXTH)
      },
      0b110 => {
          return(ExtendType_SXTW)
      },
      0b111 => {
          return(ExtendType_SXTX)
      },
      _ => {
          return(undefined : ExtendType)
      }
    }
}

val ExtendReg : forall 'N 'reg 'shift,
  'N >= 0 & ('N == 8 | 'N == 16 | 'N == 32 | 'N == 64 | not(('shift >= 0 & 'shift <= 4))).
  (int('reg), ExtendType, int('shift), int('N)) -> bits('N)

function ExtendReg (reg, exttype, shift, N) = {
    assert(shift >= 0 & shift <= 4);
    let val_name : bits('N) = X_read(reg, N);
    is_unsigned : bool = undefined;
    len : int = undefined;
    match exttype {
      ExtendType_SXTB => {
          is_unsigned = false;
          len = 8
      },
      ExtendType_SXTH => {
          is_unsigned = false;
          len = 16
      },
      ExtendType_SXTW => {
          is_unsigned = false;
          len = 32
      },
      ExtendType_SXTX => {
          is_unsigned = false;
          len = 64
      },
      ExtendType_UXTB => {
          is_unsigned = true;
          len = 8
      },
      ExtendType_UXTH => {
          is_unsigned = true;
          len = 16
      },
      ExtendType_UXTW => {
          is_unsigned = true;
          len = 32
      },
      ExtendType_UXTX => {
          is_unsigned = true;
          len = 64
      }
    };
    let is_unsigned = is_unsigned;
    let 'len = Min(len, N - shift);
    assert(constraint((0 <= 'len - 1 | not(('shift >= 0 & 'shift <= 4)))));
    return(Extend(val_name[len - 1 .. 0] @ Zeros(shift), N, is_unsigned))
}

val DecodeShift : bits(2) -> ShiftType

function DecodeShift op = {
    match op {
      0b00 => {
          return(ShiftType_LSL)
      },
      0b01 => {
          return(ShiftType_LSR)
      },
      0b10 => {
          return(ShiftType_ASR)
      },
      0b11 => {
          return(ShiftType_ROR)
      },
      _ => {
          return(undefined : ShiftType)
      }
    }
}

val ShiftReg : forall 'N 'amount 'reg,
  'N in {8, 16, 32, 64}.
  (int('reg), ShiftType, int('amount), int('N)) -> bits('N)

function ShiftReg (reg, shiftype, amount, N) = {
    result : bits('N) = X_read(reg, N);
    match shiftype {
      ShiftType_LSL => {
          result = LSL(result, amount)
      },
      ShiftType_LSR => {
          result = LSR(result, amount)
      },
      ShiftType_ASR => {
          result = ASR(result, amount)
      },
      ShiftType_ROR => {
          assert(constraint(('N > 0 & 'amount >= 0)));
          result = ROR(result, amount)
      }
    };
    return(result)
}

val Prefetch : (bits(64), bits(5)) -> unit

function Prefetch (address, prfop) = {
    hint : PrefetchHint = undefined;
    match prfop[4 .. 3] {
      0b00 => {
          hint = Prefetch_READ
      },
      0b01 => {
          hint = Prefetch_EXEC
      },
      0b10 => {
          hint = Prefetch_WRITE
      },
      0b11 => {
          return()
      }
    };
    let 'target = UInt(prfop[2 .. 1]);
    let stream : bool = [prfop[0]] != 0b0;
    Hint_Prefetch(address, hint, target, stream);
    return()
}

val _TLBInvalidate : unit -> unit

val TLBI : (TLBIRecord, Shareability) -> unit

function TLBI (r, s) = {
    sail_tlbi(struct { rec = r, shareability = s });
    _TLBInvalidate()
}

val Broadcast : (Shareability, TLBIRecord) -> unit

function Broadcast (shareability, r) = {
    return()
}

val AArch64_TLBI_ALL : (SecurityState, Regime, Shareability, TLBIMemAttr) -> unit

function AArch64_TLBI_ALL (security, regime, shareability, attr) = {
    assert(PSTATE.EL == EL3 | PSTATE.EL == EL2);
    r : TLBIRecord = undefined;
    r.op = TLBIOp_ALL;
    r.from_aarch64 = true;
    r.security = security;
    r.regime = regime;
    r.level = TLBILevel_Any;
    r.attr = attr;
    TLBI(r, shareability);
    if shareability != Shareability_NSH then {
        Broadcast(shareability, r)
    };
    return()
}

val AArch64_TLBI_VMALL : (SecurityState, Regime, bits(16), Shareability, TLBIMemAttr) -> unit

function AArch64_TLBI_VMALL (security, regime, vmid, shareability, attr) = {
    assert(PSTATE.EL == EL3 | PSTATE.EL == EL2 | PSTATE.EL == EL1);
    r : TLBIRecord = undefined;
    r.op = TLBIOp_VMALL;
    r.from_aarch64 = true;
    r.security = security;
    r.regime = regime;
    r.level = TLBILevel_Any;
    r.vmid = vmid;
    r.attr = attr;
    TLBI(r, shareability);
    if shareability != Shareability_NSH then {
        Broadcast(shareability, r)
    };
    return()
}

val AArch64_TLBI_VMALLS12 : (SecurityState, Regime, bits(16), Shareability, TLBIMemAttr) -> unit

function AArch64_TLBI_VMALLS12 (security, regime, vmid, shareability, attr) = {
    assert(PSTATE.EL == EL3 | PSTATE.EL == EL2);
    r : TLBIRecord = undefined;
    r.op = TLBIOp_VMALLS12;
    r.from_aarch64 = true;
    r.security = security;
    r.regime = regime;
    r.level = TLBILevel_Any;
    r.vmid = vmid;
    r.attr = attr;
    TLBI(r, shareability);
    if shareability != Shareability_NSH then {
        Broadcast(shareability, r)
    };
    return()
}

val AArch64_TLBI_ASID : (SecurityState, Regime, bits(16), Shareability, TLBIMemAttr, bits(64)) -> unit

function AArch64_TLBI_ASID (security, regime, vmid, shareability, attr, Xt) = {
    assert(PSTATE.EL == EL3 | PSTATE.EL == EL2 | PSTATE.EL == EL1);
    r : TLBIRecord = undefined;
    r.op = TLBIOp_ASID;
    r.from_aarch64 = true;
    r.security = security;
    r.regime = regime;
    r.vmid = vmid;
    r.level = TLBILevel_Any;
    r.attr = attr;
    r.asid = Xt[63 .. 48];
    TLBI(r, shareability);
    if shareability != Shareability_NSH then {
        Broadcast(shareability, r)
    };
    return()
}

val AArch64_TLBI_VA : (SecurityState, Regime, bits(16), Shareability, TLBILevel, TLBIMemAttr, bits(64)) -> unit

function AArch64_TLBI_VA (security, regime, vmid, shareability, level, attr, Xt) = {
    assert(PSTATE.EL == EL3 | PSTATE.EL == EL2 | PSTATE.EL == EL1);
    r : TLBIRecord = undefined;
    r.op = TLBIOp_VA;
    r.from_aarch64 = true;
    r.security = security;
    r.regime = regime;
    r.vmid = vmid;
    r.level = level;
    r.attr = attr;
    r.asid = Xt[63 .. 48];
    r.ttl = Xt[47 .. 44];
    r.address = ZeroExtend(Xt[43 .. 0] @ Zeros(12), 64);
    r.d64 = true;
    r.d128 = (match r.ttl {
      [bitzero, bitzero, _, _] => true,
      _ => false
    }) : bool;
    TLBI(r, shareability);
    if shareability != Shareability_NSH then {
        Broadcast(shareability, r)
    };
    return()
}

val AArch64_TLBIP_VA : (SecurityState, Regime, bits(16), Shareability, TLBILevel, TLBIMemAttr, bits(128)) -> unit

function AArch64_TLBIP_VA (security, regime, vmid, shareability, level, attr, Xt) = {
    assert(PSTATE.EL == EL3 | PSTATE.EL == EL2 | PSTATE.EL == EL1);
    r : TLBIRecord = undefined;
    r.op = TLBIOp_VA;
    r.from_aarch64 = true;
    r.security = security;
    r.regime = regime;
    r.vmid = vmid;
    r.level = level;
    r.attr = attr;
    r.asid = Xt[63 .. 48];
    r.ttl = Xt[47 .. 44];
    r.address = ZeroExtend(Xt[107 .. 64] @ Zeros(12), 64);
    r.d64 = (match r.ttl {
      [bitzero, bitzero, _, _] => true,
      _ => false
    }) : bool;
    r.d128 = true;
    TLBI(r, shareability);
    if shareability != Shareability_NSH then {
        Broadcast(shareability, r)
    };
    return()
}

val AArch64_TLBI_VAA : (SecurityState, Regime, bits(16), Shareability, TLBILevel, TLBIMemAttr, bits(64)) -> unit

function AArch64_TLBI_VAA (security, regime, vmid, shareability, level, attr, Xt) = {
    assert(PSTATE.EL == EL3 | PSTATE.EL == EL2 | PSTATE.EL == EL1);
    r : TLBIRecord = undefined;
    r.op = TLBIOp_VAA;
    r.from_aarch64 = true;
    r.security = security;
    r.regime = regime;
    r.vmid = vmid;
    r.level = level;
    r.attr = attr;
    r.ttl = Xt[47 .. 44];
    r.address = ZeroExtend(Xt[43 .. 0] @ Zeros(12), 64);
    r.d64 = true;
    r.d128 = (match r.ttl {
      [bitzero, bitzero, _, _] => true,
      _ => false
    }) : bool;
    TLBI(r, shareability);
    if shareability != Shareability_NSH then {
        Broadcast(shareability, r)
    };
    return()
}

val AArch64_TLBIP_VAA : (SecurityState, Regime, bits(16), Shareability, TLBILevel, TLBIMemAttr, bits(128)) -> unit

function AArch64_TLBIP_VAA (security, regime, vmid, shareability, level, attr, Xt) = {
    assert(PSTATE.EL == EL3 | PSTATE.EL == EL2 | PSTATE.EL == EL1);
    r : TLBIRecord = undefined;
    r.op = TLBIOp_VAA;
    r.from_aarch64 = true;
    r.security = security;
    r.regime = regime;
    r.vmid = vmid;
    r.level = level;
    r.attr = attr;
    r.ttl = Xt[47 .. 44];
    r.address = ZeroExtend(Xt[107 .. 64] @ Zeros(12), 64);
    r.d64 = (match r.ttl {
      [bitzero, bitzero, _, _] => true,
      _ => false
    }) : bool;
    r.d128 = true;
    TLBI(r, shareability);
    if shareability != Shareability_NSH then {
        Broadcast(shareability, r)
    };
    return()
}

val AArch64_TLBI_IPAS2 : (SecurityState, Regime, bits(16), Shareability, TLBILevel, TLBIMemAttr, bits(64)) -> unit

function AArch64_TLBI_IPAS2 (security, regime, vmid, shareability, level, attr, Xt) = {
    assert(PSTATE.EL == EL3 | PSTATE.EL == EL2);
    r : TLBIRecord = undefined;
    r.op = TLBIOp_IPAS2;
    r.from_aarch64 = true;
    r.security = security;
    r.regime = regime;
    r.vmid = vmid;
    r.level = level;
    r.attr = attr;
    r.ttl = Xt[47 .. 44];
    r.address = ZeroExtend(Xt[39 .. 0] @ Zeros(12), 64);
    r.d64 = true;
    r.d128 = (match r.ttl {
      [bitzero, bitzero, _, _] => true,
      _ => false
    }) : bool;
    match security {
      SS_NonSecure => {
          r.ipaspace = PAS_NonSecure
      },
      SS_Secure => {
          r.ipaspace = if [Xt[63]] == 0b1 then PAS_NonSecure else PAS_Secure
      },
      SS_Realm => {
          r.ipaspace = PAS_Realm
      },
      _ => {
          Unreachable()
      }
    };
    TLBI(r, shareability);
    if shareability != Shareability_NSH then {
        Broadcast(shareability, r)
    };
    return()
}

val AArch64_TLBIP_IPAS2 : (SecurityState, Regime, bits(16), Shareability, TLBILevel, TLBIMemAttr, bits(128)) -> unit

function AArch64_TLBIP_IPAS2 (security, regime, vmid, shareability, level, attr, Xt) = {
    assert(PSTATE.EL == EL3 | PSTATE.EL == EL2);
    r : TLBIRecord = undefined;
    r.op = TLBIOp_IPAS2;
    r.from_aarch64 = true;
    r.security = security;
    r.regime = regime;
    r.vmid = vmid;
    r.level = level;
    r.attr = attr;
    r.ttl = Xt[47 .. 44];
    r.address = ZeroExtend(Xt[107 .. 64] @ Zeros(12), 64);
    r.d64 = (match r.ttl {
      [bitzero, bitzero, _, _] => true,
      _ => false
    }) : bool;
    r.d128 = true;
    match security {
      SS_NonSecure => {
          r.ipaspace = PAS_NonSecure
      },
      SS_Secure => {
          r.ipaspace = if [Xt[63]] == 0b1 then PAS_NonSecure else PAS_Secure
      },
      SS_Realm => {
          r.ipaspace = PAS_Realm
      },
      _ => {
          Unreachable()
      }
    };
    TLBI(r, shareability);
    if shareability != Shareability_NSH then {
        Broadcast(shareability, r)
    };
    return()
}

val HasLargeAddress : Regime -> bool

function HasLargeAddress regime = {
    if not_bool(Have52BitIPAAndPASpaceExt()) then {
        return(false)
    };
    match regime {
      Regime_EL3 => {
          return([TCR_EL3.bits[32]] == 0b1)
      },
      Regime_EL2 => {
          return([TCR_EL2.bits[32]] == 0b1)
      },
      Regime_EL20 => {
          return([TCR_EL2.bits[59]] == 0b1)
      },
      Regime_EL10 => {
          return([TCR_EL1.bits[59]] == 0b1)
      },
      _ => {
          Unreachable();
          return(undefined : bool)
      }
    }
}

val TLBIRange : (Regime, bits(64)) -> (bool, bits(2), bits(64), bits(64))

function TLBIRange (regime, Xt) = {
    let valid_name : bool = true;
    start_address : bits(64) = Zeros(64);
    end_address_name : bits(64) = Zeros(64);
    let tg : bits(2) = Xt[47 .. 46];
    let 'scale = UInt(Xt[45 .. 44]);
    let 'num = UInt(Xt[43 .. 39]);
    tg_bits : {12, 14, 16} = 12;
    if tg == 0b00 then {
        return((false, tg, start_address, end_address_name))
    };
    match tg {
      0b01 => {
          tg_bits = 12;
          if HasLargeAddress(regime) then {
              start_address[52 .. 16] = Xt[36 .. 0];
              start_address[63 .. 53] = Replicate([Xt[36]], 11)
          } else {
              start_address[48 .. 12] = Xt[36 .. 0];
              start_address[63 .. 49] = Replicate([Xt[36]], 15)
          }
      },
      0b10 => {
          tg_bits = 14;
          if HasLargeAddress(regime) then {
              start_address[52 .. 16] = Xt[36 .. 0];
              start_address[63 .. 53] = Replicate([Xt[36]], 11)
          } else {
              start_address[50 .. 14] = Xt[36 .. 0];
              start_address[63 .. 51] = Replicate([Xt[36]], 13)
          }
      },
      0b11 => {
          tg_bits = 16;
          start_address[52 .. 16] = Xt[36 .. 0];
          start_address[63 .. 53] = Replicate([Xt[36]], 11)
      },
      _ => {
          Unreachable()
      }
    };
    let 'tg_bits = tg_bits;
    let 'range = ((num + 1) << (5 * scale + 1 + tg_bits));
    end_address_name : bits(64) = start_address + range[63 .. 0];
    if [end_address_name[52]] != [start_address[52]] then {
        end_address_name = Replicate([start_address[52]], 64 - 52) @ Ones(52)
    };
    return((valid_name, tg, start_address, end_address_name))
}

val TLBIPRange : (Regime, bits(128)) -> (bool, bits(2), bits(64), bits(64))

function TLBIPRange (regime, Xt) = {
    let valid_name : bool = true;
    start_address : bits(64) = Zeros(64);
    end_address_name : bits(64) = Zeros(64);
    let tg : bits(2) = Xt[47 .. 46];
    let 'scale = UInt(Xt[45 .. 44]);
    let 'num = UInt(Xt[43 .. 39]);
    tg_bits : {12, 14, 16} = 12;
    if tg == 0b00 then {
        return((false, tg, start_address, end_address_name))
    };
    match tg {
      0b01 => {
          tg_bits = 12;
          start_address[55 .. 12] = Xt[107 .. 64];
          start_address[63 .. 56] = Replicate([Xt[107]], 8)
      },
      0b10 => {
          tg_bits = 14;
          start_address[55 .. 14] = Xt[107 .. 66];
          start_address[63 .. 56] = Replicate([Xt[107]], 8)
      },
      0b11 => {
          tg_bits = 16;
          start_address[55 .. 16] = Xt[107 .. 68];
          start_address[63 .. 56] = Replicate([Xt[107]], 8)
      },
      _ => {
          Unreachable()
      }
    };
    let 'tg_bits = tg_bits;
    let 'range = ((num + 1) << (5 * scale + 1 + tg_bits));
    end_address_name : bits(64) = start_address + range[63 .. 0];
    if [end_address_name[55]] != [start_address[55]] then {
        end_address_name = Replicate([start_address[55]], 64 - 55) @ Ones(55)
    };
    return((valid_name, tg, start_address, end_address_name))
}

val AArch64_TLBI_RVA : (SecurityState, Regime, bits(16), Shareability, TLBILevel, TLBIMemAttr, bits(64)) -> unit

function AArch64_TLBI_RVA (security, regime, vmid, shareability, level, attr, Xt) = {
    assert(PSTATE.EL == EL3 | PSTATE.EL == EL2 | PSTATE.EL == EL1);
    r : TLBIRecord = undefined;
    r.op = TLBIOp_RVA;
    r.from_aarch64 = true;
    r.security = security;
    r.regime = regime;
    r.vmid = vmid;
    r.level = level;
    r.attr = attr;
    r.asid = Xt[63 .. 48];
    r.ttl[1 .. 0] = Xt[38 .. 37];
    r.d64 = true;
    r.d128 = r.ttl[1 .. 0] == 0b00;
    valid_name : bool = undefined;
    (valid_name, r.tg, r.address, r.end_address_name) = TLBIRange(regime, Xt);
    if not_bool(valid_name) then {
        return()
    };
    TLBI(r, shareability);
    if shareability != Shareability_NSH then {
        Broadcast(shareability, r)
    };
    return()
}

val AArch64_TLBIP_RVA : (SecurityState, Regime, bits(16), Shareability, TLBILevel, TLBIMemAttr, bits(128)) -> unit

function AArch64_TLBIP_RVA (security, regime, vmid, shareability, level, attr, Xt) = {
    assert(PSTATE.EL == EL3 | PSTATE.EL == EL2 | PSTATE.EL == EL1);
    r : TLBIRecord = undefined;
    r.op = TLBIOp_RVA;
    r.from_aarch64 = true;
    r.security = security;
    r.regime = regime;
    r.vmid = vmid;
    r.level = level;
    r.attr = attr;
    r.asid = Xt[63 .. 48];
    r.ttl[1 .. 0] = Xt[38 .. 37];
    r.d64 = r.ttl[1 .. 0] == 0b00;
    r.d128 = true;
    valid_name : bool = undefined;
    (valid_name, r.tg, r.address, r.end_address_name) = TLBIPRange(regime, Xt);
    if not_bool(valid_name) then {
        return()
    };
    TLBI(r, shareability);
    if shareability != Shareability_NSH then {
        Broadcast(shareability, r)
    };
    return()
}

val AArch64_TLBI_RVAA : (SecurityState, Regime, bits(16), Shareability, TLBILevel, TLBIMemAttr, bits(64)) -> unit

function AArch64_TLBI_RVAA (security, regime, vmid, shareability, level, attr, Xt) = {
    assert(PSTATE.EL == EL3 | PSTATE.EL == EL2 | PSTATE.EL == EL1);
    r : TLBIRecord = undefined;
    r.op = TLBIOp_RVAA;
    r.from_aarch64 = true;
    r.security = security;
    r.regime = regime;
    r.vmid = vmid;
    r.level = level;
    r.attr = attr;
    r.ttl[1 .. 0] = Xt[38 .. 37];
    r.d64 = true;
    r.d128 = r.ttl[1 .. 0] == 0b00;
    let tg : bits(2) = Xt[47 .. 46];
    let 'scale = UInt(Xt[45 .. 44]);
    let 'num = UInt(Xt[43 .. 39]);
    let 'baseaddr = SInt(Xt[36 .. 0]);
    valid_name : bool = undefined;
    (valid_name, r.tg, r.address, r.end_address_name) = TLBIRange(regime, Xt);
    if not_bool(valid_name) then {
        return()
    };
    TLBI(r, shareability);
    if shareability != Shareability_NSH then {
        Broadcast(shareability, r)
    };
    return()
}

val AArch64_TLBIP_RVAA : (SecurityState, Regime, bits(16), Shareability, TLBILevel, TLBIMemAttr, bits(128)) -> unit

function AArch64_TLBIP_RVAA (security, regime, vmid, shareability, level, attr, Xt) = {
    assert(PSTATE.EL == EL3 | PSTATE.EL == EL2 | PSTATE.EL == EL1);
    r : TLBIRecord = undefined;
    r.op = TLBIOp_RVAA;
    r.from_aarch64 = true;
    r.security = security;
    r.regime = regime;
    r.vmid = vmid;
    r.level = level;
    r.attr = attr;
    r.ttl[1 .. 0] = Xt[38 .. 37];
    r.d64 = r.ttl[1 .. 0] == 0b00;
    r.d128 = true;
    let tg : bits(2) = Xt[47 .. 46];
    let 'scale = UInt(Xt[45 .. 44]);
    let 'num = UInt(Xt[43 .. 39]);
    let 'baseaddr = SInt(Xt[36 .. 0]);
    valid_name : bool = undefined;
    (valid_name, r.tg, r.address, r.end_address_name) = TLBIPRange(regime, Xt);
    if not_bool(valid_name) then {
        return()
    };
    TLBI(r, shareability);
    if shareability != Shareability_NSH then {
        Broadcast(shareability, r)
    };
    return()
}

val AArch64_TLBI_RIPAS2 : (SecurityState, Regime, bits(16), Shareability, TLBILevel, TLBIMemAttr, bits(64)) -> unit

function AArch64_TLBI_RIPAS2 (security, regime, vmid, shareability, level, attr, Xt) = {
    assert(PSTATE.EL == EL3 | PSTATE.EL == EL2 | PSTATE.EL == EL1);
    r : TLBIRecord = undefined;
    r.op = TLBIOp_RIPAS2;
    r.from_aarch64 = true;
    r.security = security;
    r.regime = regime;
    r.vmid = vmid;
    r.level = level;
    r.attr = attr;
    r.ttl[1 .. 0] = Xt[38 .. 37];
    r.d64 = true;
    r.d128 = r.ttl[1 .. 0] == 0b00;
    let tg : bits(2) = Xt[47 .. 46];
    let 'scale = UInt(Xt[45 .. 44]);
    let 'num = UInt(Xt[43 .. 39]);
    let 'baseaddr = SInt(Xt[36 .. 0]);
    valid_name : bool = undefined;
    (valid_name, r.tg, r.address, r.end_address_name) = TLBIRange(regime, Xt);
    if not_bool(valid_name) then {
        return()
    };
    match security {
      SS_NonSecure => {
          r.ipaspace = PAS_NonSecure
      },
      SS_Secure => {
          r.ipaspace = if [Xt[63]] == 0b1 then PAS_NonSecure else PAS_Secure
      },
      SS_Realm => {
          r.ipaspace = PAS_Realm
      },
      _ => {
          Unreachable()
      }
    };
    TLBI(r, shareability);
    if shareability != Shareability_NSH then {
        Broadcast(shareability, r)
    };
    return()
}

val AArch64_TLBIP_RIPAS2 : (SecurityState, Regime, bits(16), Shareability, TLBILevel, TLBIMemAttr, bits(128)) -> unit

function AArch64_TLBIP_RIPAS2 (security, regime, vmid, shareability, level, attr, Xt) = {
    assert(PSTATE.EL == EL3 | PSTATE.EL == EL2 | PSTATE.EL == EL1);
    r : TLBIRecord = undefined;
    r.op = TLBIOp_RIPAS2;
    r.from_aarch64 = true;
    r.security = security;
    r.regime = regime;
    r.vmid = vmid;
    r.level = level;
    r.attr = attr;
    r.ttl[1 .. 0] = Xt[38 .. 37];
    r.d64 = r.ttl[1 .. 0] == 0b00;
    r.d128 = true;
    let tg : bits(2) = Xt[47 .. 46];
    let 'scale = UInt(Xt[45 .. 44]);
    let 'num = UInt(Xt[43 .. 39]);
    let 'baseaddr = SInt(Xt[36 .. 0]);
    valid_name : bool = undefined;
    (valid_name, r.tg, r.address, r.end_address_name) = TLBIPRange(regime, Xt);
    if not_bool(valid_name) then {
        return()
    };
    match security {
      SS_NonSecure => {
          r.ipaspace = PAS_NonSecure
      },
      SS_Secure => {
          r.ipaspace = if [Xt[63]] == 0b1 then PAS_NonSecure else PAS_Secure
      },
      SS_Realm => {
          r.ipaspace = PAS_Realm
      },
      _ => {
          Unreachable()
      }
    };
    TLBI(r, shareability);
    if shareability != Shareability_NSH then {
        Broadcast(shareability, r)
    };
    return()
}

val AArch64_TLBI_RPA : (TLBILevel, bits(64), Shareability) -> unit

function AArch64_TLBI_RPA (level, Xt, shareability) = {
    assert(HaveRME() & PSTATE.EL == EL3);
    r : TLBIRecord = undefined;
    range_bits : int = undefined;
    p : {12, 14, 16} = 12;
    r.op = TLBIOp_RPA;
    r.level = level;
    r.attr = TLBI_AllAttr;
    match Xt[47 .. 44] {
      0b0000 => {
          range_bits = 12
      },
      0b0001 => {
          range_bits = 14
      },
      0b0010 => {
          range_bits = 16
      },
      0b0011 => {
          range_bits = 21
      },
      0b0100 => {
          range_bits = 25
      },
      0b0101 => {
          range_bits = 29
      },
      0b0110 => {
          range_bits = 30
      },
      0b0111 => {
          range_bits = 34
      },
      0b1000 => {
          range_bits = 36
      },
      0b1001 => {
          range_bits = 39
      },
      _ => {
          range_bits = 0
      }
    };
    match DecodePGS(GPCCR_EL3[PGS]) {
      PGS_4KB => {
          p = 12
      },
      PGS_16KB => {
          p = 14
      },
      PGS_64KB => {
          p = 16
      }
    };
    let 'p = p;
    if range_bits < p then {
        range_bits = p
    };
    let 'range_bits = range_bits;
    BaseADDR : bits(52) = Zeros(52);
    match GPCCR_EL3[PGS] {
      0b00 => {
          BaseADDR[51 .. 12] = Xt[39 .. 0]
      },
      0b10 => {
          BaseADDR[51 .. 14] = Xt[39 .. 2]
      },
      0b01 => {
          BaseADDR[51 .. 16] = Xt[39 .. 4]
      },
      _ => ()
    };
    assert(constraint('range_bits >= 0));
    assert(constraint(52 >= 'range_bits));
    let start_addr : bits(52) = BaseADDR & not_vec(ZeroExtend(Ones(range_bits), 52));
    let end_addr_name : bits(52) = start_addr + ZeroExtend(Ones(range_bits), 52);
    r.address = ZeroExtend(start_addr, 64);
    r.end_address_name = ZeroExtend(end_addr_name, 64);
    TLBI(r, shareability);
    if shareability != Shareability_NSH then {
        Broadcast(shareability, r)
    };
    ()
}

val AArch64_TLBI_PAALL : Shareability -> unit

function AArch64_TLBI_PAALL shareability = {
    assert(HaveRME() & PSTATE.EL == EL3);
    r : TLBIRecord = undefined;
    r.op = TLBIOp_PAALL;
    r.level = TLBILevel_Any;
    r.attr = TLBI_AllAttr;
    TLBI(r, shareability);
    if shareability != Shareability_NSH then {
        Broadcast(shareability, r)
    };
    return()
}

val AArch64_DC : (bits(64), CacheType, CacheOp, CacheOpScope) -> unit

function AArch64_DC (regval, cachetype, cacheop, opscope_in) = {
    ss : SecurityState = undefined;
    opscope : CacheOpScope = opscope_in;
    cache : CacheRecord = undefined;
    cache.acctype = AccessType_DC;
    cache.cachetype = cachetype;
    cache.cacheop = cacheop;
    cache.opscope = opscope;
    if opscope == CacheOpScope_SetWay then {
        let ss : SecurityState = SecurityStateAtEL(PSTATE.EL);
        cache.cpas = CPASAtSecurityState(ss);
        cache.shareability = Shareability_NSH;
        (cache.setnum, cache.waynum, cache.level) = DecodeSW(regval, cachetype);
        if ((cacheop == CacheOp_Invalidate & PSTATE.EL == EL1) & EL2Enabled()) & (HCR_EL2[SWIO] == 0b1 | (HCR_EL2[DC] @ HCR_EL2[VM]) != 0b00) then {
            cache.cacheop = CacheOp_CleanInvalidate
        };
        CACHE_OP(cache);
        return()
    };
    if EL2Enabled() & not_bool(IsInHost()) then {
        if PSTATE.EL == EL0 | PSTATE.EL == EL1 then {
            cache.is_vmid_valid = true;
            cache.vmid = VMID_read()
        } else {
            cache.is_vmid_valid = false
        }
    } else {
        cache.is_vmid_valid = false
    };
    if PSTATE.EL == EL0 then {
        cache.is_asid_valid = true;
        cache.asid = ASID_read()
    } else {
        cache.is_asid_valid = false
    };
    if opscope == CacheOpScope_PoDP & __IMPDEF_boolean("Memory system does not supports PoDP") then {
        opscope = CacheOpScope_PoP
    };
    if opscope == CacheOpScope_PoP & __IMPDEF_boolean("Memory system does not supports PoP") then {
        opscope = CacheOpScope_PoC
    };
    vaddress : bits(64) = regval;
    size : int = 0;
    if cacheop == CacheOp_Invalidate then {
        size = __IMPDEF_integer("Data Cache Invalidate Watchpoint Size");
        assert(size >= 4 * pow2(UInt(CTR_EL0[DminLine])) & size <= 2048);
        assert(UInt(size[32 .. 0] & (size - 1)[32 .. 0]) == 0);
        vaddress = Align(regval, size)
    };
    let 'size = size;
    if DCInstNeedsTranslation(opscope) then {
        cache.vaddress = vaddress;
        let aligned : bool = true;
        let accdesc : AccessDescriptor = CreateAccDescDC(cache);
        let memaddrdesc : AddressDescriptor = AArch64_TranslateAddress(vaddress, accdesc, aligned, size);
        if IsFault(memaddrdesc) then {
            AArch64_Abort(regval, memaddrdesc.fault)
        };
        cache.translated = true;
        cache.paddress = memaddrdesc.paddress;
        cache.cpas = CPASAtPAS(memaddrdesc.paddress.paspace);
        if opscope == CacheOpScope_PoC | opscope == CacheOpScope_PoP | opscope == CacheOpScope_PoDP then {
            cache.shareability = memaddrdesc.memattrs.shareability
        } else {
            cache.shareability = Shareability_NSH
        }
    } else if opscope == CacheOpScope_PoE then {
        cache.translated = true;
        cache.shareability = Shareability_OSH;
        cache.paddress.address = regval[55 .. 0];
        cache.paddress.paspace = DecodePASpace([regval[62]], [regval[63]]);
        cache.cpas = CPASAtPAS(cache.paddress.paspace);
        if cache.paddress.paspace != PAS_Realm then {
            EndOfInstruction()
        };
        if __IMPDEF_boolean("Apply granule protection check on DC to PoE") then {
            memaddrdesc : AddressDescriptor = undefined;
            let accdesc : AccessDescriptor = CreateAccDescDC(cache);
            memaddrdesc.paddress = cache.paddress;
            memaddrdesc.fault.gpcf = GranuleProtectionCheck(memaddrdesc, accdesc);
            if memaddrdesc.fault.gpcf.gpf != GPCF_None then {
                memaddrdesc.fault.statuscode = Fault_GPCFOnOutput;
                memaddrdesc.fault.paddress = memaddrdesc.paddress;
                AArch64_Abort(__UNKNOWN_bits(64), memaddrdesc.fault)
            };
            ()
        };
        ()
    } else if opscope == CacheOpScope_PoPA then {
        cache.translated = true;
        cache.shareability = Shareability_OSH;
        cache.paddress.address = regval[55 .. 0];
        cache.paddress.paspace = DecodePASpace([regval[62]], [regval[63]]);
        cache.cpas = CPASAtPAS(cache.paddress.paspace)
    } else {
        cache.vaddress = vaddress;
        cache.translated = false;
        cache.shareability = __UNKNOWN_Shareability();
        cache.paddress = __UNKNOWN_FullAddress()
    };
    if ((cacheop == CacheOp_Invalidate & PSTATE.EL == EL1) & EL2Enabled()) & (HCR_EL2[DC] @ HCR_EL2[VM]) != 0b00 then {
        cache.cacheop = CacheOp_CleanInvalidate
    };
    if (cache.translated & cache.cpas == CPAS_Secure) & not_bool(HaveSecureState()) then {
        return()
    };
    CACHE_OP(cache);
    return()
}

bitfield DCZID_EL0_Type : bits(64) = {DZP : 4..4, BS : 3..0}

register DCZID_EL0 : DCZID_EL0_Type

val AArch64_MemZero : (bits(64), CacheType) -> unit

function AArch64_MemZero (regval, cachetype) = {
    let 'size = 4 * pow2(UInt(DCZID_EL0[BS]));
    assert(size <= MAX_ZERO_BLOCK_SIZE);
    if HaveMTE2Ext() then {
        assert(size >= TAG_GRANULE)
    };
    let vaddress : bits(64) = Align(regval, size);
    let tagaccess : bool = cachetype == CacheType_Tag | cachetype == CacheType_Data_Tag;
    let tagchecked : bool = cachetype == CacheType_Data;
    let accdesc : AccessDescriptor = CreateAccDescDCZero(tagaccess, tagchecked);
    if cachetype == CacheType_Tag | cachetype == CacheType_Data_Tag then {
        AArch64_TagMemZero(regval, vaddress, accdesc, size)
    };
    if cachetype == CacheType_Data | cachetype == CacheType_Data_Tag then {
        AArch64_DataMemZero(regval, vaddress, accdesc, size)
    };
    return()
}

val AArch64_IC : CacheOpScope -> unit

val AArch64_IC__1 : (bits(64), CacheOpScope) -> unit

function AArch64_IC opscope = {
    let regval : bits(64) = __UNKNOWN_bits(64);
    AArch64_IC__1(regval, opscope)
}

function AArch64_IC__1 (regval, opscope) = {
    ss : SecurityState = undefined;
    cache : CacheRecord = undefined;
    cache.acctype = AccessType_IC;
    cache.cachetype = CacheType_Instruction;
    cache.cacheop = CacheOp_Invalidate;
    cache.opscope = opscope;
    if opscope == CacheOpScope_ALLU | opscope == CacheOpScope_ALLUIS then {
        let ss : SecurityState = SecurityStateAtEL(PSTATE.EL);
        cache.cpas = CPASAtSecurityState(ss);
        if opscope == CacheOpScope_ALLUIS | ((opscope == CacheOpScope_ALLU & PSTATE.EL == EL1) & EL2Enabled()) & HCR_EL2[FB] == 0b1 then {
            cache.shareability = Shareability_ISH
        } else {
            cache.shareability = Shareability_NSH
        };
        cache.regval = regval;
        CACHE_OP(cache)
    } else {
        assert(opscope == CacheOpScope_PoU);
        if EL2Enabled() & not_bool(IsInHost()) then {
            if PSTATE.EL == EL0 | PSTATE.EL == EL1 then {
                cache.is_vmid_valid = true;
                cache.vmid = VMID_read()
            } else {
                cache.is_vmid_valid = false
            }
        } else {
            cache.is_vmid_valid = false
        };
        if PSTATE.EL == EL0 then {
            cache.is_asid_valid = true;
            cache.asid = ASID_read()
        } else {
            cache.is_asid_valid = false
        };
        let vaddress : bits(64) = regval;
        let need_translate : bool = ICInstNeedsTranslation(opscope);
        cache.vaddress = regval;
        cache.shareability = Shareability_NSH;
        cache.translated = need_translate;
        if not_bool(need_translate) then {
            cache.paddress = __UNKNOWN_FullAddress();
            CACHE_OP(cache);
            return()
        };
        let accdesc : AccessDescriptor = CreateAccDescIC(cache);
        let aligned : bool = true;
        let 'size = 0;
        let memaddrdesc : AddressDescriptor = AArch64_TranslateAddress(vaddress, accdesc, aligned, size);
        if IsFault(memaddrdesc) then {
            AArch64_Abort(regval, memaddrdesc.fault)
        };
        cache.cpas = CPASAtPAS(memaddrdesc.paddress.paspace);
        cache.paddress = memaddrdesc.paddress;
        CACHE_OP(cache)
    };
    return()
}

val AArch64_RestrictPrediction : (bits(64), RestrictType) -> unit

function AArch64_RestrictPrediction (val_name, restriction) = {
    c : ExecutionCntxt = undefined;
    let target_el : bits(2) = val_name[25 .. 24];
    if not_bool(HaveEL(target_el)) | UInt(target_el) > UInt(PSTATE.EL) then {
        EndOfInstruction()
    };
    let ns : bits(1) = [val_name[26]];
    let nse : bits(1) = [val_name[27]];
    let ss : SecurityState = TargetSecurityState(ns, nse);
    if ss == SS_Root & target_el != EL3 then {
        EndOfInstruction()
    };
    if (not_bool(HaveRME()) & target_el == EL3) & ss != SS_Secure then {
        EndOfInstruction()
    };
    c.security = ss;
    c.target_el = target_el;
    if EL2Enabled() then {
        if PSTATE.EL == EL0 & not_bool(IsInHost()) | PSTATE.EL == EL1 then {
            c.is_vmid_valid = true;
            c.all_vmid = false;
            c.vmid = VMID_read()
        } else if target_el == EL0 & not_bool(ELIsInHost(target_el)) | target_el == EL1 then {
            c.is_vmid_valid = true;
            c.all_vmid = [val_name[48]] == 0b1;
            c.vmid = val_name[47 .. 32]
        } else {
            c.is_vmid_valid = false
        }
    } else {
        c.is_vmid_valid = false
    };
    if PSTATE.EL == EL0 then {
        c.is_asid_valid = true;
        c.all_asid = false;
        c.asid = ASID_read()
    } else if target_el == EL0 then {
        c.is_asid_valid = true;
        c.all_asid = [val_name[16]] == 0b1;
        c.asid = val_name[15 .. 0]
    } else {
        c.is_asid_valid = false
    };
    c.restriction = restriction;
    RESTRICT_PREDICTIONS(c)
}

val AArch32_EL2Enabled : SecurityState -> bool

function AArch32_EL2Enabled ss = {
    if ss == SS_Secure then {
        if not_bool(HaveEL(EL2) & HaveSecureEL2Ext()) then {
            return(false)
        } else if HaveEL(EL3) then {
            return(SCR_EL3[EEL2] == 0b1)
        } else {
            return(__IMPDEF_boolean("Secure-only implementation"))
        }
    } else {
        return(HaveEL(EL2))
    }
}

val AArch32_S1IASize : bits(3) -> int

function AArch32_S1IASize txsz = {
    return(32 - UInt(txsz))
}

val AArch32_GetVARange : (bits(32), bits(3), bits(3)) -> VARange

function AArch32_GetVARange (va, t0sz, t1sz) = {
    let 'lo_iasize = AArch32_S1IASize(t0sz);
    let 'up_iasize = AArch32_S1IASize(t1sz);
    if t1sz == 0b000 & t0sz == 0b000 then {
        return(VARange_LOWER)
    } else if t1sz == 0b000 then {
        return(if is_zero_subrange(va, 31, lo_iasize) then VARange_LOWER else
          VARange_UPPER)
    } else if t0sz == 0b000 then {
        return(if is_ones_subrange(va, 31, up_iasize) then VARange_UPPER else
          VARange_LOWER)
    } else if is_zero_subrange(va, 31, lo_iasize) then {
        return(VARange_LOWER)
    } else if is_ones_subrange(va, 31, up_iasize) then {
        return(VARange_UPPER)
    } else {
        return(__UNKNOWN_VARange())
    }
}

bitfield MAIR0_Type : bits(32) =
  {Attr3 : 31..24, Attr2 : 23..16, Attr1 : 15..8, Attr0 : 7..0}

bitfield PRRR_Type : bits(32) =
  {
    NOS7 : 31..31,
    NOS6 : 30..30,
    NOS5 : 29..29,
    NOS4 : 28..28,
    NOS3 : 27..27,
    NOS2 : 26..26,
    NOS1 : 25..25,
    NOS0 : 24..24,
    NS1 : 19..19,
    NS0 : 18..18,
    DS1 : 17..17,
    DS0 : 16..16,
    TR7 : 15..14,
    TR6 : 13..12,
    TR5 : 11..10,
    TR4 : 9..8,
    TR3 : 7..6,
    TR2 : 5..4,
    TR1 : 3..2,
    TR0 : 1..0
  }

register _PRRR_NS : PRRR_Type

val PRRR_NS_read : unit -> PRRR_Type

function PRRR_NS_read () = {
    r : PRRR_Type = _PRRR_NS;
    r.bits[31 .. 0] = Slice(MAIR_EL1.bits, 0, 32);
    return(r)
}

register PRRR_S : PRRR_Type

val PRRR_read : unit -> PRRR_Type

function PRRR_read () = {
    r : PRRR_Type = undefined;
    if ELUsingAArch32(EL3) & CurrentSecurityState() == SS_Secure then {
        r = PRRR_S
    } else {
        r = PRRR_NS_read()
    };
    return(r)
}

register _MAIR0_NS : MAIR0_Type

val MAIR0_NS_read : unit -> MAIR0_Type

function MAIR0_NS_read () = {
    r : MAIR0_Type = _MAIR0_NS;
    if ELUsingAArch32(EL3) then {
        r.bits[31 .. 0] = Slice(PRRR_NS_read().bits, 0, 32)
    } else {
        if not_bool(HaveEL(EL3)) | not_bool(ELUsingAArch32(EL3)) then {
            r.bits[31 .. 0] = Slice(MAIR_EL1.bits, 0, 32)
        } else {
            r.bits[31 .. 0] = Slice(PRRR_read().bits, 0, 32)
        }
    };
    return(r)
}

register _MAIR0_S : MAIR0_Type

val MAIR0_S_read : unit -> MAIR0_Type

function MAIR0_S_read () = {
    r : MAIR0_Type = _MAIR0_S;
    r.bits[31 .. 0] = Slice(PRRR_S.bits, 0, 32);
    return(r)
}

val MAIR0_read : unit -> MAIR0_Type

function MAIR0_read () = {
    r : MAIR0_Type = undefined;
    if ELUsingAArch32(EL3) & CurrentSecurityState() == SS_Secure then {
        r = MAIR0_S_read()
    } else {
        r = MAIR0_NS_read()
    };
    return(r)
}

bitfield MAIR1_Type : bits(32) =
  {Attr7 : 31..24, Attr6 : 23..16, Attr5 : 15..8, Attr4 : 7..0}

bitfield NMRR_Type : bits(32) =
  {
    OR7 : 31..30,
    OR6 : 29..28,
    OR5 : 27..26,
    OR4 : 25..24,
    OR3 : 23..22,
    OR2 : 21..20,
    OR1 : 19..18,
    OR0 : 17..16,
    IR7 : 15..14,
    IR6 : 13..12,
    IR5 : 11..10,
    IR4 : 9..8,
    IR3 : 7..6,
    IR2 : 5..4,
    IR1 : 3..2,
    IR0 : 1..0
  }

register _NMRR_NS : NMRR_Type

val NMRR_NS_read : unit -> NMRR_Type

function NMRR_NS_read () = {
    r : NMRR_Type = _NMRR_NS;
    r.bits[31 .. 0] = Slice(MAIR_EL1.bits, 32, 32);
    return(r)
}

register NMRR_S : NMRR_Type

val NMRR_read : unit -> NMRR_Type

function NMRR_read () = {
    r : NMRR_Type = undefined;
    if ELUsingAArch32(EL3) & CurrentSecurityState() == SS_Secure then {
        r = NMRR_S
    } else {
        r = NMRR_NS_read()
    };
    return(r)
}

register _MAIR1_NS : MAIR1_Type

val MAIR1_NS_read : unit -> MAIR1_Type

function MAIR1_NS_read () = {
    r : MAIR1_Type = _MAIR1_NS;
    if ELUsingAArch32(EL3) then {
        r.bits[31 .. 0] = Slice(NMRR_NS_read().bits, 0, 32)
    } else {
        if not_bool(HaveEL(EL3)) | not_bool(ELUsingAArch32(EL3)) then {
            r.bits[31 .. 0] = Slice(MAIR_EL1.bits, 32, 32)
        } else {
            r.bits[31 .. 0] = Slice(NMRR_read().bits, 0, 32)
        }
    };
    return(r)
}

register _MAIR1_S : MAIR1_Type

val MAIR1_S_read : unit -> MAIR1_Type

function MAIR1_S_read () = {
    r : MAIR1_Type = _MAIR1_S;
    r.bits[31 .. 0] = Slice(NMRR_S.bits, 0, 32);
    return(r)
}

val MAIR1_read : unit -> MAIR1_Type

function MAIR1_read () = {
    r : MAIR1_Type = undefined;
    if ELUsingAArch32(EL3) & CurrentSecurityState() == SS_Secure then {
        r = MAIR1_S_read()
    } else {
        r = MAIR1_NS_read()
    };
    return(r)
}

bitfield TTBCR2_Type : bits(32) =
  {
    HWU162 : 18..18,
    HWU161 : 17..17,
    HWU160 : 16..16,
    HWU159 : 15..15,
    HWU062 : 14..14,
    HWU061 : 13..13,
    HWU060 : 12..12,
    HWU059 : 11..11,
    HPD1 : 10..10,
    HPD0 : 9..9
  }

register _TTBCR2_NS : TTBCR2_Type

val TTBCR2_NS_read : unit -> TTBCR2_Type

function TTBCR2_NS_read () = {
    r : TTBCR2_Type = _TTBCR2_NS;
    r.bits[31 .. 0] = Slice(TCR_EL1.bits, 32, 32);
    return(r)
}

register TTBCR2_S : TTBCR2_Type

val TTBCR2_read : unit -> TTBCR2_Type

function TTBCR2_read () = {
    r : TTBCR2_Type = undefined;
    if ELUsingAArch32(EL3) & CurrentSecurityState() == SS_Secure then {
        r = TTBCR2_S
    } else {
        r = TTBCR2_NS_read()
    };
    return(r)
}

val AArch32_S1TTWParamsEL10 : bits(32) -> S1TTWParams

function AArch32_S1TTWParamsEL10 va = {
    mair : bits(64) = undefined;
    sif : bits(1) = undefined;
    ttbcr : TTBCR_Type = undefined;
    ttbcr2 : TTBCR2_Type = undefined;
    sctlr : SCTLR_Type = undefined;
    if ELUsingAArch32(EL3) then {
        ttbcr = TTBCR_NS_read();
        ttbcr2 = TTBCR2_NS_read();
        sctlr = SCTLR_NS_read();
        mair = MAIR1_NS_read().bits @ MAIR0_NS_read().bits;
        sif = SCR[SIF]
    } else {
        ttbcr = TTBCR_read();
        ttbcr2 = TTBCR2_read();
        sctlr = SCTLR_read__2();
        mair = MAIR1_read().bits @ MAIR0_read().bits;
        sif = if HaveEL(EL3) then SCR_EL3[SIF] else 0b0
    };
    assert(ttbcr[EAE] == 0b1);
    walkparams : S1TTWParams = undefined;
    walkparams.t0sz = ttbcr[T0SZ];
    walkparams.t1sz = ttbcr[T1SZ];
    walkparams.ee = sctlr[EE];
    walkparams.wxn = sctlr[WXN];
    walkparams.uwxn = sctlr[UWXN];
    walkparams.ntlsmd = if HaveTrapLoadStoreMultipleDeviceExt() then
      sctlr[nTLSMD]
    else
      0b1;
    walkparams.mair = Mk_MAIRType(mair);
    walkparams.sif = sif;
    let varange : VARange = AArch32_GetVARange(va, walkparams.t0sz, walkparams.t1sz);
    if varange == VARange_LOWER then {
        walkparams.sh = ttbcr[SH0];
        walkparams.irgn = ttbcr[IRGN0];
        walkparams.orgn = ttbcr[ORGN0];
        walkparams.hpd = if AArch32_HaveHPDExt() then ttbcr[T2E] & ttbcr2[HPD0]
        else
          0b0
    } else {
        walkparams.sh = ttbcr[SH1];
        walkparams.irgn = ttbcr[IRGN1];
        walkparams.orgn = ttbcr[ORGN1];
        walkparams.hpd = if AArch32_HaveHPDExt() then ttbcr[T2E] & ttbcr2[HPD1]
        else
          0b0
    };
    return(walkparams)
}

bitfield HMAIR0_Type : bits(32) =
  {Attr3 : 31..24, Attr2 : 23..16, Attr1 : 15..8, Attr0 : 7..0}

register _HMAIR0 : HMAIR0_Type

val HMAIR0_read : unit -> HMAIR0_Type

function HMAIR0_read () = {
    r : HMAIR0_Type = _HMAIR0;
    r.bits[31 .. 0] = Slice(MAIR_EL2.bits, 0, 32);
    return(r)
}

bitfield HMAIR1_Type : bits(32) =
  {Attr7 : 31..24, Attr6 : 23..16, Attr5 : 15..8, Attr4 : 7..0}

register _HMAIR1 : HMAIR1_Type

val HMAIR1_read : unit -> HMAIR1_Type

function HMAIR1_read () = {
    r : HMAIR1_Type = _HMAIR1;
    r.bits[31 .. 0] = Slice(MAIR_EL2.bits, 32, 32);
    return(r)
}

bitfield HTCR_Type : bits(32) =
  {
    HWU62 : 28..28,
    HWU61 : 27..27,
    HWU60 : 26..26,
    HWU59 : 25..25,
    HPD : 24..24,
    SH0 : 13..12,
    ORGN0 : 11..10,
    IRGN0 : 9..8,
    T0SZ : 2..0
  }

register _HTCR : HTCR_Type

val HTCR_read : unit -> HTCR_Type

function HTCR_read () = {
    r : HTCR_Type = _HTCR;
    r.bits[31 .. 0] = Slice(TCR_EL2.bits, 0, 32);
    return(r)
}

val AArch32_S1TTWParamsEL2 : unit -> S1TTWParams

function AArch32_S1TTWParamsEL2 () = {
    walkparams : S1TTWParams = undefined;
    walkparams.tgx = TGx_4KB;
    walkparams.t0sz = HTCR_read()[T0SZ];
    walkparams.irgn = HTCR_read()[SH0];
    walkparams.orgn = HTCR_read()[IRGN0];
    walkparams.sh = HTCR_read()[ORGN0];
    walkparams.hpd = if AArch32_HaveHPDExt() then HTCR_read()[HPD] else 0b0;
    walkparams.ee = HSCTLR_read()[EE];
    walkparams.wxn = HSCTLR_read()[WXN];
    if HaveTrapLoadStoreMultipleDeviceExt() then {
        walkparams.ntlsmd = HSCTLR_read()[nTLSMD]
    } else {
        walkparams.ntlsmd = 0b1
    };
    walkparams.mair = Mk_MAIRType(HMAIR1_read().bits @ HMAIR0_read().bits);
    return(walkparams)
}

val AArch32_S1TTWParamsEL30 : bits(32) -> S1TTWParams

function AArch32_S1TTWParamsEL30 va = {
    assert(TTBCR_S[EAE] == 0b1);
    walkparams : S1TTWParams = undefined;
    walkparams.t0sz = TTBCR_S[T0SZ];
    walkparams.t1sz = TTBCR_S[T1SZ];
    walkparams.ee = SCTLR_S[EE];
    walkparams.wxn = SCTLR_S[WXN];
    walkparams.uwxn = SCTLR_S[UWXN];
    walkparams.ntlsmd = if HaveTrapLoadStoreMultipleDeviceExt() then
      SCTLR_S[nTLSMD]
    else
      0b1;
    walkparams.mair = Mk_MAIRType(MAIR1_S_read().bits @ MAIR0_S_read().bits);
    walkparams.sif = SCR[SIF];
    let varange : VARange = AArch32_GetVARange(va, walkparams.t0sz, walkparams.t1sz);
    if varange == VARange_LOWER then {
        walkparams.sh = TTBCR_S[SH0];
        walkparams.irgn = TTBCR_S[IRGN0];
        walkparams.orgn = TTBCR_S[ORGN0];
        walkparams.hpd = if AArch32_HaveHPDExt() then
          TTBCR_S[T2E] & TTBCR2_S[HPD0]
        else
          0b0
    } else {
        walkparams.sh = TTBCR_S[SH1];
        walkparams.irgn = TTBCR_S[IRGN1];
        walkparams.orgn = TTBCR_S[ORGN1];
        walkparams.hpd = if AArch32_HaveHPDExt() then
          TTBCR_S[T2E] & TTBCR2_S[HPD1]
        else
          0b0
    };
    return(walkparams)
}

val AArch32_GetS1TTWParams : (Regime, bits(32)) -> S1TTWParams

function AArch32_GetS1TTWParams (regime, va) = {
    walkparams : S1TTWParams = undefined;
    match regime {
      Regime_EL2 => {
          walkparams = AArch32_S1TTWParamsEL2()
      },
      Regime_EL10 => {
          walkparams = AArch32_S1TTWParamsEL10(va)
      },
      Regime_EL30 => {
          walkparams = AArch32_S1TTWParamsEL30(va)
      },
      _ => ()
    };
    return(walkparams)
}

val AArch32_S1DCacheEnabled : Regime -> bool

function AArch32_S1DCacheEnabled regime = {
    match regime {
      Regime_EL30 => {
          return(SCTLR_S[C] == 0b1)
      },
      Regime_EL2 => {
          return(HSCTLR_read()[C] == 0b1)
      },
      Regime_EL10 => {
          return((if HaveAArch32EL(EL3) then SCTLR_NS_read()[C] else
            SCTLR_read__2()[C]) == 0b1)
      },
      _ => {
          return(undefined : bool)
      }
    }
}

val AArch32_S1HasAlignmentFault : forall ('aligned : Bool).
  (AccessDescriptor, bool('aligned), bits(1), MemoryAttributes) -> bool

function AArch32_S1HasAlignmentFault (accdesc, aligned, ntlsmd, memattrs) = {
    if accdesc.acctype == AccessType_IFETCH then {
        return(false)
    } else if accdesc.a32lsmd & ntlsmd == 0b0 then {
        return(memattrs.memtype == MemType_Device & memattrs.device != DeviceType_GRE)
    } else if accdesc.acctype == AccessType_DCZero then {
        return(memattrs.memtype == MemType_Device)
    } else {
        return(memattrs.memtype == MemType_Device & not_bool(aligned))
    }
}

val AArch32_S1ICacheEnabled : Regime -> bool

function AArch32_S1ICacheEnabled regime = {
    match regime {
      Regime_EL30 => {
          return(SCTLR_S[I] == 0b1)
      },
      Regime_EL2 => {
          return(HSCTLR_read()[I] == 0b1)
      },
      Regime_EL10 => {
          return((if HaveAArch32EL(EL3) then SCTLR_NS_read()[I] else
            SCTLR_read__2()[I]) == 0b1)
      },
      _ => {
          return(undefined : bool)
      }
    }
}

val AArch32_S1DisabledOutput : forall ('aligned : Bool).
  (FaultRecord, Regime, bits(32), bool('aligned), AccessDescriptor) -> (FaultRecord, AddressDescriptor)

function AArch32_S1DisabledOutput (fault_in, regime, va, aligned, accdesc) = {
    fault : FaultRecord = fault_in;
    SetInGuardedPage(false);
    memattrs : MemoryAttributes = undefined;
    default_cacheable : bits(1) = undefined;
    if regime == Regime_EL10 & AArch32_EL2Enabled(accdesc.ss) then {
        if ELStateUsingAArch32(EL2, accdesc.ss == SS_Secure) then {
            default_cacheable = HCR_read()[DC]
        } else {
            default_cacheable = HCR_EL2[DC]
        }
    } else {
        default_cacheable = 0b0
    };
    if default_cacheable == 0b1 then {
        memattrs.memtype = MemType_Normal;
        memattrs.inner.attrs = MemAttr_WB;
        memattrs.inner.hints = MemHint_RWA;
        memattrs.outer.attrs = MemAttr_WB;
        memattrs.outer.hints = MemHint_RWA;
        memattrs.shareability = Shareability_NSH;
        if (not_bool(ELStateUsingAArch32(EL2, accdesc.ss == SS_Secure)) & HaveMTE2Ext()) & HCR_EL2[DCT] == 0b1 then {
            memattrs.tags = MemTag_AllocationTagged
        } else {
            memattrs.tags = MemTag_Untagged
        };
        memattrs.xs = 0b0
    } else if accdesc.acctype == AccessType_IFETCH then {
        memattrs.memtype = MemType_Normal;
        memattrs.shareability = Shareability_OSH;
        memattrs.tags = MemTag_Untagged;
        if AArch32_S1ICacheEnabled(regime) then {
            memattrs.inner.attrs = MemAttr_WT;
            memattrs.inner.hints = MemHint_RA;
            memattrs.outer.attrs = MemAttr_WT;
            memattrs.outer.hints = MemHint_RA
        } else {
            memattrs.inner.attrs = MemAttr_NC;
            memattrs.outer.attrs = MemAttr_NC
        };
        memattrs.xs = 0b1
    } else {
        memattrs.memtype = MemType_Device;
        memattrs.device = DeviceType_nGnRnE;
        memattrs.shareability = Shareability_OSH;
        memattrs.tags = MemTag_Untagged;
        memattrs.xs = 0b1
    };
    ntlsmd : bits(1) = undefined;
    if HaveTrapLoadStoreMultipleDeviceExt() then {
        match regime {
          Regime_EL30 => {
              ntlsmd = SCTLR_S[nTLSMD]
          },
          Regime_EL2 => {
              ntlsmd = HSCTLR_read()[nTLSMD]
          },
          Regime_EL10 => {
              ntlsmd = if HaveAArch32EL(EL3) then SCTLR_NS_read()[nTLSMD] else
                SCTLR_read__2()[nTLSMD]
          },
          _ => ()
        }
    } else {
        ntlsmd = 0b1
    };
    if AArch32_S1HasAlignmentFault(accdesc, aligned, ntlsmd, memattrs) then {
        fault.statuscode = Fault_Alignment;
        return((fault, __UNKNOWN_AddressDescriptor()))
    };
    oa : FullAddress = undefined;
    oa.address = ZeroExtend(va, 56);
    oa.paspace = if accdesc.ss == SS_Secure then PAS_Secure else PAS_NonSecure;
    let ipa : AddressDescriptor = CreateAddressDescriptor(ZeroExtend(va, 64), oa, memattrs);
    return((fault, ipa))
}

val AArch32_S1Enabled : (Regime, SecurityState) -> bool

function AArch32_S1Enabled (regime, ss) = {
    if regime == Regime_EL2 then {
        return(HSCTLR_read()[M] == 0b1)
    } else if regime == Regime_EL30 then {
        return(SCTLR_S[M] == 0b1)
    } else if not_bool(AArch32_EL2Enabled(ss)) then {
        return((if HaveAArch32EL(EL3) then SCTLR_NS_read()[M] else
          SCTLR_read__2()[M]) == 0b1)
    } else if ELStateUsingAArch32(EL2, ss == SS_Secure) then {
        return((HCR_read()[TGE] @ HCR_read()[DC]) == 0b00 & (if HaveAArch32EL(EL3) then
          SCTLR_NS_read()[M]
        else
          SCTLR_read__2()[M]) == 0b1)
    } else {
        return((HCR_EL2[TGE] @ HCR_EL2[DC]) == 0b00 & SCTLR_read__2()[M] == 0b1)
    }
}

val AArch32_S1LDHasPermissionsFault : (Regime, S1TTWParams, Permissions, MemType, PASpace, AccessDescriptor) -> bool

function AArch32_S1LDHasPermissionsFault (regime, walkparams, perms, memtype, paspace, accdesc) = {
    constraint_name : Constraint = undefined;
    pan : bits(1) = undefined;
    px : bits(1) = undefined;
    pxn : bits(1) = undefined;
    ux : bits(1) = undefined;
    r : bits(1) = undefined;
    w : bits(1) = undefined;
    x : bits(1) = undefined;
    pr : bits(1) = undefined;
    pw : bits(1) = undefined;
    ur : bits(1) = undefined;
    uw : bits(1) = undefined;
    xn : bits(1) = undefined;
    if HasUnprivileged(regime) then {
        match perms.ap[2 .. 1] {
          0b00 => {
              (pr, pw, ur, uw) = (0b1, 0b1, 0b0, 0b0)
          },
          0b01 => {
              (pr, pw, ur, uw) = (0b1, 0b1, 0b1, 0b1)
          },
          0b10 => {
              (pr, pw, ur, uw) = (0b1, 0b0, 0b0, 0b0)
          },
          0b11 => {
              (pr, pw, ur, uw) = (0b1, 0b0, 0b1, 0b0)
          }
        };
        match perms.ap_table {
          0b00 => {
              (pr, pw, ur, uw) = (pr, pw, ur, uw)
          },
          0b01 => {
              (pr, pw, ur, uw) = (pr, pw, 0b0, 0b0)
          },
          0b10 => {
              (pr, pw, ur, uw) = (pr, 0b0, ur, 0b0)
          },
          0b11 => {
              (pr, pw, ur, uw) = (pr, 0b0, 0b0, 0b0)
          }
        };
        let xn : bits(1) = perms.xn | perms.xn_table;
        let pxn : bits(1) = perms.pxn | perms.pxn_table;
        let ux : bits(1) = ur & not_vec(xn | uw & walkparams.wxn);
        let px : bits(1) = pr & not_vec(((xn | pxn) | pw & walkparams.wxn) | uw & walkparams.uwxn);
        if HavePANExt() & accdesc.pan then {
            let pan : bits(1) = PSTATE.PAN & (ur | uw);
            pr = pr & not_vec(pan);
            pw = pw & not_vec(pan)
        };
        (r, w, x) = if accdesc.el == EL0 then (ur, uw, ux) else (pr, pw, px);
        if accdesc.ss == SS_Secure & paspace == PAS_NonSecure then {
            x = x & not_vec(walkparams.sif)
        };
        ()
    } else {
        match [perms.ap[2]] {
          0b0 => {
              (r, w) = (0b1, 0b1)
          },
          0b1 => {
              (r, w) = (0b1, 0b0)
          }
        };
        match [perms.ap_table[1]] {
          0b0 => {
              (r, w) = (r, w)
          },
          0b1 => {
              (r, w) = (r, 0b0)
          }
        };
        let xn : bits(1) = perms.xn | perms.xn_table;
        x = not_vec(xn | w & walkparams.wxn)
    };
    if accdesc.acctype == AccessType_IFETCH then {
        let constraint_name : Constraint = ConstrainUnpredictable(Unpredictable_INSTRDEVICE);
        if constraint_name == Constraint_FAULT & memtype == MemType_Device then {
            return(true)
        } else {
            return(x == 0b0)
        }
    } else if accdesc.acctype == AccessType_IC | accdesc.acctype == AccessType_DC then {
        return(false)
    } else if accdesc.write then {
        return(w == 0b0)
    } else {
        return(r == 0b0)
    }
}

val AArch32_DecodeDescriptorTypeLD : forall 'level.
  (bits(64), int('level)) -> DescriptorType

function AArch32_DecodeDescriptorTypeLD (descriptor, level) = {
    if descriptor[1 .. 0] == 0b11 & level == FINAL_LEVEL then {
        return(DescriptorType_Leaf)
    } else if descriptor[1 .. 0] == 0b11 then {
        return(DescriptorType_Table)
    } else if descriptor[1 .. 0] == 0b01 & level != FINAL_LEVEL then {
        return(DescriptorType_Leaf)
    } else {
        return(DescriptorType_Invalid)
    }
}

val AArch32_TLBContextEL10 : (SecurityState, bits(32)) -> TLBContext

function AArch32_TLBContextEL10 (ss, va) = {
    tlbcontext : TLBContext = undefined;
    ttbcr : TTBCR_Type = undefined;
    ttbr0 : TTBR0_Type = undefined;
    ttbr1 : TTBR1_Type = undefined;
    contextidr : CONTEXTIDR_Type = undefined;
    if HaveAArch32EL(EL3) then {
        ttbcr = TTBCR_NS_read();
        ttbr0 = TTBR0_NS;
        ttbr1 = TTBR1_NS;
        contextidr = CONTEXTIDR_NS_read()
    } else {
        ttbcr = TTBCR_read();
        ttbr0 = TTBR0_read();
        ttbr1 = TTBR1_read();
        contextidr = CONTEXTIDR_read()
    };
    tlbcontext.ss = ss;
    tlbcontext.regime = Regime_EL10;
    if AArch32_EL2Enabled(ss) then {
        tlbcontext.vmid = ZeroExtend(VTTBR[VMID], 16)
    };
    if ttbcr[EAE] == 0b1 then {
        tlbcontext.asid = ZeroExtend(if ttbcr[A1] == 0b0 then ttbr0[ASID] else
          ttbr1[ASID], 16)
    } else {
        tlbcontext.asid = ZeroExtend(contextidr[ASID], 16)
    };
    tlbcontext.tg = TGx_4KB;
    tlbcontext.ia = ZeroExtend(va, 64);
    if HaveCommonNotPrivateTransExt() & ttbcr[EAE] == 0b1 then {
        if AArch32_GetVARange(va, ttbcr[T0SZ], ttbcr[T1SZ]) == VARange_LOWER then {
            tlbcontext.cnp = ttbr0[CnP]
        } else {
            tlbcontext.cnp = ttbr1[CnP]
        }
    } else {
        tlbcontext.cnp = 0b0
    };
    return(tlbcontext)
}

val AArch32_TLBContextEL2 : bits(32) -> TLBContext

function AArch32_TLBContextEL2 va = {
    tlbcontext : TLBContext = undefined;
    tlbcontext.ss = SS_NonSecure;
    tlbcontext.regime = Regime_EL2;
    tlbcontext.ia = ZeroExtend(va, 64);
    tlbcontext.tg = TGx_4KB;
    tlbcontext.cnp = if HaveCommonNotPrivateTransExt() then HTTBR[CnP] else 0b0;
    return(tlbcontext)
}

val AArch32_TLBContextEL30 : bits(32) -> TLBContext

function AArch32_TLBContextEL30 va = {
    tlbcontext : TLBContext = undefined;
    tlbcontext.ss = SS_Secure;
    tlbcontext.regime = Regime_EL30;
    if TTBCR_S[EAE] == 0b1 then {
        tlbcontext.asid = ZeroExtend(if TTBCR_S[A1] == 0b0 then TTBR0_S[ASID]
        else
          TTBR1_S[ASID], 16)
    } else {
        tlbcontext.asid = ZeroExtend(CONTEXTIDR_S[ASID], 16)
    };
    tlbcontext.tg = TGx_4KB;
    tlbcontext.ia = ZeroExtend(va, 64);
    if HaveCommonNotPrivateTransExt() & TTBCR_S[EAE] == 0b1 then {
        if AArch32_GetVARange(va, TTBCR_S[T0SZ], TTBCR_S[T1SZ]) == VARange_LOWER then {
            tlbcontext.cnp = TTBR0_S[CnP]
        } else {
            tlbcontext.cnp = TTBR1_S[CnP]
        }
    } else {
        tlbcontext.cnp = 0b0
    };
    return(tlbcontext)
}

val AArch32_GetS1TLBContext : (Regime, SecurityState, bits(32)) -> TLBContext

function AArch32_GetS1TLBContext (regime, ss, va) = {
    tlbcontext : TLBContext = undefined;
    match regime {
      Regime_EL2 => {
          tlbcontext = AArch32_TLBContextEL2(va)
      },
      Regime_EL10 => {
          tlbcontext = AArch32_TLBContextEL10(ss, va)
      },
      Regime_EL30 => {
          tlbcontext = AArch32_TLBContextEL30(va)
      },
      _ => ()
    };
    tlbcontext.includes_s1_name = true;
    tlbcontext.includes_s2_name = false;
    return(tlbcontext)
}

val AArch32_MAIRAttr : forall 'index. (int('index), MAIRType) -> bits(8)

function AArch32_MAIRAttr (index, mair) = {
    assert(index < 8);
    let 'bit_index = 8 * index;
    assert(constraint((0 <= 'bit_index | not('index < 8))));
    return(mair.bits[bit_index + 7 .. bit_index])
}

bitfield VTCR_Type : bits(32) =
  {
    HWU62 : 28..28,
    HWU61 : 27..27,
    HWU60 : 26..26,
    HWU59 : 25..25,
    SH0 : 13..12,
    ORGN0 : 11..10,
    IRGN0 : 9..8,
    SL0 : 7..6,
    S : 4..4,
    T0SZ : 3..0
  }

register _VTCR : VTCR_Type

val VTCR_read : unit -> VTCR_Type

function VTCR_read () = {
    r : VTCR_Type = _VTCR;
    r.bits[31 .. 0] = Slice(VTCR_EL2.bits, 0, 32);
    return(r)
}

val AArch32_GetS2TTWParams : unit -> S2TTWParams

function AArch32_GetS2TTWParams () = {
    walkparams : S2TTWParams = undefined;
    walkparams.tgx = TGx_4KB;
    walkparams.s = VTCR_read()[S];
    walkparams.t0sz = VTCR_read()[T0SZ];
    walkparams.sl0 = VTCR_read()[SL0];
    walkparams.irgn = VTCR_read()[IRGN0];
    walkparams.orgn = VTCR_read()[ORGN0];
    walkparams.sh = VTCR_read()[SH0];
    walkparams.ee = HSCTLR_read()[EE];
    walkparams.ptw = HCR_read()[PTW];
    walkparams.vm = HCR_read()[VM] | HCR_read()[DC];
    if walkparams.s != [walkparams.t0sz[3]] then {
        let (_, __tup_1 : bitvector(4)) = ConstrainUnpredictableBits(Unpredictable_RESVTCRS, 4);
        walkparams.t0sz = __tup_1
    };
    return(walkparams)
}

val AArch32_S2IASize : bits(4) -> int

function AArch32_S2IASize t0sz = {
    return(32 - SInt(t0sz))
}

val AArch32_IPAIsOutOfRange : (S2TTWParams, bits(40)) -> bool

function AArch32_IPAIsOutOfRange (walkparams, ipa) = {
    let 'iasize = AArch32_S2IASize(walkparams.t0sz);
    return(iasize < 40 & not_bool(is_zero_subrange(ipa, 39, iasize)))
}

val AArch32_S2HasAlignmentFault : forall ('aligned : Bool).
  (AccessDescriptor, bool('aligned), MemoryAttributes) -> bool

function AArch32_S2HasAlignmentFault (accdesc, aligned, memattrs) = {
    if accdesc.acctype == AccessType_IFETCH then {
        return(false)
    } else if accdesc.acctype == AccessType_DCZero then {
        return(memattrs.memtype == MemType_Device)
    } else {
        return(memattrs.memtype == MemType_Device & not_bool(aligned))
    }
}

val AArch32_S2HasPermissionsFault : (S2TTWParams, Permissions, MemType, AccessDescriptor) -> bool

function AArch32_S2HasPermissionsFault (walkparams, perms, memtype, accdesc) = {
    constraint_name : Constraint = undefined;
    px : bits(1) = undefined;
    ux : bits(1) = undefined;
    let r : bits(1) = [perms.s2ap[0]];
    let w : bits(1) = [perms.s2ap[1]];
    x : bits(1) = undefined;
    if HaveExtendedExecuteNeverExt() then {
        match perms.s2xn @ perms.s2xnx {
          0b00 => {
              (px, ux) = (r, r)
          },
          0b01 => {
              (px, ux) = (0b0, r)
          },
          0b10 => {
              (px, ux) = (0b0, 0b0)
          },
          0b11 => {
              (px, ux) = (r, 0b0)
          }
        };
        x = if accdesc.el == EL0 then ux else px
    } else {
        x = r & not_vec(perms.s2xn)
    };
    if accdesc.acctype == AccessType_TTW then {
        return(walkparams.ptw == 0b1 & memtype == MemType_Device | r == 0b0)
    } else if accdesc.acctype == AccessType_IFETCH then {
        let constraint_name : Constraint = ConstrainUnpredictable(Unpredictable_INSTRDEVICE);
        return(constraint_name == Constraint_FAULT & memtype == MemType_Device | x == 0b0)
    } else if accdesc.acctype == AccessType_IC | accdesc.acctype == AccessType_DC then {
        return(false)
    } else if accdesc.write then {
        return(w == 0b0)
    } else {
        return(r == 0b0)
    }
}

val AArch32_GetS2TLBContext : FullAddress -> TLBContext

function AArch32_GetS2TLBContext ipa = {
    assert(ipa.paspace == PAS_NonSecure);
    tlbcontext : TLBContext = undefined;
    tlbcontext.ss = SS_NonSecure;
    tlbcontext.regime = Regime_EL10;
    tlbcontext.ipaspace = ipa.paspace;
    tlbcontext.vmid = ZeroExtend(VTTBR[VMID], 16);
    tlbcontext.tg = TGx_4KB;
    tlbcontext.includes_s1_name = false;
    tlbcontext.includes_s2_name = true;
    tlbcontext.ia = ZeroExtend(ipa.address, 64);
    tlbcontext.cnp = if HaveCommonNotPrivateTransExt() then VTTBR[CnP] else 0b0;
    return(tlbcontext)
}

val AArch32_S2StartLevel : bits(2) -> int

function AArch32_S2StartLevel sl0 = {
    return(2 - UInt(sl0))
}

val AArch32_S2InconsistentSL : S2TTWParams -> bool

function AArch32_S2InconsistentSL walkparams = {
    let 'startlevel = AArch32_S2StartLevel(walkparams.sl0);
    let 'levels = FINAL_LEVEL - startlevel;
    let 'granulebits = TGxGranuleBits(walkparams.tgx);
    let 'stride = granulebits - 3;
    let 'sl_min_iasize = levels * stride + granulebits + 1;
    let 'sl_max_iasize = sl_min_iasize + (stride - 1) + 4;
    let 'iasize = AArch32_S2IASize(walkparams.t0sz);
    return(iasize < sl_min_iasize | iasize > sl_max_iasize)
}

val AArch32_S2Walk : (FaultRecord, S2TTWParams, option(int), AccessDescriptor, AddressDescriptor) -> (FaultRecord, TTWState)

function AArch32_S2Walk (fault_in, walkparams, s1level, accdesc, ipa) = {
    finalwalkstate : TTWState = undefined;
    fault : FaultRecord = fault_in;
    tlbcontext : TLBContext = undefined;
    if __tlb_enabled then {
        tlbcontext = AArch32_GetS2TLBContext(ipa.paddress);
        let tlbentry : TLBLine = S2TLBLookup(tlbcontext);
        if tlbentry.valid_name then {
            let finalwalkstate : TTWState = tlbentry.tlbrecord.walkstate;
            fault.level = finalwalkstate.level;
            return((fault, finalwalkstate))
        };
        ()
    };
    if (match walkparams.sl0 {
      [bitone, _] => true,
      _ => false
    }) : bool | AArch32_S2InconsistentSL(walkparams) then {
        fault.statuscode = Fault_Translation;
        fault.level = 1;
        return((fault, __UNKNOWN_TTWState()))
    };
    let 'iasize = AArch32_S2IASize(walkparams.t0sz);
    let 'startlevel = AArch32_S2StartLevel(walkparams.sl0);
    let 'levels = FINAL_LEVEL - startlevel;
    let 'granulebits = TGxGranuleBits(walkparams.tgx);
    let 'stride = granulebits - 3;
    if not_bool(IsZero(VTTBR.bits[47 .. 40])) then {
        fault.statuscode = Fault_AddressSize;
        fault.level = 0;
        return((fault, __UNKNOWN_TTWState()))
    };
    baseaddress : FullAddress = undefined;
    let 'baselsb = iasize - (levels * stride + granulebits) + 3;
    baseaddress.paspace = PAS_NonSecure;
    assert(constraint((0 <= 'baselsb & 'baselsb <= 39)));
    baseaddress.address = ZeroExtend(VTTBR.bits[39 .. baselsb] @ Zeros(baselsb), 56);
    walkstate : TTWState = undefined;
    walkstate.baseaddress = baseaddress;
    walkstate.level = startlevel;
    walkstate.istable = true;
    walkstate.memattrs = WalkMemAttrs(walkparams.sh, walkparams.irgn, walkparams.orgn);
    indexmsb : int = iasize - 1;
    descriptor : bits(64) = undefined;
    let walkaccess : AccessDescriptor = CreateAccDescS2TTW(accdesc);
    walkaddress : AddressDescriptor = undefined;
    walkaddress.vaddress = ipa.vaddress;
    if HCR2_read()[CD] == 0b1 then {
        walkaddress.memattrs = NormalNCMemAttr();
        walkaddress.memattrs.xs = walkstate.memattrs.xs
    } else {
        walkaddress.memattrs = walkstate.memattrs
    };
    walkaddress.memattrs.shareability = EffectiveShareability(walkaddress.memattrs);
    indexlsb : int = undefined;
    desctype : DescriptorType = undefined;
    repeat {
        fault.level = walkstate.level;
        indexlsb = (FINAL_LEVEL - walkstate.level) * stride + granulebits;
        let index : bits(40) = let 'indexmsb = indexmsb in
          {
              let 'indexlsb = indexlsb;
              assert(constraint((0 <= 'indexlsb & 'indexlsb <= 'indexmsb & 'indexmsb < 56)));
              assert(constraint(40 >= 'indexmsb - 'indexlsb + 1 + 3));
              ZeroExtend(ipa.paddress.address[indexmsb .. indexlsb] @ 0b000, 40)
          };
        walkaddress.paddress.address = walkstate.baseaddress.address | ZeroExtend(index, 56);
        walkaddress.paddress.paspace = walkstate.baseaddress.paspace;
        let translation_info : TranslationInfo = struct {
            regime = Regime_EL10,
            vmid = None(),
            asid = None(),
            va = walkaddress.vaddress,
            s1level = s1level,
            s2info = Some((ZeroExtend(ipa.paddress.address, 64), walkstate.level)),
            s1params = None(),
            s2params = Some(walkparams),
            memattrs = walkaddress.memattrs
        };
        (fault, descriptor) = FetchDescriptor(walkparams.ee, walkaddress, walkaccess, fault, 64, translation_info);
        if fault.statuscode != Fault_None then {
            return((fault, __UNKNOWN_TTWState()))
        };
        desctype = AArch32_DecodeDescriptorTypeLD(descriptor, walkstate.level);
        match desctype {
          DescriptorType_Table => {
              if not_bool(IsZero(descriptor[47 .. 40])) then {
                  fault.statuscode = Fault_AddressSize;
                  return((fault, __UNKNOWN_TTWState()))
              };
              walkstate.baseaddress.address = ZeroExtend(descriptor[39 .. 12] @ Zeros(12), 56);
              walkstate.level = walkstate.level + 1;
              indexmsb = indexlsb - 1
          },
          DescriptorType_Invalid => {
              fault.statuscode = Fault_Translation;
              return((fault, __UNKNOWN_TTWState()))
          },
          DescriptorType_Leaf => {
              walkstate.istable = false
          }
        }
    } until desctype == DescriptorType_Leaf;
    let 'indexlsb = indexlsb;
    if not_bool(IsZero(descriptor[47 .. 40])) then {
        fault.statuscode = Fault_AddressSize;
        return((fault, __UNKNOWN_TTWState()))
    };
    if [descriptor[10]] == 0b0 then {
        fault.statuscode = Fault_AccessFlag;
        return((fault, __UNKNOWN_TTWState()))
    };
    assert(constraint((0 <= 'indexlsb & 'indexlsb <= 39)));
    walkstate.baseaddress.address = ZeroExtend(descriptor[39 .. indexlsb] @ Zeros(indexlsb), 56);
    walkstate.permissions.s2ap = descriptor[7 .. 6];
    walkstate.permissions.s2xn = [descriptor[54]];
    if HaveExtendedExecuteNeverExt() then {
        walkstate.permissions.s2xnx = [descriptor[53]]
    } else {
        walkstate.permissions.s2xnx = 0b0
    };
    let memattr : bits(4) = descriptor[5 .. 2];
    let sh : bits(2) = descriptor[9 .. 8];
    let s2aarch64 : bool = false;
    walkstate.memattrs = S2DecodeMemAttrs(memattr, sh, s2aarch64);
    walkstate.contiguous = [descriptor[52]];
    if __tlb_enabled then {
        tlbcontext.xs = walkstate.memattrs.xs;
        tlbcontext.level = walkstate.level;
        tlbrecord : TLBRecord = undefined;
        tlbrecord.context = tlbcontext;
        tlbrecord.walkstate = walkstate;
        tlbrecord.blocksize = TranslationSize(walkparams.d128, walkparams.tgx, walkstate.level);
        if walkstate.contiguous == 0b1 then {
            tlbrecord.contigsize = ContiguousSize(walkparams.d128, walkparams.tgx, walkstate.level)
        } else {
            tlbrecord.contigsize = 0
        };
        S2TLBCache(tlbrecord)
    };
    return((fault, walkstate))
}

val AArch32_S2Translate : forall ('aligned : Bool).
  (FaultRecord, AddressDescriptor, option(int), bool('aligned), AccessDescriptor) -> (FaultRecord, AddressDescriptor)

function AArch32_S2Translate (fault_in, ipa, s1level, aligned, accdesc) = {
    s1aarch64 : bool = undefined;
    fault : FaultRecord = fault_in;
    assert(IsZero(ipa.paddress.address[55 .. 40]));
    if not_bool(ELStateUsingAArch32(EL2, accdesc.ss == SS_Secure)) then {
        let s1aarch64 : bool = false;
        return(AArch64_S2Translate(fault, ipa, s1aarch64, None(), aligned, accdesc))
    };
    fault.statuscode = Fault_None;
    fault.secondstage = true;
    fault.s2fs1walk = accdesc.acctype == AccessType_TTW;
    fault.ipaddress = ipa.paddress;
    let walkparams : S2TTWParams = AArch32_GetS2TTWParams();
    if walkparams.vm == 0b0 then {
        return((fault, ipa))
    };
    if AArch32_IPAIsOutOfRange(walkparams, ipa.paddress.address[39 .. 0]) then {
        fault.statuscode = Fault_Translation;
        fault.level = 1;
        return((fault, __UNKNOWN_AddressDescriptor()))
    };
    walkstate : TTWState = undefined;
    (fault, walkstate) = AArch32_S2Walk(fault, walkparams, s1level, accdesc, ipa);
    if fault.statuscode != Fault_None then {
        return((fault, __UNKNOWN_AddressDescriptor()))
    };
    if AArch32_S2HasAlignmentFault(accdesc, aligned, walkstate.memattrs) then {
        fault.statuscode = Fault_Alignment
    } else if AArch32_S2HasPermissionsFault(walkparams, walkstate.permissions, walkstate.memattrs.memtype, accdesc) then {
        fault.statuscode = Fault_Permission
    } else ();
    s2_memattrs : MemoryAttributes = undefined;
    if (accdesc.acctype == AccessType_TTW & walkstate.memattrs.memtype == MemType_Device | accdesc.acctype == AccessType_IFETCH & (walkstate.memattrs.memtype == MemType_Device | HCR2_read()[ID] == 0b1)) | (accdesc.acctype != AccessType_IFETCH & walkstate.memattrs.memtype == MemType_Normal) & HCR2_read()[CD] == 0b1 then {
        s2_memattrs = NormalNCMemAttr();
        s2_memattrs.xs = walkstate.memattrs.xs
    } else {
        s2_memattrs = walkstate.memattrs
    };
    let s2aarch64 : bool = false;
    let memattrs : MemoryAttributes = S2CombineS1MemAttrs(ipa.memattrs, s2_memattrs, s2aarch64);
    let ipa_64 : bits(64) = ZeroExtend(ipa.paddress.address[39 .. 0], 64);
    let oa : FullAddress = StageOA(ipa_64, walkparams.d128, walkparams.tgx, walkstate);
    let pa : AddressDescriptor = CreateAddressDescriptor(ipa.vaddress, oa, memattrs);
    return((fault, pa))
}

val AArch32_S1WalkLD : (FaultRecord, Regime, S1TTWParams, AccessDescriptor, bits(32)) -> (FaultRecord, TTWState)

function AArch32_S1WalkLD (fault_in, regime, walkparams, accdesc, va) = {
    finalwalkstate : TTWState = undefined;
    s2aligned : bool = undefined;
    s2fault : FaultRecord = undefined;
    s2walkaddress : AddressDescriptor = undefined;
    fault : FaultRecord = fault_in;
    tlbcontext : TLBContext = undefined;
    if __tlb_enabled then {
        tlbcontext = AArch32_GetS1TLBContext(regime, accdesc.ss, va);
        let tlbentry : TLBLine = S1TLBLookup(tlbcontext);
        if tlbentry.valid_name then {
            let finalwalkstate : TTWState = tlbentry.tlbrecord.walkstate;
            fault.level = finalwalkstate.level;
            return((fault, finalwalkstate))
        };
        ()
    };
    txsz : bits(3) = undefined;
    ttbr : bits(64) = undefined;
    epd : bits(1) = undefined;
    varange : VARange = undefined;
    if regime == Regime_EL2 then {
        ttbr = HTTBR.bits;
        txsz = walkparams.t0sz;
        varange = VARange_LOWER
    } else {
        varange = AArch32_GetVARange(va, walkparams.t0sz, walkparams.t1sz);
        ttbr0 : bits(64) = undefined;
        ttbr1 : bits(64) = undefined;
        ttbcr : TTBCR_Type = undefined;
        if regime == Regime_EL30 then {
            ttbcr = TTBCR_S;
            ttbr0 = TTBR0_S.bits;
            ttbr1 = TTBR1_S.bits
        } else if HaveAArch32EL(EL3) then {
            ttbcr = TTBCR_NS_read();
            ttbr0 = TTBR0_NS.bits;
            ttbr1 = TTBR1_NS.bits
        } else {
            ttbcr = TTBCR_read();
            ttbr0 = TTBR0_read().bits;
            ttbr1 = TTBR1_read().bits
        };
        assert(ttbcr[EAE] == 0b1);
        if varange == VARange_LOWER then {
            txsz = walkparams.t0sz;
            ttbr = ttbr0;
            epd = ttbcr[EPD0]
        } else {
            txsz = walkparams.t1sz;
            ttbr = ttbr1;
            epd = ttbcr[EPD1]
        }
    };
    if regime != Regime_EL2 & epd == 0b1 then {
        fault.level = 1;
        fault.statuscode = Fault_Translation;
        return((fault, __UNKNOWN_TTWState()))
    };
    let 'iasize = AArch32_S1IASize(txsz);
    let 'granulebits = TGxGranuleBits(walkparams.tgx);
    let 'stride = granulebits - 3;
    let 'startlevel = FINAL_LEVEL - DIV(iasize - 1 - granulebits, stride);
    let 'levels = FINAL_LEVEL - startlevel;
    if not_bool(IsZero(ttbr[47 .. 40])) then {
        fault.statuscode = Fault_AddressSize;
        fault.level = 0;
        return((fault, __UNKNOWN_TTWState()))
    };
    baseaddress : FullAddress = undefined;
    let 'baselsb = iasize - (levels * stride + granulebits) + 3;
    baseaddress.paspace = if accdesc.ss == SS_Secure then PAS_Secure else
      PAS_NonSecure;
    assert(constraint((0 <= 'baselsb & 'baselsb <= 39)));
    baseaddress.address = ZeroExtend(ttbr[39 .. baselsb] @ Zeros(baselsb), 56);
    walkstate : TTWState = undefined;
    walkstate.baseaddress = baseaddress;
    walkstate.level = startlevel;
    walkstate.istable = true;
    walkstate.nG = if HasUnprivileged(regime) then 0b1 else 0b0;
    walkstate.memattrs = WalkMemAttrs(walkparams.sh, walkparams.irgn, walkparams.orgn);
    walkstate.permissions.ap_table = 0b00;
    walkstate.permissions.xn_table = 0b0;
    walkstate.permissions.pxn_table = 0b0;
    indexmsb : int = iasize - 1;
    descriptor : bits(64) = undefined;
    walkaddress : AddressDescriptor = undefined;
    walkaddress.vaddress = ZeroExtend(va, 64);
    if not_bool(AArch32_S1DCacheEnabled(regime)) then {
        walkaddress.memattrs = NormalNCMemAttr();
        walkaddress.memattrs.xs = walkstate.memattrs.xs
    } else {
        walkaddress.memattrs = walkstate.memattrs
    };
    if ((regime == Regime_EL10 & AArch32_EL2Enabled(accdesc.ss)) & (if ELStateUsingAArch32(EL2, accdesc.ss == SS_Secure) then
      HCR_read()[VM]
    else
      HCR_EL2[VM]) == 0b1) & not_bool(__IMPDEF_boolean("Apply effective shareability at stage 1")) then {
        walkaddress.memattrs.shareability = walkstate.memattrs.shareability
    } else {
        walkaddress.memattrs.shareability = EffectiveShareability(walkaddress.memattrs)
    };
    indexlsb : int = undefined;
    desctype : DescriptorType = undefined;
    repeat {
        fault.level = walkstate.level;
        indexlsb = (FINAL_LEVEL - walkstate.level) * stride + granulebits;
        let index : bits(40) = let 'indexmsb = indexmsb in
          {
              let 'indexlsb = indexlsb;
              assert(constraint((0 <= 'indexlsb & 'indexlsb <= 'indexmsb & 'indexmsb < 32)));
              ZeroExtend(va[indexmsb .. indexlsb] @ 0b000, 40)
          };
        walkaddress.paddress.address = walkstate.baseaddress.address | ZeroExtend(index, 56);
        walkaddress.paddress.paspace = walkstate.baseaddress.paspace;
        let toplevel : bool = walkstate.level == startlevel;
        let walkaccess : AccessDescriptor = CreateAccDescS1TTW(toplevel, varange, accdesc);
        let translation_info : TranslationInfo = struct {
            regime = regime,
            vmid = None(), // TODO: if regime == Regime_EL10 then Some(VMID_read()) else None(),
            asid = None(), // TODO
            va = walkaddress.vaddress,
            s1level = Some(walkstate.level),
            s2info = None(),
            s1params = Some(walkparams),
            s2params = None(),
            memattrs = walkaddress.memattrs
        };
        if regime == Regime_EL10 & AArch32_EL2Enabled(accdesc.ss) then {
            s2aligned = true;
            (s2fault, s2walkaddress) = AArch32_S2Translate(fault, walkaddress, Some(walkstate.level), s2aligned, walkaccess);
            if s2fault.statuscode != Fault_None then {
                return((s2fault, __UNKNOWN_TTWState()))
            };
            (fault, descriptor) = FetchDescriptor(walkparams.ee, s2walkaddress, walkaccess, fault, 64, translation_info)
        } else {
            (fault, descriptor) = FetchDescriptor(walkparams.ee, walkaddress, walkaccess, fault, 64, translation_info)
        };
        if fault.statuscode != Fault_None then {
            return((fault, __UNKNOWN_TTWState()))
        };
        desctype = AArch32_DecodeDescriptorTypeLD(descriptor, walkstate.level);
        match desctype {
          DescriptorType_Table => {
              if not_bool(IsZero(descriptor[47 .. 40])) then {
                  fault.statuscode = Fault_AddressSize;
                  return((fault, __UNKNOWN_TTWState()))
              };
              walkstate.baseaddress.address = ZeroExtend(descriptor[39 .. 12] @ Zeros(12), 56);
              if walkstate.baseaddress.paspace == PAS_Secure & [descriptor[63]] == 0b1 then {
                  walkstate.baseaddress.paspace = PAS_NonSecure
              };
              if walkparams.hpd == 0b0 then {
                  walkstate.permissions.xn_table = walkstate.permissions.xn_table | [descriptor[60]];
                  walkstate.permissions.ap_table = walkstate.permissions.ap_table | descriptor[62 .. 61];
                  walkstate.permissions.pxn_table = walkstate.permissions.pxn_table | [descriptor[59]]
              };
              walkstate.level = walkstate.level + 1;
              indexmsb = indexlsb - 1
          },
          DescriptorType_Invalid => {
              fault.statuscode = Fault_Translation;
              return((fault, __UNKNOWN_TTWState()))
          },
          DescriptorType_Leaf => {
              walkstate.istable = false
          }
        }
    } until desctype == DescriptorType_Leaf;
    let 'indexlsb = indexlsb;
    if not_bool(IsZero(descriptor[47 .. 40])) then {
        fault.statuscode = Fault_AddressSize;
        return((fault, __UNKNOWN_TTWState()))
    };
    if [descriptor[10]] == 0b0 then {
        fault.statuscode = Fault_AccessFlag;
        return((fault, __UNKNOWN_TTWState()))
    };
    walkstate.permissions.xn = [descriptor[54]];
    walkstate.permissions.pxn = [descriptor[53]];
    walkstate.permissions.ap = descriptor[7 .. 6] @ 0b1;
    walkstate.contiguous = [descriptor[52]];
    if regime == Regime_EL2 then {
        walkstate.nG = 0b0
    } else if accdesc.ss == SS_Secure & walkstate.baseaddress.paspace == PAS_NonSecure then {
        walkstate.nG = 0b1
    } else {
        walkstate.nG = [descriptor[11]]
    };
    assert(constraint((0 <= 'indexlsb & 'indexlsb <= 39)));
    walkstate.baseaddress.address = ZeroExtend(descriptor[39 .. indexlsb] @ Zeros(indexlsb), 56);
    if walkstate.baseaddress.paspace == PAS_Secure & [descriptor[5]] == 0b1 then {
        walkstate.baseaddress.paspace = PAS_NonSecure
    };
    let memattr : bits(3) = descriptor[4 .. 2];
    let sh : bits(2) = descriptor[9 .. 8];
    let attr : bits(8) = AArch32_MAIRAttr(UInt(memattr), walkparams.mair);
    let s1aarch64 : bool = false;
    walkstate.memattrs = S1DecodeMemAttrs(attr, sh, s1aarch64, walkparams);
    if __tlb_enabled then {
        tlbcontext.xs = walkstate.memattrs.xs;
        tlbcontext.level = walkstate.level;
        tlbcontext.nG = walkstate.nG;
        tlbrecord : TLBRecord = undefined;
        tlbrecord.context = tlbcontext;
        tlbrecord.walkstate = walkstate;
        tlbrecord.blocksize = TranslationSize(walkparams.d128, walkparams.tgx, walkstate.level);
        if walkstate.contiguous == 0b1 then {
            tlbrecord.contigsize = ContiguousSize(walkparams.d128, walkparams.tgx, walkstate.level)
        } else {
            tlbrecord.contigsize = 0
        };
        S1TLBCache(tlbrecord)
    };
    return((fault, walkstate))
}

val AArch32_VAIsOutOfRange : (Regime, S1TTWParams, bits(32)) -> bool

function AArch32_VAIsOutOfRange (regime, walkparams, va) = {
    iasize : int = undefined;
    lo_iasize : int = undefined;
    up_iasize : int = undefined;
    if regime == Regime_EL2 then {
        let 'iasize = AArch32_S1IASize(walkparams.t0sz);
        return(walkparams.t0sz != 0b000 & not_bool(is_zero_subrange(va, 31, iasize)))
    } else if walkparams.t1sz != 0b000 & walkparams.t0sz != 0b000 then {
        let 'lo_iasize = AArch32_S1IASize(walkparams.t0sz);
        let 'up_iasize = AArch32_S1IASize(walkparams.t1sz);
        return(not_bool(is_zero_subrange(va, 31, lo_iasize)) & not_bool(is_ones_subrange(va, 31, up_iasize)))
    } else {
        return(false)
    }
}

val AArch32_S1TranslateLD : forall ('aligned : Bool).
  (FaultRecord, Regime, bits(32), bool('aligned), AccessDescriptor) -> (FaultRecord, AddressDescriptor)

function AArch32_S1TranslateLD (fault_in, regime, va, aligned, accdesc) = {
    fault : FaultRecord = fault_in;
    if not_bool(AArch32_S1Enabled(regime, accdesc.ss)) then {
        return(AArch32_S1DisabledOutput(fault, regime, va, aligned, accdesc))
    };
    let walkparams : S1TTWParams = AArch32_GetS1TTWParams(regime, va);
    if AArch32_VAIsOutOfRange(regime, walkparams, va) then {
        fault.level = 1;
        fault.statuscode = Fault_Translation;
        return((fault, __UNKNOWN_AddressDescriptor()))
    };
    walkstate : TTWState = undefined;
    (fault, walkstate) = AArch32_S1WalkLD(fault, regime, walkparams, accdesc, va);
    if fault.statuscode != Fault_None then {
        return((fault, __UNKNOWN_AddressDescriptor()))
    };
    SetInGuardedPage(false);
    if AArch32_S1HasAlignmentFault(accdesc, aligned, walkparams.ntlsmd, walkstate.memattrs) then {
        fault.statuscode = Fault_Alignment
    } else if AArch32_S1LDHasPermissionsFault(regime, walkparams, walkstate.permissions, walkstate.memattrs.memtype, walkstate.baseaddress.paspace, accdesc) then {
        fault.statuscode = Fault_Permission
    } else ();
    if fault.statuscode != Fault_None then {
        return((fault, __UNKNOWN_AddressDescriptor()))
    };
    memattrs : MemoryAttributes = undefined;
    if accdesc.acctype == AccessType_IFETCH & (walkstate.memattrs.memtype == MemType_Device | not_bool(AArch32_S1ICacheEnabled(regime))) | (accdesc.acctype != AccessType_IFETCH & walkstate.memattrs.memtype == MemType_Normal) & not_bool(AArch32_S1DCacheEnabled(regime)) then {
        memattrs = NormalNCMemAttr();
        memattrs.xs = walkstate.memattrs.xs
    } else {
        memattrs = walkstate.memattrs
    };
    if ((regime == Regime_EL10 & AArch32_EL2Enabled(accdesc.ss)) & (if ELStateUsingAArch32(EL2, accdesc.ss == SS_Secure) then
      HCR_read()[VM]
    else
      HCR_EL2[VM]) == 0b1) & not_bool(__IMPDEF_boolean("Apply effective shareability at stage 1")) then {
        memattrs.shareability = walkstate.memattrs.shareability
    } else {
        memattrs.shareability = EffectiveShareability(memattrs)
    };
    let oa : FullAddress = StageOA(ZeroExtend(va, 64), walkparams.d128, walkparams.tgx, walkstate);
    let ipa : AddressDescriptor = CreateAddressDescriptor(ZeroExtend(va, 64), oa, memattrs);
    return((fault, ipa))
}

bitfield DACR32_EL2_Type : bits(64) =
  {
    D15 : 31..30,
    D14 : 29..28,
    D13 : 27..26,
    D12 : 25..24,
    D11 : 23..22,
    D10 : 21..20,
    D9 : 19..18,
    D8 : 17..16,
    D7 : 15..14,
    D6 : 13..12,
    D5 : 11..10,
    D4 : 9..8,
    D3 : 7..6,
    D2 : 5..4,
    D1 : 3..2,
    D0 : 1..0
  }

register DACR32_EL2 : DACR32_EL2_Type

bitfield DACR_Type : bits(32) =
  {
    D15 : 31..30,
    D14 : 29..28,
    D13 : 27..26,
    D12 : 25..24,
    D11 : 23..22,
    D10 : 21..20,
    D9 : 19..18,
    D8 : 17..16,
    D7 : 15..14,
    D6 : 13..12,
    D5 : 11..10,
    D4 : 9..8,
    D3 : 7..6,
    D2 : 5..4,
    D1 : 3..2,
    D0 : 1..0
  }

register _DACR_NS : DACR_Type

val DACR_NS_read : unit -> DACR_Type

function DACR_NS_read () = {
    r : DACR_Type = _DACR_NS;
    r.bits[31 .. 0] = Slice(DACR32_EL2.bits, 0, 32);
    return(r)
}

register DACR_S : DACR_Type

val DACR_read : unit -> DACR_Type

function DACR_read () = {
    r : DACR_Type = undefined;
    if ELUsingAArch32(EL3) & CurrentSecurityState() == SS_Secure then {
        r = DACR_S
    } else {
        r = DACR_NS_read()
    };
    return(r)
}

val AArch32_OutputDomain : (Regime, bits(4)) -> bits(2)

function AArch32_OutputDomain (regime, domain) = {
    Dn : bits(2) = undefined;
    let 'index = 2 * UInt(domain);
    if regime == Regime_EL30 then {
        Dn = DACR_S.bits[index + 1 .. index]
    } else if HaveAArch32EL(EL3) then {
        Dn = DACR_NS_read().bits[index + 1 .. index]
    } else {
        Dn = DACR_read().bits[index + 1 .. index]
    };
    if Dn == 0b10 then {
        let (_, __tup_1 : bits(2)) = ConstrainUnpredictableBits(Unpredictable_RESDACR, 2);
        Dn = __tup_1
    };
    return(Dn)
}

val AArch32_S1SDHasPermissionsFault : (Regime, Permissions, MemType, PASpace, AccessDescriptor) -> bool

function AArch32_S1SDHasPermissionsFault (regime, perms_in, memtype, paspace, accdesc) = {
    pan : bits(1) = undefined;
    r : bits(1) = undefined;
    w : bits(1) = undefined;
    x : bits(1) = undefined;
    perms : Permissions = perms_in;
    pr : bits(1) = undefined;
    pw : bits(1) = undefined;
    ur : bits(1) = undefined;
    uw : bits(1) = undefined;
    sctlr : SCTLR_Type = undefined;
    if regime == Regime_EL30 then {
        sctlr = SCTLR_S
    } else if HaveAArch32EL(EL3) then {
        sctlr = SCTLR_NS_read()
    } else {
        sctlr = SCTLR_read__2()
    };
    if sctlr[AFE] == 0b0 then {
        if perms.ap == 0b100 then {
            perms.ap = __IMPDEF_bits(3, "Reserved short descriptor AP encoding")
        };
        match perms.ap {
          0b000 => {
              (pr, pw, ur, uw) = (0b0, 0b0, 0b0, 0b0)
          },
          0b001 => {
              (pr, pw, ur, uw) = (0b1, 0b1, 0b0, 0b0)
          },
          0b010 => {
              (pr, pw, ur, uw) = (0b1, 0b1, 0b1, 0b0)
          },
          0b011 => {
              (pr, pw, ur, uw) = (0b1, 0b1, 0b1, 0b1)
          },
          0b101 => {
              (pr, pw, ur, uw) = (0b1, 0b0, 0b0, 0b0)
          },
          0b110 => {
              (pr, pw, ur, uw) = (0b1, 0b0, 0b1, 0b0)
          },
          0b111 => {
              (pr, pw, ur, uw) = (0b1, 0b0, 0b1, 0b0)
          },
          _ => ()
        }
    } else {
        match perms.ap[2 .. 1] {
          0b00 => {
              (pr, pw, ur, uw) = (0b1, 0b1, 0b0, 0b0)
          },
          0b01 => {
              (pr, pw, ur, uw) = (0b1, 0b1, 0b1, 0b1)
          },
          0b10 => {
              (pr, pw, ur, uw) = (0b1, 0b0, 0b0, 0b0)
          },
          0b11 => {
              (pr, pw, ur, uw) = (0b1, 0b0, 0b1, 0b0)
          },
          _ => ()
        }
    };
    let ux : bits(1) = ur & not_vec(perms.xn | uw & sctlr[WXN]);
    let px : bits(1) = pr & not_vec(((perms.xn | perms.pxn) | pw & sctlr[WXN]) | uw & sctlr[UWXN]);
    if HavePANExt() & accdesc.pan then {
        let pan : bits(1) = PSTATE.PAN & (ur | uw);
        pr = pr & not_vec(pan);
        pw = pw & not_vec(pan)
    };
    (r, w, x) = if accdesc.el == EL0 then (ur, uw, ux) else (pr, pw, px);
    if accdesc.ss == SS_Secure & paspace == PAS_NonSecure then {
        x = x & not_vec(if ELUsingAArch32(EL3) then SCR[SIF] else SCR_EL3[SIF])
    };
    let x = x;
    if accdesc.acctype == AccessType_IFETCH then {
        if memtype == MemType_Device & ConstrainUnpredictable(Unpredictable_INSTRDEVICE) == Constraint_FAULT then {
            return(true)
        } else {
            return(x == 0b0)
        }
    } else if accdesc.acctype == AccessType_IC | accdesc.acctype == AccessType_DC then {
        return(false)
    } else if accdesc.write then {
        return(w == 0b0)
    } else {
        return(r == 0b0)
    }
}

val AArch32_DecodeDescriptorTypeSD : forall 'level.
  (bits(32), int('level)) -> SDFType

function AArch32_DecodeDescriptorTypeSD (descriptor, level) = {
    if level == 1 & descriptor[1 .. 0] == 0b01 then {
        return(SDFType_Table)
    } else if level == 1 & ([descriptor[18]] @ [descriptor[1]]) == 0b01 then {
        return(SDFType_Section)
    } else if level == 1 & ([descriptor[18]] @ [descriptor[1]]) == 0b11 then {
        return(SDFType_Supersection)
    } else if level == 2 & descriptor[1 .. 0] == 0b01 then {
        return(SDFType_LargePage)
    } else if level == 2 & (match descriptor[1 .. 0] {
      [bitone, _] => true,
      _ => false
    }) : bool then {
        return(SDFType_SmallPage)
    } else {
        return(SDFType_Invalid)
    }
}

val __IMPDEF_MemoryAttributes : string -> MemoryAttributes

function __IMPDEF_MemoryAttributes x = {
    return(__UNKNOWN_MemoryAttributes())
}

val AArch32_DefaultTEXDecode : (bits(3), bits(1), bits(1), bits(1)) -> MemoryAttributes

function AArch32_DefaultTEXDecode (TEX_in, C_in, B_in, s) = {
    memattrs : MemoryAttributes = undefined;
    TEX : bits(3) = TEX_in;
    C : bits(1) = C_in;
    B : bits(1) = B_in;
    if (TEX == 0b001 & (C @ B) == 0b01 | TEX == 0b010 & (C @ B) != 0b00) | TEX == 0b011 then {
        texcb : bits(5) = undefined;
        let (_, __tup_1 : bits(5)) =
          ConstrainUnpredictableBits(Unpredictable_RESTEXCB, 5)
        in
          {
              texcb = __tup_1
          };
        TEX = texcb[4 .. 2];
        C = [texcb[1]];
        B = [texcb[0]]
    };
    match (TEX @ C) @ B {
      0b00000 => {
          memattrs.memtype = MemType_Device;
          memattrs.device = DeviceType_nGnRnE;
          memattrs.shareability = Shareability_OSH
      },
      0b00001 => {
          memattrs.memtype = MemType_Device;
          memattrs.device = DeviceType_nGnRE;
          memattrs.shareability = Shareability_OSH
      },
      0b01000 => {
          memattrs.memtype = MemType_Device;
          memattrs.device = DeviceType_nGnRE;
          memattrs.shareability = Shareability_OSH
      },
      0b00010 => {
          memattrs.memtype = MemType_Normal;
          memattrs.inner.attrs = MemAttr_WT;
          memattrs.inner.hints = MemHint_RA;
          memattrs.outer.attrs = MemAttr_WT;
          memattrs.outer.hints = MemHint_RA;
          memattrs.shareability = if s == 0b1 then Shareability_OSH else
            Shareability_NSH
      },
      0b00011 => {
          memattrs.memtype = MemType_Normal;
          memattrs.inner.attrs = MemAttr_WB;
          memattrs.inner.hints = MemHint_RA;
          memattrs.outer.attrs = MemAttr_WB;
          memattrs.outer.hints = MemHint_RA;
          memattrs.shareability = if s == 0b1 then Shareability_OSH else
            Shareability_NSH
      },
      0b00100 => {
          memattrs.memtype = MemType_Normal;
          memattrs.inner.attrs = MemAttr_NC;
          memattrs.outer.attrs = MemAttr_NC;
          memattrs.shareability = Shareability_OSH
      },
      0b00110 => {
          memattrs = __IMPDEF_MemoryAttributes("")
      },
      0b00111 => {
          memattrs.memtype = MemType_Normal;
          memattrs.inner.attrs = MemAttr_WB;
          memattrs.inner.hints = MemHint_RWA;
          memattrs.outer.attrs = MemAttr_WB;
          memattrs.outer.hints = MemHint_RWA;
          memattrs.shareability = if s == 0b1 then Shareability_OSH else
            Shareability_NSH
      },
      [bitone, _, _, _, _] => {
          memattrs.memtype = MemType_Normal;
          memattrs.inner = DecodeSDFAttr(C @ B);
          memattrs.outer = DecodeSDFAttr(TEX[1 .. 0]);
          if memattrs.inner.attrs == MemAttr_NC & memattrs.outer.attrs == MemAttr_NC then {
              memattrs.shareability = Shareability_OSH
          } else {
              memattrs.shareability = if s == 0b1 then Shareability_OSH else
                Shareability_NSH
          }
      },
      _ => {
          Unreachable()
      }
    };
    memattrs.inner.transient = false;
    memattrs.outer.transient = false;
    memattrs.tags = MemTag_Untagged;
    if memattrs.inner.attrs == MemAttr_WB & memattrs.outer.attrs == MemAttr_WB then {
        memattrs.xs = 0b0
    } else {
        memattrs.xs = 0b1
    };
    return(memattrs)
}

val AArch32_RemappedTEXDecode : (Regime, bits(3), bits(1), bits(1), bits(1)) -> MemoryAttributes

function AArch32_RemappedTEXDecode (regime, TEX, C, B, s) = {
    NOSm : bits(1) = undefined;
    NSn : bits(1) = undefined;
    memattrs : MemoryAttributes = undefined;
    prrr : PRRR_Type = undefined;
    nmrr : NMRR_Type = undefined;
    let 'region = UInt(([TEX[0]] @ C) @ B);
    if region == 6 then {
        return(__IMPDEF_MemoryAttributes(""))
    };
    if regime == Regime_EL30 then {
        prrr = PRRR_S;
        nmrr = NMRR_S
    } else if HaveAArch32EL(EL3) then {
        prrr = PRRR_NS_read();
        nmrr = NMRR_NS_read()
    } else {
        prrr = PRRR_read();
        nmrr = NMRR_read()
    };
    let 'base = 2 * region;
    attrfield : bits(0 + ('base + 1 - 'base + 1)) = prrr.bits[base + 1 .. base];
    if attrfield == 0b11 then {
        let (_, __tup_1 : bits(0 + ('base + 1 - 'base + 1))) = ConstrainUnpredictableBits(Unpredictable_RESPRRR, 2);
        attrfield = __tup_1
    };
    IRn : bits(0 + ('base + 1 - 'base + 1)) = undefined;
    ORn : bits(0 + ('base + 17 - ('base + 16) + 1)) = undefined;
    match attrfield {
      0b00 => {
          memattrs.memtype = MemType_Device;
          memattrs.device = DeviceType_nGnRnE;
          memattrs.shareability = Shareability_OSH
      },
      0b01 => {
          memattrs.memtype = MemType_Device;
          memattrs.device = DeviceType_nGnRE;
          memattrs.shareability = Shareability_OSH
      },
      0b10 => {
          let NSn : bits(1) = if s == 0b0 then prrr[NS0] else prrr[NS1];
          let NOSm : bits(1) = [prrr.bits[region + 24]] & NSn;
          let IRn : bits(0 + ('base + 1 - 'base + 1)) = nmrr.bits[base + 1 .. base];
          let ORn : bits(0 + ('base + 17 - ('base + 16) + 1)) = nmrr.bits[base + 17 .. base + 16];
          memattrs.memtype = MemType_Normal;
          memattrs.inner = DecodeSDFAttr(IRn);
          memattrs.outer = DecodeSDFAttr(ORn);
          if memattrs.inner.attrs == MemAttr_NC & memattrs.outer.attrs == MemAttr_NC then {
              memattrs.shareability = Shareability_OSH
          } else {
              let sh : bits(2) = NSn @ NOSm;
              memattrs.shareability = DecodeShareability(sh)
          }
      },
      0b11 => {
          Unreachable()
      },
      _ => ()
    };
    memattrs.inner.transient = false;
    memattrs.outer.transient = false;
    memattrs.tags = MemTag_Untagged;
    if memattrs.inner.attrs == MemAttr_WB & memattrs.outer.attrs == MemAttr_WB then {
        memattrs.xs = 0b0
    } else {
        memattrs.xs = 0b1
    };
    return(memattrs)
}

val AArch32_TranslationSizeSD : SDFType -> int

function AArch32_TranslationSizeSD sdftype = {
    tsize : {12, 16, 20, 24} = 12;
    match sdftype {
      SDFType_SmallPage => {
          tsize = 12
      },
      SDFType_LargePage => {
          tsize = 16
      },
      SDFType_Section => {
          tsize = 20
      },
      SDFType_Supersection => {
          tsize = 24
      },
      _ => ()
    };
    let 'tsize = tsize;
    return(tsize)
}

val RemapRegsHaveResetValues : unit -> bool

val AArch32_S1WalkSD : (FaultRecord, Regime, AccessDescriptor, bits(32)) -> (FaultRecord, TTWState)

function AArch32_S1WalkSD (fault_in, regime, accdesc, va) = {
    finalwalkstate : TTWState = undefined;
    s2aligned : bool = undefined;
    s2fault : FaultRecord = undefined;
    s2walkaddress : AddressDescriptor = undefined;
    fault : FaultRecord = fault_in;
    tlbcontext : TLBContext = undefined;
    if __tlb_enabled then {
        tlbcontext = AArch32_GetS1TLBContext(regime, accdesc.ss, va);
        let tlbentry : TLBLine = S1TLBLookup(tlbcontext);
        if tlbentry.valid_name then {
            let finalwalkstate : TTWState = tlbentry.tlbrecord.walkstate;
            fault.level = finalwalkstate.level;
            return((fault, finalwalkstate))
        };
        ()
    };
    sctlr : SCTLR_Type = undefined;
    ttbcr : TTBCR_Type = undefined;
    ttbr0 : TTBR0_Type = undefined;
    ttbr1 : TTBR1_Type = undefined;
    if regime == Regime_EL30 then {
        sctlr = SCTLR_S;
        ttbcr = TTBCR_S;
        ttbr0 = TTBR0_S;
        ttbr1 = TTBR1_S
    } else if HaveAArch32EL(EL3) then {
        sctlr = SCTLR_NS_read();
        ttbcr = TTBCR_NS_read();
        ttbr0 = TTBR0_NS;
        ttbr1 = TTBR1_NS
    } else {
        sctlr = SCTLR_read__2();
        ttbcr = TTBCR_read();
        ttbr0 = TTBR0_read();
        ttbr1 = TTBR1_read()
    };
    assert(ttbcr[EAE] == 0b0);
    let ee : bits(1) = sctlr[EE];
    let afe : bits(1) = sctlr[AFE];
    let tre : bits(1) = sctlr[TRE];
    n : range(0, 7) = UInt(ttbcr[N]);
    ttb : bits(32) = undefined;
    pd : bits(1) = undefined;
    irgn : bits(2) = undefined;
    rgn : bits(2) = undefined;
    s : bits(1) = undefined;
    nos : bits(1) = undefined;
    varange : VARange = undefined;
    if n == 0 | is_zero_subrange(va, 31, 32 - n) then {
        ttb = ttbr0[TTB0] @ Zeros(7);
        pd = ttbcr[PD0];
        irgn = ttbr0[IRGN];
        rgn = ttbr0[RGN];
        s = ttbr0[S];
        nos = ttbr0[NOS];
        varange = VARange_LOWER
    } else {
        n = 0;
        ttb = ttbr1[TTB1] @ Zeros(7);
        pd = ttbcr[PD1];
        irgn = ttbr1[IRGN];
        rgn = ttbr1[RGN];
        s = ttbr1[S];
        nos = ttbr1[NOS];
        varange = VARange_UPPER
    };
    let 'n = n;
    if pd == 0b1 then {
        fault.level = 1;
        fault.statuscode = Fault_Translation;
        return((fault, __UNKNOWN_TTWState()))
    };
    baseaddress : FullAddress = undefined;
    baseaddress.paspace = if accdesc.ss == SS_Secure then PAS_Secure else
      PAS_NonSecure;
    baseaddress.address = ZeroExtend(ttb[31 .. 14 - n] @ Zeros(14 - n), 56);
    let 'startlevel = 1;
    walkstate : TTWState = undefined;
    walkstate.baseaddress = baseaddress;
    walkstate.nG = 0b1;
    walkstate.memattrs = WalkMemAttrs(s @ nos, irgn, rgn);
    walkstate.level = startlevel;
    walkstate.istable = true;
    domain : bits(4) = undefined;
    descriptor : bits(32) = undefined;
    walkaddress : AddressDescriptor = undefined;
    walkaddress.vaddress = ZeroExtend(va, 64);
    if not_bool(AArch32_S1DCacheEnabled(regime)) then {
        walkaddress.memattrs = NormalNCMemAttr();
        walkaddress.memattrs.xs = walkstate.memattrs.xs
    } else {
        walkaddress.memattrs = walkstate.memattrs
    };
    if ((regime == Regime_EL10 & AArch32_EL2Enabled(accdesc.ss)) & (if ELStateUsingAArch32(EL2, accdesc.ss == SS_Secure) then
      HCR_read()[VM]
    else
      HCR_EL2[VM]) == 0b1) & not_bool(__IMPDEF_boolean("Apply effective shareability at stage 1")) then {
        walkaddress.memattrs.shareability = walkstate.memattrs.shareability
    } else {
        walkaddress.memattrs.shareability = EffectiveShareability(walkaddress.memattrs)
    };
    nG : bits(1) = undefined;
    ns : bits(1) = undefined;
    pxn : bits(1) = undefined;
    ap : bits(3) = undefined;
    tex : bits(3) = undefined;
    c : bits(1) = undefined;
    b : bits(1) = undefined;
    xn : bits(1) = undefined;
    repeat {
        fault.level = walkstate.level;
        index : bits(32) = undefined;
        if walkstate.level == 1 then {
            index = ZeroExtend(va[31 - n .. 20] @ 0b00, 32)
        } else {
            index = ZeroExtend(va[19 .. 12] @ 0b00, 32)
        };
        walkaddress.paddress.address = walkstate.baseaddress.address | ZeroExtend(index, 56);
        walkaddress.paddress.paspace = walkstate.baseaddress.paspace;
        let toplevel : bool = walkstate.level == startlevel;
        let walkaccess : AccessDescriptor = CreateAccDescS1TTW(toplevel, varange, accdesc);
        let translation_info : TranslationInfo = struct {
            regime = regime,
            vmid = None(), // TODO: if regime == Regime_EL10 then Some(VMID_read()) else None(),
            asid = None(), // TODO
            va = walkaddress.vaddress,
            s1level = Some(walkstate.level),
            s2info = None(),
            s1params = None(), // TODO: AArch32 doesn't use S1TTWParams?
            s2params = None(),
            memattrs = walkaddress.memattrs
        };
        if regime == Regime_EL10 & AArch32_EL2Enabled(accdesc.ss) then {
            s2aligned = true;
            (s2fault, s2walkaddress) = AArch32_S2Translate(fault, walkaddress, Some(walkstate.level), s2aligned, walkaccess);
            if s2fault.statuscode != Fault_None then {
                return((s2fault, __UNKNOWN_TTWState()))
            };
            (fault, descriptor) = FetchDescriptor(ee, s2walkaddress, walkaccess, fault, 32, translation_info)
        } else {
            (fault, descriptor) = FetchDescriptor(ee, walkaddress, walkaccess, fault, 32, translation_info)
        };
        if fault.statuscode != Fault_None then {
            return((fault, __UNKNOWN_TTWState()))
        };
        walkstate.sdftype = AArch32_DecodeDescriptorTypeSD(descriptor, walkstate.level);
        match walkstate.sdftype {
          SDFType_Invalid => {
              fault.domain = domain;
              fault.statuscode = Fault_Translation;
              return((fault, __UNKNOWN_TTWState()))
          },
          SDFType_Table => {
              domain = descriptor[8 .. 5];
              ns = [descriptor[3]];
              pxn = [descriptor[2]];
              walkstate.baseaddress.address = ZeroExtend(descriptor[31 .. 10] @ Zeros(10), 56);
              walkstate.level = 2
          },
          SDFType_SmallPage => {
              nG = [descriptor[11]];
              s = [descriptor[10]];
              ap = [descriptor[9]] @ descriptor[5 .. 4];
              tex = descriptor[8 .. 6];
              c = [descriptor[3]];
              b = [descriptor[2]];
              xn = [descriptor[0]];
              walkstate.baseaddress.address = ZeroExtend(descriptor[31 .. 12] @ Zeros(12), 56);
              walkstate.istable = false
          },
          SDFType_LargePage => {
              xn = [descriptor[15]];
              tex = descriptor[14 .. 12];
              nG = [descriptor[11]];
              s = [descriptor[10]];
              ap = [descriptor[9]] @ descriptor[5 .. 4];
              c = [descriptor[3]];
              b = [descriptor[2]];
              walkstate.baseaddress.address = ZeroExtend(descriptor[31 .. 16] @ Zeros(16), 56);
              walkstate.istable = false
          },
          SDFType_Section => {
              ns = [descriptor[19]];
              nG = [descriptor[17]];
              s = [descriptor[16]];
              ap = [descriptor[15]] @ descriptor[11 .. 10];
              tex = descriptor[14 .. 12];
              domain = descriptor[8 .. 5];
              xn = [descriptor[4]];
              c = [descriptor[3]];
              b = [descriptor[2]];
              pxn = [descriptor[0]];
              walkstate.baseaddress.address = ZeroExtend(descriptor[31 .. 20] @ Zeros(20), 56);
              walkstate.istable = false
          },
          SDFType_Supersection => {
              ns = [descriptor[19]];
              nG = [descriptor[17]];
              s = [descriptor[16]];
              ap = [descriptor[15]] @ descriptor[11 .. 10];
              tex = descriptor[14 .. 12];
              xn = [descriptor[4]];
              c = [descriptor[3]];
              b = [descriptor[2]];
              pxn = [descriptor[0]];
              domain = 0b0000;
              walkstate.baseaddress.address = ZeroExtend((descriptor[8 .. 5] @ (descriptor[23 .. 20] @ descriptor[31 .. 24])) @ Zeros(24), 56);
              walkstate.istable = false
          }
        }
    } until walkstate.sdftype != SDFType_Table;
    if afe == 0b1 & [ap[0]] == 0b0 then {
        fault.domain = domain;
        fault.statuscode = Fault_AccessFlag;
        return((fault, __UNKNOWN_TTWState()))
    };
    if tre == 0b1 then {
        walkstate.memattrs = AArch32_RemappedTEXDecode(regime, tex, c, b, s)
    } else if RemapRegsHaveResetValues() then {
        walkstate.memattrs = AArch32_DefaultTEXDecode(tex, c, b, s)
    } else {
        walkstate.memattrs = __IMPDEF_MemoryAttributes("")
    };
    walkstate.permissions.ap = ap;
    walkstate.permissions.xn = xn;
    walkstate.permissions.pxn = pxn;
    walkstate.domain = domain;
    walkstate.nG = nG;
    if accdesc.ss == SS_Secure & ns == 0b0 then {
        walkstate.baseaddress.paspace = PAS_Secure
    } else {
        walkstate.baseaddress.paspace = PAS_NonSecure
    };
    if __tlb_enabled then {
        tlbcontext.xs = walkstate.memattrs.xs;
        tlbcontext.nG = walkstate.nG;
        tlbrecord : TLBRecord = undefined;
        tlbrecord.context = tlbcontext;
        tlbrecord.walkstate = walkstate;
        tlbrecord.blocksize = AArch32_TranslationSizeSD(walkstate.sdftype);
        tlbrecord.contigsize = 0;
        S1TLBCache(tlbrecord)
    };
    return((fault, walkstate))
}

val AArch32_SDStageOA : (FullAddress, bits(32), SDFType) -> FullAddress

function AArch32_SDStageOA (baseaddress, va, sdftype) = {
    tsize : {12, 16, 20, 24} = 12;
    match sdftype {
      SDFType_SmallPage => {
          tsize = 12
      },
      SDFType_LargePage => {
          tsize = 16
      },
      SDFType_Section => {
          tsize = 20
      },
      SDFType_Supersection => {
          tsize = 24
      },
      _ => ()
    };
    let 'tsize = tsize;
    oa : FullAddress = undefined;
    oa.address = baseaddress.address[55 .. tsize] @ va[tsize - 1 .. 0];
    oa.paspace = baseaddress.paspace;
    return(oa)
}

val AArch32_S1TranslateSD : forall ('aligned : Bool).
  (FaultRecord, Regime, bits(32), bool('aligned), AccessDescriptor) -> (FaultRecord, AddressDescriptor, SDFType)

function AArch32_S1TranslateSD (fault_in, regime, va, aligned, accdesc) = {
    ipa : AddressDescriptor = undefined;
    fault : FaultRecord = fault_in;
    if not_bool(AArch32_S1Enabled(regime, accdesc.ss)) then {
        ipa : AddressDescriptor = undefined;
        (fault, ipa) = AArch32_S1DisabledOutput(fault, regime, va, aligned, accdesc);
        return((fault, ipa, __UNKNOWN_SDFType()))
    };
    walkstate : TTWState = undefined;
    (fault, walkstate) = AArch32_S1WalkSD(fault, regime, accdesc, va);
    if fault.statuscode != Fault_None then {
        return((fault, __UNKNOWN_AddressDescriptor(), __UNKNOWN_SDFType()))
    };
    let domain : bits(2) = AArch32_OutputDomain(regime, walkstate.domain);
    SetInGuardedPage(false);
    ntlsmd : bits(1) = undefined;
    if HaveTrapLoadStoreMultipleDeviceExt() then {
        match regime {
          Regime_EL30 => {
              ntlsmd = SCTLR_S[nTLSMD]
          },
          Regime_EL10 => {
              ntlsmd = if HaveAArch32EL(EL3) then SCTLR_NS_read()[nTLSMD] else
                SCTLR_read__2()[nTLSMD]
          },
          _ => ()
        }
    } else {
        ntlsmd = 0b1
    };
    if AArch32_S1HasAlignmentFault(accdesc, aligned, ntlsmd, walkstate.memattrs) then {
        fault.statuscode = Fault_Alignment
    } else if not_bool(accdesc.acctype == AccessType_IC | accdesc.acctype == AccessType_DC) & domain == Domain_NoAccess then {
        fault.statuscode = Fault_Domain
    } else if domain == Domain_Client then {
        if AArch32_S1SDHasPermissionsFault(regime, walkstate.permissions, walkstate.memattrs.memtype, walkstate.baseaddress.paspace, accdesc) then {
            fault.statuscode = Fault_Permission
        };
        ()
    } else ();
    if fault.statuscode != Fault_None then {
        fault.domain = walkstate.domain;
        return((fault, __UNKNOWN_AddressDescriptor(), walkstate.sdftype))
    };
    memattrs : MemoryAttributes = undefined;
    if accdesc.acctype == AccessType_IFETCH & (walkstate.memattrs.memtype == MemType_Device | not_bool(AArch32_S1ICacheEnabled(regime))) | (accdesc.acctype != AccessType_IFETCH & walkstate.memattrs.memtype == MemType_Normal) & not_bool(AArch32_S1DCacheEnabled(regime)) then {
        memattrs = NormalNCMemAttr();
        memattrs.xs = walkstate.memattrs.xs
    } else {
        memattrs = walkstate.memattrs
    };
    if ((regime == Regime_EL10 & AArch32_EL2Enabled(accdesc.ss)) & (if ELStateUsingAArch32(EL2, accdesc.ss == SS_Secure) then
      HCR_read()[VM]
    else
      HCR_EL2[VM]) == 0b1) & not_bool(__IMPDEF_boolean("Apply effective shareability at stage 1")) then {
        memattrs.shareability = walkstate.memattrs.shareability
    } else {
        memattrs.shareability = EffectiveShareability(memattrs)
    };
    let oa : FullAddress = AArch32_SDStageOA(walkstate.baseaddress, va, walkstate.sdftype);
    let ipa : AddressDescriptor = CreateAddressDescriptor(ZeroExtend(va, 64), oa, memattrs);
    return((fault, ipa, walkstate.sdftype))
}

val AArch64_PARFaultStatus : FaultRecord -> bits(6)

function AArch64_PARFaultStatus fault = {
    fst : bits(6) = undefined;
    if fault.statuscode == Fault_Domain then {
        assert(fault.level == 1 | fault.level == 2);
        fst[1 .. 0] = if fault.level == 1 then 0b01 else 0b10;
        fst[5 .. 2] = 0b1111
    } else {
        fst = EncodeLDFSC(fault.statuscode, fault.level)
    };
    return(fst)
}

val AArch64_isPARFormatD128 : forall ('is_ATS1Ex : Bool).
  (Regime, bool('is_ATS1Ex)) -> bool

function AArch64_isPARFormatD128 (regime, is_ATS1Ex) = {
    isPARFormatD128 : bool = undefined;
    if regime == Regime_EL2 | not_bool(Have128BitDescriptorExt()) then {
        isPARFormatD128 = false
    } else {
        isPARFormatD128 = false;
        match regime {
          Regime_EL3 => {
              isPARFormatD128 = TCR_EL3[D128] == 0b1
          },
          Regime_EL20 => {
              isPARFormatD128 = TCR2_EL2[D128] == 0b1
          },
          Regime_EL10 => {
              if (is_ATS1Ex | not_bool(EL2Enabled())) | (HCR_EL2[VM] @ HCR_EL2[DC]) == 0b00 then {
                  isPARFormatD128 = TCR2_EL1[D128] == 0b1
              } else {
                  isPARFormatD128 = VTCR_EL2[D128] == 0b1
              }
          },
          _ => ()
        }
    };
    return(isPARFormatD128)
}

bitfield PAR_Type : bits(64) =
  {
    ATTR : 63..56,
    PA : 39..12,
    LPAE : 11..11,
    NOS : 10..10,
    FSTAGE : 9..9,
    NS : 9..9,
    S2WLK : 8..8,
    SH : 8..7,
    FS : (6..6 @ 5..1),
    Inner : 6..4,
    Outer : 3..2,
    FST : 6..1,
    SS : 1..1,
    F : 0..0
  }

register PAR_NS : PAR_Type

register PAR_S : PAR_Type

val PAR_read : unit -> PAR_Type

function PAR_read () = {
    r : PAR_Type = undefined;
    if ELUsingAArch32(EL3) & CurrentSecurityState() == SS_Secure then {
        r = PAR_S
    } else {
        r = PAR_NS
    };
    return(r)
}

bitfield PAR_EL1_Type : bits(128) =
  {
    D128 : 64..64,
    ATTR : 63..56,
    DirtyBit : 15..15,
    Overlay : 14..14,
    TopLevel : 13..13,
    AssuredOnly : 12..12,
    NSE : 11..11,
    S : 9..9,
    NS : 9..9,
    PTW : 8..8,
    SH : 8..7,
    FST : 6..1,
    F : 0..0
  }

register _PAR_EL1 : PAR_EL1_Type

val PAR_EL1_read : unit -> PAR_EL1_Type

function PAR_EL1_read () = {
    r : PAR_EL1_Type = _PAR_EL1;
    r.bits[63 .. 0] = Slice(PAR_read().bits, 0, 64);
    return(r)
}

val PAR_write : PAR_Type -> unit

function PAR_write value_name = {
    let r : PAR_Type = value_name;
    if ELUsingAArch32(EL3) & CurrentSecurityState() == SS_Secure then {
        PAR_S = r
    } else {
        PAR_NS = r
    };
    return()
}

val PAR_EL1_write : PAR_EL1_Type -> unit

function PAR_EL1_write value_name = {
    let r : PAR_EL1_Type = value_name;
    PAR_write() = Mk_PAR_Type(SetSlice(64, PAR_read().bits, 0, Slice(r.bits, 0, 64)));
    _PAR_EL1 = r;
    return()
}

val __IMPDEF_bit : string -> bits(1)

function __IMPDEF_bit x = {
    return(__UNKNOWN_bit())
}

val AArch64_EncodePAR : forall ('is_ATS1Ex : Bool).
  (Regime, bool('is_ATS1Ex), AddressDescriptor) -> unit

function AArch64_EncodePAR (regime, is_ATS1Ex, addrdesc) = {
    PAR_EL1_write() = Mk_PAR_EL1_Type(Zeros(128));
    let paspace : PASpace = addrdesc.paddress.paspace;
    if AArch64_isPARFormatD128(regime, is_ATS1Ex) then {
        PAR_EL1_write() = [PAR_EL1_read() with D128 = 0b1]
    } else {
        PAR_EL1_write() = [PAR_EL1_read() with D128 = 0b0]
    };
    if not_bool(IsFault(addrdesc)) then {
        PAR_EL1_write() = [PAR_EL1_read() with F = 0b0];
        if HaveRME() then {
            if regime == Regime_EL3 then {
                match paspace {
                  PAS_Secure => {
                      {
                          __tmp : PAR_EL1_Type = PAR_EL1_read();
                          (__tmp[NSE] @ __tmp[NS]) = 0b00;
                          PAR_EL1_write() = __tmp
                      }
                  },
                  PAS_NonSecure => {
                      {
                          __tmp : PAR_EL1_Type = PAR_EL1_read();
                          (__tmp[NSE] @ __tmp[NS]) = 0b01;
                          PAR_EL1_write() = __tmp
                      }
                  },
                  PAS_Root => {
                      {
                          __tmp : PAR_EL1_Type = PAR_EL1_read();
                          (__tmp[NSE] @ __tmp[NS]) = 0b10;
                          PAR_EL1_write() = __tmp
                      }
                  },
                  PAS_Realm => {
                      {
                          __tmp : PAR_EL1_Type = PAR_EL1_read();
                          (__tmp[NSE] @ __tmp[NS]) = 0b11;
                          PAR_EL1_write() = __tmp
                      }
                  }
                }
            } else if SecurityStateForRegime(regime) == SS_Secure then {
                PAR_EL1_write() = [PAR_EL1_read() with NSE = __UNKNOWN_bit()];
                PAR_EL1_write() = [PAR_EL1_read() with NS = if paspace == PAS_Secure then
                  0b0
                else
                  0b1]
            } else if SecurityStateForRegime(regime) == SS_Realm then {
                if regime == Regime_EL10 & is_ATS1Ex then {
                    PAR_EL1_write() = [PAR_EL1_read() with NSE = __UNKNOWN_bit()];
                    PAR_EL1_write() = [PAR_EL1_read() with NS = __UNKNOWN_bit()]
                } else {
                    PAR_EL1_write() = [PAR_EL1_read() with NSE = __UNKNOWN_bit()];
                    PAR_EL1_write() = [PAR_EL1_read() with NS = if paspace == PAS_Realm then
                      0b0
                    else
                      0b1]
                }
            } else {
                PAR_EL1_write() = [PAR_EL1_read() with NSE = __UNKNOWN_bit()];
                PAR_EL1_write() = [PAR_EL1_read() with NS = __UNKNOWN_bit()]
            }
        } else {
            PAR_EL1_write() = Mk_PAR_EL1_Type([PAR_EL1_read().bits with 11 .. 11 = 0b1]);
            if SecurityStateForRegime(regime) == SS_Secure then {
                PAR_EL1_write() = [PAR_EL1_read() with NS = if paspace == PAS_Secure then
                  0b0
                else
                  0b1]
            } else {
                PAR_EL1_write() = [PAR_EL1_read() with NS = __UNKNOWN_bit()]
            }
        };
        PAR_EL1_write() = [PAR_EL1_read() with SH = ReportedPARShareability(PAREncodeShareability(addrdesc.memattrs))];
        if PAR_EL1_read()[D128] == 0b1 then {
            PAR_EL1_write() = Mk_PAR_EL1_Type([PAR_EL1_read().bits with 119 .. 76 = addrdesc.paddress.address[55 .. 12]])
        } else {
            PAR_EL1_write() = Mk_PAR_EL1_Type([PAR_EL1_read().bits with 55 .. 12 = addrdesc.paddress.address[55 .. 12]])
        };
        PAR_EL1_write() = [PAR_EL1_read() with ATTR = ReportedPARAttrs(EncodePARAttrs(addrdesc.memattrs))];
        PAR_EL1_write() = Mk_PAR_EL1_Type([PAR_EL1_read().bits with 10 .. 10 = __IMPDEF_bit("Non-Faulting PAR")])
    } else {
        PAR_EL1_write() = [PAR_EL1_read() with F = 0b1];
        PAR_EL1_write() = [PAR_EL1_read() with DirtyBit = if addrdesc.fault.dirtybit then
          0b1
        else
          0b0];
        PAR_EL1_write() = [PAR_EL1_read() with Overlay = if addrdesc.fault.overlay then
          0b1
        else
          0b0];
        PAR_EL1_write() = [PAR_EL1_read() with TopLevel = if addrdesc.fault.toplevel then
          0b1
        else
          0b0];
        PAR_EL1_write() = [PAR_EL1_read() with AssuredOnly = if addrdesc.fault.assuredonly then
          0b1
        else
          0b0];
        PAR_EL1_write() = [PAR_EL1_read() with FST = AArch64_PARFaultStatus(addrdesc.fault)];
        PAR_EL1_write() = [PAR_EL1_read() with PTW = if addrdesc.fault.s2fs1walk then
          0b1
        else
          0b0];
        PAR_EL1_write() = [PAR_EL1_read() with S = if addrdesc.fault.secondstage then
          0b1
        else
          0b0];
        PAR_EL1_write() = Mk_PAR_EL1_Type([PAR_EL1_read().bits with 11 .. 11 = 0b1]);
        PAR_EL1_write() = Mk_PAR_EL1_Type([PAR_EL1_read().bits with 63 .. 48 = __IMPDEF_bits(16, "Faulting PAR")])
    };
    return()
}

val AArch64_AT : (bits(64), TranslationStage, bits(2), ATAccess) -> unit

function AArch64_AT (address, stage_in, el_in, ataccess) = {
    stage : TranslationStage = stage_in;
    el : bits(2) = el_in;
    let effective_nse_ns : bits(2) = EffectiveSCR_EL3_NSE() @ EffectiveSCR_EL3_NS();
    if ((HaveRME() & PSTATE.EL == EL3) & effective_nse_ns == 0b10) & el != EL3 then {
        throw(Error_Undefined())
    };
    if ((HCR_EL2[E2H] @ HCR_EL2[TGE]) == 0b11 & el == EL1) & stage == TranslationStage_1 then {
        el = EL2
    };
    if (HaveEL(EL3) & stage == TranslationStage_12) & not_bool(EL2Enabled()) then {
        stage = TranslationStage_1
    };
    let write : bool = ataccess == ATAccess_WritePAN | ataccess == ATAccess_Write;
    let ss : SecurityState = SecurityStateAtEL(el);
    let pan : bool = ataccess == ATAccess_ReadPAN | ataccess == ATAccess_WritePAN;
    let accdesc : AccessDescriptor = CreateAccDescAT(ss, el, write, pan);
    let aligned : bool = true;
    fault : FaultRecord = NoFault__1(accdesc);
    regime : Regime = undefined;
    if stage == TranslationStage_12 then {
        regime = Regime_EL10
    } else {
        regime = TranslationRegime(el)
    };
    addrdesc : AddressDescriptor = undefined;
    if el == EL0 & ELUsingAArch32(EL1) | el != EL0 & ELUsingAArch32(el) then {
        if regime == Regime_EL2 | TTBCR_read()[EAE] == 0b1 then {
            (fault, addrdesc) = AArch32_S1TranslateLD(fault, regime, address[31 .. 0], aligned, accdesc)
        } else {
            let (__tup_0 : FaultRecord, __tup_1 : AddressDescriptor, _) = AArch32_S1TranslateSD(fault, regime, address[31 .. 0], aligned, accdesc);
            fault = __tup_0;
            addrdesc = __tup_1
        }
    } else {
        (fault, addrdesc) = AArch64_S1Translate(fault, regime, address, aligned, accdesc)
    };
    if stage == TranslationStage_12 & fault.statuscode == Fault_None then {
        s1aarch64 : bool = undefined;
        if (ELUsingAArch32(EL1) & regime == Regime_EL10) & EL2Enabled() then {
            addrdesc.vaddress = ZeroExtend(address, 64);
            (fault, addrdesc) = AArch32_S2Translate(fault, addrdesc, None(), aligned, accdesc)
        } else if regime == Regime_EL10 & EL2Enabled() then {
            let s1aarch64 : bool = true;
            (fault, addrdesc) = AArch64_S2Translate(fault, addrdesc, s1aarch64, None(), aligned, accdesc)
        } else ()
    };
    let is_ATS1Ex : bool = stage != TranslationStage_12;
    if fault.statuscode != Fault_None then {
        addrdesc = CreateFaultyAddressDescriptor(address, fault);
        if (IsExternalAbort__1(fault) | PSTATE.EL == EL1 & fault.s2fs1walk) | (HaveRME() & fault.gpcf.gpf != GPCF_None) & (ReportAsGPCException(fault) | ((HCR_EL2[GPF] == 0b1 & PSTATE.EL == EL1) & (el == EL1 | el == EL0)) & is_ATS1Ex) then {
            PAR_EL1_write() = Mk_PAR_EL1_Type(__UNKNOWN_bits(128));
            AArch64_Abort(address, addrdesc.fault)
        };
        ()
    };
    let addrdesc = addrdesc;
    AArch64_EncodePAR(regime, is_ATS1Ex, addrdesc);
    return()
}

bitfield CTILSR_Type : bits(32) = {nTT : 2..2, SLK : 1..1, SLI : 0..0}

register CTILSR : CTILSR_Type

bitfield EDLSR_Type : bits(32) = {nTT : 2..2, SLK : 1..1, SLI : 0..0}

register EDLSR : EDLSR_Type

bitfield PMLSR_Type : bits(32) = {nTT : 2..2, SLK : 1..1, SLI : 0..0}

register PMLSR : PMLSR_Type

type DBGDTRRX_EL0_Type = bits(64)

register DBGDTRRX_EL0 : DBGDTRRX_EL0_Type

type DBGDTRTX_EL0_Type = bits(64)

register DBGDTRTX_EL0 : DBGDTRTX_EL0_Type

bitfield DBGDTR_EL0_Type : bits(64) = {HighWord : 63..32, LowWord : 31..0}

register _DBGDTR_EL0 : DBGDTR_EL0_Type

val DBGDTR_EL0_read__1 : unit -> DBGDTR_EL0_Type

function DBGDTR_EL0_read__1 () = {
    r : DBGDTR_EL0_Type = _DBGDTR_EL0;
    if __IMPDEF_boolean("read") then {
        r.bits[63 .. 32] = Slice(DBGDTRTX_EL0, 0, 32)
    } else {
        if __IMPDEF_boolean("read") then {
            r.bits[63 .. 32] = Slice(DBGDTRTX_EL0, 0, 32)
        } else {
            r.bits[63 .. 32] = Slice(DBGDTRRX_EL0, 0, 32)
        }
    };
    if __IMPDEF_boolean("read") then {
        r.bits[31 .. 0] = Slice(DBGDTRRX_EL0, 0, 32)
    } else {
        if __IMPDEF_boolean("read") then {
            r.bits[31 .. 0] = Slice(DBGDTRRX_EL0, 0, 32)
        } else {
            r.bits[31 .. 0] = Slice(DBGDTRTX_EL0, 0, 32)
        }
    };
    return(r)
}

bitfield EDPRSR_Type : bits(32) =
  {
    EPMADE : 16..16,
    EDADE : 14..14,
    SDR : 11..11,
    SPMAD : 10..10,
    EPMAD : 9..9,
    SDAD : 8..8,
    EDAD : 7..7,
    DLK : 6..6,
    OSLK : 5..5,
    HALTED : 4..4,
    SR : 3..3,
    R : 2..2,
    SPD : 1..1,
    PU : 0..0
  }

register EDPRSR : EDPRSR_Type

val ExecuteA64 : bits(32) -> unit

val ExecuteT32__1 : bits(32) -> unit

bitfield DBGDCCINT_Type : bits(32) = {RX : 30..30, TX : 29..29}

bitfield MDCCINT_EL1_Type : bits(64) = {RX : 30..30, TX : 29..29}

register MDCCINT_EL1 : MDCCINT_EL1_Type

register _DBGDCCINT : DBGDCCINT_Type

val DBGDCCINT_read : unit -> DBGDCCINT_Type

function DBGDCCINT_read () = {
    r : DBGDCCINT_Type = _DBGDCCINT;
    r.bits[31 .. 0] = Slice(MDCCINT_EL1.bits, 0, 32);
    return(r)
}

val LR_write : bits(32) -> unit

function LR_write value_name = {
    R_set(14) = value_name;
    return()
}

val DCPSInstruction : bits(2) -> unit

function DCPSInstruction target_el = {
    from_32 : bool = undefined;
    SynchronizeContext();
    handle_el : bits(2) = undefined;
    match target_el {
      ? if ? == EL1 => {
          if PSTATE.EL == EL2 | PSTATE.EL == EL3 & not_bool(UsingAArch32()) then {
              handle_el = PSTATE.EL
          } else if EL2Enabled() & HCR_EL2[TGE] == 0b1 then {
              throw(Error_Undefined())
          } else {
              handle_el = EL1
          }
      },
      ? if ? == EL2 => {
          if not_bool(HaveEL(EL2)) then {
              throw(Error_Undefined())
          } else if PSTATE.EL == EL3 & not_bool(UsingAArch32()) then {
              handle_el = EL3
          } else if not_bool(IsSecureEL2Enabled()) & CurrentSecurityState() == SS_Secure then {
              throw(Error_Undefined())
          } else {
              handle_el = EL2
          }
      },
      ? if ? == EL3 => {
          if EDSCR_read()[SDD] == 0b1 | not_bool(HaveEL(EL3)) then {
              throw(Error_Undefined())
          } else {
              handle_el = EL3
          }
      },
      _ => {
          Unreachable()
      }
    };
    let from_secure : bool = CurrentSecurityState() == SS_Secure;
    if ELUsingAArch32(handle_el) then {
        if PSTATE.M == M32_Monitor then {
            SCR[NS] = 0b0
        };
        assert(UsingAArch32());
        match handle_el {
          ? if ? == EL1 => {
              AArch32_WriteMode(M32_Svc);
              if HavePANExt() & SCTLR_read__2()[SPAN] == 0b0 then {
                  PSTATE.PAN = 0b1
              };
              ()
          },
          ? if ? == EL2 => {
              AArch32_WriteMode(M32_Hyp)
          },
          ? if ? == EL3 => {
              AArch32_WriteMode(M32_Monitor);
              if HavePANExt() then {
                  if not_bool(from_secure) then {
                      PSTATE.PAN = 0b0
                  } else if SCTLR_read__2()[SPAN] == 0b0 then {
                      PSTATE.PAN = 0b1
                  } else ()
              };
              ()
          },
          _ => ()
        };
        if handle_el == EL2 then {
            ELR_hyp_write() = __UNKNOWN_bits(32);
            HSR_write() = Mk_HSR_Type(__UNKNOWN_bits(32))
        } else {
            LR_write() = __UNKNOWN_bits(32)
        };
        SPSR_set(32) = __UNKNOWN_bits(32);
        PSTATE.E = SCTLR_read__1()[EE];
        DLR_write() = __UNKNOWN_bits(32);
        DSPSR_write() = Mk_DSPSR_Type(__UNKNOWN_bits(32))
    } else {
        let from_32 : bool = UsingAArch32();
        if from_32 then {
            AArch64_MaybeZeroRegisterUppers()
        };
        if (from_32 & HaveSME()) & PSTATE.SM == 0b1 then {
            ResetSVEState()
        } else {
            MaybeZeroSVEUppers(target_el)
        };
        PSTATE.nRW = 0b0;
        PSTATE.SP = 0b1;
        PSTATE.EL = handle_el;
        if HavePANExt() & (handle_el == EL1 & SCTLR_EL1[SPAN] == 0b0 | ((handle_el == EL2 & HCR_EL2[E2H] == 0b1) & HCR_EL2[TGE] == 0b1) & SCTLR_EL2[SPAN] == 0b0) then {
            PSTATE.PAN = 0b1
        };
        ELR_set__1() = __UNKNOWN_bits(64);
        SPSR_set(64) = __UNKNOWN_bits(64);
        ESR_set__1() = Mk_ESRType(__UNKNOWN_bits(64));
        DLR_EL0 = __UNKNOWN_bits(64);
        DSPSR_EL0 = Mk_DSPSR_EL0_Type(__UNKNOWN_bits(64));
        if HaveUAOExt() then {
            PSTATE.UAO = 0b0
        };
        if HaveMTEExt() then {
            PSTATE.TCO = 0b1
        };
        if HaveGCS() then {
            PSTATE.EXLOCK = 0b0
        };
        ()
    };
    UpdateEDSCRFields();
    sync_errors : bool = HaveIESB() & SCTLR_read__1()[IESB] == 0b1;
    if HaveDoubleFaultExt() & not_bool(UsingAArch32()) then {
        sync_errors = sync_errors | (EffectiveEA() == 0b1 & SCR_EL3[NMEA] == 0b1) & PSTATE.EL == EL3
    };
    if not_bool(ConstrainUnpredictableBool(Unpredictable_IESBinDebug)) then {
        sync_errors = false
    };
    if sync_errors then {
        SynchronizeErrors()
    };
    return()
}

val DebugRestorePSR : unit -> unit

function DebugRestorePSR () = {
    if UsingAArch32() then {
        let spsr : bits(32) = SPSR_read(32);
        SetPSTATEFromPSR(spsr);
        (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V @ PSTATE.Q @ PSTATE.GE @ PSTATE.SS @ PSTATE.A @ PSTATE.I @ PSTATE.F) = __UNKNOWN_bits(13);
        PSTATE.IT = 0b00000000;
        PSTATE.T = 0b1;
        DLR_write() = __UNKNOWN_bits(32);
        DSPSR_write() = Mk_DSPSR_Type(__UNKNOWN_bits(32))
    } else {
        let spsr : bits(64) = SPSR_read(64);
        SetPSTATEFromPSR(spsr);
        (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V @ PSTATE.SS @ PSTATE.D @ PSTATE.A @ PSTATE.I @ PSTATE.F) = __UNKNOWN_bits(9);
        DLR_EL0 = __UNKNOWN_bits(64);
        DSPSR_EL0 = Mk_DSPSR_EL0_Type(__UNKNOWN_bits(64))
    };
    UpdateEDSCRFields()
}

val DRPSInstruction : unit -> unit

function DRPSInstruction () = {
    SynchronizeContext();
    sync_errors : bool = HaveIESB() & SCTLR_read__1()[IESB] == 0b1;
    if HaveDoubleFaultExt() & not_bool(UsingAArch32()) then {
        sync_errors = sync_errors | (EffectiveEA() == 0b1 & SCR_EL3[NMEA] == 0b1) & PSTATE.EL == EL3
    };
    if not_bool(ConstrainUnpredictableBool(Unpredictable_IESBinDebug)) then {
        sync_errors = false
    };
    if sync_errors then {
        SynchronizeErrors()
    };
    DebugRestorePSR();
    return()
}

val DLR_read : unit -> DLR_Type

function DLR_read () = {
    r : DLR_Type = _DLR;
    r[31 .. 0] = Slice(DLR_EL0, 0, 32);
    return(r)
}

val DSPSR_read : unit -> DSPSR_Type

function DSPSR_read () = {
    r : DSPSR_Type = _DSPSR;
    r.bits[31 .. 0] = Slice(DSPSR_EL0.bits, 0, 32);
    return(r)
}

val DSPSR2_read : unit -> DSPSR2_Type

function DSPSR2_read () = {
    r : DSPSR2_Type = _DSPSR2;
    r.bits[31 .. 0] = Slice(DSPSR_EL0.bits, 32, 32);
    return(r)
}

val CheckPendingResetCatch : unit -> unit

function CheckPendingResetCatch () = {
    if HaltingAllowed() & EDESR[RC] == 0b1 then {
        let is_async : bool = true;
        Halt__1(DebugHalt_ResetCatch, is_async)
    };
    ()
}

bitfield CTIDEVCTL_Type : bits(32) = {RCE : 1..1, OSUCE : 0..0}

register CTIDEVCTL : CTIDEVCTL_Type

val CheckResetCatch : unit -> unit

function CheckResetCatch () = {
    if HaveDoPD() & CTIDEVCTL[RCE] == 0b1 | not_bool(HaveDoPD()) & EDECR[RCE] == 0b1 then {
        EDESR[RC] = 0b1;
        if HaltingAllowed() then {
            Halt(DebugHalt_ResetCatch)
        };
        ()
    };
    ()
}

val CheckPendingOSUnlockCatch : unit -> unit

function CheckPendingOSUnlockCatch () = {
    if HaltingAllowed() & EDESR[OSUC] == 0b1 then {
        let is_async : bool = true;
        Halt__1(DebugHalt_OSUnlockCatch, is_async)
    };
    ()
}

val CheckOSUnlockCatch : unit -> unit

function CheckOSUnlockCatch () = {
    if HaveDoPD() & CTIDEVCTL[OSUCE] == 0b1 | not_bool(HaveDoPD()) & EDECR[OSUCE] == 0b1 then {
        if not_bool(Halted()) then {
            EDESR[OSUC] = 0b1
        };
        ()
    };
    ()
}

val CheckPendingExceptionCatch : forall ('is_async : Bool).
  bool('is_async) -> unit

function CheckPendingExceptionCatch is_async = {
    if (Havev8p8Debug() & HaltingAllowed()) & EDESR[EC] == 0b1 then {
        Halt__1(DebugHalt_ExceptionCatch, is_async)
    };
    ()
}

val CheckSoftwareStep : unit -> unit

function CheckSoftwareStep () = {
    let step_enabled : bool = (not_bool(ELUsingAArch32(DebugTarget())) & AArch64_GenerateDebugExceptions()) & MDSCR_EL1[SS] == 0b1;
    if step_enabled & PSTATE.SS == 0b1 then {
        __InstructionStep = true
    };
    if not_bool(step_enabled) then {
        __InstructionStep = false
    };
    if step_enabled & PSTATE.SS == 0b0 then {
        AArch64_SoftwareStepException()
    };
    ()
}

bitfield EDVIDSR_Type : bits(32) =
  {
    NS : 31..31,
    E2 : 30..30,
    E3 : 29..29,
    HV : 28..28,
    VMID : (15..8 @ 7..0),
    CONTEXTIDR_EL2 : 31..0
  }

register EDVIDSR : EDVIDSR_Type

bitfield PMPCSR_Type : bits(64) =
  {
    NS : 63..63,
    EL : 62..61,
    T : 60..60,
    NSE : 59..59,
    PCSample : (55..32 @ 31..0)
  }

register PMPCSR : PMPCSR_Type

bitfield PMVIDSR_Type : bits(32) = {VMID : (15..8 @ 7..0)}

register PMVIDSR : PMVIDSR_Type

bitfield HTRFCR_Type : bits(32) =
  {TS : 6..5, CX : 3..3, E2TRE : 1..1, E0HTRE : 0..0}

bitfield TRFCR_EL2_Type : bits(64) =
  {TS : 6..5, CX : 3..3, E2TRE : 1..1, E0HTRE : 0..0}

register TRFCR_EL2 : TRFCR_EL2_Type

register _HTRFCR : HTRFCR_Type

val HTRFCR_read : unit -> HTRFCR_Type

function HTRFCR_read () = {
    r : HTRFCR_Type = _HTRFCR;
    r.bits[31 .. 0] = Slice(TRFCR_EL2.bits, 0, 32);
    return(r)
}

bitfield TRFCR_EL1_Type : bits(64) = {TS : 6..5, E1TRE : 1..1, E0TRE : 0..0}

register TRFCR_EL1 : TRFCR_EL1_Type

bitfield TRFCR_Type : bits(32) = {TS : 6..5, E1TRE : 1..1, E0TRE : 0..0}

register _TRFCR : TRFCR_Type

val TRFCR_read : unit -> TRFCR_Type

function TRFCR_read () = {
    r : TRFCR_Type = _TRFCR;
    r.bits[31 .. 0] = Slice(TRFCR_EL1.bits, 0, 32);
    return(r)
}

val TraceSynchronizationBarrier : unit -> unit

function TraceSynchronizationBarrier () = {
    return()
}

val AArch32_ReportedInnerAttrs : bits(3) -> bits(3)

val AArch32_ReportedOuterAttrs : bits(2) -> bits(2)

val AArch64_CheckNVCondsIfCurrentEL : forall 'crm 'crn 'op0 'op1 'op2.
  (int('op0), int('op1), int('crn), int('crm), int('op2)) -> bool

val DC_CIPAPA : bits(64) -> unit

val DC_CIGDPAPA : bits(64) -> unit

val BPIALLIS : unit -> unit

val BPIALL : unit -> unit

val BPIMVA : bits(32) -> unit

val CP15DMB : unit -> unit

val CP15DSB : unit -> unit

val CP15ISB : unit -> unit

val UnallocatedA32_Instruction : bits(32) -> unit

val UnallocatedT32_32_Instruction : bits(32) -> unit

val UnallocatedT32_16_Instruction : bits(16) -> unit

val AArch64_PendingUnmaskedPhysicalInterrupts : bits(3) -> (bool, bool, bool)

val AArch64_PendingUnmaskedVirtualInterrupts : bits(3) -> (bool, bool, bool)

val AArch32_PendingUnmaskedPhysicalInterrupts : unit -> (bool, bool, bool)

val AArch32_PendingUnmaskedVirtualInterrupts : unit -> (bool, bool, bool)

val TakePendingInterrupts : InterruptReq -> bool

val __UpdateSystemCounter : unit -> unit

register __CTIBase : bits(56) = UInt(0x22020000)[56 - 1 .. 0]

register __CNTControlBase : bits(56) = UInt(0x16200000)[56 - 1 .. 0]

register __ExtDebugBase : bits(56) = UInt(0x22010000)[56 - 1 .. 0]

register __GICCPUInterfaceBase : bits(56) = UInt(0x13082000)[56 - 1 .. 0]

register __GICDistBase : bits(56) = UInt(0x2c010000)[56 - 1 .. 0]

register __GICITSControlBase : bits(56) = UInt(0x2c120000)[56 - 1 .. 0]

register __PMUBase : bits(56) = UInt(0x22030000)[56 - 1 .. 0]

val ExecuteA32 : bits(32) -> unit

val ExecuteT16 : bits(16) -> unit

val __SetThisInstrDetails : (__InstrEnc, bits(32), bits(4)) -> unit

val __FetchInstr : bits(64) -> (__InstrEnc, bits(32))

val __DefaultCond : __InstrEnc -> bits(4)

val __DecodeExecute : (__InstrEnc, bits(32)) -> unit

val __InstructionExecute : unit -> unit

val __TopLevel : unit -> unit

val __CycleEnd : unit -> unit

register __syncAbortOnReadNormCache : bool = true

register __syncAbortOnReadNormNonCache : bool = true

register __syncAbortOnDeviceRead : bool = true

register __syncAbortOnSoRead : bool = true

register __syncAbortOnSoWrite : bool = true

register __syncAbortOnPrefetch : bool = true

register __syncAbortOnTTWCache : bool = true

register __syncAbortOnTTWNonCache : bool = true

register __syncAbortOnWriteNormCache : bool = false

register __syncAbortOnWriteNormNonCache : bool = false

register __syncAbortOnDeviceWrite : bool = false

val SetResetVector : bits(64) -> unit

val EncodePARange : unit -> bits(4)

val EncodeVARange : unit -> bits(4)

val ResetControlRegisters : forall ('cold : Bool). bool('cold) -> unit

val AArch32_ResetControlRegisters : forall ('cold_reset : Bool).
  bool('cold_reset) -> unit

val TakeReset : forall ('cold : Bool). bool('cold) -> unit

val AArch64_IMPDEFResets : unit -> unit

val AArch32_IMPDEFResets : unit -> unit

val AArch64_SetLSInstructionSyndrome : forall 'Rt ('acq_rel : Bool) ('sign_extend : Bool) ('sixty_four : Bool) 'size.
  (int('size), bool('sign_extend), int('Rt), bool('sixty_four), bool('acq_rel)) -> unit

val AArch32_SetLSInstructionSyndrome : forall 'Rt ('acq_rel : Bool) ('sign_extend : Bool) 'size.
  (int('size), bool('sign_extend), int('Rt), bool('acq_rel)) -> unit

val SetIss2 : bits(5) -> unit

val SetLoadStoreType : bits(2) -> unit

val Hint_PreloadDataForWrite : bits(32) -> unit

val Hint_PreloadData : bits(32) -> unit

val Hint_PreloadInstr : bits(32) -> unit

val AArch32_MarkExclusiveVA : forall 'processorid 'size.
  (bits(32), int('processorid), int('size)) -> unit

val AArch32_IsExclusiveVA : forall 'processorid 'size.
  (bits(32), int('processorid), int('size)) -> bool

register __supported_va_size : int = 56

register __unpred_tsize_aborts : bool = true

register __dczid_log2_block_size : int = UInt(0x8)

register __gmid_log2_block_size : int = UInt(0x4)

register __num_ctx_breakpoints : int = NUM_BREAKPOINTS

register __ignore_rvbar_in_aarch32 : bool = false

register __trickbox_enabled : bool = false

register __mops_forward_copy : bool = true

register __CNTbase_frequency : bits(32) = 0x05F5E100

register __DBG_ROM_ADDR : bits(56) = UInt(0x22000000)[56 - 1 .. 0]

register __exclusive_granule_size : bits(4) = 0b0100

register __mpam_has_altsp : bool = true

register CFG_RMR_AA64 : bits(1) = 0b1

register ZCR_EL3_LEN_VALUE : int = negate(1)

register CPTR_EL3_EZ_VALUE : int = negate(1)

register CPTR_EL3_ESM_VALUE : int = negate(1)

register SMCR_EL3_LEN_VALUE : int = negate(1)

register __rme_l0gptsz : bits(4) = Zeros(4)

register __has_spe_pseudo_cycles : bool = false

register HEAP_BASE : bits(64) = ZeroExtend(0x00000000, 64)

register HEAP_LIMIT : bits(64) = ZeroExtend(0x0f000000, 64)

register STACK_BASE : bits(64) = ZeroExtend(0x10000000, 64)

register STACK_LIMIT : bits(64) = ZeroExtend(0x0f000000, 64)

register __mecid_width : bits(4) = 0x0

register CFG_MPIDR : bits(32) = 0x80000000

val __ConfigureV81 : forall ('enabled : Bool). bool('enabled) -> unit

function __ConfigureV81 enabled = {
    v8Ap1_IMPLEMENTED = enabled
}

val __ConfigureV82 : forall ('enabled : Bool). bool('enabled) -> unit

function __ConfigureV82 enabled = {
    v8Ap2_IMPLEMENTED = enabled;
    if enabled then {
        __ConfigureV81(enabled)
    };
    ()
}

val __ConfigureV83 : forall ('enabled : Bool). bool('enabled) -> unit

function __ConfigureV83 enabled = {
    v8Ap3_IMPLEMENTED = enabled;
    if enabled then {
        __ConfigureV82(enabled)
    };
    ()
}

val __ConfigureV84 : forall ('enabled : Bool). bool('enabled) -> unit

function __ConfigureV84 enabled = {
    v8Ap4_IMPLEMENTED = enabled;
    if enabled then {
        __ConfigureV83(enabled)
    };
    ()
}

val __ConfigureV85 : forall ('enabled : Bool). bool('enabled) -> unit

function __ConfigureV85 enabled = {
    v8Ap5_IMPLEMENTED = enabled;
    if enabled then {
        __ConfigureV84(enabled)
    };
    ()
}

val __ConfigureV86 : forall ('enabled : Bool). bool('enabled) -> unit

function __ConfigureV86 enabled = {
    v8Ap6_IMPLEMENTED = enabled;
    if enabled then {
        __ConfigureV85(enabled)
    };
    ()
}

val __ConfigureV87 : forall ('enabled : Bool). bool('enabled) -> unit

function __ConfigureV87 enabled = {
    v8Ap7_IMPLEMENTED = enabled;
    if enabled then {
        __ConfigureV86(enabled)
    };
    ()
}

val __ConfigureV88 : forall ('enabled : Bool). bool('enabled) -> unit

function __ConfigureV88 enabled = {
    v8Ap8_IMPLEMENTED = enabled;
    if enabled then {
        __ConfigureV87(enabled)
    };
    ()
}

val __ConfigureV89 : forall ('enabled : Bool). bool('enabled) -> unit

function __ConfigureV89 enabled = {
    v8Ap9_IMPLEMENTED = enabled;
    if enabled then {
        __ConfigureV88(enabled)
    };
    ()
}

val __ConfigureV90 : forall ('enabled : Bool). bool('enabled) -> unit

function __ConfigureV90 enabled = {
    v9Ap0_IMPLEMENTED = enabled;
    if enabled then {
        __ConfigureV85(enabled)
    };
    ()
}

val __ConfigureV91 : forall ('enabled : Bool). bool('enabled) -> unit

function __ConfigureV91 enabled = {
    v9Ap1_IMPLEMENTED = enabled;
    if enabled then {
        __ConfigureV90(enabled);
        __ConfigureV86(enabled)
    };
    ()
}

val __ConfigureV92 : forall ('enabled : Bool). bool('enabled) -> unit

function __ConfigureV92 enabled = {
    v9Ap2_IMPLEMENTED = enabled;
    if enabled then {
        __ConfigureV91(enabled);
        __ConfigureV87(enabled)
    };
    ()
}

val __ConfigureV93 : forall ('enabled : Bool). bool('enabled) -> unit

function __ConfigureV93 enabled = {
    v9Ap3_IMPLEMENTED = enabled;
    if enabled then {
        __ConfigureV92(enabled);
        __ConfigureV88(enabled)
    };
    ()
}

val __ConfigureV94 : forall ('enabled : Bool). bool('enabled) -> unit

function __ConfigureV94 enabled = {
    v9Ap4_IMPLEMENTED = enabled;
    if enabled then {
        __ConfigureV93(enabled);
        __ConfigureV89(enabled)
    };
    ()
}

val decode_max_smeveclen : forall 'value_name. int('value_name) -> int

function decode_max_smeveclen value_name = {
    svl : int = (value_name >> 1);
    bitpos : int = 0;
    while svl != 0 do {
        svl = (svl >> 1);
        bitpos = bitpos + 1
    };
    if value_name == 0 | bitpos > 4 then {
        bitpos = 2
    };
    let 'bitpos = bitpos;
    let 'max_svl = 128 * pow2(bitpos);
    return(max_svl)
}

val decode_max_sveveclen : forall 'value_name. int('value_name) -> int

function decode_max_sveveclen value_name = {
    max_vl : int = value_name * 64;
    if max_vl > 2048 then {
        max_vl = 2048
    };
    let 'max_vl = max_vl;
    if not_bool(IsPow2(max_vl)) then {
        return(FloorPow2(max_vl))
    };
    return(max_vl)
}

val AArch32_ReservedBreakpointType : forall 'n.
  (int('n), bits(4)) -> (Constraint, bits(4))

function AArch32_ReservedBreakpointType (n, bt_in) = {
    bt : bits(4) = bt_in;
    reserved : bool = false;
    let context_aware : bool = n >= NumBreakpointsImplemented() - NumContextAwareBreakpointsImplemented();
    if (match bt {
      [bitzero, bitone, bitzero, _] => true,
      _ => false
    }) : bool & HaltOnBreakpointOrWatchpoint() then {
        reserved = true
    };
    if not_bool((match bt {
      [bitzero, _, bitzero, _] => true,
      _ => false
    }) : bool) & not_bool(context_aware) then {
        reserved = true
    };
    if (match bt {
      [bitone, _, _, _] => true,
      _ => false
    }) : bool & not_bool(HaveEL(EL2)) then {
        reserved = true
    };
    if ((match bt {
      [bitzero, bitone, bitone, _] => true,
      [bitone, bitone, _, _] => true,
      _ => false
    }) : bool & not_bool(HaveVirtHostExt())) & not_bool(HaveV82Debug()) then {
        reserved = true
    };
    if reserved then {
        c : Constraint = undefined;
        (c, bt) = ConstrainUnpredictableBits(Unpredictable_RESBPTYPE, 4);
        assert(c == Constraint_DISABLED | c == Constraint_UNKNOWN);
        if c == Constraint_DISABLED then {
            return((c, __UNKNOWN_bits(4)))
        };
        ()
    };
    return((Constraint_NONE, bt))
}

bitfield DBGBCR_Type : bits(32) =
  {
    BT : 23..20,
    LBN : 19..16,
    SSC : 15..14,
    HMC : 13..13,
    BAS : 8..5,
    PMC : 2..1,
    E : 0..0
  }

register _DBGBCR : vector(16, DBGBCR_Type)

val DBGBCR_read : forall 'n, (0 <= 'n & 'n < 16). int('n) -> DBGBCR_Type

function DBGBCR_read n = {
    r : DBGBCR_Type = _DBGBCR[n];
    r.bits[31 .. 0] = Slice(DBGBCR_EL1[n].bits, 0, 32);
    return(r)
}

bitfield DBGBVR_Type : bits(32) = {VA : 31..2, ContextID : 31..0}

register _DBGBVR : vector(16, DBGBVR_Type)

val DBGBVR_read : forall 'n, (0 <= 'n & 'n < 16). int('n) -> DBGBVR_Type

function DBGBVR_read n = {
    r : DBGBVR_Type = _DBGBVR[n];
    r.bits[31 .. 0] = Slice(DBGBVR_EL1[n].bits, 0, 32);
    return(r)
}

bitfield DBGBXVR_Type : bits(32) = {VMID : (15..8 @ 7..0), ContextID2 : 31..0}

register _DBGBXVR : vector(16, DBGBXVR_Type)

val DBGBXVR_read : forall 'n, (0 <= 'n & 'n < 16). int('n) -> DBGBXVR_Type

function DBGBXVR_read n = {
    r : DBGBXVR_Type = _DBGBXVR[n];
    r.bits[31 .. 0] = Slice(DBGBVR_EL1[n].bits, 32, 32);
    return(r)
}

val AArch32_BreakpointValueMatch : forall ('linked_to : Bool) 'n_in.
  (int('n_in), bits(32), bool('linked_to)) -> (bool, bool)

function AArch32_BreakpointValueMatch (n_in, vaddress, linked_to) = {
    n : int = n_in;
    c : Constraint = undefined;
    if n >= NumBreakpointsImplemented() then {
        (c, n) = ConstrainUnpredictableInteger(0, NumBreakpointsImplemented() - 1, Unpredictable_BPNOTIMPL);
        assert(c == Constraint_DISABLED | c == Constraint_UNKNOWN);
        if c == Constraint_DISABLED then {
            return((false, false))
        };
        ()
    };
    let 'n = n;
    assert(constraint((0 <= 'n & 'n < 16)));
    if DBGBCR_read(n)[E] == 0b0 then {
        return((false, false))
    };
    dbgtype : bits(4) = DBGBCR_read(n)[BT];
    (c, dbgtype) = AArch32_ReservedBreakpointType(n, dbgtype);
    if c == Constraint_DISABLED then {
        return((false, false))
    };
    let match_addr : bool = (match dbgtype {
      [bitzero, _, bitzero, _] => true,
      _ => false
    }) : bool;
    let mismatch : bool = (match dbgtype {
      [bitzero, bitone, bitzero, _] => true,
      _ => false
    }) : bool;
    let match_vmid : bool = (match dbgtype {
      [bitone, bitzero, _, _] => true,
      _ => false
    }) : bool;
    let match_cid1 : bool = (match dbgtype {
      [_, _, bitone, _] => true,
      _ => false
    }) : bool;
    let match_cid2 : bool = (match dbgtype {
      [bitone, bitone, _, _] => true,
      _ => false
    }) : bool;
    let linking_enabled : bool = (match dbgtype {
      [_, _, _, bitone] => true,
      _ => false
    }) : bool;
    if linked_to & not_bool(linking_enabled) then {
        if not_bool(ConstrainUnpredictableBool(Unpredictable_BPLINKINGDISABLED)) then {
            return((false, false))
        };
        ()
    };
    if (not_bool(linked_to) & linking_enabled) & not_bool(match_addr) then {
        return((false, false))
    };
    bvr_match : bool = false;
    bxvr_match : bool = false;
    if match_addr then {
        let 'byte = UInt(vaddress[1 .. 0]);
        assert(byte == 0 | byte == 2);
        let byte_select_match : bool = [DBGBCR_read(n)[BAS][byte]] == 0b1;
        let 'top = 31;
        bvr_match = vaddress[top .. 2] == DBGBVR_read(n).bits[top .. 2] & byte_select_match
    } else if match_cid1 then {
        bvr_match = PSTATE.EL != EL2 & CONTEXTIDR_read().bits == DBGBVR_read(n).bits[31 .. 0]
    } else ();
    if match_vmid then {
        vmid : bits(16) = undefined;
        bvr_vmid : bits(16) = undefined;
        if ELUsingAArch32(EL2) then {
            vmid = ZeroExtend(VTTBR[VMID], 16);
            bvr_vmid = ZeroExtend(DBGBXVR_read(n).bits[7 .. 0], 16)
        } else if not_bool(Have16bitVMID()) | VTCR_EL2[VS] == 0b0 then {
            vmid = ZeroExtend(VTTBR_EL2_read()[VMID][7 .. 0], 16);
            bvr_vmid = ZeroExtend(DBGBXVR_read(n).bits[7 .. 0], 16)
        } else {
            vmid = VTTBR_EL2_read()[VMID];
            bvr_vmid = DBGBXVR_read(n).bits[15 .. 0]
        };
        bxvr_match = ((PSTATE.EL == EL0 | PSTATE.EL == EL1) & EL2Enabled()) & vmid == bvr_vmid
    } else if match_cid2 then {
        bxvr_match = ((PSTATE.EL != EL3 & EL2Enabled()) & not_bool(ELUsingAArch32(EL2))) & DBGBXVR_read(n).bits[31 .. 0] == CONTEXTIDR_EL2.bits[31 .. 0]
    } else ();
    let bvr_match_valid : bool = match_addr | match_cid1;
    let bxvr_match_valid : bool = match_vmid | match_cid2;
    let val_match : bool = (not_bool(bxvr_match_valid) | bxvr_match) & (not_bool(bvr_match_valid) | bvr_match);
    return((val_match & not_bool(mismatch), not_bool(val_match) & mismatch))
}

val AArch32_StateMatch : forall ('isbreakpnt : Bool) ('linked_in : Bool) 'linked_n_in.
  (bits(2), bits(1), bits(2), bool('linked_in), int('linked_n_in), bool('isbreakpnt), AccessDescriptor) -> bool

function AArch32_StateMatch (ssc_in, hmc_in, pxc_in, linked_in, linked_n_in, isbreakpnt, accdesc) = {
    first_ctx_cmp : int = undefined;
    last_ctx_cmp : int = undefined;
    linked_to : bool = undefined;
    vaddress : bits(32) = undefined;
    hmc : bits(1) = hmc_in;
    ssc : bits(2) = ssc_in;
    pxc : bits(2) = pxc_in;
    linked : bool = linked_in;
    linked_n : int = linked_n_in;
    c : Constraint = undefined;
    let (__tup_0 : Constraint, __tup_1 : bits(2), _, __tup_3 : bits(1), __tup_4 : bits(2)) =
      CheckValidStateMatch(ssc, 0b0, hmc, pxc, isbreakpnt)
    in
      {
          c = __tup_0;
          ssc = __tup_1;
          hmc = __tup_3;
          pxc = __tup_4
      };
    if c == Constraint_DISABLED then {
        return(false)
    };
    let pl2_match : bool = HaveEL(EL2) & (hmc == 0b1 & (ssc @ pxc) != 0b1000 | ssc == 0b11);
    let pl1_match : bool = [pxc[0]] == 0b1;
    let pl0_match : bool = [pxc[1]] == 0b1;
    let ssu_match : bool = ((isbreakpnt & hmc == 0b0) & pxc == 0b00) & ssc != 0b11;
    priv_match : bool = undefined;
    if ssu_match then {
        priv_match = PSTATE.M == M32_User | PSTATE.M == M32_Svc | PSTATE.M == M32_System
    } else {
        match accdesc.el {
          ? if ? == EL3 => {
              priv_match = pl1_match
          },
          ? if ? == EL2 => {
              priv_match = pl2_match
          },
          ? if ? == EL1 => {
              priv_match = pl1_match
          },
          ? if ? == EL0 => {
              priv_match = pl0_match
          },
          _ => ()
        }
    };
    ss_match : bool = undefined;
    match ssc {
      0b00 => {
          ss_match = true
      },
      0b01 => {
          ss_match = accdesc.ss == SS_NonSecure
      },
      0b10 => {
          ss_match = accdesc.ss == SS_Secure
      },
      0b11 => {
          ss_match = hmc == 0b1 | accdesc.ss == SS_Secure
      },
      _ => ()
    };
    linked_match : bool = false;
    if linked then {
        if not_bool(IsContextMatchingBreakpoint(linked_n)) then {
            (first_ctx_cmp, last_ctx_cmp) = ContextMatchingBreakpointRange();
            let 'last_ctx_cmp = last_ctx_cmp;
            let 'first_ctx_cmp = first_ctx_cmp;
            (c, linked_n) = ConstrainUnpredictableInteger(first_ctx_cmp, last_ctx_cmp, Unpredictable_BPNOTCTXCMP);
            assert(c == Constraint_DISABLED | c == Constraint_NONE | c == Constraint_UNKNOWN);
            match c {
              Constraint_DISABLED => {
                  return(false)
              },
              Constraint_NONE => {
                  linked = false
              },
              _ => ()
            }
        };
        let 'linked_n = linked_n;
        let vaddress : bits(32) = __UNKNOWN_bits(32);
        let linked_to : bool = true;
        let (__tup_0 : bool, _) = AArch32_BreakpointValueMatch(linked_n, vaddress, linked_to);
        linked_match = __tup_0
    };
    return((priv_match & ss_match) & (not_bool(linked) | linked_match))
}

val AArch32_BreakpointMatch : forall 'n 'size, (0 <= 'n & 'n < 16).
  (int('n), bits(32), AccessDescriptor, int('size)) -> (bool, bool)

function AArch32_BreakpointMatch (n, vaddress, accdesc, size) = {
    match_i : bool = undefined;
    mismatch_i : bool = undefined;
    value_match_name : bool = undefined;
    value_mismatch_name : bool = undefined;
    assert(ELUsingAArch32(S1TranslationRegime__1()));
    assert(n < NumBreakpointsImplemented());
    let enabled : bool = DBGBCR_read(n)[E] == 0b1;
    let isbreakpnt : bool = true;
    let linked : bool = (match DBGBCR_read(n)[BT] {
      [bitzero, _, bitzero, bitone] => true,
      _ => false
    }) : bool;
    let linked_to : bool = false;
    let 'linked_n = UInt(DBGBCR_read(n)[LBN]);
    let state_match : bool = AArch32_StateMatch(DBGBCR_read(n)[SSC], DBGBCR_read(n)[HMC], DBGBCR_read(n)[PMC], linked, linked_n, isbreakpnt, accdesc);
    (value_match_name, value_mismatch_name) = AArch32_BreakpointValueMatch(n, vaddress, linked_to);
    if size == 4 then {
        (match_i, mismatch_i) = AArch32_BreakpointValueMatch(n, vaddress + 2, linked_to);
        if not_bool(value_match_name) & match_i then {
            value_match_name = ConstrainUnpredictableBool(Unpredictable_BPMATCHHALF)
        };
        if value_mismatch_name & not_bool(mismatch_i) then {
            value_mismatch_name = ConstrainUnpredictableBool(Unpredictable_BPMISMATCHHALF)
        };
        ()
    };
    if [vaddress[1]] == 0b1 & DBGBCR_read(n)[BAS] == 0b1111 then {
        if value_match_name then {
            value_match_name = ConstrainUnpredictableBool(Unpredictable_BPMATCHHALF)
        };
        if not_bool(value_mismatch_name) then {
            value_mismatch_name = ConstrainUnpredictableBool(Unpredictable_BPMISMATCHHALF)
        };
        ()
    };
    let val_match : bool = (value_match_name & state_match) & enabled;
    let mismatch : bool = (value_mismatch_name & state_match) & enabled;
    return((val_match, mismatch))
}

val AArch32_CheckBreakpoint : forall 'size.
  (FaultRecord, bits(32), AccessDescriptor, int('size)) -> FaultRecord

function AArch32_CheckBreakpoint (fault_in, vaddress, accdesc, size) = {
    match_i : bool = undefined;
    mismatch_i : bool = undefined;
    reason : bits(6) = undefined;
    assert(ELUsingAArch32(S1TranslationRegime__1()));
    assert(size == 2 | size == 4);
    fault : FaultRecord = fault_in;
    val_match : bool = false;
    mismatch : bool = false;
    foreach (i from 0 to (NumBreakpointsImplemented() - 1) by 1 in inc) {
        assert(constraint(('loop_i < 16 | not('size in {2, 4}))));
        (match_i, mismatch_i) = AArch32_BreakpointMatch(i, vaddress, accdesc, size);
        val_match = val_match | match_i;
        mismatch = mismatch | mismatch_i
    };
    if val_match & HaltOnBreakpointOrWatchpoint() then {
        let reason : bits(6) = DebugHalt_Breakpoint;
        Halt(reason)
    } else if val_match | mismatch then {
        fault.statuscode = Fault_Debug;
        fault.debugmoe = DebugException_Breakpoint
    } else ();
    return(fault)
}

bitfield DBGVCR32_EL2_Type : bits(64) =
  {
    NSF : 31..31,
    NSI : 30..30,
    NSD : 28..28,
    NSP : 27..27,
    NSS : 26..26,
    NSU : 25..25,
    F : 7..7,
    SF : 7..7,
    I : 6..6,
    SI : 6..6,
    D : 4..4,
    SD : 4..4,
    P : 3..3,
    SP : 3..3,
    S : 2..2,
    SS : 2..2,
    U : 1..1,
    SU : 1..1
  }

register DBGVCR32_EL2 : DBGVCR32_EL2_Type

bitfield DBGVCR_Type : bits(32) =
  {
    NSF : 31..31,
    NSI : 30..30,
    NSD : 28..28,
    NSP : 27..27,
    NSS : 26..26,
    NSU : 25..25,
    MF : 15..15,
    MI : 14..14,
    MD : 12..12,
    MP : 11..11,
    MS : 10..10,
    F : 7..7,
    SF : 7..7,
    I : 6..6,
    SI : 6..6,
    D : 4..4,
    SD : 4..4,
    P : 3..3,
    SP : 3..3,
    S : 2..2,
    SS : 2..2,
    U : 1..1,
    SU : 1..1
  }

register _DBGVCR : DBGVCR_Type

val DBGVCR_read : unit -> DBGVCR_Type

function DBGVCR_read () = {
    r : DBGVCR_Type = _DBGVCR;
    r.bits[31 .. 0] = Slice(DBGVCR32_EL2.bits, 0, 32);
    return(r)
}

val AArch32_VCRMatch : bits(32) -> bool

function AArch32_VCRMatch vaddress = {
    match_word : bits(32) = undefined;
    ss : SecurityState = undefined;
    val_match : bool = undefined;
    if (UsingAArch32() & ELUsingAArch32(EL1)) & PSTATE.EL != EL2 then {
        match_word : bits(32) = Zeros(32);
        let ss : SecurityState = CurrentSecurityState();
        if vaddress[31 .. 5] == ExcVectorBase()[31 .. 5] then {
            if HaveEL(EL3) & ss == SS_NonSecure then {
                match_word[UInt(vaddress[4 .. 2]) + 24] = Bit(0b1)
            } else {
                match_word[UInt(vaddress[4 .. 2]) + 0] = Bit(0b1)
            }
        };
        if ((HaveEL(EL3) & ELUsingAArch32(EL3)) & vaddress[31 .. 5] == MVBAR.bits[31 .. 5]) & ss == SS_Secure then {
            match_word[UInt(vaddress[4 .. 2]) + 8] = Bit(0b1)
        };
        mask : bits(32) = undefined;
        if not_bool(HaveEL(EL3)) then {
            mask = ((0b00000000 @ 0b00000000) @ 0b00000000) @ 0b11011110
        } else if not_bool(ELUsingAArch32(EL3)) then {
            mask = ((0b11011110 @ 0b00000000) @ 0b00000000) @ 0b11011110
        } else {
            mask = ((0b11011110 @ 0b00000000) @ 0b11011100) @ 0b11011110
        };
        let match_word : bits(32) = (match_word & DBGVCR_read().bits) & mask;
        val_match = not_bool(IsZero(match_word));
        if not_bool(IsZero(match_word[28 .. 27] @ (match_word[12 .. 11] @ match_word[4 .. 3]))) & DebugTarget() == PSTATE.EL then {
            val_match = ConstrainUnpredictableBool(Unpredictable_VCMATCHDAPA)
        };
        if not_bool(IsZero(vaddress[1 .. 0])) & val_match then {
            val_match = ConstrainUnpredictableBool(Unpredictable_VCMATCHHALF)
        };
        ()
    } else {
        val_match = false
    };
    return(val_match)
}

val AArch32_CheckVectorCatch : forall 'size.
  (FaultRecord, bits(32), int('size)) -> FaultRecord

function AArch32_CheckVectorCatch (fault_in, vaddress, size) = {
    assert(ELUsingAArch32(S1TranslationRegime__1()));
    fault : FaultRecord = fault_in;
    val_match : bool = AArch32_VCRMatch(vaddress);
    if (size == 4 & not_bool(val_match)) & AArch32_VCRMatch(vaddress + 2) then {
        val_match = ConstrainUnpredictableBool(Unpredictable_VCMATCHHALF)
    };
    if val_match then {
        fault.statuscode = Fault_Debug;
        fault.debugmoe = DebugException_VectorCatch
    };
    return(fault)
}

bitfield DBGWCR_Type : bits(32) =
  {
    MASK : 28..24,
    WT : 20..20,
    LBN : 19..16,
    SSC : 15..14,
    HMC : 13..13,
    BAS : 12..5,
    LSC : 4..3,
    PAC : 2..1,
    E : 0..0
  }

register _DBGWCR : vector(16, DBGWCR_Type)

val DBGWCR_read : forall 'n, (0 <= 'n & 'n < 16). int('n) -> DBGWCR_Type

function DBGWCR_read n = {
    r : DBGWCR_Type = _DBGWCR[n];
    r.bits[31 .. 0] = Slice(DBGWCR_EL1[n].bits, 0, 32);
    return(r)
}

bitfield DBGWVR_Type : bits(32) = {VA : 31..2}

register _DBGWVR : vector(16, DBGWVR_Type)

val DBGWVR_read : forall 'n, (0 <= 'n & 'n < 16). int('n) -> DBGWVR_Type

function DBGWVR_read n = {
    r : DBGWVR_Type = _DBGWVR[n];
    r.bits[31 .. 0] = Slice(DBGWVR_EL1[n].bits, 0, 32);
    return(r)
}

val AArch32_WatchpointByteMatch : forall 'n, (0 <= 'n & 'n < 16).
  (int('n), bits(32)) -> bool

function AArch32_WatchpointByteMatch (n, vaddress) = {
    LSB : bits(8) = undefined;
    MSB : bits(8) = undefined;
    let 'top = 31;
    bottom : {2, 3} = if [DBGWVR_read(n).bits[2]] == 0b1 then 2 else 3;
    byte_select_match : bool = let 'bottom = bottom in
      {
          [DBGWCR_read(n)[BAS][UInt(vaddress[bottom - 1 .. 0])]] != 0b0
      };
    mask : int = UInt(DBGWCR_read(n)[MASK]);
    if mask > 0 & not_bool(IsOnes(DBGWCR_read(n)[BAS])) then {
        byte_select_match = ConstrainUnpredictableBool(Unpredictable_WPMASKANDBAS)
    } else {
        let LSB : bits(8) = DBGWCR_read(n)[BAS] & not_vec(DBGWCR_read(n)[BAS] - 1);
        let MSB : bits(8) = DBGWCR_read(n)[BAS] + LSB;
        if not_bool(IsZero(MSB & MSB - 1)) then {
            byte_select_match = ConstrainUnpredictableBool(Unpredictable_WPBASCONTIGUOUS);
            bottom = 3
        };
        ()
    };
    let 'bottom = bottom;
    if mask > 0 & mask <= 2 then {
        c : Constraint = undefined;
        (c, mask) = ConstrainUnpredictableInteger(3, 31, Unpredictable_RESWPMASK);
        assert(c == Constraint_DISABLED | c == Constraint_NONE | c == Constraint_UNKNOWN);
        match c {
          Constraint_DISABLED => {
              return(false)
          },
          Constraint_NONE => {
              mask = 0
          },
          _ => ()
        }
    };
    let 'mask = mask;
    WVR_match : bool = undefined;
    if mask > bottom then {
        assert(constraint((0 <= 'mask & 'mask <= 'top & 'top < 32)));
        WVR_match = vaddress[top .. mask] == DBGWVR_read(n).bits[top .. mask];
        if WVR_match & not_bool(is_zero_subrange(DBGWVR_read(n).bits, mask - 1, bottom)) then {
            WVR_match = ConstrainUnpredictableBool(Unpredictable_WPMASKEDBITS)
        };
        ()
    } else {
        WVR_match = vaddress[top .. bottom] == DBGWVR_read(n).bits[top .. bottom]
    };
    return(WVR_match & byte_select_match)
}

val AArch32_WatchpointMatch : forall 'n 'size, (0 <= 'n & 'n < 16).
  (int('n), bits(32), int('size), AccessDescriptor) -> bool

function AArch32_WatchpointMatch (n, vaddress, size, accdesc) = {
    assert(ELUsingAArch32(S1TranslationRegime__1()));
    assert(n < NumWatchpointsImplemented());
    let enabled : bool = DBGWCR_read(n)[E] == 0b1;
    let linked : bool = DBGWCR_read(n)[WT] == 0b1;
    let isbreakpnt : bool = false;
    let 'linked_n = UInt(DBGWCR_EL1[n][LBN]);
    let state_match : bool = AArch32_StateMatch(DBGWCR_read(n)[SSC], DBGWCR_read(n)[HMC], DBGWCR_read(n)[PAC], linked, linked_n, isbreakpnt, accdesc);
    ls_match : bool = undefined;
    match DBGWCR_read(n)[LSC][1 .. 0] {
      0b00 => {
          ls_match = false
      },
      0b01 => {
          ls_match = accdesc.read
      },
      0b10 => {
          ls_match = accdesc.write | accdesc.acctype == AccessType_DC
      },
      0b11 => {
          ls_match = true
      },
      _ => ()
    };
    value_match_name : bool = false;
    foreach (byte from 0 to (size - 1) by 1 in inc) {
        value_match_name = value_match_name | AArch32_WatchpointByteMatch(n, vaddress + byte)
    };
    return(((value_match_name & state_match) & ls_match) & enabled)
}

val AArch32_CheckWatchpoint : forall 'size.
  (FaultRecord, bits(32), AccessDescriptor, int('size)) -> FaultRecord

function AArch32_CheckWatchpoint (fault_in, vaddress, accdesc, size) = {
    reason : bits(6) = undefined;
    assert(ELUsingAArch32(S1TranslationRegime__1()));
    fault : FaultRecord = fault_in;
    if accdesc.acctype == AccessType_DC then {
        if accdesc.cacheop != CacheOp_Invalidate then {
            return(fault)
        } else if not_bool(__IMPDEF_boolean("DCIMVAC generates watchpoint")) then {
            return(fault)
        } else ()
    } else if not_bool(IsDataAccess(accdesc.acctype)) then {
        return(fault)
    } else ();
    val_match : bool = false;
    foreach (i from 0 to (NumWatchpointsImplemented() - 1) by 1 in inc) {
        assert(constraint('loop_i < 16));
        if AArch32_WatchpointMatch(i, vaddress, size, accdesc) then {
            val_match = true
        };
        ()
    };
    if val_match & HaltOnBreakpointOrWatchpoint() then {
        let reason : bits(6) = DebugHalt_Watchpoint;
        EDWAR = ZeroExtend(vaddress, 64);
        Halt(reason)
    } else if val_match then {
        fault.statuscode = Fault_Debug;
        fault.debugmoe = DebugException_Watchpoint
    } else ();
    return(fault)
}

val AArch32_CheckDebug : forall 'size.
  (bits(32), AccessDescriptor, int('size)) -> FaultRecord

function AArch32_CheckDebug (vaddress, accdesc, size) = {
    fault : FaultRecord = NoFault__1(accdesc);
    let d_side : bool = IsDataAccess(accdesc.acctype) | accdesc.acctype == AccessType_DC;
    let i_side : bool = accdesc.acctype == AccessType_IFETCH;
    let generate_exception : bool = AArch32_GenerateDebugExceptions() & DBGDSCRext_read()[MDBGen] == 0b1;
    let halt : bool = HaltOnBreakpointOrWatchpoint();
    let vector_catch_first_name : bool = ConstrainUnpredictableBool(Unpredictable_BPVECTORCATCHPRI);
    if (i_side & vector_catch_first_name) & generate_exception then {
        fault = AArch32_CheckVectorCatch(fault, vaddress, size)
    };
    if fault.statuscode == Fault_None & (generate_exception | halt) then {
        if d_side then {
            fault = AArch32_CheckWatchpoint(fault, vaddress, accdesc, size)
        } else if i_side then {
            fault = AArch32_CheckBreakpoint(fault, vaddress, accdesc, size)
        } else ()
    };
    if ((fault.statuscode == Fault_None & i_side) & not_bool(vector_catch_first_name)) & generate_exception then {
        return(AArch32_CheckVectorCatch(fault, vaddress, size))
    };
    return(fault)
}

val AArch32_FullTranslate : forall ('aligned : Bool).
  (bits(32), AccessDescriptor, bool('aligned)) -> AddressDescriptor

function AArch32_FullTranslate (va, accdesc, aligned) = {
    fault : FaultRecord = NoFault__1(accdesc);
    let regime : Regime = TranslationRegime(accdesc.el);
    ipa : AddressDescriptor = undefined;
    if regime == Regime_EL2 | TTBCR_read()[EAE] == 0b1 then {
        (fault, ipa) = AArch32_S1TranslateLD(fault, regime, va, aligned, accdesc)
    } else {
        let (__tup_0 : FaultRecord, __tup_1 : AddressDescriptor, _) = AArch32_S1TranslateSD(fault, regime, va, aligned, accdesc);
        fault = __tup_0;
        ipa = __tup_1
    };
    if fault.statuscode != Fault_None then {
        return(CreateFaultyAddressDescriptor(ZeroExtend(va, 64), fault))
    };
    if regime == Regime_EL10 & EL2Enabled() then {
        ipa.vaddress = ZeroExtend(va, 64);
        pa : AddressDescriptor = undefined;
        (fault, pa) = AArch32_S2Translate(fault, ipa, None(), aligned, accdesc);
        if fault.statuscode != Fault_None then {
            return(CreateFaultyAddressDescriptor(ZeroExtend(va, 64), fault))
        } else {
            return(pa)
        }
    } else {
        return(ipa)
    }
}

val AArch32_TranslateAddress : forall ('aligned : Bool) 'size.
  (bits(32), AccessDescriptor, bool('aligned), int('size)) -> AddressDescriptor

function AArch32_TranslateAddress (va, accdesc, aligned, size) = {
    let regime : Regime = TranslationRegime(PSTATE.EL);
    if not_bool(RegimeUsingAArch32(regime)) then {
        return(AArch64_TranslateAddress(ZeroExtend(va, 64), accdesc, aligned, size))
    };
    result : AddressDescriptor = AArch32_FullTranslate(va, accdesc, aligned);
    if not_bool(IsFault(result)) then {
        result.fault = AArch32_CheckDebug(va, accdesc, size)
    };
    result.vaddress = ZeroExtend(va, 64);
    return(result)
}

val AArch32_DC : (bits(32), CacheOp, CacheOpScope) -> unit

function AArch32_DC (regval, cacheop, opscope) = {
    cache : CacheRecord = undefined;
    cache.acctype = AccessType_DC;
    cache.cacheop = cacheop;
    cache.opscope = opscope;
    cache.cachetype = CacheType_Data;
    cache.security = SecurityStateAtEL(PSTATE.EL);
    if opscope == CacheOpScope_SetWay then {
        cache.shareability = Shareability_NSH;
        (cache.setnum, cache.waynum, cache.level) = DecodeSW(ZeroExtend(regval, 64), CacheType_Data);
        if ((cacheop == CacheOp_Invalidate & PSTATE.EL == EL1) & EL2Enabled()) & (not_bool(ELUsingAArch32(EL2)) & (HCR_EL2[SWIO] == 0b1 | (HCR_EL2[DC] @ HCR_EL2[VM]) != 0b00) | ELUsingAArch32(EL2) & (HCR_read()[SWIO] == 0b1 | (HCR_read()[DC] @ HCR_read()[VM]) != 0b00)) then {
            cache.cacheop = CacheOp_CleanInvalidate
        };
        CACHE_OP(cache);
        return()
    };
    if EL2Enabled() then {
        if PSTATE.EL == EL0 | PSTATE.EL == EL1 then {
            cache.is_vmid_valid = true;
            cache.vmid = VMID_read()
        } else {
            cache.is_vmid_valid = false
        }
    } else {
        cache.is_vmid_valid = false
    };
    if PSTATE.EL == EL0 then {
        cache.is_asid_valid = true;
        cache.asid = ASID_read()
    } else {
        cache.is_asid_valid = false
    };
    let need_translate : bool = DCInstNeedsTranslation(opscope);
    vaddress : bits(32) = regval;
    size : int = 0;
    if cacheop == CacheOp_Invalidate then {
        size = __IMPDEF_integer("Data Cache Invalidate Watchpoint Size");
        assert(size >= 4 * pow2(UInt(CTR_EL0[DminLine])) & size <= 2048);
        assert(UInt(size[32 .. 0] & (size - 1)[32 .. 0]) == 0);
        vaddress = Align(regval, size)
    };
    let 'size = size;
    cache.translated = need_translate;
    cache.vaddress = ZeroExtend(vaddress, 64);
    if need_translate then {
        let aligned : bool = true;
        let accdesc : AccessDescriptor = CreateAccDescDC(cache);
        let memaddrdesc : AddressDescriptor = AArch32_TranslateAddress(vaddress, accdesc, aligned, size);
        if IsFault(memaddrdesc) then {
            AArch32_Abort(regval, memaddrdesc.fault)
        };
        cache.paddress = memaddrdesc.paddress;
        if opscope == CacheOpScope_PoC then {
            cache.shareability = memaddrdesc.memattrs.shareability
        } else {
            cache.shareability = Shareability_NSH
        }
    } else {
        cache.shareability = __UNKNOWN_Shareability();
        cache.paddress = __UNKNOWN_FullAddress()
    };
    if ((cacheop == CacheOp_Invalidate & PSTATE.EL == EL1) & EL2Enabled()) & (not_bool(ELUsingAArch32(EL2)) & (HCR_EL2[DC] @ HCR_EL2[VM]) != 0b00 | ELUsingAArch32(EL2) & (HCR_read()[DC] @ HCR_read()[VM]) != 0b00) then {
        cache.cacheop = CacheOp_CleanInvalidate
    };
    CACHE_OP(cache);
    return()
}

val AArch32_IC : CacheOpScope -> unit

val AArch32_IC__1 : (bits(32), CacheOpScope) -> unit

function AArch32_IC opscope = {
    let regval : bits(32) = __UNKNOWN_bits(32);
    AArch32_IC__1(regval, opscope)
}

function AArch32_IC__1 (regval, opscope) = {
    need_translate : bool = undefined;
    cache : CacheRecord = undefined;
    cache.acctype = AccessType_IC;
    cache.cachetype = CacheType_Instruction;
    cache.cacheop = CacheOp_Invalidate;
    cache.opscope = opscope;
    cache.security = SecurityStateAtEL(PSTATE.EL);
    if opscope == CacheOpScope_ALLU | opscope == CacheOpScope_ALLUIS then {
        if opscope == CacheOpScope_ALLUIS | ((opscope == CacheOpScope_ALLU & PSTATE.EL == EL1) & EL2Enabled()) & HCR_read()[FB] == 0b1 then {
            cache.shareability = Shareability_ISH
        } else {
            cache.shareability = Shareability_NSH
        };
        cache.regval = ZeroExtend(regval, 64);
        CACHE_OP(cache)
    } else {
        assert(opscope == CacheOpScope_PoU);
        if EL2Enabled() then {
            if PSTATE.EL == EL0 | PSTATE.EL == EL1 then {
                cache.is_vmid_valid = true;
                cache.vmid = VMID_read()
            } else {
                cache.is_vmid_valid = false
            }
        } else {
            cache.is_vmid_valid = false
        };
        if PSTATE.EL == EL0 then {
            cache.is_asid_valid = true;
            cache.asid = ASID_read()
        } else {
            cache.is_asid_valid = false
        };
        let need_translate : bool = ICInstNeedsTranslation(opscope);
        cache.shareability = Shareability_NSH;
        cache.vaddress = ZeroExtend(regval, 64);
        cache.translated = need_translate;
        if not_bool(need_translate) then {
            cache.paddress = __UNKNOWN_FullAddress();
            CACHE_OP(cache);
            return()
        };
        let 'size = 0;
        let aligned : bool = true;
        let accdesc : AccessDescriptor = CreateAccDescIC(cache);
        let memaddrdesc : AddressDescriptor = AArch32_TranslateAddress(regval, accdesc, aligned, size);
        if IsFault(memaddrdesc) then {
            AArch32_Abort(regval, memaddrdesc.fault)
        };
        cache.paddress = memaddrdesc.paddress;
        CACHE_OP(cache)
    };
    return()
}

val AArch32_PARFaultStatusLD : FaultRecord -> bits(6)

function AArch32_PARFaultStatusLD fault = {
    syndrome : bits(6) = undefined;
    if fault.statuscode == Fault_Domain then {
        assert(fault.level == 1 | fault.level == 2);
        syndrome[1 .. 0] = if fault.level == 1 then 0b01 else 0b10;
        syndrome[5 .. 2] = 0b1111
    } else {
        syndrome = EncodeLDFSC(fault.statuscode, fault.level)
    };
    return(syndrome)
}

val AArch32_EncodePARLD : (AddressDescriptor, SecurityState) -> unit

function AArch32_EncodePARLD (addrdesc, ss) = {
    if not_bool(IsFault(addrdesc)) then {
        ns : bits(1) = undefined;
        if ss == SS_NonSecure then {
            ns = __UNKNOWN_bit()
        } else if addrdesc.paddress.paspace == PAS_Secure then {
            ns = 0b0
        } else {
            ns = 0b1
        };
        let ns : bits(1) = if addrdesc.paddress.paspace == PAS_Secure then 0b0
        else
          0b1;
        PAR_write() = [PAR_read() with F = 0b0];
        PAR_write() = [PAR_read() with SH = ReportedPARShareability(PAREncodeShareability(addrdesc.memattrs))];
        PAR_write() = [PAR_read() with NS = ns];
        PAR_write() = Mk_PAR_Type([PAR_read().bits with 10 .. 10 = __IMPDEF_bit("Non-Faulting PAR")]);
        PAR_write() = [PAR_read() with LPAE = 0b1];
        PAR_write() = [PAR_read() with PA = addrdesc.paddress.address[39 .. 12]];
        PAR_write() = [PAR_read() with ATTR = ReportedPARAttrs(EncodePARAttrs(addrdesc.memattrs))]
    } else {
        PAR_write() = [PAR_read() with F = 0b1];
        PAR_write() = [PAR_read() with FST = AArch32_PARFaultStatusLD(addrdesc.fault)];
        PAR_write() = [PAR_read() with S2WLK = if addrdesc.fault.s2fs1walk then
          0b1
        else
          0b0];
        PAR_write() = [PAR_read() with FSTAGE = if addrdesc.fault.secondstage then
          0b1
        else
          0b0];
        PAR_write() = [PAR_read() with LPAE = 0b1];
        PAR_write() = Mk_PAR_Type([PAR_read().bits with 63 .. 48 = __IMPDEF_bits(16, "Faulting PAR")])
    };
    return()
}

val AArch32_PARFaultStatusSD : FaultRecord -> bits(6)

function AArch32_PARFaultStatusSD fault = {
    syndrome : bits(6) = undefined;
    syndrome[5] = Bit(if IsExternalAbort__1(fault) then fault.extflag else 0b0);
    syndrome[4 .. 0] = EncodeSDFSC(fault.statuscode, fault.level);
    return(syndrome)
}

val AArch32_PARInnerAttrs : MemoryAttributes -> bits(3)

function AArch32_PARInnerAttrs memattrs = {
    result : bits(3) = undefined;
    if memattrs.memtype == MemType_Device then {
        if memattrs.device == DeviceType_nGnRnE then {
            result = 0b001
        } else if memattrs.device == DeviceType_nGnRE then {
            result = 0b011
        } else ()
    } else {
        let inner : MemAttrHints = memattrs.inner;
        if inner.attrs == MemAttr_NC then {
            result = 0b000
        } else if inner.attrs == MemAttr_WB & [inner.hints[0]] == 0b1 then {
            result = 0b101
        } else if inner.attrs == MemAttr_WT then {
            result = 0b110
        } else if inner.attrs == MemAttr_WB & [inner.hints[0]] == 0b0 then {
            result = 0b111
        } else ()
    };
    return(result)
}

val AArch32_PAROuterAttrs : MemoryAttributes -> bits(2)

function AArch32_PAROuterAttrs memattrs = {
    result : bits(2) = undefined;
    if memattrs.memtype == MemType_Device then {
        result = __UNKNOWN_bits(2)
    } else {
        let outer : MemAttrHints = memattrs.outer;
        if outer.attrs == MemAttr_NC then {
            result = 0b00
        } else if outer.attrs == MemAttr_WB & [outer.hints[0]] == 0b1 then {
            result = 0b01
        } else if outer.attrs == MemAttr_WT & [outer.hints[0]] == 0b0 then {
            result = 0b10
        } else if outer.attrs == MemAttr_WB & [outer.hints[0]] == 0b0 then {
            result = 0b11
        } else ()
    };
    return(result)
}

val AArch32_EncodePARSD : (AddressDescriptor, bits(1), SecurityState) -> unit

function AArch32_EncodePARSD (addrdesc_in, supersection, ss) = {
    addrdesc : AddressDescriptor = addrdesc_in;
    if not_bool(IsFault(addrdesc)) then {
        if addrdesc.memattrs.memtype == MemType_Device | addrdesc.memattrs.inner.attrs == MemAttr_NC & addrdesc.memattrs.outer.attrs == MemAttr_NC then {
            addrdesc.memattrs.shareability = Shareability_OSH
        };
        ns : bits(1) = undefined;
        if ss == SS_NonSecure then {
            ns = __UNKNOWN_bit()
        } else if addrdesc.paddress.paspace == PAS_Secure then {
            ns = 0b0
        } else {
            ns = 0b1
        };
        let ns : bits(1) = if addrdesc.paddress.paspace == PAS_Secure then 0b0
        else
          0b1;
        let sh : bits(2) = if addrdesc.memattrs.shareability != Shareability_NSH then
          0b01
        else
          0b00;
        PAR_write() = [PAR_read() with F = 0b0];
        PAR_write() = [PAR_read() with SS = supersection];
        PAR_write() = [PAR_read() with Outer = AArch32_ReportedOuterAttrs(AArch32_PAROuterAttrs(addrdesc.memattrs))];
        PAR_write() = [PAR_read() with Inner = AArch32_ReportedInnerAttrs(AArch32_PARInnerAttrs(addrdesc.memattrs))];
        PAR_write() = [PAR_read() with SH = ReportedPARShareability(sh)];
        PAR_write() = Mk_PAR_Type([PAR_read().bits with 8 .. 8 = __IMPDEF_bit("Non-Faulting PAR")]);
        PAR_write() = [PAR_read() with NS = ns];
        PAR_write() = [PAR_read() with NOS = if addrdesc.memattrs.shareability == Shareability_OSH then
          0b0
        else
          0b1];
        PAR_write() = [PAR_read() with LPAE = 0b0];
        PAR_write() = [PAR_read() with PA = addrdesc.paddress.address[39 .. 12]]
    } else {
        PAR_write() = [PAR_read() with F = 0b1];
        PAR_write() = [PAR_read() with FST = AArch32_PARFaultStatusSD(addrdesc.fault)];
        PAR_write() = [PAR_read() with LPAE = 0b0];
        PAR_write() = Mk_PAR_Type([PAR_read().bits with 31 .. 16 = __IMPDEF_bits(16, "Faulting PAR")])
    };
    return()
}

val AArch32_AT : (bits(32), TranslationStage, bits(2), ATAccess) -> unit

function AArch32_AT (vaddress, stage_in, el, ataccess) = {
    stage : TranslationStage = stage_in;
    ss : SecurityState = undefined;
    regime : Regime = undefined;
    eae : bool = undefined;
    if el == EL2 then {
        regime = Regime_EL2;
        eae = true;
        ss = SS_NonSecure
    } else if stage == TranslationStage_1 | stage == TranslationStage_12 & not_bool(HaveEL(EL2)) then {
        stage = TranslationStage_1;
        ss = SecurityStateAtEL(PSTATE.EL);
        regime = if ss == SS_Secure & ELUsingAArch32(EL3) then Regime_EL30 else
          Regime_EL10;
        eae = TTBCR_read()[EAE] == 0b1
    } else {
        regime = Regime_EL10;
        eae = if HaveAArch32EL(EL3) then TTBCR_NS_read()[EAE] == 0b1 else
          TTBCR_read()[EAE] == 0b1;
        ss = SS_NonSecure
    };
    addrdesc : AddressDescriptor = undefined;
    sdftype : SDFType = undefined;
    let aligned : bool = true;
    supersection : bits(1) = 0b0;
    let write : bool = ataccess == ATAccess_WritePAN | ataccess == ATAccess_Write;
    let pan : bool = ataccess == ATAccess_WritePAN | ataccess == ATAccess_ReadPAN;
    let accdesc : AccessDescriptor = CreateAccDescAT(ss, el, write, pan);
    fault : FaultRecord = NoFault__1(accdesc);
    if eae then {
        (fault, addrdesc) = AArch32_S1TranslateLD(fault, regime, vaddress, aligned, accdesc)
    } else {
        (fault, addrdesc, sdftype) = AArch32_S1TranslateSD(fault, regime, vaddress, aligned, accdesc);
        supersection = if sdftype == SDFType_Supersection then 0b1 else 0b0
    };
    if stage == TranslationStage_12 & fault.statuscode == Fault_None then {
        (fault, addrdesc) = AArch32_S2Translate(fault, addrdesc, None(), aligned, accdesc)
    };
    if fault.statuscode != Fault_None then {
        if IsExternalAbort__1(fault) | (PSTATE.EL == EL1 & EL2Enabled()) & fault.s2fs1walk then {
            PAR_write() = Mk_PAR_Type(__UNKNOWN_bits(64));
            AArch32_Abort(vaddress, fault)
        };
        ()
    };
    addrdesc.fault = fault;
    if (eae | stage == TranslationStage_12 & (HCR_read()[VM] == 0b1 | HCR_read()[DC] == 0b1)) | (stage == TranslationStage_1 & el != EL2) & PSTATE.EL == EL2 then {
        AArch32_EncodePARLD(addrdesc, ss)
    } else {
        AArch32_EncodePARSD(addrdesc, supersection, ss)
    };
    return()
}

val AArch32_RestrictPrediction : (bits(32), RestrictType) -> unit

function AArch32_RestrictPrediction (val_name, restriction) = {
    c : ExecutionCntxt = undefined;
    let target_el : bits(2) = val_name[25 .. 24];
    if not_bool(HaveEL(target_el)) | UInt(target_el) > UInt(PSTATE.EL) then {
        EndOfInstruction()
    };
    let ns : bits(1) = [val_name[26]];
    let nse : bits(1) = __UNKNOWN_bit();
    let ss : SecurityState = TargetSecurityState(ns, nse);
    c.security = ss;
    c.target_el = target_el;
    if EL2Enabled() then {
        if PSTATE.EL == EL0 | PSTATE.EL == EL1 then {
            c.is_vmid_valid = true;
            c.all_vmid = false;
            c.vmid = VMID_read()
        } else if target_el == EL0 | target_el == EL1 then {
            c.is_vmid_valid = true;
            c.all_vmid = [val_name[27]] == 0b1;
            c.vmid = ZeroExtend(val_name[23 .. 16], 16)
        } else {
            c.is_vmid_valid = false
        }
    } else {
        c.is_vmid_valid = false
    };
    if PSTATE.EL == EL0 then {
        c.is_asid_valid = true;
        c.all_asid = false;
        c.asid = ASID_read()
    } else if target_el == EL0 then {
        c.is_asid_valid = true;
        c.all_asid = [val_name[8]] == 0b1;
        c.asid = ZeroExtend(val_name[7 .. 0], 16)
    } else {
        c.is_asid_valid = false
    };
    c.restriction = restriction;
    RESTRICT_PREDICTIONS(c)
}

val RRX_C : forall 'N, 'N > 1. (bits('N), bits(1)) -> (bits('N), bits(1))

function RRX_C (x, carry_in) = {
    let result : bits('N) = [(x >> 1) with ('N - 1) = Bit(carry_in)];
    let carry_out : bits(1) = [x[0]];
    return((result, carry_out))
}

val Shift_C : forall 'N 'amount, 'N >= 0.
  (bits('N), SRType, int('amount), bits(1)) -> (bits('N), bits(1))

function Shift_C (value_name, srtype, amount, carry_in) = {
    assert(not_bool(srtype == SRType_RRX & amount != 1));
    result : bits('N) = undefined;
    carry_out : bits(1) = undefined;
    if amount == 0 then {
        (result, carry_out) = (value_name, carry_in)
    } else {
        match srtype {
          SRType_LSL => {
              (result, carry_out) = LSL_C(value_name, amount)
          },
          SRType_LSR => {
              (result, carry_out) = LSR_C(value_name, amount)
          },
          SRType_ASR => {
              assert(constraint(('N >= 0 & 'amount >= 0)));
              (result, carry_out) = ASR_C(value_name, amount)
          },
          SRType_ROR => {
              assert(constraint('N > 0));
              (result, carry_out) = ROR_C(value_name, amount)
          },
          SRType_RRX => {
              assert(constraint('N > 1));
              (result, carry_out) = RRX_C(value_name, carry_in)
          }
        }
    };
    return((result, carry_out))
}

val A32ExpandImm_C : (bits(12), bits(1)) -> (bits(32), bits(1))

function A32ExpandImm_C (imm12, carry_in) = {
    carry_out : bits(1) = undefined;
    imm32 : bits(32) = undefined;
    let unrotated_value : bits(32) = ZeroExtend(imm12[7 .. 0], 32);
    (imm32, carry_out) = Shift_C(unrotated_value, SRType_ROR, 2 * UInt(imm12[11 .. 8]), carry_in);
    return((imm32, carry_out))
}

val A32ExpandImm : bits(12) -> bits(32)

function A32ExpandImm imm12 = {
    imm32 : bits(32) = undefined;
    let (__tup_0 : bits(32), _) = A32ExpandImm_C(imm12, PSTATE.C) in
      {
          imm32 = __tup_0
      };
    return(imm32)
}

val DecodeImmShift : (bits(2), bits(5)) -> (SRType, int)

function DecodeImmShift (srtype, imm5) = {
    shift_t : SRType = undefined;
    shift_n : range(0, 32) = undefined;
    match srtype {
      0b00 => {
          shift_t = SRType_LSL;
          shift_n = UInt(imm5)
      },
      0b01 => {
          shift_t = SRType_LSR;
          shift_n = if imm5 == 0b00000 then 32 else UInt(imm5)
      },
      0b10 => {
          shift_t = SRType_ASR;
          shift_n = if imm5 == 0b00000 then 32 else UInt(imm5)
      },
      0b11 => {
          if imm5 == 0b00000 then {
              shift_t = SRType_RRX;
              shift_n = 1
          } else {
              shift_t = SRType_ROR;
              shift_n = UInt(imm5)
          }
      }
    };
    let 'shift_n = shift_n;
    return((shift_t, shift_n))
}

val DecodeRegShift : bits(2) -> SRType

function DecodeRegShift srtype = {
    shift_t : SRType = undefined;
    match srtype {
      0b00 => {
          shift_t = SRType_LSL
      },
      0b01 => {
          shift_t = SRType_LSR
      },
      0b10 => {
          shift_t = SRType_ASR
      },
      0b11 => {
          shift_t = SRType_ROR
      }
    };
    let shift_t = shift_t;
    return(shift_t)
}

val Shift : forall 'N 'amount, 'N >= 0.
  (bits('N), SRType, int('amount), bits(1)) -> bits('N)

function Shift (value_name, srtype, amount, carry_in) = {
    result : bits('N) = undefined;
    let (__tup_0 : bits('N), _) = Shift_C(value_name, srtype, amount, carry_in)
    in
      {
          result = __tup_0
      };
    return(result)
}

val T32ExpandImm_C : (bits(12), bits(1)) -> (bits(32), bits(1))

function T32ExpandImm_C (imm12, carry_in) = {
    unrotated_value : bits(32) = undefined;
    imm32 : bits(32) = undefined;
    carry_out : bits(1) = undefined;
    if imm12[11 .. 10] == 0b00 then {
        match imm12[9 .. 8] {
          0b00 => {
              imm32 = ZeroExtend(imm12[7 .. 0], 32)
          },
          0b01 => {
              imm32 = ((0b00000000 @ imm12[7 .. 0]) @ 0b00000000) @ imm12[7 .. 0]
          },
          0b10 => {
              imm32 = ((imm12[7 .. 0] @ 0b00000000) @ imm12[7 .. 0]) @ 0b00000000
          },
          0b11 => {
              imm32 = ((imm12[7 .. 0] @ imm12[7 .. 0]) @ imm12[7 .. 0]) @ imm12[7 .. 0]
          }
        };
        carry_out = carry_in
    } else {
        let unrotated_value : bits(32) = ZeroExtend(0b1 @ imm12[6 .. 0], 32);
        (imm32, carry_out) = ROR_C(unrotated_value, UInt(imm12[11 .. 7]))
    };
    return((imm32, carry_out))
}

val T32ExpandImm : bits(12) -> bits(32)

function T32ExpandImm imm12 = {
    imm32 : bits(32) = undefined;
    let (__tup_0 : bits(32), _) = T32ExpandImm_C(imm12, PSTATE.C) in
      {
          imm32 = __tup_0
      };
    return(imm32)
}

val AArch32_SystemAccessTrapSyndrome : forall 'ec.
  (bits(32), int('ec)) -> ExceptionRecord

function AArch32_SystemAccessTrapSyndrome (instr, ec) = {
    except : ExceptionRecord = undefined;
    match ec {
      0 => {
          except = ExceptionSyndrome(Exception_Uncategorized)
      },
      3 => {
          except = ExceptionSyndrome(Exception_CP15RTTrap)
      },
      4 => {
          except = ExceptionSyndrome(Exception_CP15RRTTrap)
      },
      5 => {
          except = ExceptionSyndrome(Exception_CP14RTTrap)
      },
      6 => {
          except = ExceptionSyndrome(Exception_CP14DTTrap)
      },
      7 => {
          except = ExceptionSyndrome(Exception_AdvSIMDFPAccessTrap)
      },
      8 => {
          except = ExceptionSyndrome(Exception_FPIDTrap)
      },
      12 => {
          except = ExceptionSyndrome(Exception_CP14RRTTrap)
      },
      _ => {
          Unreachable()
      }
    };
    iss : bits(20) = Zeros(20);
    if except.exceptype == Exception_Uncategorized then {
        return(except)
    } else if except.exceptype == Exception_FPIDTrap | except.exceptype == Exception_CP14RTTrap | except.exceptype == Exception_CP15RTTrap then {
        iss[13 .. 10] = instr[19 .. 16];
        iss[8 .. 5] = instr[15 .. 12];
        iss[9] = Bit(0b0);
        if except.exceptype != Exception_FPIDTrap then {
            iss[19 .. 17] = instr[7 .. 5];
            iss[16 .. 14] = instr[23 .. 21];
            iss[4 .. 1] = instr[3 .. 0]
        } else {
            iss[19 .. 17] = 0b000;
            iss[16 .. 14] = 0b111;
            iss[4 .. 1] = 0b0000
        }
    } else if except.exceptype == Exception_CP14RRTTrap | except.exceptype == Exception_AdvSIMDFPAccessTrap | except.exceptype == Exception_CP15RRTTrap then {
        iss[19 .. 16] = instr[7 .. 4];
        iss[13 .. 10] = instr[19 .. 16];
        iss[8 .. 5] = instr[15 .. 12];
        iss[4 .. 1] = instr[3 .. 0]
    } else if except.exceptype == Exception_CP14DTTrap then {
        iss[19 .. 12] = instr[7 .. 0];
        iss[4] = Bit([instr[23]]);
        iss[2 .. 1] = [instr[24]] @ [instr[21]];
        if instr[19 .. 16] == 0b1111 then {
            iss[8 .. 5] = __UNKNOWN_bits(4);
            iss[3] = Bit(0b1)
        };
        ()
    } else ();
    iss[0] = Bit([instr[20]]);
    except.syndrome[24 .. 20] = ConditionSyndrome();
    except.syndrome[19 .. 0] = iss;
    return(except)
}

val AArch32_TakeHypTrapException : forall 'ec. int('ec) -> unit

val AArch32_TakeHypTrapException__1 : ExceptionRecord -> unit

function AArch32_TakeHypTrapException ec = {
    let except : ExceptionRecord = AArch32_SystemAccessTrapSyndrome(ThisInstr(), ec);
    AArch32_TakeHypTrapException__1(except)
}

function AArch32_TakeHypTrapException__1 except = {
    assert((HaveEL(EL2) & CurrentSecurityState() == SS_NonSecure) & ELUsingAArch32(EL2));
    let preferred_exception_return : bits(32) = ThisInstrAddr(32);
    let 'vect_offset = UInt(0x14);
    AArch32_EnterHypMode(except, preferred_exception_return, vect_offset)
}

val AArch32_SystemAccessTrap : forall 'ec. (bits(5), int('ec)) -> unit

function AArch32_SystemAccessTrap (mode, ec) = {
    except : ExceptionRecord = undefined;
    target_el : bits(2) = undefined;
    valid_name : bool = undefined;
    (valid_name, target_el) = ELFromM32(mode);
    assert(((valid_name & HaveEL(target_el)) & target_el != EL0) & UInt(target_el) >= UInt(PSTATE.EL));
    if target_el == EL2 then {
        let except : ExceptionRecord = AArch32_SystemAccessTrapSyndrome(ThisInstr(), ec);
        AArch32_TakeHypTrapException__1(except)
    } else {
        AArch32_TakeUndefInstrException()
    }
}

bitfield HSTR_Type : bits(32) =
  {
    T15 : 15..15,
    T13 : 13..13,
    T12 : 12..12,
    T11 : 11..11,
    T10 : 10..10,
    T9 : 9..9,
    T8 : 8..8,
    T7 : 7..7,
    T6 : 6..6,
    T5 : 5..5,
    T3 : 3..3,
    T2 : 2..2,
    T1 : 1..1,
    T0 : 0..0
  }

register _HSTR : HSTR_Type

val HSTR_read : unit -> HSTR_Type

function HSTR_read () = {
    r : HSTR_Type = _HSTR;
    r.bits[31 .. 0] = Slice(HSTR_EL2.bits, 0, 32);
    return(r)
}

val AArch32_CheckCP15InstrCoarseTraps : forall 'CRm 'CRn 'nreg.
  (int('CRn), int('nreg), int('CRm)) -> unit

function AArch32_CheckCP15InstrCoarseTraps (CRn, nreg, CRm) = {
    major : int = undefined;
    if PSTATE.EL == EL0 & (not_bool(ELUsingAArch32(EL1)) | EL2Enabled() & not_bool(ELUsingAArch32(EL2))) then {
        AArch64_CheckCP15InstrCoarseTraps(CRn, nreg, CRm)
    };
    let trapped_encoding : bool = (CRn == 9 & (CRm == 0 | CRm == 1 | CRm == 2 | CRm == 5 | CRm == 6 | CRm == 7 | CRm == 8) | CRn == 10 & (CRm == 0 | CRm == 1 | CRm == 4 | CRm == 8)) | CRn == 11 & (CRm == 0 | CRm == 1 | CRm == 2 | CRm == 3 | CRm == 4 | CRm == 5 | CRm == 6 | CRm == 7 | CRm == 8 | CRm == 15);
    if (PSTATE.EL == EL0 | PSTATE.EL == EL1) & EL2Enabled() then {
        let 'major = if nreg == 1 then CRn else CRm;
        assert(constraint((0 <= 'major & 'major < 32)));
        if not_bool(major == 4 | major == 14) & [HSTR_read().bits[major]] == 0b1 | (HCR_read()[TIDCP] == 0b1 & nreg == 1) & trapped_encoding then {
            if PSTATE.EL == EL0 & __IMPDEF_boolean("UNDEF unallocated CP15 access at EL0") then {
                throw(Error_Undefined())
            };
            if ELUsingAArch32(EL2) then {
                AArch32_SystemAccessTrap(M32_Hyp, UInt(0x3))
            } else {
                AArch64_AArch32SystemAccessTrap(EL2, UInt(0x3))
            }
        };
        ()
    };
    ()
}

val AArch32_CheckFPAdvSIMDTrap : forall ('advsimd : Bool).
  bool('advsimd) -> unit

function AArch32_CheckFPAdvSIMDTrap advsimd = {
    except : ExceptionRecord = undefined;
    hcptr_cp10 : bits(1) = undefined;
    hcptr_tase : bits(1) = undefined;
    ss : SecurityState = undefined;
    if EL2Enabled() & not_bool(ELUsingAArch32(EL2)) then {
        AArch64_CheckFPAdvSIMDTrap()
    } else {
        if ((HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & CPTR_EL3[TFP] == 0b1) & EL3SDDUndefPriority() then {
            throw(Error_Undefined())
        };
        let ss : SecurityState = CurrentSecurityState();
        if HaveEL(EL2) & ss != SS_Secure then {
            hcptr_tase : bits(1) = HCPTR_read()[TASE];
            hcptr_cp10 : bits(1) = HCPTR_read()[TCP10];
            if HaveEL(EL3) & ELUsingAArch32(EL3) then {
                if NSACR[NSASEDIS] == 0b1 then {
                    hcptr_tase = 0b1
                };
                if NSACR[cp10] == 0b0 then {
                    hcptr_cp10 = 0b1
                };
                ()
            };
            if advsimd & hcptr_tase == 0b1 | hcptr_cp10 == 0b1 then {
                except : ExceptionRecord = ExceptionSyndrome(Exception_AdvSIMDFPAccessTrap);
                except.syndrome[24 .. 20] = ConditionSyndrome();
                if advsimd then {
                    except.syndrome[5] = Bit(0b1)
                } else {
                    except.syndrome[5] = Bit(0b0);
                    except.syndrome[3 .. 0] = 0b1010
                };
                if PSTATE.EL == EL2 then {
                    AArch32_TakeUndefInstrException__1(except)
                } else {
                    AArch32_TakeHypTrapException__1(except)
                }
            };
            ()
        };
        if HaveEL(EL3) & not_bool(ELUsingAArch32(EL3)) then {
            if CPTR_EL3[TFP] == 0b1 then {
                if EL3SDDUndef() then {
                    throw(Error_Undefined())
                } else {
                    AArch64_AdvSIMDFPAccessTrap(EL3)
                }
            };
            ()
        };
        ()
    }
}

val AArch32_CheckAdvSIMDOrFPEnabled : forall ('advsimd : Bool) ('fpexc_check : Bool).
  (bool('fpexc_check), bool('advsimd)) -> unit

function AArch32_CheckAdvSIMDOrFPEnabled (fpexc_check, advsimd) = {
    cpacr_asedis : bits(1) = undefined;
    cpacr_cp10 : bits(2) = undefined;
    fpexc_en : bits(1) = undefined;
    if (PSTATE.EL == EL0 & not_bool(ELUsingAArch32(EL1))) & (not_bool(EL2Enabled()) | not_bool(ELUsingAArch32(EL2)) & HCR_EL2[TGE] == 0b0) then {
        AArch64_CheckFPEnabled();
        AArch64_CheckFPAdvSIMDEnabled()
    } else if (((PSTATE.EL == EL0 & EL2Enabled()) & not_bool(ELUsingAArch32(EL2))) & HCR_EL2[TGE] == 0b1) & not_bool(ELUsingAArch32(EL1)) then {
        if fpexc_check & HCR_EL2[RW] == 0b0 then {
            let fpexc_en : bits(1) = __IMPDEF_bits(1, "FPEXC.EN value when TGE==1 and RW==0");
            if fpexc_en == 0b0 then {
                throw(Error_Undefined())
            };
            ()
        };
        AArch64_CheckFPEnabled()
    } else {
        cpacr_asedis : bits(1) = CPACR_read__1()[ASEDIS];
        cpacr_cp10 : bits(2) = CPACR_read__1()[cp10];
        if (HaveEL(EL3) & ELUsingAArch32(EL3)) & CurrentSecurityState() == SS_NonSecure then {
            if NSACR[NSASEDIS] == 0b1 then {
                cpacr_asedis = 0b1
            };
            if NSACR[cp10] == 0b0 then {
                cpacr_cp10 = 0b00
            };
            ()
        };
        if PSTATE.EL != EL2 then {
            if advsimd & cpacr_asedis == 0b1 then {
                throw(Error_Undefined())
            };
            disabled : bool = undefined;
            match cpacr_cp10 {
              0b00 => {
                  disabled = true
              },
              0b01 => {
                  disabled = PSTATE.EL == EL0
              },
              0b10 => {
                  disabled = ConstrainUnpredictableBool(Unpredictable_RESCPACR)
              },
              0b11 => {
                  disabled = false
              }
            };
            let disabled = disabled;
            if disabled then {
                throw(Error_Undefined())
            };
            ()
        };
        if fpexc_check & FPEXC_read()[EN] == 0b0 then {
            throw(Error_Undefined())
        };
        AArch32_CheckFPAdvSIMDTrap(advsimd)
    }
}

val D_read : forall 'n. int('n) -> bits(64)

function D_read n = {
    assert(n >= 0 & n <= 31);
    let 'base = MOD(n, 2) * 64;
    let vreg : bits(128) = V_read(DIV(n, 2), 128);
    return(vreg[base + 63 .. base])
}

val CheckAdvSIMDEnabled : unit -> unit

function CheckAdvSIMDEnabled () = {
    let fpexc_check : bool = true;
    let advsimd : bool = true;
    AArch32_CheckAdvSIMDOrFPEnabled(fpexc_check, advsimd);
    foreach (i from 0 to 31 by 1 in inc) {
        _Dclone[i] = D_read(i)
    };
    return()
}

val CheckAdvSIMDOrVFPEnabled : forall ('advsimd : Bool) ('include_fpexc_check_name : Bool).
  (bool('include_fpexc_check_name), bool('advsimd)) -> unit

function CheckAdvSIMDOrVFPEnabled (include_fpexc_check_name, advsimd) = {
    AArch32_CheckAdvSIMDOrFPEnabled(include_fpexc_check_name, advsimd);
    return()
}

val CheckCryptoEnabled32 : unit -> unit

function CheckCryptoEnabled32 () = {
    CheckAdvSIMDEnabled();
    return()
}

val CheckVFPEnabled : forall ('include_fpexc_check_name : Bool).
  bool('include_fpexc_check_name) -> unit

function CheckVFPEnabled include_fpexc_check_name = {
    let advsimd : bool = false;
    AArch32_CheckAdvSIMDOrFPEnabled(include_fpexc_check_name, advsimd);
    return()
}

val FPHalvedSub : forall 'N, 'N in {16, 32, 64}.
  (bits('N), bits('N), FPCRType) -> bits('N)

function FPHalvedSub (op1, op2, fpcr) = {
    done : bool = undefined;
    inf1 : bool = undefined;
    inf2 : bool = undefined;
    result : bits('N) = undefined;
    result_sign : bits(1) = undefined;
    result_value : real = undefined;
    sign1 : bits(1) = undefined;
    sign2 : bits(1) = undefined;
    type1 : FPType = undefined;
    type2 : FPType = undefined;
    value1_name : real = undefined;
    value2_name : real = undefined;
    zero1 : bool = undefined;
    zero2 : bool = undefined;
    assert('N == 16 | 'N == 32 | 'N == 64);
    let rounding : FPRounding = FPRoundingMode(fpcr);
    (type1, sign1, value1_name) = FPUnpack(op1, fpcr);
    (type2, sign2, value2_name) = FPUnpack(op2, fpcr);
    (done, result) = FPProcessNaNs(type1, type2, op1, op2, fpcr);
    if not_bool(done) then {
        let inf1 : bool = type1 == FPType_Infinity;
        let inf2 : bool = type2 == FPType_Infinity;
        let zero1 : bool = type1 == FPType_Zero;
        let zero2 : bool = type2 == FPType_Zero;
        if (inf1 & inf2) & sign1 == sign2 then {
            result = FPDefaultNaN__1(fpcr, 'N);
            FPProcessException(FPExc_InvalidOp, fpcr)
        } else if inf1 & sign1 == 0b0 | inf2 & sign2 == 0b1 then {
            result = FPInfinity(0b0, 'N)
        } else if inf1 & sign1 == 0b1 | inf2 & sign2 == 0b0 then {
            result = FPInfinity(0b1, 'N)
        } else if (zero1 & zero2) & sign1 != sign2 then {
            result = FPZero(sign1, 'N)
        } else {
            let result_value : real = (value1_name - value2_name) / 2.0;
            if result_value == 0.0 then {
                let result_sign : bits(1) = if rounding == FPRounding_NEGINF then
                  0b1
                else
                  0b0;
                result = FPZero(result_sign, 'N)
            } else {
                result = FPRound(result_value, fpcr, 'N)
            }
        }
    };
    return(result)
}

val StandardFPSCRValue : unit -> FPCRType

function StandardFPSCRValue () = {
    let value_name : bits(32) = (((0b00000 @ FPSCR_read__1()[AHP]) @ 0b110000) @ FPSCR_read__1()[FZ16]) @ 0b0000000000000000000;
    return(Mk_FPCRType(ZeroExtend(value_name, 64)))
}

val FPRecipStep : forall 'N, 'N in {16, 32}. (bits('N), bits('N)) -> bits('N)

function FPRecipStep (op1, op2) = {
    done : bool = undefined;
    inf1 : bool = undefined;
    inf2 : bool = undefined;
    result : bits('N) = undefined;
    sign1 : bits(1) = undefined;
    sign2 : bits(1) = undefined;
    type1 : FPType = undefined;
    type2 : FPType = undefined;
    value1_name : real = undefined;
    value2_name : real = undefined;
    zero1 : bool = undefined;
    zero2 : bool = undefined;
    assert('N == 16 | 'N == 32);
    let fpcr : FPCRType = StandardFPSCRValue();
    (type1, sign1, value1_name) = FPUnpack(op1, fpcr);
    (type2, sign2, value2_name) = FPUnpack(op2, fpcr);
    (done, result) = FPProcessNaNs(type1, type2, op1, op2, fpcr);
    if not_bool(done) then {
        let inf1 : bool = type1 == FPType_Infinity;
        let inf2 : bool = type2 == FPType_Infinity;
        let zero1 : bool = type1 == FPType_Zero;
        let zero2 : bool = type2 == FPType_Zero;
        product : bits('N) = undefined;
        if inf1 & zero2 | zero1 & inf2 then {
            product = FPZero(0b0, 'N)
        } else {
            product = FPMul(op1, op2, fpcr)
        };
        let two : bits('N) = FPTwo(0b0, 'N);
        result = FPSub(two, product, fpcr)
    };
    return(result)
}

val FPRSqrtStep : forall 'N, 'N in {16, 32}. (bits('N), bits('N)) -> bits('N)

function FPRSqrtStep (op1, op2) = {
    done : bool = undefined;
    inf1 : bool = undefined;
    inf2 : bool = undefined;
    result : bits('N) = undefined;
    sign1 : bits(1) = undefined;
    sign2 : bits(1) = undefined;
    type1 : FPType = undefined;
    type2 : FPType = undefined;
    value1_name : real = undefined;
    value2_name : real = undefined;
    zero1 : bool = undefined;
    zero2 : bool = undefined;
    assert('N == 16 | 'N == 32);
    let fpcr : FPCRType = StandardFPSCRValue();
    (type1, sign1, value1_name) = FPUnpack(op1, fpcr);
    (type2, sign2, value2_name) = FPUnpack(op2, fpcr);
    (done, result) = FPProcessNaNs(type1, type2, op1, op2, fpcr);
    if not_bool(done) then {
        let inf1 : bool = type1 == FPType_Infinity;
        let inf2 : bool = type2 == FPType_Infinity;
        let zero1 : bool = type1 == FPType_Zero;
        let zero2 : bool = type2 == FPType_Zero;
        product : bits('N) = undefined;
        if inf1 & zero2 | zero1 & inf2 then {
            product = FPZero(0b0, 'N)
        } else {
            product = FPMul(op1, op2, fpcr)
        };
        let three : bits('N) = FPThree(0b0, 'N);
        result = FPHalvedSub(three, product, fpcr)
    };
    return(result)
}

val AArch32_UnalignedAccessFaults : AccessDescriptor -> bool

function AArch32_UnalignedAccessFaults accdesc = {
    return((((AlignmentEnforced() | accdesc.a32lsmd) | accdesc.exclusive) | accdesc.acqsc) | accdesc.relsc)
}

val AArch32_MemSingle_read : forall ('aligned : Bool) 'size,
  'size in {1, 2, 4, 8, 16}.
  (bits(32), int('size), AccessDescriptor, bool('aligned)) -> bits('size * 8)

val AArch32_MemSingle_read__1 : forall ('aligned : Bool) ('ispair : Bool) 'size,
  'size in {1, 2, 4, 8, 16}.
  (bits(32), int('size), AccessDescriptor, bool('aligned), bool('ispair)) -> bits('size * 8)

function AArch32_MemSingle_read (address, size, accdesc, aligned) = {
    let ispair : bool = false;
    return(AArch32_MemSingle_read__1(address, size, accdesc, aligned, ispair))
}

function AArch32_MemSingle_read__1 (address, size, accdesc_in, aligned, ispair) = {
    assert(size == 1 | size == 2 | size == 4 | size == 8 | size == 16);
    value_name : bits('size * 8) = undefined;
    let accdesc : AccessDescriptor = accdesc_in;
    assert(IsAligned__1(address, size));
    let memaddrdesc : AddressDescriptor = AArch32_TranslateAddress(address, accdesc, aligned, size);
    if IsFault(memaddrdesc) then {
        AArch32_Abort(address, memaddrdesc.fault)
    };
    if SPESampleInFlight then {
        let is_load : bool = true;
        SPESampleLoadStore(is_load, accdesc, memaddrdesc)
    };
    memstatus : PhysMemRetStatus = undefined;
    (memstatus, value_name) = PhysMemRead(memaddrdesc, size, accdesc, None()); // TODO: TranslationInfo
    if IsFault__2(memstatus) then {
        HandleExternalReadAbort(memstatus, memaddrdesc, size, accdesc)
    };
    return(value_name)
}

val AArch32_MemSingle_set : forall ('aligned : Bool) 'size,
  'size in {1, 2, 4, 8, 16}.
  (bits(32), int('size), AccessDescriptor, bool('aligned), bits('size * 8)) -> unit

val AArch32_MemSingle_set__1 : forall ('aligned : Bool) ('ispair : Bool) 'size,
  'size in {1, 2, 4, 8, 16}.
  (bits(32), int('size), AccessDescriptor, bool('aligned), bool('ispair), bits('size * 8)) -> unit

function AArch32_MemSingle_set (address, size, accdesc, aligned, value_name) = {
    let ispair : bool = false;
    AArch32_MemSingle_set__1(address, size, accdesc, aligned, ispair) = value_name;
    return()
}

function AArch32_MemSingle_set__1 (address, size, accdesc_in, aligned, ispair, value_name) = {
    assert(size == 1 | size == 2 | size == 4 | size == 8 | size == 16);
    let accdesc : AccessDescriptor = accdesc_in;
    assert(IsAligned__1(address, size));
    let memaddrdesc : AddressDescriptor = AArch32_TranslateAddress(address, accdesc, aligned, size);
    if IsFault(memaddrdesc) then {
        AArch32_Abort(address, memaddrdesc.fault)
    };
    if memaddrdesc.memattrs.shareability != Shareability_NSH then {
        ClearExclusiveByAddress(memaddrdesc.paddress, ProcessorID(), size)
    };
    if SPESampleInFlight then {
        let is_load : bool = false;
        SPESampleLoadStore(is_load, accdesc, memaddrdesc)
    };
    let memstatus : PhysMemRetStatus = PhysMemWrite(memaddrdesc, size, accdesc, None(), value_name); // TODO: TranslationInfo
    if IsFault__2(memstatus) then {
        HandleExternalWriteAbort(memstatus, memaddrdesc, size, accdesc)
    };
    return()
}

val Mem_with_type_read : forall 'size,
  'size in {1, 2, 4, 8, 16}.
  (bits(32), int('size), AccessDescriptor) -> bits('size * 8)

val Mem_with_type_read__1 : forall ('ispair : Bool) 'size,
  'size in {1, 2, 4, 8, 16}.
  (bits(32), int('size), AccessDescriptor, bool('ispair)) -> bits('size * 8)

function Mem_with_type_read (address, size, accdesc) = {
    let ispair : bool = false;
    return(Mem_with_type_read__1(address, size, accdesc, ispair))
}

function Mem_with_type_read__1 (address, size, accdesc, ispair) = {
    c : Constraint = undefined;
    assert(size == 1 | size == 2 | size == 4 | size == 8 | size == 16);
    let 'halfsize = DIV(size, 2);
    value_name : bits('size * 8) = undefined;
    let 'alignment = if ispair then halfsize else size;
    aligned : bool = IsAligned__1(address, alignment);
    if not_bool(aligned) & AArch32_UnalignedAccessFaults(accdesc) then {
        AArch32_Abort(address, AlignmentFault(accdesc))
    };
    if aligned then {
        value_name = AArch32_MemSingle_read__1(address, size, accdesc, aligned, ispair)
    } else {
        assert(size > 1);
        value_name[7 .. 0] = AArch32_MemSingle_read(address, 1, accdesc, aligned);
        let c : Constraint = ConstrainUnpredictable(Unpredictable_DEVPAGE2);
        assert(c == Constraint_FAULT | c == Constraint_NONE);
        if c == Constraint_NONE then {
            aligned = true
        };
        foreach (i from 1 to (size - 1) by 1 in inc) {
            value_name[8 * i + 7 .. 8 * i] = AArch32_MemSingle_read(address + i, 1, accdesc, aligned)
        }
    };
    if BigEndian(accdesc.acctype) then {
        value_name = BigEndianReverse(value_name)
    };
    let value_name = value_name;
    return(value_name)
}

val Mem_with_type_set : forall 'size, 'size * 8 >= 0.
  (bits(32), int('size), AccessDescriptor, bits('size * 8)) -> unit

val Mem_with_type_set__1 : forall ('ispair : Bool) 'size, 'size * 8 >= 0.
  (bits(32), int('size), AccessDescriptor, bool('ispair), bits('size * 8)) -> unit

function Mem_with_type_set (address, size, accdesc, value_in_name) = {
    let ispair : bool = false;
    Mem_with_type_set__1(address, size, accdesc, ispair) = value_in_name
}

function Mem_with_type_set__1 (address, size, accdesc, ispair, value_in_name) = {
    c : Constraint = undefined;
    let 'halfsize = DIV(size, 2);
    value_name : bits('size * 8) = value_in_name;
    let 'alignment = if ispair then halfsize else size;
    aligned : bool = IsAligned__1(address, alignment);
    if not_bool(aligned) & AArch32_UnalignedAccessFaults(accdesc) then {
        AArch32_Abort(address, AlignmentFault(accdesc))
    };
    if BigEndian(accdesc.acctype) then {
        assert(constraint(('size * 8 == 8 | 'size * 8 == 16 | 'size * 8 == 32 | 'size * 8 == 64 | 'size * 8 == 128)));
        value_name = BigEndianReverse(value_name)
    };
    if aligned then {
        assert(constraint('size in {1, 2, 4, 8, 16}));
        AArch32_MemSingle_set__1(address, size, accdesc, aligned, ispair) = value_name
    } else {
        assert(size > 1);
        AArch32_MemSingle_set(address, 1, accdesc, aligned) = value_name[7 .. 0];
        let c : Constraint = ConstrainUnpredictable(Unpredictable_DEVPAGE2);
        assert(c == Constraint_FAULT | c == Constraint_NONE);
        if c == Constraint_NONE then {
            aligned = true
        };
        foreach (i from 1 to (size - 1) by 1 in inc) {
            AArch32_MemSingle_set(address + i, 1, accdesc, aligned) = value_name[8 * i + 7 .. 8 * i]
        }
    };
    return()
}

val MemA_read : forall 'size,
  'size in {1, 2, 4, 8, 16}.
  (bits(32), int('size)) -> bits(8 * 'size)

function MemA_read (address, size) = {
    let acqrel : bool = false;
    let tagchecked : bool = false;
    let accdesc : AccessDescriptor = CreateAccDescExLDST(MemOp_LOAD, acqrel, tagchecked);
    return(Mem_with_type_read(address, size, accdesc))
}

val MemA_set : forall 'size, 8 * 'size >= 0.
  (bits(32), int('size), bits(8 * 'size)) -> unit

function MemA_set (address, size, value_name) = {
    let acqrel : bool = false;
    let tagchecked : bool = false;
    let accdesc : AccessDescriptor = CreateAccDescExLDST(MemOp_STORE, acqrel, tagchecked);
    Mem_with_type_set(address, size, accdesc) = value_name;
    return()
}

val MemU_read : forall 'size,
  'size in {1, 2, 4, 8, 16}.
  (bits(32), int('size)) -> bits(8 * 'size)

function MemU_read (address, size) = {
    let nontemporal : bool = false;
    let privileged : bool = PSTATE.EL != EL0;
    let tagchecked : bool = false;
    let accdesc : AccessDescriptor = CreateAccDescGPR(MemOp_LOAD, nontemporal, privileged, tagchecked);
    return(Mem_with_type_read(address, size, accdesc))
}

val MemU_set : forall 'size, 8 * 'size >= 0.
  (bits(32), int('size), bits(8 * 'size)) -> unit

function MemU_set (address, size, value_name) = {
    let nontemporal : bool = false;
    let privileged : bool = PSTATE.EL != EL0;
    let tagchecked : bool = false;
    let accdesc : AccessDescriptor = CreateAccDescGPR(MemOp_STORE, nontemporal, privileged, tagchecked);
    Mem_with_type_set(address, size, accdesc) = value_name;
    return()
}

val MemU_unpriv_read : forall 'size,
  'size in {1, 2, 4, 8, 16}.
  (bits(32), int('size)) -> bits(8 * 'size)

function MemU_unpriv_read (address, size) = {
    let nontemporal : bool = false;
    let privileged : bool = false;
    let tagchecked : bool = false;
    let accdesc : AccessDescriptor = CreateAccDescGPR(MemOp_LOAD, nontemporal, privileged, tagchecked);
    return(Mem_with_type_read(address, size, accdesc))
}

val MemU_unpriv_set : forall 'size, 8 * 'size >= 0.
  (bits(32), int('size), bits(8 * 'size)) -> unit

function MemU_unpriv_set (address, size, value_name) = {
    let nontemporal : bool = false;
    let privileged : bool = false;
    let tagchecked : bool = false;
    let accdesc : AccessDescriptor = CreateAccDescGPR(MemOp_STORE, nontemporal, privileged, tagchecked);
    Mem_with_type_set(address, size, accdesc) = value_name;
    return()
}

val MemO_read : forall 'size,
  'size in {1, 2, 4, 8, 16}.
  (bits(32), int('size)) -> bits(8 * 'size)

function MemO_read (address, size) = {
    let tagchecked : bool = false;
    let accdesc : AccessDescriptor = CreateAccDescAcqRel(MemOp_LOAD, tagchecked);
    return(Mem_with_type_read(address, size, accdesc))
}

val MemO_set : forall 'size, 8 * 'size >= 0.
  (bits(32), int('size), bits(8 * 'size)) -> unit

function MemO_set (address, size, value_name) = {
    let tagchecked : bool = false;
    let accdesc : AccessDescriptor = CreateAccDescAcqRel(MemOp_STORE, tagchecked);
    Mem_with_type_set(address, size, accdesc) = value_name;
    return()
}

val MemS_read : forall 'size,
  'size in {1, 2, 4, 8, 16}.
  (bits(32), int('size)) -> bits(8 * 'size)

function MemS_read (address, size) = {
    let accdesc : AccessDescriptor = CreateAccDescA32LSMD(MemOp_LOAD);
    return(Mem_with_type_read(address, size, accdesc))
}

val MemS_set : forall 'size, 8 * 'size >= 0.
  (bits(32), int('size), bits(8 * 'size)) -> unit

function MemS_set (address, size, value_name) = {
    let accdesc : AccessDescriptor = CreateAccDescA32LSMD(MemOp_STORE);
    Mem_with_type_set(address, size, accdesc) = value_name;
    return()
}

val AArch32_SetExclusiveMonitors : forall 'size. (bits(32), int('size)) -> unit

function AArch32_SetExclusiveMonitors (address, size) = {
    __ExclusiveMonitorSet = true;
    let acqrel : bool = false;
    let tagchecked : bool = false;
    let accdesc : AccessDescriptor = CreateAccDescExLDST(MemOp_LOAD, acqrel, tagchecked);
    let aligned : bool = IsAligned__1(address, size);
    if not_bool(aligned) then {
        AArch32_Abort(address, AlignmentFault(accdesc))
    };
    let memaddrdesc : AddressDescriptor = AArch32_TranslateAddress(address, accdesc, aligned, size);
    if IsFault(memaddrdesc) then {
        return()
    };
    if memaddrdesc.memattrs.shareability != Shareability_NSH then {
        MarkExclusiveGlobal(memaddrdesc.paddress, ProcessorID(), size)
    };
    MarkExclusiveLocal(memaddrdesc.paddress, ProcessorID(), size);
    AArch32_MarkExclusiveVA(address, ProcessorID(), size)
}

val AArch32_ExclusiveMonitorsPass : forall 'size. (bits(32), int('size)) -> bool

function AArch32_ExclusiveMonitorsPass (address, size) = {
    let acqrel : bool = false;
    let tagchecked : bool = false;
    let accdesc : AccessDescriptor = CreateAccDescExLDST(MemOp_STORE, acqrel, tagchecked);
    let aligned : bool = IsAligned__1(address, size);
    if not_bool(aligned) then {
        AArch32_Abort(address, AlignmentFault(accdesc))
    };
    if not_bool(AArch32_IsExclusiveVA(address, ProcessorID(), size)) then {
        return(false)
    };
    let memaddrdesc : AddressDescriptor = AArch32_TranslateAddress(address, accdesc, aligned, size);
    if IsFault(memaddrdesc) then {
        AArch32_Abort(address, memaddrdesc.fault)
    };
    passed : bool = IsExclusiveLocal(memaddrdesc.paddress, ProcessorID(), size);
    ClearExclusiveLocal(ProcessorID());
    if passed & memaddrdesc.memattrs.shareability != Shareability_NSH then {
        passed = IsExclusiveGlobal(memaddrdesc.paddress, ProcessorID(), size)
    };
    return(passed)
}

val S_read : forall 'n. int('n) -> bits(32)

function S_read n = {
    assert(n >= 0 & n <= 31);
    let 'base = MOD(n, 4) * 32;
    let vreg : bits(128) = V_read(DIV(n, 4), 128);
    return(vreg[base + 31 .. base])
}

val S_set : forall 'n. (int('n), bits(32)) -> unit

function S_set (n, value_name) = {
    assert(n >= 0 & n <= 31);
    let 'base = MOD(n, 4) * 32;
    vreg : bits(128) = V_read(DIV(n, 4), 128);
    vreg[base + 31 .. base] = value_name;
    V_set(DIV(n, 4), 128) = vreg;
    return()
}

val D_set : forall 'n. (int('n), bits(64)) -> unit

function D_set (n, value_name) = {
    assert(n >= 0 & n <= 31);
    let 'base = MOD(n, 2) * 64;
    vreg : bits(128) = V_read(DIV(n, 2), 128);
    vreg[base + 63 .. base] = value_name;
    V_set(DIV(n, 2), 128) = vreg;
    return()
}

val Q_read : forall 'n. int('n) -> bits(128)

function Q_read n = {
    assert(n >= 0 & n <= 15);
    return(V_read(n, 128))
}

val Q_set : forall 'n. (int('n), bits(128)) -> unit

function Q_set (n, value_name) = {
    assert(n >= 0 & n <= 15);
    V_set(n, 128) = value_name;
    return()
}

val AArch32_ResetGeneralRegisters : unit -> unit

function AArch32_ResetGeneralRegisters () = {
    foreach (i from 0 to 7 by 1 in inc) {
        R_set(i) = __UNKNOWN_bits(32)
    };
    foreach (i from 8 to 12 by 1 in inc) {
        Rmode_set(i, M32_User) = __UNKNOWN_bits(32);
        Rmode_set(i, M32_FIQ) = __UNKNOWN_bits(32)
    };
    if HaveEL(EL2) then {
        Rmode_set(13, M32_Hyp) = __UNKNOWN_bits(32)
    };
    foreach (i from 13 to 14 by 1 in inc) {
        Rmode_set(i, M32_User) = __UNKNOWN_bits(32);
        Rmode_set(i, M32_FIQ) = __UNKNOWN_bits(32);
        Rmode_set(i, M32_IRQ) = __UNKNOWN_bits(32);
        Rmode_set(i, M32_Svc) = __UNKNOWN_bits(32);
        Rmode_set(i, M32_Abort) = __UNKNOWN_bits(32);
        Rmode_set(i, M32_Undef) = __UNKNOWN_bits(32);
        if HaveEL(EL3) then {
            Rmode_set(i, M32_Monitor) = __UNKNOWN_bits(32)
        };
        ()
    };
    return()
}

val AArch32_ResetSIMDFPRegisters : unit -> unit

function AArch32_ResetSIMDFPRegisters () = {
    foreach (i from 0 to 15 by 1 in inc) {
        Q_set(i) = __UNKNOWN_bits(128)
    };
    return()
}

val AArch32_ResetSpecialRegisters : unit -> unit

function AArch32_ResetSpecialRegisters () = {
    SPSR_fiq.bits[31 .. 0] = __UNKNOWN_bits(32);
    SPSR_irq.bits[31 .. 0] = __UNKNOWN_bits(32);
    SPSR_svc_write() = Mk_SPSR_svc_Type([SPSR_svc_read().bits with 31 .. 0 = __UNKNOWN_bits(32)]);
    SPSR_abt.bits[31 .. 0] = __UNKNOWN_bits(32);
    SPSR_und.bits[31 .. 0] = __UNKNOWN_bits(32);
    if HaveEL(EL2) then {
        SPSR_hyp_write() = Mk_SPSR_hyp_Type(__UNKNOWN_bits(32));
        ELR_hyp_write() = __UNKNOWN_bits(32)
    };
    if HaveEL(EL3) then {
        SPSR_mon = Mk_SPSR_mon_Type(__UNKNOWN_bits(32))
    };
    DLR_write() = __UNKNOWN_bits(32);
    DSPSR_write() = Mk_DSPSR_Type(__UNKNOWN_bits(32));
    return()
}

val AArch32_ExceptionReturn : (bits(32), bits(32)) -> unit

function AArch32_ExceptionReturn (new_pc_in, spsr) = {
    new_pc : bits(32) = new_pc_in;
    SynchronizeContext();
    __InstructionStep = false;
    SetPSTATEFromPSR(spsr);
    ClearExclusiveLocal(ProcessorID());
    SendEventLocal();
    if PSTATE.IL == 0b1 then {
        new_pc[1 .. 0] = __UNKNOWN_bits(2)
    } else {
        if PSTATE.T == 0b1 then {
            new_pc[0] = Bit(0b0)
        } else {
            new_pc[1 .. 0] = 0b00
        }
    };
    let branch_conditional : bool = not_bool((match AArch32_CurrentCond() {
      [bitone, bitone, bitone, _] => true,
      _ => false
    }) : bool);
    BranchTo(new_pc, BranchType_ERET, branch_conditional);
    CheckExceptionCatch(false)
}

val ALUExceptionReturn : bits(32) -> unit

function ALUExceptionReturn address = {
    if PSTATE.EL == EL2 then {
        throw(Error_Undefined())
    } else if PSTATE.M == M32_User | PSTATE.M == M32_System then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_ALUEXCEPTIONRETURN);
        assert(c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    } else {
        AArch32_ExceptionReturn(address, SPSR_read(32))
    }
}

val SelectInstrSet : InstrSet -> unit

function SelectInstrSet iset = {
    assert(CurrentInstrSet() == InstrSet_A32 | CurrentInstrSet() == InstrSet_T32);
    assert(iset == InstrSet_A32 | iset == InstrSet_T32);
    PSTATE.T = if iset == InstrSet_A32 then 0b0 else 0b1;
    return()
}

val BXWritePC : (bits(32), BranchType) -> unit

function BXWritePC (address_in, branch_type) = {
    address : bits(32) = address_in;
    if [address[0]] == 0b1 then {
        SelectInstrSet(InstrSet_T32);
        address[0] = Bit(0b0)
    } else {
        SelectInstrSet(InstrSet_A32);
        if [address[1]] == 0b1 & ConstrainUnpredictableBool(Unpredictable_A32FORCEALIGNPC) then {
            address[1] = Bit(0b0)
        };
        ()
    };
    let branch_conditional : bool = not_bool((match AArch32_CurrentCond() {
      [bitone, bitone, bitone, _] => true,
      _ => false
    }) : bool);
    BranchTo(address, branch_type, branch_conditional)
}

val BranchWritePC : (bits(32), BranchType) -> unit

function BranchWritePC (address_in, branch_type) = {
    address : bits(32) = address_in;
    if CurrentInstrSet() == InstrSet_A32 then {
        address[1 .. 0] = 0b00
    } else {
        address[0] = Bit(0b0)
    };
    let branch_conditional : bool = not_bool((match AArch32_CurrentCond() {
      [bitone, bitone, bitone, _] => true,
      _ => false
    }) : bool);
    BranchTo(address, branch_type, branch_conditional)
}

val ALUWritePC : bits(32) -> unit

function ALUWritePC address = {
    if CurrentInstrSet() == InstrSet_A32 then {
        BXWritePC(address, BranchType_INDIR)
    } else {
        BranchWritePC(address, BranchType_INDIR)
    }
}

val CBWritePC : bits(32) -> unit

function CBWritePC address_in = {
    address : bits(32) = address_in;
    assert(CurrentInstrSet() == InstrSet_T32);
    address[0] = Bit(0b0);
    let branch_conditional : bool = true;
    BranchTo(address, BranchType_DIR, branch_conditional)
}

val LoadWritePC : bits(32) -> unit

function LoadWritePC address = {
    BXWritePC(address, BranchType_INDIR)
}

val PCStoreValue : unit -> bits(32)

function PCStoreValue () = {
    return(PC_read__1())
}

val Din_read : forall 'n. int('n) -> bits(64)

function Din_read n = {
    assert(n >= 0 & n <= 31);
    return(_Dclone[n])
}

val Qin_read : forall 'n. int('n) -> bits(128)

function Qin_read n = {
    assert(n >= 0 & n <= 15);
    return(Din_read(2 * n + 1) @ Din_read(2 * n))
}

val AArch32_WriteModeByInstr : bits(5) -> unit

function AArch32_WriteModeByInstr mode = {
    el : bits(2) = undefined;
    valid_name : bool = undefined;
    (valid_name, el) = ELFromM32(mode);
    if UInt(el) > UInt(PSTATE.EL) then {
        valid_name = false
    };
    if (PSTATE.M == M32_Hyp | mode == M32_Hyp) & PSTATE.M != mode then {
        valid_name = false
    };
    if (((PSTATE.M == M32_Monitor & HaveEL(EL2)) & el == EL1) & SCR[NS] == 0b1) & HCR_read()[TGE] == 0b1 then {
        valid_name = false
    };
    let valid_name = valid_name;
    if not_bool(valid_name) then {
        PSTATE.IL = 0b1
    } else {
        AArch32_WriteMode(mode)
    }
}

val BankedRegisterAccessValid : (bits(5), bits(5)) -> unit

function BankedRegisterAccessValid (SYSm, mode) = {
    match SYSm {
      [bitzero, bitzero, bitzero, _, _] => {
          if mode != M32_FIQ then {
              throw(Error_Unpredictable())
          };
          ()
      },
      0b00100 => {
          if mode != M32_FIQ then {
              throw(Error_Unpredictable())
          };
          ()
      },
      0b00101 => {
          if mode == M32_System then {
              throw(Error_Unpredictable())
          };
          ()
      },
      0b00110 => {
          if mode == M32_Hyp | mode == M32_System then {
              throw(Error_Unpredictable())
          };
          ()
      },
      [bitzero, bitone, bitzero, _, _] => {
          if mode == M32_FIQ then {
              throw(Error_Unpredictable())
          };
          ()
      },
      [bitzero, bitone, bitone, bitzero, _] => {
          if mode == M32_FIQ then {
              throw(Error_Unpredictable())
          };
          ()
      },
      0b01110 => {
          if mode == M32_FIQ then {
              throw(Error_Unpredictable())
          };
          ()
      },
      [bitone, bitzero, bitzero, bitzero, _] => {
          if mode == M32_IRQ then {
              throw(Error_Unpredictable())
          };
          ()
      },
      [bitone, bitzero, bitzero, bitone, _] => {
          if mode == M32_Svc then {
              throw(Error_Unpredictable())
          };
          ()
      },
      [bitone, bitzero, bitone, bitzero, _] => {
          if mode == M32_Abort then {
              throw(Error_Unpredictable())
          };
          ()
      },
      [bitone, bitzero, bitone, bitone, _] => {
          if mode == M32_Undef then {
              throw(Error_Unpredictable())
          };
          ()
      },
      [bitone, bitone, bitone, bitzero, _] => {
          if (not_bool(HaveEL(EL3)) | CurrentSecurityState() != SS_Secure) | mode == M32_Monitor then {
              throw(Error_Unpredictable())
          };
          ()
      },
      0b11110 => {
          if not_bool(HaveEL(EL2)) | not_bool(mode == M32_Monitor | mode == M32_Hyp) then {
              throw(Error_Unpredictable())
          };
          ()
      },
      0b11111 => {
          if not_bool(HaveEL(EL2)) | mode != M32_Monitor then {
              throw(Error_Unpredictable())
          };
          ()
      },
      _ => {
          throw(Error_Unpredictable())
      }
    };
    return()
}

val ConditionPassed : unit -> bool

function ConditionPassed () = {
    return(ConditionHolds(AArch32_CurrentCond()))
}

val CPSRWriteByInstr : (bits(32), bits(4)) -> unit

function CPSRWriteByInstr (value_name, bytemask) = {
    let privileged : bool = PSTATE.EL != EL0;
    if [bytemask[3]] == 0b1 then {
        (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V @ PSTATE.Q) = value_name[31 .. 27]
    };
    if [bytemask[2]] == 0b1 then {
        if HaveSSBSExt() then {
            PSTATE.SSBS = [value_name[23]]
        };
        if privileged then {
            PSTATE.PAN = [value_name[22]]
        };
        if HaveDITExt() then {
            PSTATE.DIT = [value_name[21]]
        };
        PSTATE.GE = value_name[19 .. 16]
    };
    if [bytemask[1]] == 0b1 then {
        PSTATE.E = [value_name[9]];
        if privileged then {
            PSTATE.A = [value_name[8]]
        };
        ()
    };
    if [bytemask[0]] == 0b1 then {
        if privileged then {
            (PSTATE.I @ PSTATE.F) = value_name[7 .. 6];
            AArch32_WriteModeByInstr(value_name[4 .. 0])
        };
        ()
    };
    return()
}

val InITBlock : unit -> bool

function InITBlock () = {
    if CurrentInstrSet() == InstrSet_T32 then {
        return(PSTATE.IT[3 .. 0] != 0b0000)
    } else {
        return(false)
    }
}

val LastInITBlock : unit -> bool

function LastInITBlock () = {
    return(PSTATE.IT[3 .. 0] == 0b1000)
}

val SPSRaccessValid : (bits(5), bits(5)) -> unit

function SPSRaccessValid (SYSm, mode) = {
    match SYSm {
      0b01110 => {
          if mode == M32_FIQ then {
              throw(Error_Unpredictable())
          };
          ()
      },
      0b10000 => {
          if mode == M32_IRQ then {
              throw(Error_Unpredictable())
          };
          ()
      },
      0b10010 => {
          if mode == M32_Svc then {
              throw(Error_Unpredictable())
          };
          ()
      },
      0b10100 => {
          if mode == M32_Abort then {
              throw(Error_Unpredictable())
          };
          ()
      },
      0b10110 => {
          if mode == M32_Undef then {
              throw(Error_Unpredictable())
          };
          ()
      },
      0b11100 => {
          if (not_bool(HaveEL(EL3)) | mode == M32_Monitor) | CurrentSecurityState() != SS_Secure then {
              throw(Error_Unpredictable())
          };
          ()
      },
      0b11110 => {
          if not_bool(HaveEL(EL2)) | mode != M32_Monitor then {
              throw(Error_Unpredictable())
          };
          ()
      },
      _ => {
          throw(Error_Unpredictable())
      }
    };
    return()
}

val SPSRWriteByInstr : (bits(32), bits(4)) -> unit

function SPSRWriteByInstr (value_name, bytemask) = {
    new_spsr : bits(32) = SPSR_read(32);
    if [bytemask[3]] == 0b1 then {
        new_spsr[31 .. 24] = value_name[31 .. 24]
    };
    if [bytemask[2]] == 0b1 then {
        new_spsr[23 .. 16] = value_name[23 .. 16]
    };
    if [bytemask[1]] == 0b1 then {
        new_spsr[15 .. 8] = value_name[15 .. 8]
    };
    if [bytemask[0]] == 0b1 then {
        new_spsr[7 .. 0] = value_name[7 .. 0]
    };
    SPSR_set(32) = new_spsr;
    return()
}

val AArch32_SysRegReadCanWriteAPSR : forall 'cp_num.
  (int('cp_num), bits(32)) -> bool

function AArch32_SysRegReadCanWriteAPSR (cp_num, instr) = {
    assert(UsingAArch32());
    assert(cp_num == 14 | cp_num == 15);
    assert(cp_num == UInt(instr[11 .. 8]));
    let 'opc1 = UInt(instr[23 .. 21]);
    let 'opc2 = UInt(instr[7 .. 5]);
    let 'CRn = UInt(instr[19 .. 16]);
    let 'CRm = UInt(instr[3 .. 0]);
    if (((cp_num == 14 & opc1 == 0) & CRn == 0) & CRm == 1) & opc2 == 0 then {
        return(true)
    };
    return(false)
}

val UnsignedSat : forall 'N 'i, 0 <= 'N - 1. (int('i), int('N)) -> bits('N)

function UnsignedSat (i, N) = {
    result : bits('N) = undefined;
    let (__tup_0 : bits('N), _) = UnsignedSatQ(i, N) in
      {
          result = __tup_0
      };
    return(result)
}

val SignedSat : forall 'N 'i, 0 <= 'N - 1. (int('i), int('N)) -> bits('N)

function SignedSat (i, N) = {
    result : bits('N) = undefined;
    let (__tup_0 : bits('N), _) = SignedSatQ(i, N) in
      {
          result = __tup_0
      };
    return(result)
}

val Sat : forall 'N 'i ('is_unsigned : Bool),
  'N >= 0.
  (int('i), int('N), bool('is_unsigned)) -> bits('N)

function Sat (i, N, is_unsigned) = {
    let result : bits('N) = if is_unsigned then {
        assert(constraint(0 <= 'N - 1));
        UnsignedSat(i, N)
    } else {
        assert(constraint(0 <= 'N - 1));
        SignedSat(i, N)
    };
    return(result)
}

val AArch32_ESBOperation : unit -> unit

function AArch32_ESBOperation () = {
    el : bits(2) = undefined;
    route_to_aarch64 : bool = PSTATE.EL == EL0 & not_bool(ELUsingAArch32(EL1));
    if (not_bool(route_to_aarch64) & EL2Enabled()) & not_bool(ELUsingAArch32(EL2)) then {
        route_to_aarch64 = HCR_EL2[TGE] == 0b1 | HCR_EL2[AMO] == 0b1
    };
    if (not_bool(route_to_aarch64) & HaveEL(EL3)) & not_bool(ELUsingAArch32(EL3)) then {
        route_to_aarch64 = EffectiveEA() == 0b1
    };
    if route_to_aarch64 then {
        AArch64_ESBOperation();
        return()
    };
    let route_to_monitor : bool = (HaveEL(EL3) & ELUsingAArch32(EL3)) & EffectiveEA() == 0b1;
    let route_to_hyp : bool = ((PSTATE.EL == EL0 | PSTATE.EL == EL1) & EL2Enabled()) & (HCR_read()[TGE] == 0b1 | HCR_read()[AMO] == 0b1);
    target : bits(5) = undefined;
    if route_to_monitor then {
        target = M32_Monitor
    } else if route_to_hyp | PSTATE.M == M32_Hyp then {
        target = M32_Hyp
    } else {
        target = M32_Abort
    };
    mask_active : bool = undefined;
    if CurrentSecurityState() == SS_Secure then {
        mask_active = true
    } else if target == M32_Monitor then {
        mask_active = SCR[AW] == 0b1 & (not_bool(HaveEL(EL2)) | HCR_read()[TGE] == 0b0 & HCR_read()[AMO] == 0b0)
    } else {
        mask_active = target == M32_Abort | PSTATE.M == M32_Hyp
    };
    let mask_set : bool = PSTATE.A == 0b1;
    let (_, __tup_1 : bits(2)) = ELFromM32(target) in
      {
          el = __tup_1
      };
    let intdis : bool = Halted() | ExternalDebugInterruptsDisabled(el);
    let masked : bool = intdis | mask_active & mask_set;
    if masked & IsSynchronizablePhysicalSErrorPending() then {
        syndrome : bits(32) = Zeros(32);
        syndrome[31] = Bit(0b1);
        syndrome[15 .. 0] = AArch32_PhysicalSErrorSyndrome();
        DISR_write() = Mk_DISR_Type(syndrome);
        ClearPendingPhysicalSError()
    };
    return()
}

val AArch32_vESBOperation : unit -> unit

function AArch32_vESBOperation () = {
    assert((PSTATE.EL == EL0 | PSTATE.EL == EL1) & EL2Enabled());
    if not_bool(ELUsingAArch32(EL2)) then {
        AArch64_vESBOperation();
        return()
    };
    let vSEI_enabled : bool = HCR_read()[TGE] == 0b0 & HCR_read()[AMO] == 0b1;
    let vSEI_pending : bool = vSEI_enabled & HCR_read()[VA] == 0b1;
    let vintdis : bool = Halted() | ExternalDebugInterruptsDisabled(EL1);
    let vmasked : bool = vintdis | PSTATE.A == 0b1;
    if vSEI_pending & vmasked then {
        syndrome : bits(32) = Zeros(32);
        syndrome[31] = Bit(0b1);
        syndrome[15 .. 14] = VDFSR_read().bits[15 .. 14];
        syndrome[12] = Bit([VDFSR_read().bits[12]]);
        syndrome[9] = Bit(TTBCR_read()[EAE]);
        if TTBCR_read()[EAE] == 0b1 then {
            syndrome[5 .. 0] = 0b010001
        } else {
            (syndrome[10 .. 10] @ syndrome[3 .. 0]) = 0b10110
        };
        VDISR_write() = Mk_VDISR_Type(syndrome);
        HCR_write() = [HCR_read() with VA = 0b0]
    };
    return()
}

val AArch32_TakeReset : forall ('cold_reset : Bool). bool('cold_reset) -> unit

function AArch32_TakeReset cold_reset = {
    assert(not_bool(HaveAArch64()));
    if HaveEL(EL3) then {
        AArch32_WriteMode(M32_Svc);
        SCR[NS] = 0b0
    } else if HaveEL(EL2) then {
        AArch32_WriteMode(M32_Hyp)
    } else {
        AArch32_WriteMode(M32_Svc)
    };
    AArch32_ResetControlRegisters(cold_reset);
    FPEXC_write() = [FPEXC_read() with EN = 0b0];
    (PSTATE.A @ PSTATE.I @ PSTATE.F) = 0b111;
    PSTATE.IT = 0b00000000;
    if HaveEL(EL2) & not_bool(HaveEL(EL3)) then {
        PSTATE.T = HSCTLR_read()[TE];
        PSTATE.E = HSCTLR_read()[EE]
    } else {
        PSTATE.T = SCTLR_read__2()[TE];
        PSTATE.E = SCTLR_read__2()[EE]
    };
    PSTATE.IL = 0b0;
    // AArch32_ResetGeneralRegisters();
    AArch32_ResetSIMDFPRegisters();
    AArch32_ResetSpecialRegisters();
    ResetExternalDebugRegisters(cold_reset);
    rv : bits(32) = undefined;
    if HaveEL(EL3) then {
        if [MVBAR.bits[0]] == 0b1 then {
            rv = MVBAR.bits[31 .. 1] @ 0b0
        } else {
            rv = __IMPDEF_bits(32, "reset vector address")
        }
    } else {
        rv = RVBAR[31 .. 1] @ 0b0
    };
    assert([rv[0]] == 0b0 & (PSTATE.T == 0b1 | [rv[1]] == 0b0));
    let branch_conditional : bool = false;
    BranchTo(rv, BranchType_RESET, branch_conditional)
}

val AArch32_CheckAdvSIMDOrFPRegisterTraps : bits(4) -> unit

function AArch32_CheckAdvSIMDOrFPRegisterTraps reg = {
    tid0 : bits(1) = undefined;
    tid3 : bits(1) = undefined;
    if PSTATE.EL == EL1 & EL2Enabled() then {
        let tid0 : bits(1) = if ELUsingAArch32(EL2) then HCR_read()[TID0] else
          HCR_EL2[TID0];
        let tid3 : bits(1) = if ELUsingAArch32(EL2) then HCR_read()[TID3] else
          HCR_EL2[TID3];
        if tid0 == 0b1 & reg == 0b0000 | tid3 == 0b1 & (reg == 0b0101 | reg == 0b0110 | reg == 0b0111) then {
            if ELUsingAArch32(EL2) then {
                AArch32_SystemAccessTrap(M32_Hyp, UInt(0x8))
            } else {
                AArch64_AArch32SystemAccessTrap(EL2, UInt(0x8))
            }
        };
        ()
    };
    ()
}

val AArch32_TakeSMCException : unit -> unit

function AArch32_TakeSMCException () = {
    assert(HaveEL(EL3) & ELUsingAArch32(EL3));
    AArch32_ITAdvance();
    SSAdvance();
    let preferred_exception_return : bits(32) = NextInstrAddr(32);
    let 'vect_offset = UInt(0x08);
    let 'lr_offset = 0;
    AArch32_EnterMonitorMode(preferred_exception_return, lr_offset, vect_offset)
}

val AArch32_TakeHVCException : bits(16) -> unit

function AArch32_TakeHVCException immediate = {
    assert(HaveEL(EL2) & ELUsingAArch32(EL2));
    AArch32_ITAdvance();
    SSAdvance();
    let preferred_exception_return : bits(32) = NextInstrAddr(32);
    let 'vect_offset = UInt(0x08);
    except : ExceptionRecord = ExceptionSyndrome(Exception_HypervisorCall);
    except.syndrome[15 .. 0] = immediate;
    if PSTATE.EL == EL2 then {
        AArch32_EnterHypMode(except, preferred_exception_return, vect_offset)
    } else {
        AArch32_EnterHypMode(except, preferred_exception_return, UInt(0x14))
    }
}

val AArch32_CallHypervisor : bits(16) -> unit

function AArch32_CallHypervisor immediate = {
    assert(HaveEL(EL2));
    if not_bool(ELUsingAArch32(EL2)) then {
        AArch64_CallHypervisor(immediate)
    } else {
        AArch32_TakeHVCException(immediate)
    }
}

val AArch32_TakeSVCException : bits(16) -> unit

function AArch32_TakeSVCException immediate = {
    except : ExceptionRecord = undefined;
    AArch32_ITAdvance();
    SSAdvance();
    let route_to_hyp : bool = (PSTATE.EL == EL0 & EL2Enabled()) & HCR_read()[TGE] == 0b1;
    let preferred_exception_return : bits(32) = NextInstrAddr(32);
    let 'vect_offset = UInt(0x08);
    let 'lr_offset = 0;
    if PSTATE.EL == EL2 | route_to_hyp then {
        except : ExceptionRecord = ExceptionSyndrome(Exception_SupervisorCall);
        except.syndrome[15 .. 0] = immediate;
        if PSTATE.EL == EL2 then {
            AArch32_EnterHypMode(except, preferred_exception_return, vect_offset)
        } else {
            AArch32_EnterHypMode(except, preferred_exception_return, UInt(0x14))
        }
    } else {
        AArch32_EnterMode(M32_Svc, preferred_exception_return, lr_offset, vect_offset)
    }
}

val AArch32_CallSupervisor : bits(16) -> unit

function AArch32_CallSupervisor immediate_in = {
    immediate : bits(16) = immediate_in;
    if AArch32_CurrentCond() != 0b1110 then {
        immediate = __UNKNOWN_bits(16)
    };
    if AArch32_GeneralExceptionsToAArch64() then {
        AArch64_CallSupervisor(immediate)
    } else {
        AArch32_TakeSVCException(immediate)
    }
}

val AArch32_TakeMonitorTrapException : unit -> unit

function AArch32_TakeMonitorTrapException () = {
    assert(HaveEL(EL3) & ELUsingAArch32(EL3));
    let preferred_exception_return : bits(32) = ThisInstrAddr(32);
    let 'vect_offset = UInt(0x04);
    let 'lr_offset = if CurrentInstrSet() == InstrSet_A32 then 4 else 2;
    AArch32_EnterMonitorMode(preferred_exception_return, lr_offset, vect_offset)
}

val AArch32_UndefinedFault : unit -> unit

function AArch32_UndefinedFault () = {
    if AArch32_GeneralExceptionsToAArch64() then {
        AArch64_UndefinedFault()
    };
    AArch32_TakeUndefInstrException()
}

val AArch32_CheckIllegalState : unit -> unit

function AArch32_CheckIllegalState () = {
    except : ExceptionRecord = undefined;
    route_to_hyp : bool = undefined;
    vect_offset : int = undefined;
    if AArch32_GeneralExceptionsToAArch64() then {
        AArch64_CheckIllegalState()
    } else if PSTATE.IL == 0b1 then {
        let route_to_hyp : bool = (PSTATE.EL == EL0 & EL2Enabled()) & HCR_read()[TGE] == 0b1;
        let preferred_exception_return : bits(32) = ThisInstrAddr(32);
        let 'vect_offset = UInt(0x04);
        if PSTATE.EL == EL2 | route_to_hyp then {
            let except : ExceptionRecord = ExceptionSyndrome(Exception_IllegalState);
            if PSTATE.EL == EL2 then {
                AArch32_EnterHypMode(except, preferred_exception_return, vect_offset)
            } else {
                AArch32_EnterHypMode(except, preferred_exception_return, UInt(0x14))
            }
        } else {
            AArch32_TakeUndefInstrException()
        }
    } else ()
}

val AArch32_CheckForSVCTrap : bits(16) -> unit

function AArch32_CheckForSVCTrap immediate = {
    except : ExceptionRecord = undefined;
    route_to_el2 : bool = undefined;
    vect_offset : int = undefined;
    if HaveFGTExt() then {
        route_to_el2 : bool = false;
        if PSTATE.EL == EL0 then {
            route_to_el2 = ((not_bool(ELUsingAArch32(EL1)) & EL2Enabled()) & HFGITR_EL2[SVC_EL0] == 0b1) & (HCR_EL2[E2H] @ HCR_EL2[TGE]) != 0b11 & (not_bool(HaveEL(EL3)) | SCR_EL3[FGTEn] == 0b1)
        };
        if route_to_el2 then {
            except : ExceptionRecord = ExceptionSyndrome(Exception_SupervisorCall);
            except.syndrome[15 .. 0] = immediate;
            except.trappedsyscallinst = true;
            let preferred_exception_return : bits(64) = ThisInstrAddr(64);
            let 'vect_offset = UInt(0x0);
            sail_take_exception(None());
            AArch64_TakeException(EL2, except, preferred_exception_return, vect_offset)
        };
        ()
    };
    let route_to_el2 = route_to_el2;
    ()
}

val AArch32_CheckForSMCUndefOrTrap : unit -> unit

function AArch32_CheckForSMCUndefOrTrap () = {
    except : ExceptionRecord = undefined;
    route_to_hyp : bool = undefined;
    if not_bool(HaveEL(EL3)) | PSTATE.EL == EL0 then {
        throw(Error_Undefined())
    };
    if EL2Enabled() & not_bool(ELUsingAArch32(EL2)) then {
        AArch64_CheckForSMCUndefOrTrap(Zeros(16))
    } else {
        let route_to_hyp : bool = (EL2Enabled() & PSTATE.EL == EL1) & HCR_read()[TSC] == 0b1;
        if route_to_hyp then {
            let except : ExceptionRecord = ExceptionSyndrome(Exception_MonitorCall);
            AArch32_TakeHypTrapException__1(except)
        };
        ()
    }
}

val AArch32_CheckForWFxTrap : (bits(2), WFxType) -> unit

function AArch32_CheckForWFxTrap (target_el, wfxtype) = {
    except : ExceptionRecord = undefined;
    assert(HaveEL(target_el));
    if not_bool(ELUsingAArch32(target_el)) then {
        AArch64_CheckForWFxTrap(target_el, wfxtype);
        return()
    };
    let is_wfe : bool = wfxtype == WFxType_WFE;
    trap : bool = undefined;
    match target_el {
      ? if ? == EL1 => {
          trap = (if is_wfe then SCTLR_read__2()[nTWE] else
            SCTLR_read__2()[nTWI]) == 0b0
      },
      ? if ? == EL2 => {
          trap = (if is_wfe then HCR_read()[TWE] else HCR_read()[TWI]) == 0b1
      },
      ? if ? == EL3 => {
          trap = (if is_wfe then SCR[TWE] else SCR[TWI]) == 0b1
      },
      _ => ()
    };
    if trap then {
        if ((target_el == EL1 & EL2Enabled()) & not_bool(ELUsingAArch32(EL2))) & HCR_EL2[TGE] == 0b1 then {
            AArch64_WFxTrap(wfxtype, target_el)
        };
        if target_el == EL3 then {
            AArch32_TakeMonitorTrapException()
        } else if target_el == EL2 then {
            except : ExceptionRecord = ExceptionSyndrome(Exception_WFxTrap);
            except.syndrome[24 .. 20] = ConditionSyndrome();
            match wfxtype {
              WFxType_WFI => {
                  except.syndrome[0] = Bit(0b0)
              },
              WFxType_WFE => {
                  except.syndrome[0] = Bit(0b1)
              },
              _ => ()
            };
            AArch32_TakeHypTrapException__1(except)
        } else {
            AArch32_TakeUndefInstrException()
        }
    };
    ()
}

val AArch32_CheckITEnabled : bits(4) -> unit

function AArch32_CheckITEnabled mask = {
    accdesc : AccessDescriptor = undefined;
    aligned : bool = undefined;
    next_instr : bits(16) = undefined;
    it_disabled : bits(1) = undefined;
    if PSTATE.EL == EL2 then {
        it_disabled = HSCTLR_read()[ITD]
    } else {
        it_disabled = if ELUsingAArch32(EL1) then SCTLR_read__2()[ITD] else
          SCTLR_read__1()[ITD]
    };
    if it_disabled == 0b1 then {
        if mask != 0b1000 then {
            throw(Error_Undefined())
        };
        let accdesc : AccessDescriptor = CreateAccDescIFetch();
        let aligned : bool = true;
        let next_instr : bits(16) = AArch32_MemSingle_read(NextInstrAddr(32), 2, accdesc, aligned);
        if (match next_instr {
          [bitone, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _, _] => true,
          [bitone, bitzero, bitone, bitone, _, _, _, _, _, _, _, _, _, _, _, _] => true,
          [bitone, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _, _] => true,
          [bitzero, bitone, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _, _] => true,
          [bitzero, bitone, bitzero, bitzero, bitzero, bitone, _, _, _, bitone, bitone, bitone, bitone, _, _, _] => true,
          [bitzero, bitone, bitzero, bitzero, bitzero, bitone, _, _, bitone, _, _, _, _, bitone, bitone, bitone] => true,
          _ => false
        }) : bool then {
            throw(Error_Undefined())
        };
        ()
    };
    return()
}

val AArch32_CheckSETENDEnabled : unit -> unit

function AArch32_CheckSETENDEnabled () = {
    setend_disabled : bits(1) = undefined;
    if PSTATE.EL == EL2 then {
        setend_disabled = HSCTLR_read()[SED]
    } else {
        setend_disabled = if ELUsingAArch32(EL1) then SCTLR_read__2()[SED] else
          SCTLR_read__1()[SED]
    };
    if setend_disabled == 0b1 then {
        throw(Error_Undefined())
    };
    let setend_disabled = setend_disabled;
    return()
}

val AArch32_TakePhysicalSErrorException : forall ('implicit_esb : Bool).
  bool('implicit_esb) -> unit

function AArch32_TakePhysicalSErrorException implicit_esb = {
    route_to_aarch64 : bool = PSTATE.EL == EL0 & not_bool(ELUsingAArch32(EL1));
    if (not_bool(route_to_aarch64) & EL2Enabled()) & not_bool(ELUsingAArch32(EL2)) then {
        route_to_aarch64 = HCR_EL2[TGE] == 0b1 | not_bool(IsInHost()) & HCR_EL2[AMO] == 0b1
    };
    if (not_bool(route_to_aarch64) & HaveEL(EL3)) & not_bool(ELUsingAArch32(EL3)) then {
        route_to_aarch64 = EffectiveEA() == 0b1
    };
    if route_to_aarch64 then {
        AArch64_TakePhysicalSErrorException(implicit_esb)
    };
    let route_to_monitor : bool = HaveEL(EL3) & SCR[EA] == 0b1;
    let route_to_hyp : bool = ((PSTATE.EL == EL0 | PSTATE.EL == EL1) & EL2Enabled()) & (HCR_read()[TGE] == 0b1 | HCR_read()[AMO] == 0b1);
    let preferred_exception_return : bits(32) = ThisInstrAddr(32);
    let 'vect_offset = UInt(0x10);
    let 'lr_offset = 8;
    target_el : bits(2) = undefined;
    if route_to_monitor then {
        target_el = EL3
    } else if PSTATE.EL == EL2 | route_to_hyp then {
        target_el = EL2
    } else {
        target_el = EL1
    };
    let fault : FaultRecord = GetPendingPhysicalSError();
    let vaddress : bits(32) = __UNKNOWN_bits(32);
    let except : ExceptionRecord = AArch32_AbortSyndrome(Exception_DataAbort, fault, vaddress, target_el);
    if IsSErrorEdgeTriggered() then {
        ClearPendingPhysicalSError()
    };
    match target_el {
      ? if ? == EL3 => {
          AArch32_ReportDataAbort(route_to_monitor, fault, vaddress);
          AArch32_EnterMonitorMode(preferred_exception_return, lr_offset, vect_offset)
      },
      ? if ? == EL2 => {
          if PSTATE.EL == EL2 then {
              AArch32_EnterHypMode(except, preferred_exception_return, vect_offset)
          } else {
              AArch32_EnterHypMode(except, preferred_exception_return, UInt(0x14))
          }
      },
      ? if ? == EL1 => {
          AArch32_ReportDataAbort(route_to_monitor, fault, vaddress);
          AArch32_EnterMode(M32_Abort, preferred_exception_return, lr_offset, vect_offset)
      },
      _ => {
          Unreachable()
      }
    }
}

val AArch32_TakeVirtualSErrorException : unit -> unit

function AArch32_TakeVirtualSErrorException () = {
    assert((PSTATE.EL == EL0 | PSTATE.EL == EL1) & EL2Enabled());
    if ELUsingAArch32(EL2) then {
        assert(HCR_read()[TGE] == 0b0 & HCR_read()[AMO] == 0b1)
    } else {
        assert(HCR_EL2[TGE] == 0b0 & HCR_EL2[AMO] == 0b1)
    };
    if PSTATE.EL == EL0 & not_bool(ELUsingAArch32(EL1)) then {
        AArch64_TakeVirtualSErrorException()
    };
    let route_to_monitor : bool = false;
    let preferred_exception_return : bits(32) = ThisInstrAddr(32);
    let 'vect_offset = UInt(0x10);
    let 'lr_offset = 8;
    let vaddress : bits(32) = __UNKNOWN_bits(32);
    let parity : bool = false;
    let fault : Fault = Fault_AsyncExternal;
    let 'level = __UNKNOWN_integer();
    fsr : bits(32) = Zeros(32);
    if HaveRASExt() then {
        if ELUsingAArch32(EL2) then {
            fsr[15 .. 14] = VDFSR_read()[AET];
            fsr[12] = Bit(VDFSR_read()[ExT])
        } else {
            fsr[15 .. 14] = VSESR_EL2[AET];
            fsr[12] = Bit(VSESR_EL2[ExT])
        }
    } else {
        fsr[12] = Bit(__IMPDEF_bit("Virtual External abort type"))
    };
    if TTBCR_read()[EAE] == 0b1 then {
        fsr[9] = Bit(0b1);
        fsr[5 .. 0] = EncodeLDFSC(fault, level)
    } else {
        fsr[9] = Bit(0b0);
        (fsr[10 .. 10] @ fsr[3 .. 0]) = EncodeSDFSC(fault, level)
    };
    DFSR_write() = Mk_DFSR_Type(fsr);
    DFAR_write() = __UNKNOWN_bits(32);
    ClearPendingVirtualSError();
    AArch32_EnterMode(M32_Abort, preferred_exception_return, lr_offset, vect_offset)
}

val AArch32_TakePhysicalIRQException : unit -> unit

function AArch32_TakePhysicalIRQException () = {
    except : ExceptionRecord = undefined;
    route_to_aarch64 : bool = PSTATE.EL == EL0 & not_bool(ELUsingAArch32(EL1));
    if (not_bool(route_to_aarch64) & EL2Enabled()) & not_bool(ELUsingAArch32(EL2)) then {
        route_to_aarch64 = HCR_EL2[TGE] == 0b1 | HCR_EL2[IMO] == 0b1 & not_bool(IsInHost())
    };
    if (not_bool(route_to_aarch64) & HaveEL(EL3)) & not_bool(ELUsingAArch32(EL3)) then {
        route_to_aarch64 = SCR_EL3[IRQ] == 0b1
    };
    if route_to_aarch64 then {
        AArch64_TakePhysicalIRQException()
    };
    let route_to_monitor : bool = HaveEL(EL3) & SCR[IRQ] == 0b1;
    let route_to_hyp : bool = ((PSTATE.EL == EL0 | PSTATE.EL == EL1) & EL2Enabled()) & (HCR_read()[TGE] == 0b1 | HCR_read()[IMO] == 0b1);
    let preferred_exception_return : bits(32) = ThisInstrAddr(32);
    let 'vect_offset = UInt(0x18);
    let 'lr_offset = 4;
    if route_to_monitor then {
        AArch32_EnterMonitorMode(preferred_exception_return, lr_offset, vect_offset)
    } else if PSTATE.EL == EL2 | route_to_hyp then {
        let except : ExceptionRecord = ExceptionSyndrome(Exception_IRQ);
        AArch32_EnterHypMode(except, preferred_exception_return, vect_offset)
    } else {
        AArch32_EnterMode(M32_IRQ, preferred_exception_return, lr_offset, vect_offset)
    }
}

val AArch32_TakeVirtualIRQException : unit -> unit

function AArch32_TakeVirtualIRQException () = {
    assert((PSTATE.EL == EL0 | PSTATE.EL == EL1) & EL2Enabled());
    if ELUsingAArch32(EL2) then {
        assert(HCR_read()[TGE] == 0b0 & HCR_read()[IMO] == 0b1)
    } else {
        assert(HCR_EL2[TGE] == 0b0 & HCR_EL2[IMO] == 0b1)
    };
    if PSTATE.EL == EL0 & not_bool(ELUsingAArch32(EL1)) then {
        AArch64_TakeVirtualIRQException()
    };
    let preferred_exception_return : bits(32) = ThisInstrAddr(32);
    let 'vect_offset = UInt(0x18);
    let 'lr_offset = 4;
    AArch32_EnterMode(M32_IRQ, preferred_exception_return, lr_offset, vect_offset)
}

val AArch32_TakePhysicalFIQException : unit -> unit

function AArch32_TakePhysicalFIQException () = {
    except : ExceptionRecord = undefined;
    route_to_aarch64 : bool = PSTATE.EL == EL0 & not_bool(ELUsingAArch32(EL1));
    if (not_bool(route_to_aarch64) & EL2Enabled()) & not_bool(ELUsingAArch32(EL2)) then {
        route_to_aarch64 = HCR_EL2[TGE] == 0b1 | HCR_EL2[FMO] == 0b1 & not_bool(IsInHost())
    };
    if (not_bool(route_to_aarch64) & HaveEL(EL3)) & not_bool(ELUsingAArch32(EL3)) then {
        route_to_aarch64 = SCR_EL3[FIQ] == 0b1
    };
    if route_to_aarch64 then {
        AArch64_TakePhysicalFIQException()
    };
    let route_to_monitor : bool = HaveEL(EL3) & SCR[FIQ] == 0b1;
    let route_to_hyp : bool = ((PSTATE.EL == EL0 | PSTATE.EL == EL1) & EL2Enabled()) & (HCR_read()[TGE] == 0b1 | HCR_read()[FMO] == 0b1);
    let preferred_exception_return : bits(32) = ThisInstrAddr(32);
    let 'vect_offset = UInt(0x1C);
    let 'lr_offset = 4;
    if route_to_monitor then {
        AArch32_EnterMonitorMode(preferred_exception_return, lr_offset, vect_offset)
    } else if PSTATE.EL == EL2 | route_to_hyp then {
        let except : ExceptionRecord = ExceptionSyndrome(Exception_FIQ);
        AArch32_EnterHypMode(except, preferred_exception_return, vect_offset)
    } else {
        AArch32_EnterMode(M32_FIQ, preferred_exception_return, lr_offset, vect_offset)
    }
}

val AArch32_TakeVirtualFIQException : unit -> unit

function AArch32_TakeVirtualFIQException () = {
    assert((PSTATE.EL == EL0 | PSTATE.EL == EL1) & EL2Enabled());
    if ELUsingAArch32(EL2) then {
        assert(HCR_read()[TGE] == 0b0 & HCR_read()[FMO] == 0b1)
    } else {
        assert(HCR_EL2[TGE] == 0b0 & HCR_EL2[FMO] == 0b1)
    };
    if PSTATE.EL == EL0 & not_bool(ELUsingAArch32(EL1)) then {
        AArch64_TakeVirtualFIQException()
    };
    let preferred_exception_return : bits(32) = ThisInstrAddr(32);
    let 'vect_offset = UInt(0x1C);
    let 'lr_offset = 4;
    AArch32_EnterMode(M32_FIQ, preferred_exception_return, lr_offset, vect_offset)
}

val AArch32_SoftwareBreakpoint : bits(16) -> unit

function AArch32_SoftwareBreakpoint immediate = {
    if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (HCR_EL2[TGE] == 0b1 | MDCR_EL2[TDE] == 0b1) | not_bool(ELUsingAArch32(EL1)) then {
        AArch64_SoftwareBreakpoint(immediate)
    };
    let accdesc : AccessDescriptor = CreateAccDescIFetch();
    fault : FaultRecord = NoFault__1(accdesc);
    let vaddress : bits(32) = __UNKNOWN_bits(32);
    fault.statuscode = Fault_Debug;
    fault.debugmoe = DebugException_BKPT;
    AArch32_Abort(vaddress, fault)
}

val AArch32_CheckPCAlignment : unit -> unit

function AArch32_CheckPCAlignment () = {
    let pc : bits(32) = ThisInstrAddr(32);
    if CurrentInstrSet() == InstrSet_A32 & [pc[1]] == 0b1 | [pc[0]] == 0b1 then {
        if AArch32_GeneralExceptionsToAArch64() then {
            AArch64_PCAlignmentFault()
        };
        let accdesc : AccessDescriptor = CreateAccDescIFetch();
        fault : FaultRecord = NoFault__1(accdesc);
        fault.statuscode = Fault_Alignment;
        AArch32_Abort(pc, fault)
    };
    ()
}

type PMEVCNTR_Type = bits(32)

register _PMEVCNTR : vector(31, PMEVCNTR_Type)

val PMEVCNTR_read : forall 'n, (0 <= 'n & 'n < 31). int('n) -> PMEVCNTR_Type

function PMEVCNTR_read n = {
    r : PMEVCNTR_Type = _PMEVCNTR[n];
    r[31 .. 0] = Slice(PMEVCNTR_EL0[n], 0, 32);
    return(r)
}

val PMEVCNTR_set : forall 'n, (0 <= 'n & 'n < 31).
  (int('n), PMEVCNTR_Type) -> unit

function PMEVCNTR_set (n, value_name) = {
    let r : PMEVCNTR_Type = value_name;
    PMEVCNTR_EL0[n][31 .. 0] = Slice(r, 0, 32);
    _PMEVCNTR[n] = r;
    return()
}

val PMOVSR_write : PMOVSR_Type -> unit

function PMOVSR_write value_name = {
    let r : PMOVSR_Type = value_name;
    PMOVSCLR_EL0.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _PMOVSR = r;
    return()
}

bitfield PMOVSSET_Type : bits(32) =
  {
    C : 31..31,
    P30 : 30..30,
    P29 : 29..29,
    P28 : 28..28,
    P27 : 27..27,
    P26 : 26..26,
    P25 : 25..25,
    P24 : 24..24,
    P23 : 23..23,
    P22 : 22..22,
    P21 : 21..21,
    P20 : 20..20,
    P19 : 19..19,
    P18 : 18..18,
    P17 : 17..17,
    P16 : 16..16,
    P15 : 15..15,
    P14 : 14..14,
    P13 : 13..13,
    P12 : 12..12,
    P11 : 11..11,
    P10 : 10..10,
    P9 : 9..9,
    P8 : 8..8,
    P7 : 7..7,
    P6 : 6..6,
    P5 : 5..5,
    P4 : 4..4,
    P3 : 3..3,
    P2 : 2..2,
    P1 : 1..1,
    P0 : 0..0
  }

register _PMOVSSET : PMOVSSET_Type

val PMOVSSET_read : unit -> PMOVSSET_Type

function PMOVSSET_read () = {
    r : PMOVSSET_Type = _PMOVSSET;
    r.bits[31 .. 0] = Slice(PMOVSSET_EL0.bits, 0, 32);
    return(r)
}

val PMOVSSET_write : PMOVSSET_Type -> unit

function PMOVSSET_write value_name = {
    let r : PMOVSSET_Type = value_name;
    PMOVSSET_EL0.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _PMOVSSET = r;
    return()
}

val AArch32_IncrementEventCounter : forall 'idx 'increment_name,
  (0 <= 'idx & 'idx < 31).
  (int('idx), int('increment_name)) -> unit

function AArch32_IncrementEventCounter (idx, increment_name) = {
    if HaveAArch64() then {
        assert(constraint(0 <= 'idx));
        assert(constraint('idx < 31));
        AArch64_IncrementEventCounter(idx, increment_name);
        return()
    };
    let 'old_value = UInt(PMEVCNTR_read(idx));
    let 'new_value = old_value + PMUCountValue(idx, increment_name);
    PMEVCNTR_set(idx) = new_value[31 .. 0];
    let 'ovflw = 32;
    if old_value[64 .. ovflw] != new_value[64 .. ovflw] then {
        PMOVSSET_write() = Mk_PMOVSSET_Type([PMOVSSET_read().bits with idx .. idx = 0b1]);
        PMOVSR_write() = Mk_PMOVSR_Type([PMOVSR_read().bits with idx .. idx = 0b1]);
        if [idx[0]] == 0b0 & idx + 1 < GetNumEventCounters() then {
            PMUEvent__2(PMU_EVENT_CHAIN, 1, idx + 1)
        };
        ()
    };
    ()
}

val AArch32_ClearEventCounters : unit -> unit

function AArch32_ClearEventCounters () = {
    if HaveAArch64() then {
        AArch64_ClearEventCounters();
        return()
    };
    let 'counters = AArch32_GetNumEventCountersAccessible();
    if counters != 0 then {
        foreach (idx from 0 to (counters - 1) by 1 in inc) {
            assert(constraint(0 <= 'loop_idx));
            assert(constraint('loop_idx < 31));
            PMEVCNTR_set(idx) = Zeros(32)
        }
    };
    ()
}

val AArch32_PMUSwIncrement : bits(32) -> unit

function AArch32_PMUSwIncrement sw_incr = {
    if PMCR_read()[E] == 0b0 & HDCR_read()[HPME] == 0b0 then {
        return()
    };
    let 'counters = AArch32_GetNumEventCountersAccessible();
    if counters != 0 then {
        foreach (idx from 0 to (counters - 1) by 1 in inc) {
            assert(constraint((0 <= 'loop_idx & 'loop_idx < 32)));
            if [sw_incr[idx]] == 0b1 then {
                PMUEvent__2(PMU_EVENT_SW_INCR, 1, idx)
            };
            ()
        }
    };
    ()
}

bitfield PMCCNTR_Type : bits(64) = {CCNT : 63..0}

register _PMCCNTR : PMCCNTR_Type

val PMCCNTR_read : unit -> PMCCNTR_Type

function PMCCNTR_read () = {
    r : PMCCNTR_Type = _PMCCNTR;
    r.bits[63 .. 0] = Slice(PMCCNTR_EL0.bits, 0, 64);
    return(r)
}

val PMCCNTR_write : PMCCNTR_Type -> unit

function PMCCNTR_write value_name = {
    let r : PMCCNTR_Type = value_name;
    PMCCNTR_EL0.bits[63 .. 0] = Slice(r.bits, 0, 64);
    _PMCCNTR = r;
    return()
}

val AArch32_IncrementCycleCounter : unit -> unit

function AArch32_IncrementCycleCounter () = {
    if CountPMUEvents(CYCLE_COUNTER_ID) & ((PMCR_read()[LC] == 0b1 | PMCR_read()[D] == 0b0) | HasElapsed64Cycles()) then {
        let 'old_value = UInt(PMCCNTR_read().bits);
        let 'new_value = old_value + 1;
        PMCCNTR_write() = Mk_PMCCNTR_Type(new_value[63 .. 0]);
        let 'ovflw = if PMCR_read()[LC] == 0b1 then 64 else 32;
        if old_value[64 .. ovflw] != new_value[64 .. ovflw] then {
            PMOVSSET_write() = [PMOVSSET_read() with C = 0b1];
            PMOVSR_write() = [PMOVSR_read() with C = 0b1]
        };
        ()
    };
    ()
}

val AArch32_PMUCycle : unit -> unit

function AArch32_PMUCycle () = {
    if PMCR_read()[E] == 0b0 & HDCR_read()[HPME] == 0b0 then {
        if ShouldBRBEFreeze() then {
            BRBEFreeze()
        };
        return()
    };
    if HaveAArch64() then {
        AArch64_PMUCycle();
        return()
    };
    if not_bool(HavePMUv3()) then {
        return()
    };
    PMUEvent(PMU_EVENT_CPU_CYCLES);
    let 'counters = GetNumEventCounters();
    if counters != 0 then {
        foreach (idx from 0 to (counters - 1) by 1 in inc) {
            assert(constraint((0 <= 'loop_idx & 'loop_idx <= 32)));
            if CountPMUEvents(idx) then {
                assert(constraint((0 <= 'loop_idx & 'loop_idx < 31)));
                let 'accumulated = PMUEventAccumulator[idx];
                AArch32_IncrementEventCounter(idx, accumulated)
            };
            assert(constraint((0 <= 'loop_idx & 'loop_idx < 31)));
            PMUEventAccumulator[idx] = 0
        }
    };
    AArch32_IncrementCycleCounter();
    CheckForPMUOverflow()
}

val AArch32_DTLBI_ALL : (SecurityState, Regime, Shareability, TLBIMemAttr) -> unit

function AArch32_DTLBI_ALL (security, regime, shareability, attr) = {
    assert(PSTATE.EL == EL3 | PSTATE.EL == EL2 | PSTATE.EL == EL1);
    r : TLBIRecord = undefined;
    r.op = TLBIOp_DALL;
    r.from_aarch64 = false;
    r.security = security;
    r.regime = regime;
    r.level = TLBILevel_Any;
    r.attr = attr;
    TLBI(r, shareability);
    if shareability != Shareability_NSH then {
        Broadcast(shareability, r)
    };
    return()
}

val AArch32_DTLBI_ASID : (SecurityState, Regime, bits(16), Shareability, TLBIMemAttr, bits(32)) -> unit

function AArch32_DTLBI_ASID (security, regime, vmid, shareability, attr, Rt) = {
    assert(PSTATE.EL == EL3 | PSTATE.EL == EL2 | PSTATE.EL == EL1);
    r : TLBIRecord = undefined;
    r.op = TLBIOp_DASID;
    r.from_aarch64 = false;
    r.security = security;
    r.regime = regime;
    r.vmid = vmid;
    r.level = TLBILevel_Any;
    r.attr = attr;
    r.asid = Zeros(8) @ Rt[7 .. 0];
    TLBI(r, shareability);
    if shareability != Shareability_NSH then {
        Broadcast(shareability, r)
    };
    return()
}

val AArch32_DTLBI_VA : (SecurityState, Regime, bits(16), Shareability, TLBILevel, TLBIMemAttr, bits(32)) -> unit

function AArch32_DTLBI_VA (security, regime, vmid, shareability, level, attr, Rt) = {
    assert(PSTATE.EL == EL3 | PSTATE.EL == EL2 | PSTATE.EL == EL1);
    r : TLBIRecord = undefined;
    r.op = TLBIOp_DVA;
    r.from_aarch64 = false;
    r.security = security;
    r.regime = regime;
    r.vmid = vmid;
    r.level = level;
    r.attr = attr;
    r.asid = Zeros(8) @ Rt[7 .. 0];
    r.address = (Zeros(32) @ Rt[31 .. 12]) @ Zeros(12);
    TLBI(r, shareability);
    if shareability != Shareability_NSH then {
        Broadcast(shareability, r)
    };
    return()
}

val AArch32_ITLBI_ALL : (SecurityState, Regime, Shareability, TLBIMemAttr) -> unit

function AArch32_ITLBI_ALL (security, regime, shareability, attr) = {
    assert(PSTATE.EL == EL3 | PSTATE.EL == EL2 | PSTATE.EL == EL1);
    r : TLBIRecord = undefined;
    r.op = TLBIOp_IALL;
    r.from_aarch64 = false;
    r.security = security;
    r.regime = regime;
    r.level = TLBILevel_Any;
    r.attr = attr;
    TLBI(r, shareability);
    if shareability != Shareability_NSH then {
        Broadcast(shareability, r)
    };
    return()
}

val AArch32_ITLBI_ASID : (SecurityState, Regime, bits(16), Shareability, TLBIMemAttr, bits(32)) -> unit

function AArch32_ITLBI_ASID (security, regime, vmid, shareability, attr, Rt) = {
    assert(PSTATE.EL == EL3 | PSTATE.EL == EL2 | PSTATE.EL == EL1);
    r : TLBIRecord = undefined;
    r.op = TLBIOp_IASID;
    r.from_aarch64 = false;
    r.security = security;
    r.regime = regime;
    r.vmid = vmid;
    r.level = TLBILevel_Any;
    r.attr = attr;
    r.asid = Zeros(8) @ Rt[7 .. 0];
    TLBI(r, shareability);
    if shareability != Shareability_NSH then {
        Broadcast(shareability, r)
    };
    return()
}

val AArch32_ITLBI_VA : (SecurityState, Regime, bits(16), Shareability, TLBILevel, TLBIMemAttr, bits(32)) -> unit

function AArch32_ITLBI_VA (security, regime, vmid, shareability, level, attr, Rt) = {
    assert(PSTATE.EL == EL3 | PSTATE.EL == EL2 | PSTATE.EL == EL1);
    r : TLBIRecord = undefined;
    r.op = TLBIOp_IVA;
    r.from_aarch64 = false;
    r.security = security;
    r.regime = regime;
    r.vmid = vmid;
    r.level = level;
    r.attr = attr;
    r.asid = Zeros(8) @ Rt[7 .. 0];
    r.address = (Zeros(32) @ Rt[31 .. 12]) @ Zeros(12);
    TLBI(r, shareability);
    if shareability != Shareability_NSH then {
        Broadcast(shareability, r)
    };
    return()
}

val AArch32_TLBI_ALL : (SecurityState, Regime, Shareability, TLBIMemAttr) -> unit

function AArch32_TLBI_ALL (security, regime, shareability, attr) = {
    assert(PSTATE.EL == EL3 | PSTATE.EL == EL2);
    r : TLBIRecord = undefined;
    r.op = TLBIOp_ALL;
    r.from_aarch64 = false;
    r.security = security;
    r.regime = regime;
    r.level = TLBILevel_Any;
    r.attr = attr;
    TLBI(r, shareability);
    if shareability != Shareability_NSH then {
        Broadcast(shareability, r)
    };
    return()
}

val AArch32_TLBI_VMALL : (SecurityState, Regime, bits(16), Shareability, TLBIMemAttr) -> unit

function AArch32_TLBI_VMALL (security, regime, vmid, shareability, attr) = {
    assert(PSTATE.EL == EL3 | PSTATE.EL == EL2 | PSTATE.EL == EL1);
    r : TLBIRecord = undefined;
    r.op = TLBIOp_VMALL;
    r.from_aarch64 = false;
    r.security = security;
    r.regime = regime;
    r.level = TLBILevel_Any;
    r.vmid = vmid;
    r.attr = attr;
    TLBI(r, shareability);
    if shareability != Shareability_NSH then {
        Broadcast(shareability, r)
    };
    return()
}

val AArch32_TLBI_ASID : (SecurityState, Regime, bits(16), Shareability, TLBIMemAttr, bits(32)) -> unit

function AArch32_TLBI_ASID (security, regime, vmid, shareability, attr, Rt) = {
    assert(PSTATE.EL == EL3 | PSTATE.EL == EL2 | PSTATE.EL == EL1);
    r : TLBIRecord = undefined;
    r.op = TLBIOp_ASID;
    r.from_aarch64 = false;
    r.security = security;
    r.regime = regime;
    r.vmid = vmid;
    r.level = TLBILevel_Any;
    r.attr = attr;
    r.asid = Zeros(8) @ Rt[7 .. 0];
    TLBI(r, shareability);
    if shareability != Shareability_NSH then {
        Broadcast(shareability, r)
    };
    return()
}

val AArch32_TLBI_VA : (SecurityState, Regime, bits(16), Shareability, TLBILevel, TLBIMemAttr, bits(32)) -> unit

function AArch32_TLBI_VA (security, regime, vmid, shareability, level, attr, Rt) = {
    assert(PSTATE.EL == EL3 | PSTATE.EL == EL2 | PSTATE.EL == EL1);
    r : TLBIRecord = undefined;
    r.op = TLBIOp_VA;
    r.from_aarch64 = false;
    r.security = security;
    r.regime = regime;
    r.vmid = vmid;
    r.level = level;
    r.attr = attr;
    r.asid = Zeros(8) @ Rt[7 .. 0];
    r.address = (Zeros(32) @ Rt[31 .. 12]) @ Zeros(12);
    TLBI(r, shareability);
    if shareability != Shareability_NSH then {
        Broadcast(shareability, r)
    };
    return()
}

val AArch32_TLBI_VAA : (SecurityState, Regime, bits(16), Shareability, TLBILevel, TLBIMemAttr, bits(32)) -> unit

function AArch32_TLBI_VAA (security, regime, vmid, shareability, level, attr, Rt) = {
    assert(PSTATE.EL == EL3 | PSTATE.EL == EL2 | PSTATE.EL == EL1);
    r : TLBIRecord = undefined;
    r.op = TLBIOp_VAA;
    r.from_aarch64 = false;
    r.security = security;
    r.regime = regime;
    r.vmid = vmid;
    r.level = level;
    r.attr = attr;
    r.address = (Zeros(32) @ Rt[31 .. 12]) @ Zeros(12);
    TLBI(r, shareability);
    if shareability != Shareability_NSH then {
        Broadcast(shareability, r)
    };
    return()
}

val AArch32_TLBI_IPAS2 : (SecurityState, Regime, bits(16), Shareability, TLBILevel, TLBIMemAttr, bits(32)) -> unit

function AArch32_TLBI_IPAS2 (security, regime, vmid, shareability, level, attr, Rt) = {
    assert(PSTATE.EL == EL3 | PSTATE.EL == EL2);
    assert(security == SS_NonSecure);
    r : TLBIRecord = undefined;
    r.op = TLBIOp_IPAS2;
    r.from_aarch64 = false;
    r.security = security;
    r.regime = regime;
    r.vmid = vmid;
    r.level = level;
    r.attr = attr;
    r.address = (Zeros(24) @ Rt[27 .. 0]) @ Zeros(12);
    r.ipaspace = PAS_NonSecure;
    TLBI(r, shareability);
    if shareability != Shareability_NSH then {
        Broadcast(shareability, r)
    };
    return()
}

bitfield ID_MMFR2_EL1_Type : bits(64) =
  {
    HWAccFlg : 31..28,
    WFIStall : 27..24,
    MemBarr : 23..20,
    UniTLB : 19..16,
    HvdTLB : 15..12,
    L1HvdRng : 11..8,
    L1HvdBG : 7..4,
    L1HvdFG : 3..0
  }

register ID_MMFR2_EL1 : ID_MMFR2_EL1_Type

bitfield ID_MMFR4_EL1_Type : bits(64) =
  {
    EVT : 31..28,
    CCIDX : 27..24,
    LSM : 23..20,
    HPDS : 19..16,
    CnP : 15..12,
    XNX : 11..8,
    AC2 : 7..4,
    SpecSEI : 3..0
  }

register ID_MMFR4_EL1 : ID_MMFR4_EL1_Type

bitfield ID_AA64MMFR2_EL1_Type : bits(64) =
  {
    E0PD : 63..60,
    EVT : 59..56,
    BBM : 55..52,
    TTL : 51..48,
    FWB : 43..40,
    IDS : 39..36,
    AT : 35..32,
    ST : 31..28,
    NV : 27..24,
    CCIDX : 23..20,
    VARange : 19..16,
    IESB : 15..12,
    LSM : 11..8,
    UAO : 7..4,
    CnP : 3..0
  }

register ID_AA64MMFR2_EL1 : ID_AA64MMFR2_EL1_Type

bitfield HDFGRTR_EL2_Type : bits(64) =
  {
    PMBIDR_EL1 : 63..63,
    nPMSNEVFR_EL1 : 62..62,
    nBRBDATA : 61..61,
    nBRBCTL : 60..60,
    nBRBIDR : 59..59,
    PMCEIDn_EL0 : 58..58,
    PMUSERENR_EL0 : 57..57,
    TRCVICTLR : 48..48,
    TRCSTATR : 47..47,
    TRCSSCSRn : 46..46,
    TRCSEQSTR : 45..45,
    TRCPRGCTLR : 44..44,
    TRCOSLSR : 43..43,
    TRCIMSPECn : 41..41,
    TRCID : 40..40,
    TRCCNTVRn : 37..37,
    TRCCLAIM : 36..36,
    TRCAUXCTLR : 35..35,
    TRCAUTHSTATUS : 34..34,
    TRC : 33..33,
    PMSLATFR_EL1 : 32..32,
    PMSIRR_EL1 : 31..31,
    PMSIDR_EL1 : 30..30,
    PMSICR_EL1 : 29..29,
    PMSFCR_EL1 : 28..28,
    PMSEVFR_EL1 : 27..27,
    PMSCR_EL1 : 26..26,
    PMBSR_EL1 : 25..25,
    PMBPTR_EL1 : 24..24,
    PMBLIMITR_EL1 : 23..23,
    PMMIR_EL1 : 22..22,
    PMSELR_EL0 : 19..19,
    PMOVS : 18..18,
    PMINTEN : 17..17,
    PMCNTEN : 16..16,
    PMCCNTR_EL0 : 15..15,
    PMCCFILTR_EL0 : 14..14,
    PMEVTYPERn_EL0 : 13..13,
    PMEVCNTRn_EL0 : 12..12,
    OSDLR_EL1 : 11..11,
    OSECCR_EL1 : 10..10,
    OSLSR_EL1 : 9..9,
    DBGPRCR_EL1 : 7..7,
    DBGAUTHSTATUS_EL1 : 6..6,
    DBGCLAIM : 5..5,
    MDSCR_EL1 : 4..4,
    DBGWVRn_EL1 : 3..3,
    DBGWCRn_EL1 : 2..2,
    DBGBVRn_EL1 : 1..1,
    DBGBCRn_EL1 : 0..0
  }

register HDFGRTR_EL2 : HDFGRTR_EL2_Type

bitfield ICV_NMIAR1_EL1_Type : bits(64) = {INTID : 23..0}

register ICV_NMIAR1_EL1 : ICV_NMIAR1_EL1_Type

bitfield ICH_LR_EL2_Type : bits(64) =
  {
    State : 63..62,
    HW : 61..61,
    Group : 60..60,
    NMI : 59..59,
    Priority : 55..48,
    pINTID : 44..32,
    vINTID : 31..0
  }

register ICH_LR_EL2 : vector(16, ICH_LR_EL2_Type)

bitfield MVFR0_EL1_Type : bits(64) =
  {
    FPRound : 31..28,
    FPShVec : 27..24,
    FPSqrt : 23..20,
    FPDivide : 19..16,
    FPTrap : 15..12,
    FPDP : 11..8,
    FPSP : 7..4,
    SIMDReg : 3..0
  }

register MVFR0_EL1 : MVFR0_EL1_Type

bitfield ICC_HPPIR1_EL1_Type : bits(64) = {INTID : 23..0}

register ICC_HPPIR1_EL1 : ICC_HPPIR1_EL1_Type

type ICC_AP0R_EL1_Type = bits(64)

register ICC_AP0R_EL1 : vector(4, ICC_AP0R_EL1_Type)

bitfield ID_AA64DFR0_EL1_Type : bits(64) =
  {
    HPMN0 : 63..60,
    ExtTrcBuff : 59..56,
    BRBE : 55..52,
    MTPMU : 51..48,
    TraceBuffer : 47..44,
    TraceFilt : 43..40,
    DoubleLock : 39..36,
    PMSVer : 35..32,
    CTX_CMPs : 31..28,
    SEBEP : 27..24,
    WRPs : 23..20,
    PMSS : 19..16,
    BRPs : 15..12,
    PMUVer : 11..8,
    TraceVer : 7..4,
    DebugVer : 3..0
  }

register ID_AA64DFR0_EL1 : ID_AA64DFR0_EL1_Type

bitfield ICV_BPR1_EL1_Type : bits(64) = {BinaryPoint : 2..0}

register ICV_BPR1_EL1 : ICV_BPR1_EL1_Type

bitfield ID_ISAR2_EL1_Type : bits(64) =
  {
    Reversal : 31..28,
    PSR_AR : 27..24,
    MultU : 23..20,
    MultS : 19..16,
    Mult : 15..12,
    MultiAccessInt : 11..8,
    MemHint : 7..4,
    LoadStore : 3..0
  }

register ID_ISAR2_EL1 : ID_ISAR2_EL1_Type

bitfield PMECR_EL1_Type : bits(64) = {SSE : 4..3, KPME : 2..2, PMEE : 1..0}

register PMECR_EL1 : PMECR_EL1_Type

type AIDR_EL1_Type = bits(64)

register AIDR_EL1 : AIDR_EL1_Type

bitfield ICV_EOIR1_EL1_Type : bits(64) = {INTID : 23..0}

register ICV_EOIR1_EL1 : ICV_EOIR1_EL1_Type

bitfield RMR_EL1_Type : bits(64) = {RR : 1..1, AA64 : 0..0}

register RMR_EL1 : RMR_EL1_Type

bitfield OSLAR_EL1_Type : bits(64) = {OSLK : 0..0}

register OSLAR_EL1 : OSLAR_EL1_Type

bitfield ICC_HPPIR0_EL1_Type : bits(64) = {INTID : 23..0}

register ICC_HPPIR0_EL1 : ICC_HPPIR0_EL1_Type

val __set_CNTHPS_CTL_EL2 : CNTHPS_CTL_EL2_Type -> unit

function __set_CNTHPS_CTL_EL2 value_name = {
    let r : CNTHPS_CTL_EL2_Type = value_name;
    CNTHPS_CTL_EL2.bits[1 .. 0] = Slice(r.bits, 0, 2);
    CNTHPS_CTL_EL2.bits[63 .. 3] = Slice(r.bits, 3, 61);
    return()
}

bitfield HAFGRTR_EL2_Type : bits(64) =
  {
    AMEVTYPER115_EL0 : 49..49,
    AMEVCNTR115_EL0 : 48..48,
    AMEVTYPER114_EL0 : 47..47,
    AMEVCNTR114_EL0 : 46..46,
    AMEVTYPER113_EL0 : 45..45,
    AMEVCNTR113_EL0 : 44..44,
    AMEVTYPER112_EL0 : 43..43,
    AMEVCNTR112_EL0 : 42..42,
    AMEVTYPER111_EL0 : 41..41,
    AMEVCNTR111_EL0 : 40..40,
    AMEVTYPER110_EL0 : 39..39,
    AMEVCNTR110_EL0 : 38..38,
    AMEVTYPER19_EL0 : 37..37,
    AMEVCNTR19_EL0 : 36..36,
    AMEVTYPER18_EL0 : 35..35,
    AMEVCNTR18_EL0 : 34..34,
    AMEVTYPER17_EL0 : 33..33,
    AMEVCNTR17_EL0 : 32..32,
    AMEVTYPER16_EL0 : 31..31,
    AMEVCNTR16_EL0 : 30..30,
    AMEVTYPER15_EL0 : 29..29,
    AMEVCNTR15_EL0 : 28..28,
    AMEVTYPER14_EL0 : 27..27,
    AMEVCNTR14_EL0 : 26..26,
    AMEVTYPER13_EL0 : 25..25,
    AMEVCNTR13_EL0 : 24..24,
    AMEVTYPER12_EL0 : 23..23,
    AMEVCNTR12_EL0 : 22..22,
    AMEVTYPER11_EL0 : 21..21,
    AMEVCNTR11_EL0 : 20..20,
    AMEVTYPER10_EL0 : 19..19,
    AMEVCNTR10_EL0 : 18..18,
    AMCNTEN1 : 17..17,
    AMEVCNTR03_EL0 : 4..4,
    AMEVCNTR02_EL0 : 3..3,
    AMEVCNTR01_EL0 : 2..2,
    AMEVCNTR00_EL0 : 1..1,
    AMCNTEN0 : 0..0
  }

register HAFGRTR_EL2 : HAFGRTR_EL2_Type

bitfield ICC_BPR0_EL1_Type : bits(64) = {BinaryPoint : 2..0}

register ICC_BPR0_EL1 : ICC_BPR0_EL1_Type

bitfield ID_AA64DFR1_EL1_Type : bits(64) =
  {
    ABL_CMPs : 63..56,
    DPFZS : 55..52,
    EBEP : 51..48,
    ITE : 47..44,
    ABLE : 43..40,
    PMICNTR : 39..36,
    SPMU : 35..32,
    CTX_CMPs : 31..24,
    WRPs : 23..16,
    BRPs : 15..8,
    SYSPMUID : 7..0
  }

register ID_AA64DFR1_EL1 : ID_AA64DFR1_EL1_Type

bitfield ACCDATA_EL1_Type : bits(64) = {ACCDATA : 31..0}

register ACCDATA_EL1 : ACCDATA_EL1_Type

val __set_SCTLR_EL1 : SCTLR_EL1_Type -> unit

function __set_SCTLR_EL1 value_name = {
    let r : SCTLR_EL1_Type = value_name;
    SCTLR_EL1.bits[4 .. 0] = Slice(r.bits, 0, 5);
    SCTLR_EL1.bits[6] = Bit(Slice(r.bits, 6, 1));
    SCTLR_EL1.bits[63 .. 8] = Slice(r.bits, 8, 56);
    if not_bool(not_bool(__IMPDEF_boolean("IMPLEMENTED_ITD"))) then {
        SCTLR_EL1[ITD] = r[ITD]
    };
    if not_bool(not_bool(__IMPDEF_boolean("IMPLEMENTED_CP15BEN"))) then {
        SCTLR_EL1[CP15BEN] = r[CP15BEN]
    };
    return()
}

type REVIDR_EL1_Type = bits(64)

register REVIDR_EL1 : REVIDR_EL1_Type

bitfield PMSSCR_EL1_Type : bits(64) = {NC : 32..32, SS : 0..0}

register PMSSCR_EL1 : PMSSCR_EL1_Type

val __set_PMSSCR_EL1 : PMSSCR_EL1_Type -> unit

function __set_PMSSCR_EL1 value_name = {
    let r : PMSSCR_EL1_Type = value_name;
    PMSSCR_EL1.bits[63 .. 1] = Slice(r.bits, 1, 63);
    if not_bool(__IMPDEF_boolean("Capture events are disabled")) then {
        PMSSCR_EL1[SS] = r[SS]
    };
    return()
}

bitfield LORID_EL1_Type : bits(64) = {LD : 23..16, LR : 7..0}

register LORID_EL1 : LORID_EL1_Type

type TPIDR_EL2_Type = bits(64)

register TPIDR_EL2 : TPIDR_EL2_Type

bitfield CNTP_TVAL_EL0_Type : bits(64) = {TimerValue : 31..0}

register CNTP_TVAL_EL0 : CNTP_TVAL_EL0_Type

bitfield ID_AA64ISAR1_EL1_Type : bits(64) =
  {
    LS64 : 63..60,
    XS : 59..56,
    I8MM : 55..52,
    DGH : 51..48,
    BF16 : 47..44,
    SPECRES : 43..40,
    SB : 39..36,
    FRINTTS : 35..32,
    GPI : 31..28,
    GPA : 27..24,
    LRCPC : 23..20,
    FCMA : 19..16,
    JSCVT : 15..12,
    API : 11..8,
    APA : 7..4,
    DPB : 3..0
  }

register ID_AA64ISAR1_EL1 : ID_AA64ISAR1_EL1_Type

bitfield ID_AA64MMFR4_EL1_Type : bits(64) = {EIESB : 7..4}

register ID_AA64MMFR4_EL1 : ID_AA64MMFR4_EL1_Type

type ACTLR_EL2_Type = bits(64)

register ACTLR_EL2 : ACTLR_EL2_Type

bitfield ICH_EISR_EL2_Type : bits(64) =
  {
    Status15 : 15..15,
    Status14 : 14..14,
    Status13 : 13..13,
    Status12 : 12..12,
    Status11 : 11..11,
    Status10 : 10..10,
    Status9 : 9..9,
    Status8 : 8..8,
    Status7 : 7..7,
    Status6 : 6..6,
    Status5 : 5..5,
    Status4 : 4..4,
    Status3 : 3..3,
    Status2 : 2..2,
    Status1 : 1..1,
    Status0 : 0..0
  }

register ICH_EISR_EL2 : ICH_EISR_EL2_Type

bitfield MIDR_EL1_Type : bits(64) =
  {
    Implementer : 31..24,
    Variant : 23..20,
    Architecture : 19..16,
    PartNum : 15..4,
    Revision : 3..0
  }

register MIDR_EL1 : MIDR_EL1_Type

bitfield ICC_RPR_EL1_Type : bits(64) =
  {NMI : 63..63, NMI_NS : 62..62, Priority : 7..0}

register ICC_RPR_EL1 : ICC_RPR_EL1_Type

bitfield ICH_ELRSR_EL2_Type : bits(64) =
  {
    Status15 : 15..15,
    Status14 : 14..14,
    Status13 : 13..13,
    Status12 : 12..12,
    Status11 : 11..11,
    Status10 : 10..10,
    Status9 : 9..9,
    Status8 : 8..8,
    Status7 : 7..7,
    Status6 : 6..6,
    Status5 : 5..5,
    Status4 : 4..4,
    Status3 : 3..3,
    Status2 : 2..2,
    Status1 : 1..1,
    Status0 : 0..0
  }

register ICH_ELRSR_EL2 : ICH_ELRSR_EL2_Type

bitfield ICC_SGI0R_EL1_Type : bits(64) =
  {
    Aff3 : 55..48,
    RS : 47..44,
    IRM : 40..40,
    Aff2 : 39..32,
    INTID : 27..24,
    Aff1 : 23..16,
    TargetList : 15..0
  }

register ICC_SGI0R_EL1 : ICC_SGI0R_EL1_Type

val __set_FPCR : FPCR_Type -> unit

function __set_FPCR value_name = {
    let r : FPCR_Type = value_name;
    FPCR.bits[7 .. 0] = Slice(r.bits, 0, 8);
    FPCR.bits[14 .. 13] = Slice(r.bits, 13, 2);
    FPCR.bits[19] = Bit(Slice(r.bits, 19, 1));
    FPCR.bits[63 .. 22] = Slice(r.bits, 22, 42);
    if not_bool(__IMPDEF_boolean("IMPLEMENTED_FPSCR.LEN,STRIDE as RAZ")) then {
        FPCR[Stride] = r[Stride]
    };
    if not_bool(__IMPDEF_boolean("IMPLEMENTED_FPSCR.LEN,STRIDE as RAZ")) then {
        FPCR[length] = r[length]
    };
    if not_bool(not_bool(__IMPDEF_boolean("IMPLEMENTED_trapping of Input Denormal floating-point exceptions"))) then {
        FPCR[IDE] = r[IDE]
    };
    if not_bool(not_bool(__IMPDEF_boolean("IMPLEMENTED_trapping of Inexact floating-point exceptions"))) then {
        FPCR[IXE] = r[IXE]
    };
    if not_bool(not_bool(__IMPDEF_boolean("IMPLEMENTED_trapping of Underflow floating-point exceptions"))) then {
        FPCR[UFE] = r[UFE]
    };
    if not_bool(not_bool(__IMPDEF_boolean("IMPLEMENTED_trapping of Overflow floating-point exceptions"))) then {
        FPCR[OFE] = r[OFE]
    };
    if not_bool(not_bool(__IMPDEF_boolean("IMPLEMENTED_trapping of Divide by Zero floating-point exceptions"))) then {
        FPCR[DZE] = r[DZE]
    };
    if not_bool(not_bool(__IMPDEF_boolean("IMPLEMENTED_trapping of Invalid Operation floating-point exceptions"))) then {
        FPCR[IOE] = r[IOE]
    };
    return()
}

val __set_CNTHVS_CTL_EL2 : CNTHVS_CTL_EL2_Type -> unit

function __set_CNTHVS_CTL_EL2 value_name = {
    let r : CNTHVS_CTL_EL2_Type = value_name;
    CNTHVS_CTL_EL2.bits[1 .. 0] = Slice(r.bits, 0, 2);
    CNTHVS_CTL_EL2.bits[63 .. 3] = Slice(r.bits, 3, 61);
    return()
}

bitfield SPMACCESSR_EL1_Type : bits(64) =
  {
    P31 : 63..62,
    P30 : 61..60,
    P29 : 59..58,
    P28 : 57..56,
    P27 : 55..54,
    P26 : 53..52,
    P25 : 51..50,
    P24 : 49..48,
    P23 : 47..46,
    P22 : 45..44,
    P21 : 43..42,
    P20 : 41..40,
    P19 : 39..38,
    P18 : 37..36,
    P17 : 35..34,
    P16 : 33..32,
    P15 : 31..30,
    P14 : 29..28,
    P13 : 27..26,
    P12 : 25..24,
    P11 : 23..22,
    P10 : 21..20,
    P9 : 19..18,
    P8 : 17..16,
    P7 : 15..14,
    P6 : 13..12,
    P5 : 11..10,
    P4 : 9..8,
    P3 : 7..6,
    P2 : 5..4,
    P1 : 3..2,
    P0 : 1..0
  }

register SPMACCESSR_EL1 : SPMACCESSR_EL1_Type

bitfield SPMSELR_EL0_Type : bits(64) = {SYSPMUSEL : 9..4, BANK : 1..0}

register SPMSELR_EL0 : SPMSELR_EL0_Type

val __get_selected_SPMACCESSR_EL1_field : unit -> bits(2)

function __get_selected_SPMACCESSR_EL1_field () = {
    let 'idx = UInt(SPMSELR_EL0[SYSPMUSEL]) * 2;
    return(Slice(SPMACCESSR_EL1.bits, idx, 2))
}

bitfield ID_AA64PFR1_EL1_Type : bits(64) =
  {
    PFAR : 63..60,
    DF2 : 59..56,
    MTEX : 55..52,
    THE : 51..48,
    GCS : 47..44,
    MTE_frac : 43..40,
    NMI : 39..36,
    CSV2_frac : 35..32,
    RNDR_trap : 31..28,
    SME : 27..24,
    MPAM_frac : 19..16,
    RAS_frac : 15..12,
    MTE : 11..8,
    SSBS : 7..4,
    BT : 3..0
  }

register ID_AA64PFR1_EL1 : ID_AA64PFR1_EL1_Type

bitfield ID_AA64PFR0_EL1_Type : bits(64) =
  {
    CSV3 : 63..60,
    CSV2 : 59..56,
    RME : 55..52,
    DIT : 51..48,
    AMU : 47..44,
    MPAM : 43..40,
    SEL2 : 39..36,
    SVE : 35..32,
    RAS : 31..28,
    GIC : 27..24,
    AdvSIMD : 23..20,
    FP : 19..16,
    EL3 : 15..12,
    EL2 : 11..8,
    EL1 : 7..4,
    EL0 : 3..0
  }

register ID_AA64PFR0_EL1 : ID_AA64PFR0_EL1_Type

bitfield ICH_AP1R_EL2_Type : bits(64) =
  {
    NMI : 63..63,
    P31 : 31..31,
    P30 : 30..30,
    P29 : 29..29,
    P28 : 28..28,
    P27 : 27..27,
    P26 : 26..26,
    P25 : 25..25,
    P24 : 24..24,
    P23 : 23..23,
    P22 : 22..22,
    P21 : 21..21,
    P20 : 20..20,
    P19 : 19..19,
    P18 : 18..18,
    P17 : 17..17,
    P16 : 16..16,
    P15 : 15..15,
    P14 : 14..14,
    P13 : 13..13,
    P12 : 12..12,
    P11 : 11..11,
    P10 : 10..10,
    P9 : 9..9,
    P8 : 8..8,
    P7 : 7..7,
    P6 : 6..6,
    P5 : 5..5,
    P4 : 4..4,
    P3 : 3..3,
    P2 : 2..2,
    P1 : 1..1,
    P0 : 0..0
  }

register ICH_AP1R_EL2 : vector(4, ICH_AP1R_EL2_Type)

bitfield ICC_DIR_EL1_Type : bits(64) = {INTID : 23..0}

register ICC_DIR_EL1 : ICC_DIR_EL1_Type

bitfield PMEVCNTSVR_EL1_Type : bits(64) = {EVCNT : 63..0}

register PMEVCNTSVR_EL1 : vector(31, PMEVCNTSVR_EL1_Type)

bitfield ID_AA64ISAR0_EL1_Type : bits(64) =
  {
    RNDR : 63..60,
    TLB : 59..56,
    TS : 55..52,
    FHM : 51..48,
    DP : 47..44,
    SM4 : 43..40,
    SM3 : 39..36,
    SHA3 : 35..32,
    RDM : 31..28,
    TME : 27..24,
    Atomic : 23..20,
    CRC32 : 19..16,
    SHA2 : 15..12,
    SHA1 : 11..8,
    AES : 7..4
  }

register ID_AA64ISAR0_EL1 : ID_AA64ISAR0_EL1_Type

bitfield PMMIR_EL1_Type : bits(64) =
  {
    EDGE : 27..24,
    THWIDTH : 23..20,
    BUS_WIDTH : 19..16,
    BUS_SLOTS : 15..8,
    SLOTS : 7..0
  }

register PMMIR_EL1 : PMMIR_EL1_Type

bitfield ICV_IAR0_EL1_Type : bits(64) = {INTID : 23..0}

register ICV_IAR0_EL1 : ICV_IAR0_EL1_Type

bitfield ICC_IGRPEN1_EL1_Type : bits(64) = {Enable : 0..0}

register ICC_IGRPEN1_EL1_S : ICC_IGRPEN1_EL1_Type

register ICC_IGRPEN1_EL1_NS : ICC_IGRPEN1_EL1_Type

val ICC_IGRPEN1_EL1_read : unit -> ICC_IGRPEN1_EL1_Type

function ICC_IGRPEN1_EL1_read () = {
    r : ICC_IGRPEN1_EL1_Type = undefined;
    if ELUsingAArch32(EL3) & CurrentSecurityState() == SS_Secure then {
        r = ICC_IGRPEN1_EL1_S
    } else {
        r = ICC_IGRPEN1_EL1_NS
    };
    return(r)
}

val ICC_IGRPEN1_EL1_write : ICC_IGRPEN1_EL1_Type -> unit

function ICC_IGRPEN1_EL1_write value_name = {
    let r : ICC_IGRPEN1_EL1_Type = value_name;
    if ELUsingAArch32(EL3) & CurrentSecurityState() == SS_Secure then {
        ICC_IGRPEN1_EL1_S = r
    } else {
        ICC_IGRPEN1_EL1_NS = r
    };
    return()
}

bitfield ID_MMFR5_EL1_Type : bits(64) = {nTLBPA : 7..4, ETS : 3..0}

register ID_MMFR5_EL1 : ID_MMFR5_EL1_Type

bitfield ICC_NMIAR1_EL1_Type : bits(64) = {INTID : 23..0}

register ICC_NMIAR1_EL1 : ICC_NMIAR1_EL1_Type

bitfield DBGCLAIMSET_EL1_Type : bits(64) = {CLAIM : 7..0}

register DBGCLAIMSET_EL1 : DBGCLAIMSET_EL1_Type

bitfield ICC_SRE_EL1_Type : bits(64) = {DIB : 2..2, DFB : 1..1, SRE : 0..0}

register ICC_SRE_EL1_S : ICC_SRE_EL1_Type

register ICC_SRE_EL1_NS : ICC_SRE_EL1_Type

val ICC_SRE_EL1_read : unit -> ICC_SRE_EL1_Type

function ICC_SRE_EL1_read () = {
    r : ICC_SRE_EL1_Type = undefined;
    if ELUsingAArch32(EL3) & CurrentSecurityState() == SS_Secure then {
        r = ICC_SRE_EL1_S
    } else {
        r = ICC_SRE_EL1_NS
    };
    return(r)
}

val ICC_SRE_EL1_write : ICC_SRE_EL1_Type -> unit

function ICC_SRE_EL1_write value_name = {
    let r : ICC_SRE_EL1_Type = value_name;
    if ELUsingAArch32(EL3) & CurrentSecurityState() == SS_Secure then {
        ICC_SRE_EL1_S = r
    } else {
        ICC_SRE_EL1_NS = r
    };
    return()
}

bitfield ICH_AP0R_EL2_Type : bits(64) =
  {
    P31 : 31..31,
    P30 : 30..30,
    P29 : 29..29,
    P28 : 28..28,
    P27 : 27..27,
    P26 : 26..26,
    P25 : 25..25,
    P24 : 24..24,
    P23 : 23..23,
    P22 : 22..22,
    P21 : 21..21,
    P20 : 20..20,
    P19 : 19..19,
    P18 : 18..18,
    P17 : 17..17,
    P16 : 16..16,
    P15 : 15..15,
    P14 : 14..14,
    P13 : 13..13,
    P12 : 12..12,
    P11 : 11..11,
    P10 : 10..10,
    P9 : 9..9,
    P8 : 8..8,
    P7 : 7..7,
    P6 : 6..6,
    P5 : 5..5,
    P4 : 4..4,
    P3 : 3..3,
    P2 : 2..2,
    P1 : 1..1,
    P0 : 0..0
  }

register ICH_AP0R_EL2 : vector(4, ICH_AP0R_EL2_Type)

bitfield ICC_IAR0_EL1_Type : bits(64) = {INTID : 23..0}

register ICC_IAR0_EL1 : ICC_IAR0_EL1_Type

type TPIDR_EL1_Type = bits(64)

register TPIDR_EL1 : TPIDR_EL1_Type

bitfield ID_ISAR4_EL1_Type : bits(64) =
  {
    SWP_frac : 31..28,
    PSR_M : 27..24,
    SynchPrim_frac : 23..20,
    Barrier : 19..16,
    SMC : 15..12,
    Writeback : 11..8,
    WithShifts : 7..4,
    Unpriv : 3..0
  }

register ID_ISAR4_EL1 : ID_ISAR4_EL1_Type

bitfield ID_ISAR1_EL1_Type : bits(64) =
  {
    Jazelle : 31..28,
    Interwork : 27..24,
    Immediate : 23..20,
    IfThen : 19..16,
    Extend : 15..12,
    Except_AR : 11..8,
    Except : 7..4,
    Endian : 3..0
  }

register ID_ISAR1_EL1 : ID_ISAR1_EL1_Type

bitfield PMUACR_EL1_Type : bits(64) =
  {
    F0 : 32..32,
    C : 31..31,
    P30 : 30..30,
    P29 : 29..29,
    P28 : 28..28,
    P27 : 27..27,
    P26 : 26..26,
    P25 : 25..25,
    P24 : 24..24,
    P23 : 23..23,
    P22 : 22..22,
    P21 : 21..21,
    P20 : 20..20,
    P19 : 19..19,
    P18 : 18..18,
    P17 : 17..17,
    P16 : 16..16,
    P15 : 15..15,
    P14 : 14..14,
    P13 : 13..13,
    P12 : 12..12,
    P11 : 11..11,
    P10 : 10..10,
    P9 : 9..9,
    P8 : 8..8,
    P7 : 7..7,
    P6 : 6..6,
    P5 : 5..5,
    P4 : 4..4,
    P3 : 3..3,
    P2 : 2..2,
    P1 : 1..1,
    P0 : 0..0
  }

register PMUACR_EL1 : PMUACR_EL1_Type

type ACTLR_EL1_Type = bits(64)

register ACTLR_EL1 : ACTLR_EL1_Type

bitfield RMR_EL2_Type : bits(64) = {RR : 1..1, AA64 : 0..0}

register RMR_EL2 : RMR_EL2_Type

bitfield PMSELR_EL0_Type : bits(64) = {SEL : 4..0}

register PMSELR_EL0 : PMSELR_EL0_Type

bitfield ICC_CTLR_EL1_Type : bits(64) =
  {
    ExtRange : 19..19,
    RSS : 18..18,
    A3V : 15..15,
    SEIS : 14..14,
    IDbits : 13..11,
    PRIbits : 10..8,
    PMHE : 6..6,
    EOImode : 1..1,
    CBPR : 0..0
  }

register ICC_CTLR_EL1_S : ICC_CTLR_EL1_Type

register ICC_CTLR_EL1_NS : ICC_CTLR_EL1_Type

val ICC_CTLR_EL1_read : unit -> ICC_CTLR_EL1_Type

function ICC_CTLR_EL1_read () = {
    r : ICC_CTLR_EL1_Type = undefined;
    if ELUsingAArch32(EL3) & CurrentSecurityState() == SS_Secure then {
        r = ICC_CTLR_EL1_S
    } else {
        r = ICC_CTLR_EL1_NS
    };
    return(r)
}

val ICC_CTLR_EL1_write : ICC_CTLR_EL1_Type -> unit

function ICC_CTLR_EL1_write value_name = {
    let r : ICC_CTLR_EL1_Type = value_name;
    if ELUsingAArch32(EL3) & CurrentSecurityState() == SS_Secure then {
        ICC_CTLR_EL1_S = r
    } else {
        ICC_CTLR_EL1_NS = r
    };
    return()
}

bitfield ID_ISAR6_EL1_Type : bits(64) =
  {
    CLRBHB : 31..28,
    I8MM : 27..24,
    BF16 : 23..20,
    SPECRES : 19..16,
    SB : 15..12,
    FHM : 11..8,
    DP : 7..4,
    JSCVT : 3..0
  }

register ID_ISAR6_EL1 : ID_ISAR6_EL1_Type

bitfield ICC_AP1R_EL1_Type : bits(64) = {NMI : 63..63}

register ICC_AP1R_EL1_S : vector(4, ICC_AP1R_EL1_Type)

register ICC_AP1R_EL1_NS : vector(4, ICC_AP1R_EL1_Type)

val ICC_AP1R_EL1_read : forall 'n. int('n) -> ICC_AP1R_EL1_Type

function ICC_AP1R_EL1_read n = {
    r : ICC_AP1R_EL1_Type = undefined;
    if ELUsingAArch32(EL3) & CurrentSecurityState() == SS_Secure then {
        assert(constraint((0 <= 'n & 'n < 4)));
        r = ICC_AP1R_EL1_S[n]
    } else {
        assert(constraint((0 <= 'n & 'n < 4)));
        r = ICC_AP1R_EL1_NS[n]
    };
    return(r)
}

val ICC_AP1R_EL1_set : forall 'n. (int('n), ICC_AP1R_EL1_Type) -> unit

function ICC_AP1R_EL1_set (n, value_name) = {
    let r : ICC_AP1R_EL1_Type = value_name;
    if ELUsingAArch32(EL3) & CurrentSecurityState() == SS_Secure then {
        assert(constraint((0 <= 'n & 'n < 4)));
        ICC_AP1R_EL1_S[n] = r
    } else {
        assert(constraint((0 <= 'n & 'n < 4)));
        ICC_AP1R_EL1_NS[n] = r
    };
    return()
}

val __set_CNTP_CTL_EL0 : CNTP_CTL_EL0_Type -> unit

function __set_CNTP_CTL_EL0 value_name = {
    let r : CNTP_CTL_EL0_Type = value_name;
    CNTP_CTL_EL0.bits[1 .. 0] = Slice(r.bits, 0, 2);
    CNTP_CTL_EL0.bits[63 .. 3] = Slice(r.bits, 3, 61);
    return()
}

type HFGITR2_EL2_Type = bits(64)

register HFGITR2_EL2 : HFGITR2_EL2_Type

bitfield CNTHV_TVAL_EL2_Type : bits(64) = {TimerValue : 31..0}

register CNTHV_TVAL_EL2 : CNTHV_TVAL_EL2_Type

bitfield ICH_MISR_EL2_Type : bits(64) =
  {
    VGrp1D : 7..7,
    VGrp1E : 6..6,
    VGrp0D : 5..5,
    VGrp0E : 4..4,
    NP : 3..3,
    LRENP : 2..2,
    U : 1..1,
    EOI : 0..0
  }

register ICH_MISR_EL2 : ICH_MISR_EL2_Type

bitfield CSSELR_EL1_Type : bits(64) = {TnD : 4..4, Level : 3..1, InD : 0..0}

register CSSELR_EL1 : CSSELR_EL1_Type

bitfield ICV_RPR_EL1_Type : bits(64) = {NMI : 63..63, Priority : 7..0}

register ICV_RPR_EL1 : ICV_RPR_EL1_Type

bitfield ICV_PMR_EL1_Type : bits(64) = {Priority : 7..0}

register ICV_PMR_EL1 : ICV_PMR_EL1_Type

bitfield ICV_HPPIR0_EL1_Type : bits(64) = {INTID : 23..0}

register ICV_HPPIR0_EL1 : ICV_HPPIR0_EL1_Type

bitfield ICV_BPR0_EL1_Type : bits(64) = {BinaryPoint : 2..0}

register ICV_BPR0_EL1 : ICV_BPR0_EL1_Type

bitfield ISR_EL1_Type : bits(64) =
  {IS : 10..10, FS : 9..9, A : 8..8, I : 7..7, F : 6..6}

register ISR_EL1 : ISR_EL1_Type

bitfield ID_ISAR3_EL1_Type : bits(64) =
  {
    T32EE : 31..28,
    TrueNOP : 27..24,
    T32Copy : 23..20,
    TabBranch : 19..16,
    SynchPrim : 15..12,
    SVC : 11..8,
    SIMD : 7..4,
    Saturate : 3..0
  }

register ID_ISAR3_EL1 : ID_ISAR3_EL1_Type

type AFSR1_EL1_Type = bits(64)

register AFSR1_EL1 : AFSR1_EL1_Type

bitfield PMCCNTSVR_EL1_Type : bits(64) = {CCNT : 63..0}

register PMCCNTSVR_EL1 : PMCCNTSVR_EL1_Type

bitfield MECIDR_EL2_Type : bits(64) = {MECIDWidthm1 : 3..0}

register MECIDR_EL2 : MECIDR_EL2_Type

bitfield PMINTENSET_EL1_Type : bits(64) =
  {
    F0 : 32..32,
    C : 31..31,
    P30 : 30..30,
    P29 : 29..29,
    P28 : 28..28,
    P27 : 27..27,
    P26 : 26..26,
    P25 : 25..25,
    P24 : 24..24,
    P23 : 23..23,
    P22 : 22..22,
    P21 : 21..21,
    P20 : 20..20,
    P19 : 19..19,
    P18 : 18..18,
    P17 : 17..17,
    P16 : 16..16,
    P15 : 15..15,
    P14 : 14..14,
    P13 : 13..13,
    P12 : 12..12,
    P11 : 11..11,
    P10 : 10..10,
    P9 : 9..9,
    P8 : 8..8,
    P7 : 7..7,
    P6 : 6..6,
    P5 : 5..5,
    P4 : 4..4,
    P3 : 3..3,
    P2 : 2..2,
    P1 : 1..1,
    P0 : 0..0
  }

register PMINTENSET_EL1 : PMINTENSET_EL1_Type

bitfield SMIDR_EL1_Type : bits(64) =
  {Implementer : 31..24, Revision : 23..16, SMPS : 15..15, Affinity : 11..0}

register SMIDR_EL1 : SMIDR_EL1_Type

bitfield HFGWTR_EL2_Type : bits(64) =
  {
    nAMAIR2_EL1 : 63..63,
    nMAIR2_EL1 : 62..62,
    nS2POR_EL1 : 61..61,
    nPOR_EL1 : 60..60,
    nPOR_EL0 : 59..59,
    nPIR_EL1 : 58..58,
    nPIRE0_EL1 : 57..57,
    nRCWMASK_EL1 : 56..56,
    nTPIDR2_EL0 : 55..55,
    nSMPRI_EL1 : 54..54,
    nGCS_EL1 : 53..53,
    nGCS_EL0 : 52..52,
    nACCDATA_EL1 : 50..50,
    ERXADDR_EL1 : 49..49,
    ERXPFGCDN_EL1 : 48..48,
    ERXPFGCTL_EL1 : 47..47,
    ERXMISCn_EL1 : 45..45,
    ERXSTATUS_EL1 : 44..44,
    ERXCTLR_EL1 : 43..43,
    ERRSELR_EL1 : 41..41,
    ICC_IGRPENn_EL1 : 39..39,
    VBAR_EL1 : 38..38,
    TTBR1_EL1 : 37..37,
    TTBR0_EL1 : 36..36,
    TPIDR_EL0 : 35..35,
    TPIDRRO_EL0 : 34..34,
    TPIDR_EL1 : 33..33,
    TCR_EL1 : 32..32,
    SCXTNUM_EL0 : 31..31,
    SCXTNUM_EL1 : 30..30,
    SCTLR_EL1 : 29..29,
    PAR_EL1 : 27..27,
    MAIR_EL1 : 24..24,
    LORSA_EL1 : 23..23,
    LORN_EL1 : 22..22,
    LOREA_EL1 : 20..20,
    LORC_EL1 : 19..19,
    FAR_EL1 : 17..17,
    ESR_EL1 : 16..16,
    CSSELR_EL1 : 13..13,
    CPACR_EL1 : 12..12,
    CONTEXTIDR_EL1 : 11..11,
    APIBKey : 8..8,
    APIAKey : 7..7,
    APGAKey : 6..6,
    APDBKey : 5..5,
    APDAKey : 4..4,
    AMAIR_EL1 : 3..3,
    AFSR1_EL1 : 1..1,
    AFSR0_EL1 : 0..0
  }

register HFGWTR_EL2 : HFGWTR_EL2_Type

bitfield SMPRI_EL1_Type : bits(64) = {Priority : 3..0}

register SMPRI_EL1 : SMPRI_EL1_Type

bitfield PMUSERENR_EL0_Type : bits(64) =
  {
    TID : 6..6,
    IR : 5..5,
    UEN : 4..4,
    ER : 3..3,
    CR : 2..2,
    SW : 1..1,
    EN : 0..0
  }

register PMUSERENR_EL0 : PMUSERENR_EL0_Type

type AMAIR2_EL2_Type = bits(64)

register AMAIR2_EL2 : AMAIR2_EL2_Type

type ICV_AP0R_EL1_Type = bits(64)

register ICV_AP0R_EL1 : vector(4, ICV_AP0R_EL1_Type)

type AFSR0_EL3_Type = bits(64)

register AFSR0_EL3 : AFSR0_EL3_Type

type CNTFRQ_EL0_Type = bits(64)

register CNTFRQ_EL0 : CNTFRQ_EL0_Type

bitfield ICV_CTLR_EL1_Type : bits(64) =
  {
    ExtRange : 19..19,
    RSS : 18..18,
    A3V : 15..15,
    SEIS : 14..14,
    IDbits : 13..11,
    PRIbits : 10..8,
    EOImode : 1..1,
    CBPR : 0..0
  }

register ICV_CTLR_EL1 : ICV_CTLR_EL1_Type

type AFSR1_EL2_Type = bits(64)

register AFSR1_EL2 : AFSR1_EL2_Type

bitfield ICV_IAR1_EL1_Type : bits(64) = {INTID : 23..0}

register ICV_IAR1_EL1 : ICV_IAR1_EL1_Type

val __set_FPEXC32_EL2 : FPEXC32_EL2_Type -> unit

function __set_FPEXC32_EL2 value_name = {
    let r : FPEXC32_EL2_Type = value_name;
    FPEXC32_EL2.bits[6 .. 5] = Slice(r.bits, 5, 2);
    FPEXC32_EL2.bits[30 .. 8] = Slice(r.bits, 8, 23);
    FPEXC32_EL2.bits[63 .. 32] = Slice(r.bits, 32, 32);
    if not_bool(not_bool(__IMPDEF_boolean("IMPLEMENTED_trapping of Input Denormal floating-point exceptions"))) then {
        FPEXC32_EL2[IDF] = r[IDF]
    };
    if not_bool(not_bool(__IMPDEF_boolean("IMPLEMENTED_trapping of Inexact floating-point exceptions"))) then {
        FPEXC32_EL2[IXF] = r[IXF]
    };
    if not_bool(not_bool(__IMPDEF_boolean("IMPLEMENTED_trapping of Underflow floating-point exceptions"))) then {
        FPEXC32_EL2[UFF] = r[UFF]
    };
    if not_bool(not_bool(__IMPDEF_boolean("IMPLEMENTED_trapping of Overflow floating-point exceptions"))) then {
        FPEXC32_EL2[OFF] = r[OFF]
    };
    if not_bool(not_bool(__IMPDEF_boolean("IMPLEMENTED_trapping of Divide by Zero floating-point exceptions"))) then {
        FPEXC32_EL2[DZF] = r[DZF]
    };
    if not_bool(not_bool(__IMPDEF_boolean("IMPLEMENTED_trapping of Invalid Operation floating-point exceptions"))) then {
        FPEXC32_EL2[IOF] = r[IOF]
    };
    return()
}

val __set_MDSCR_EL1 : MDSCR_EL1_Type -> unit

function __set_MDSCR_EL1 value_name = {
    let r : MDSCR_EL1_Type = value_name;
    MDSCR_EL1.bits[5 .. 0] = Slice(r.bits, 0, 6);
    MDSCR_EL1.bits[13 .. 7] = Slice(r.bits, 7, 7);
    MDSCR_EL1.bits[18 .. 15] = Slice(r.bits, 15, 4);
    MDSCR_EL1.bits[20] = Bit(Slice(r.bits, 20, 1));
    MDSCR_EL1.bits[25 .. 24] = Slice(r.bits, 24, 2);
    MDSCR_EL1.bits[28] = Bit(Slice(r.bits, 28, 1));
    MDSCR_EL1.bits[34 .. 32] = Slice(r.bits, 32, 3);
    MDSCR_EL1.bits[63 .. 36] = Slice(r.bits, 36, 28);
    if not_bool(OSLSR_EL1[OSLK] == 0b0) then {
        MDSCR_EL1[EHBWE] = r[EHBWE]
    };
    if OSLSR_EL1[OSLK] == 0b1 then {
        MDSCR_EL1[TFO] = r[TFO]
    };
    if OSLSR_EL1[OSLK] == 0b1 then {
        MDSCR_EL1[RXfull] = r[RXfull]
    };
    if OSLSR_EL1[OSLK] == 0b1 then {
        MDSCR_EL1[TXfull] = r[TXfull]
    };
    if OSLSR_EL1[OSLK] == 0b1 then {
        MDSCR_EL1[RXO] = r[RXO]
    };
    if OSLSR_EL1[OSLK] == 0b1 then {
        MDSCR_EL1[TXU] = r[TXU]
    };
    if OSLSR_EL1[OSLK] == 0b1 then {
        MDSCR_EL1[INTdis] = r[INTdis]
    };
    if OSLSR_EL1[OSLK] == 0b1 then {
        MDSCR_EL1[TDA] = r[TDA]
    };
    if OSLSR_EL1[OSLK] == 0b1 then {
        MDSCR_EL1[SC2] = r[SC2]
    };
    if OSLSR_EL1[OSLK] == 0b1 then {
        MDSCR_EL1[HDE] = r[HDE]
    };
    if OSLSR_EL1[OSLK] == 0b1 then {
        MDSCR_EL1[ERR] = r[ERR]
    };
    return()
}

val __set_GPCCR_EL3 : GPCCR_EL3_Type -> unit

function __set_GPCCR_EL3 value_name = {
    let r : GPCCR_EL3_Type = value_name;
    GPCCR_EL3.bits[19 .. 0] = Slice(r.bits, 0, 20);
    GPCCR_EL3.bits[63 .. 24] = Slice(r.bits, 24, 40);
    return()
}

bitfield ID_PFR0_EL1_Type : bits(64) =
  {
    RAS : 31..28,
    DIT : 27..24,
    AMU : 23..20,
    CSV2 : 19..16,
    State3 : 15..12,
    State2 : 11..8,
    State1 : 7..4,
    State0 : 3..0
  }

register ID_PFR0_EL1 : ID_PFR0_EL1_Type

bitfield MVFR1_EL1_Type : bits(64) =
  {
    SIMDFMAC : 31..28,
    FPHP : 27..24,
    SIMDHP : 23..20,
    SIMDSP : 19..16,
    SIMDInt : 15..12,
    SIMDLS : 11..8,
    FPDNaN : 7..4,
    FPFtZ : 3..0
  }

register MVFR1_EL1 : MVFR1_EL1_Type

bitfield HDFGWTR2_EL2_Type : bits(64) =
  {
    nPMZR_EL0 : 21..21,
    nPMSDSFR_EL1 : 19..19,
    nSPMSCR_EL1 : 16..16,
    nSPMACCESSR_EL1 : 15..15,
    nSPMCR_EL0 : 14..14,
    nSPMOVS : 13..13,
    nSPMINTEN : 12..12,
    nSPMCNTEN : 11..11,
    nSPMSELR_EL0 : 10..10,
    nSPMEVTYPERn_EL0 : 9..9,
    nSPMEVCNTRn_EL0 : 8..8,
    nPMSSCR_EL1 : 7..7,
    nMDSELR_EL1 : 5..5,
    nPMUACR_EL1 : 4..4,
    nPMICFILTR_EL0 : 3..3,
    nPMICNTR_EL0 : 2..2,
    nPMIAR_EL1 : 1..1,
    nPMECR_EL1 : 0..0
  }

register HDFGWTR2_EL2 : HDFGWTR2_EL2_Type

bitfield ID_ISAR0_EL1_Type : bits(64) =
  {
    Divide : 27..24,
    Debug : 23..20,
    Coproc : 19..16,
    CmpBranch : 15..12,
    BitField : 11..8,
    BitCount : 7..4,
    Swap : 3..0
  }

register ID_ISAR0_EL1 : ID_ISAR0_EL1_Type

type AFSR0_EL1_Type = bits(64)

register AFSR0_EL1 : AFSR0_EL1_Type

val __set_CNTHP_CTL_EL2 : CNTHP_CTL_EL2_Type -> unit

function __set_CNTHP_CTL_EL2 value_name = {
    let r : CNTHP_CTL_EL2_Type = value_name;
    CNTHP_CTL_EL2.bits[1 .. 0] = Slice(r.bits, 0, 2);
    CNTHP_CTL_EL2.bits[63 .. 3] = Slice(r.bits, 3, 61);
    return()
}

bitfield CNTHVS_TVAL_EL2_Type : bits(64) = {TimerValue : 31..0}

register CNTHVS_TVAL_EL2 : CNTHVS_TVAL_EL2_Type

bitfield CNTHP_TVAL_EL2_Type : bits(64) = {TimerValue : 31..0}

register CNTHP_TVAL_EL2 : CNTHP_TVAL_EL2_Type

bitfield SPMACCESSR_EL2_Type : bits(64) =
  {
    P31 : 63..62,
    P30 : 61..60,
    P29 : 59..58,
    P28 : 57..56,
    P27 : 55..54,
    P26 : 53..52,
    P25 : 51..50,
    P24 : 49..48,
    P23 : 47..46,
    P22 : 45..44,
    P21 : 43..42,
    P20 : 41..40,
    P19 : 39..38,
    P18 : 37..36,
    P17 : 35..34,
    P16 : 33..32,
    P15 : 31..30,
    P14 : 29..28,
    P13 : 27..26,
    P12 : 25..24,
    P11 : 23..22,
    P10 : 21..20,
    P9 : 19..18,
    P8 : 17..16,
    P7 : 15..14,
    P6 : 13..12,
    P5 : 11..10,
    P4 : 9..8,
    P3 : 7..6,
    P2 : 5..4,
    P1 : 3..2,
    P0 : 1..0
  }

register SPMACCESSR_EL2 : SPMACCESSR_EL2_Type

val __get_selected_SPMACCESSR_EL2_field : unit -> bits(2)

function __get_selected_SPMACCESSR_EL2_field () = {
    let 'idx = UInt(SPMSELR_EL0[SYSPMUSEL]) * 2;
    return(Slice(SPMACCESSR_EL2.bits, idx, 2))
}

bitfield PMZR_EL0_Type : bits(64) =
  {
    F0 : 32..32,
    C : 31..31,
    P30 : 30..30,
    P29 : 29..29,
    P28 : 28..28,
    P27 : 27..27,
    P26 : 26..26,
    P25 : 25..25,
    P24 : 24..24,
    P23 : 23..23,
    P22 : 22..22,
    P21 : 21..21,
    P20 : 20..20,
    P19 : 19..19,
    P18 : 18..18,
    P17 : 17..17,
    P16 : 16..16,
    P15 : 15..15,
    P14 : 14..14,
    P13 : 13..13,
    P12 : 12..12,
    P11 : 11..11,
    P10 : 10..10,
    P9 : 9..9,
    P8 : 8..8,
    P7 : 7..7,
    P6 : 6..6,
    P5 : 5..5,
    P4 : 4..4,
    P3 : 3..3,
    P2 : 2..2,
    P1 : 1..1,
    P0 : 0..0
  }

register PMZR_EL0 : PMZR_EL0_Type

bitfield PMICNTSVR_EL1_Type : bits(64) = {ICNT : 63..0}

register PMICNTSVR_EL1 : PMICNTSVR_EL1_Type

bitfield MDRAR_EL1_Type : bits(64) = {ROMADDR : 55..12, Valid : 1..0}

register MDRAR_EL1 : MDRAR_EL1_Type

type OSDTRRX_EL1_Type = bits(64)

register OSDTRRX_EL1 : OSDTRRX_EL1_Type

bitfield ICC_IGRPEN1_EL3_Type : bits(64) =
  {EnableGrp1S : 1..1, EnableGrp1NS : 0..0}

register ICC_IGRPEN1_EL3 : ICC_IGRPEN1_EL3_Type

bitfield ID_MMFR1_EL1_Type : bits(64) =
  {
    BPred : 31..28,
    L1TstCln : 27..24,
    L1Uni : 23..20,
    L1Hvd : 19..16,
    L1UniSW : 15..12,
    L1HvdSW : 11..8,
    L1UniVA : 7..4,
    L1HvdVA : 3..0
  }

register ID_MMFR1_EL1 : ID_MMFR1_EL1_Type

bitfield LORSA_EL1_Type : bits(64) = {SA : 55..16, Valid : 0..0}

register LORSA_EL1 : LORSA_EL1_Type

bitfield ID_AA64MMFR1_EL1_Type : bits(64) =
  {
    ECBHB : 63..60,
    CMOW : 59..56,
    TIDCP1 : 55..52,
    nTLBPA : 51..48,
    AFP : 47..44,
    HCX : 43..40,
    ETS : 39..36,
    TWED : 35..32,
    XNX : 31..28,
    SpecSEI : 27..24,
    PAN : 23..20,
    LO : 19..16,
    HPDS : 15..12,
    VH : 11..8,
    VMIDBits : 7..4,
    HAFDBS : 3..0
  }

register ID_AA64MMFR1_EL1 : ID_AA64MMFR1_EL1_Type

bitfield PMSWINC_EL0_Type : bits(64) =
  {
    P30 : 30..30,
    P29 : 29..29,
    P28 : 28..28,
    P27 : 27..27,
    P26 : 26..26,
    P25 : 25..25,
    P24 : 24..24,
    P23 : 23..23,
    P22 : 22..22,
    P21 : 21..21,
    P20 : 20..20,
    P19 : 19..19,
    P18 : 18..18,
    P17 : 17..17,
    P16 : 16..16,
    P15 : 15..15,
    P14 : 14..14,
    P13 : 13..13,
    P12 : 12..12,
    P11 : 11..11,
    P10 : 10..10,
    P9 : 9..9,
    P8 : 8..8,
    P7 : 7..7,
    P6 : 6..6,
    P5 : 5..5,
    P4 : 4..4,
    P3 : 3..3,
    P2 : 2..2,
    P1 : 1..1,
    P0 : 0..0
  }

register PMSWINC_EL0 : PMSWINC_EL0_Type

type SCXTNUM_EL2_Type = bits(64)

register SCXTNUM_EL2 : SCXTNUM_EL2_Type

val __set_CNTV_CTL_EL0 : CNTV_CTL_EL0_Type -> unit

function __set_CNTV_CTL_EL0 value_name = {
    let r : CNTV_CTL_EL0_Type = value_name;
    CNTV_CTL_EL0.bits[1 .. 0] = Slice(r.bits, 0, 2);
    CNTV_CTL_EL0.bits[63 .. 3] = Slice(r.bits, 3, 61);
    return()
}

bitfield PMIAR_EL1_Type : bits(64) = {ADDRESS : 63..0}

register PMIAR_EL1 : PMIAR_EL1_Type

type TPIDR_EL3_Type = bits(64)

register TPIDR_EL3 : TPIDR_EL3_Type

bitfield ID_MMFR0_EL1_Type : bits(64) =
  {
    InnerShr : 31..28,
    FCSE : 27..24,
    AuxReg : 23..20,
    TCM : 19..16,
    ShareLvl : 15..12,
    OuterShr : 11..8,
    PMSA : 7..4,
    VMSA : 3..0
  }

register ID_MMFR0_EL1 : ID_MMFR0_EL1_Type

type OSDTRTX_EL1_Type = bits(64)

register OSDTRTX_EL1 : OSDTRTX_EL1_Type

bitfield ICH_VMCR_EL2_Type : bits(64) =
  {
    VPMR : 31..24,
    VBPR0 : 23..21,
    VBPR1 : 20..18,
    VEOIM : 9..9,
    VCBPR : 4..4,
    VFIQEn : 3..3,
    VAckCtl : 2..2,
    VENG1 : 1..1,
    VENG0 : 0..0
  }

register ICH_VMCR_EL2 : ICH_VMCR_EL2_Type

bitfield VPIDR_EL2_Type : bits(64) =
  {
    Implementer : 31..24,
    Variant : 23..20,
    Architecture : 19..16,
    PartNum : 15..4,
    Revision : 3..0
  }

register VPIDR_EL2 : VPIDR_EL2_Type

type ACTLR_EL3_Type = bits(64)

register ACTLR_EL3 : ACTLR_EL3_Type

bitfield ICC_CTLR_EL3_Type : bits(64) =
  {
    ExtRange : 19..19,
    RSS : 18..18,
    nDS : 17..17,
    A3V : 15..15,
    SEIS : 14..14,
    IDbits : 13..11,
    PRIbits : 10..8,
    PMHE : 6..6,
    RM : 5..5,
    EOImode_EL1NS : 4..4,
    EOImode_EL1S : 3..3,
    EOImode_EL3 : 2..2,
    CBPR_EL1NS : 1..1,
    CBPR_EL1S : 0..0
  }

register ICC_CTLR_EL3 : ICC_CTLR_EL3_Type

val __set_SCTLR_EL2 : SCTLR_EL2_Type -> unit

function __set_SCTLR_EL2 value_name = {
    let r : SCTLR_EL2_Type = value_name;
    SCTLR_EL2.bits[6 .. 0] = Slice(r.bits, 0, 7);
    SCTLR_EL2.bits[63 .. 8] = Slice(r.bits, 8, 56);
    if not_bool(not_bool(__IMPDEF_boolean("IMPLEMENTED_ITD"))) then {
        SCTLR_EL2[ITD] = r[ITD]
    };
    return()
}

type AMAIR_EL2_Type = bits(64)

register AMAIR_EL2 : AMAIR_EL2_Type

type AMAIR_EL3_Type = bits(64)

register AMAIR_EL3 : AMAIR_EL3_Type

bitfield ICC_SRE_EL2_Type : bits(64) =
  {Enable : 3..3, DIB : 2..2, DFB : 1..1, SRE : 0..0}

register ICC_SRE_EL2 : ICC_SRE_EL2_Type

val __set_CNTPS_CTL_EL1 : CNTPS_CTL_EL1_Type -> unit

function __set_CNTPS_CTL_EL1 value_name = {
    let r : CNTPS_CTL_EL1_Type = value_name;
    CNTPS_CTL_EL1.bits[1 .. 0] = Slice(r.bits, 0, 2);
    CNTPS_CTL_EL1.bits[63 .. 3] = Slice(r.bits, 3, 61);
    return()
}

bitfield LORC_EL1_Type : bits(64) = {DS : 9..2, EN : 0..0}

register LORC_EL1 : LORC_EL1_Type

bitfield ID_AA64PFR2_EL1_Type : bits(64) =
  {MTEFAR : 11..8, MTESTOREONLY : 7..4, MTEPERM : 3..0}

register ID_AA64PFR2_EL1 : ID_AA64PFR2_EL1_Type

type SCXTNUM_EL1_Type = bits(64)

register SCXTNUM_EL1 : SCXTNUM_EL1_Type

bitfield CCSIDR2_EL1_Type : bits(64) = {NumSets : 23..0}

register CCSIDR2_EL1 : CCSIDR2_EL1_Type

bitfield ICC_ASGI1R_EL1_Type : bits(64) =
  {
    Aff3 : 55..48,
    RS : 47..44,
    IRM : 40..40,
    Aff2 : 39..32,
    INTID : 27..24,
    Aff1 : 23..16,
    TargetList : 15..0
  }

register ICC_ASGI1R_EL1 : ICC_ASGI1R_EL1_Type

bitfield ID_AA64ISAR2_EL1_Type : bits(64) =
  {
    CSSC : 55..52,
    RPRFM : 51..48,
    PRFMSLC : 43..40,
    SYSINSTR_128 : 39..36,
    SYSREG_128 : 35..32,
    CLRBHB : 31..28,
    PAC_frac : 27..24,
    BC : 23..20,
    MOPS : 19..16,
    APA3 : 15..12,
    GPA3 : 11..8,
    RPRES : 7..4,
    WFxT : 3..0
  }

register ID_AA64ISAR2_EL1 : ID_AA64ISAR2_EL1_Type

bitfield HFGRTR2_EL2_Type : bits(64) =
  {nRCWSMASK_EL1 : 2..2, nERXGSR_EL1 : 1..1, nPFAR_EL1 : 0..0}

register HFGRTR2_EL2 : HFGRTR2_EL2_Type

type TPIDRRO_EL0_Type = bits(64)

register TPIDRRO_EL0 : TPIDRRO_EL0_Type

bitfield ID_ISAR5_EL1_Type : bits(64) =
  {
    VCMA : 31..28,
    RDM : 27..24,
    CRC32 : 19..16,
    SHA2 : 15..12,
    SHA1 : 11..8,
    AES : 7..4,
    SEVL : 3..0
  }

register ID_ISAR5_EL1 : ID_ISAR5_EL1_Type

bitfield RMR_EL3_Type : bits(64) = {RR : 1..1, AA64 : 0..0}

register RMR_EL3 : RMR_EL3_Type

bitfield ICH_HCR_EL2_Type : bits(64) =
  {
    EOIcount : 31..27,
    DVIM : 15..15,
    TDIR : 14..14,
    TSEI : 13..13,
    TALL1 : 12..12,
    TALL0 : 11..11,
    TC : 10..10,
    vSGIEOICount : 8..8,
    VGrp1DIE : 7..7,
    VGrp1EIE : 6..6,
    VGrp0DIE : 5..5,
    VGrp0EIE : 4..4,
    NPIE : 3..3,
    LRENPIE : 2..2,
    UIE : 1..1,
    En : 0..0
  }

register ICH_HCR_EL2 : ICH_HCR_EL2_Type

bitfield ICC_IGRPEN0_EL1_Type : bits(64) = {Enable : 0..0}

register ICC_IGRPEN0_EL1 : ICC_IGRPEN0_EL1_Type

bitfield CNTHPS_TVAL_EL2_Type : bits(64) = {TimerValue : 31..0}

register CNTHPS_TVAL_EL2 : CNTHPS_TVAL_EL2_Type

bitfield ICC_BPR1_EL1_Type : bits(64) = {BinaryPoint : 2..0}

register ICC_BPR1_EL1_S : ICC_BPR1_EL1_Type

register ICC_BPR1_EL1_NS : ICC_BPR1_EL1_Type

val ICC_BPR1_EL1_read : unit -> ICC_BPR1_EL1_Type

function ICC_BPR1_EL1_read () = {
    r : ICC_BPR1_EL1_Type = undefined;
    if ELUsingAArch32(EL3) & CurrentSecurityState() == SS_Secure then {
        r = ICC_BPR1_EL1_S
    } else {
        r = ICC_BPR1_EL1_NS
    };
    return(r)
}

val ICC_BPR1_EL1_write : ICC_BPR1_EL1_Type -> unit

function ICC_BPR1_EL1_write value_name = {
    let r : ICC_BPR1_EL1_Type = value_name;
    if ELUsingAArch32(EL3) & CurrentSecurityState() == SS_Secure then {
        ICC_BPR1_EL1_S = r
    } else {
        ICC_BPR1_EL1_NS = r
    };
    return()
}

type AMAIR_EL1_Type = bits(64)

register AMAIR_EL1 : AMAIR_EL1_Type

type SCXTNUM_EL0_Type = bits(64)

register SCXTNUM_EL0 : SCXTNUM_EL0_Type

bitfield ICC_EOIR1_EL1_Type : bits(64) = {INTID : 23..0}

register ICC_EOIR1_EL1 : ICC_EOIR1_EL1_Type

bitfield ID_AA64MMFR0_EL1_Type : bits(64) =
  {
    ECV : 63..60,
    FGT : 59..56,
    ExS : 47..44,
    TGran4_2 : 43..40,
    TGran64_2 : 39..36,
    TGran16_2 : 35..32,
    TGran4 : 31..28,
    TGran64 : 27..24,
    TGran16 : 23..20,
    BigEndEL0 : 19..16,
    SNSMem : 15..12,
    BigEnd : 11..8,
    ASIDBits : 7..4,
    PARange : 3..0
  }

register ID_AA64MMFR0_EL1 : ID_AA64MMFR0_EL1_Type

type TPIDR2_EL0_Type = bits(64)

register TPIDR2_EL0 : TPIDR2_EL0_Type

val __set_PMCR_EL0 : PMCR_EL0_Type -> unit

function __set_PMCR_EL0 value_name = {
    let r : PMCR_EL0_Type = value_name;
    PMCR_EL0.bits[0] = Bit(Slice(r.bits, 0, 1));
    PMCR_EL0.bits[15 .. 3] = Slice(r.bits, 3, 13);
    PMCR_EL0.bits[63 .. 32] = Slice(r.bits, 32, 32);
    if not_bool(not_bool(IsFeatureImplemented(FEAT_PMUv3p7))) then {
        PMCR_EL0[IMP] = r[IMP]
    };
    if not_bool(PMCR_EL0[IMP] != 0b00000000) then {
        PMCR_EL0[IDCODE] = r[IDCODE]
    };
    PMCR_EL0[C] = r[C];
    PMCR_EL0[P] = r[P];
    return()
}

bitfield HDFGRTR2_EL2_Type : bits(64) =
  {
    nPMSDSFR_EL1 : 19..19,
    nSPMDEVAFF_EL1 : 18..18,
    nSPMID : 17..17,
    nSPMSCR_EL1 : 16..16,
    nSPMACCESSR_EL1 : 15..15,
    nSPMCR_EL0 : 14..14,
    nSPMOVS : 13..13,
    nSPMINTEN : 12..12,
    nSPMCNTEN : 11..11,
    nSPMSELR_EL0 : 10..10,
    nSPMEVTYPERn_EL0 : 9..9,
    nSPMEVCNTRn_EL0 : 8..8,
    nPMSSCR_EL1 : 7..7,
    nPMSSDATA : 6..6,
    nMDSELR_EL1 : 5..5,
    nPMUACR_EL1 : 4..4,
    nPMICFILTR_EL0 : 3..3,
    nPMICNTR_EL0 : 2..2,
    nPMIAR_EL1 : 1..1,
    nPMECR_EL1 : 0..0
  }

register HDFGRTR2_EL2 : HDFGRTR2_EL2_Type

val SDER32_EL3_write : SDER32_EL3_Type -> unit

function SDER32_EL3_write value_name = {
    let r : SDER32_EL3_Type = value_name;
    SDER32_EL2.bits[63 .. 0] = Slice(r.bits, 0, 64);
    _SDER32_EL3 = r;
    return()
}

bitfield VMPIDR_EL2_Type : bits(64) =
  {
    Aff3 : 39..32,
    U : 30..30,
    MT : 24..24,
    Aff2 : 23..16,
    Aff1 : 15..8,
    Aff0 : 7..0
  }

register VMPIDR_EL2 : VMPIDR_EL2_Type

bitfield ID_AA64MMFR3_EL1_Type : bits(64) =
  {
    Spec_FPACC : 63..60,
    ADERR : 59..56,
    SDERR : 55..52,
    ANERR : 47..44,
    SNERR : 43..40,
    D128_2 : 39..36,
    D128 : 35..32,
    MEC : 31..28,
    AIE : 27..24,
    S2POE : 23..20,
    S1POE : 19..16,
    S2PIE : 15..12,
    S1PIE : 11..8,
    SCTLRX : 7..4,
    TCRX : 3..0
  }

register ID_AA64MMFR3_EL1 : ID_AA64MMFR3_EL1_Type

bitfield ICH_VTR_EL2_Type : bits(64) =
  {
    PRIbits : 31..29,
    PREbits : 28..26,
    IDbits : 25..23,
    SEIS : 22..22,
    A3V : 21..21,
    nV4 : 20..20,
    TDS : 19..19,
    DVIM : 18..18,
    ListRegs : 4..0
  }

register ICH_VTR_EL2 : ICH_VTR_EL2_Type

bitfield ID_PFR1_EL1_Type : bits(64) =
  {
    GIC : 31..28,
    Virt_frac : 27..24,
    Sec_frac : 23..20,
    GenTimer : 19..16,
    Virtualization : 15..12,
    MProgMod : 11..8,
    Security : 7..4,
    ProgMod : 3..0
  }

register ID_PFR1_EL1 : ID_PFR1_EL1_Type

val __set_MDSELR_EL1 : MDSELR_EL1_Type -> unit

function __set_MDSELR_EL1 value_name = {
    let r : MDSELR_EL1_Type = value_name;
    MDSELR_EL1.bits[3 .. 0] = Slice(r.bits, 0, 4);
    MDSELR_EL1.bits[63 .. 6] = Slice(r.bits, 6, 58);
    if not_bool(NUM_BREAKPOINTS <= 16 & NUM_WATCHPOINTS <= 16) then {
        MDSELR_EL1[BANK] = r[BANK]
    };
    return()
}

val DBGDTR_EL0_write : DBGDTR_EL0_Type -> unit

function DBGDTR_EL0_write value_name = {
    let r : DBGDTR_EL0_Type = value_name;
    if __IMPDEF_boolean("read") then {
        DBGDTRTX_EL0[31 .. 0] = Slice(r.bits, 32, 32)
    } else {
        if __IMPDEF_boolean("read") then {
            DBGDTRTX_EL0[31 .. 0] = Slice(r.bits, 32, 32)
        } else {
            DBGDTRRX_EL0[31 .. 0] = Slice(r.bits, 32, 32)
        }
    };
    if __IMPDEF_boolean("read") then {
        DBGDTRRX_EL0[31 .. 0] = Slice(r.bits, 0, 32)
    } else {
        if __IMPDEF_boolean("read") then {
            DBGDTRRX_EL0[31 .. 0] = Slice(r.bits, 0, 32)
        } else {
            DBGDTRTX_EL0[31 .. 0] = Slice(r.bits, 0, 32)
        }
    };
    _DBGDTR_EL0 = r;
    return()
}

bitfield ICV_EOIR0_EL1_Type : bits(64) = {INTID : 23..0}

register ICV_EOIR0_EL1 : ICV_EOIR0_EL1_Type

bitfield ID_DFR1_EL1_Type : bits(64) = {HPMN0 : 7..4, MTPMU : 3..0}

register ID_DFR1_EL1 : ID_DFR1_EL1_Type

type SCXTNUM_EL3_Type = bits(64)

register SCXTNUM_EL3 : SCXTNUM_EL3_Type

type TPIDR_EL0_Type = bits(64)

register TPIDR_EL0 : TPIDR_EL0_Type

type ID_AFR0_EL1_Type = bits(64)

register ID_AFR0_EL1 : ID_AFR0_EL1_Type

bitfield RNDRRS_Type : bits(64) = {RNDRRS : 63..0}

register RNDRRS : RNDRRS_Type

bitfield LORN_EL1_Type : bits(64) = {Num : 7..0}

register LORN_EL1 : LORN_EL1_Type

bitfield ICV_IGRPEN0_EL1_Type : bits(64) = {Enable : 0..0}

register ICV_IGRPEN0_EL1 : ICV_IGRPEN0_EL1_Type

bitfield CCSIDR_EL1_Type : bits(64) = {Associativity : 23..3, LineSize : 2..0}

register CCSIDR_EL1 : CCSIDR_EL1_Type

bitfield SMPRIMAP_EL2_Type : bits(64) =
  {
    P15 : 63..60,
    P14 : 59..56,
    P13 : 55..52,
    P12 : 51..48,
    P11 : 47..44,
    P10 : 43..40,
    P9 : 39..36,
    P8 : 35..32,
    P7 : 31..28,
    P6 : 27..24,
    P5 : 23..20,
    P4 : 19..16,
    P3 : 15..12,
    P2 : 11..8,
    P1 : 7..4,
    P0 : 3..0
  }

register SMPRIMAP_EL2 : SMPRIMAP_EL2_Type

bitfield RNDR_Type : bits(64) = {RNDR : 63..0}

register RNDR : RNDR_Type

bitfield HFGRTR_EL2_Type : bits(64) =
  {
    nAMAIR2_EL1 : 63..63,
    nMAIR2_EL1 : 62..62,
    nS2POR_EL1 : 61..61,
    nPOR_EL1 : 60..60,
    nPOR_EL0 : 59..59,
    nPIR_EL1 : 58..58,
    nPIRE0_EL1 : 57..57,
    nRCWMASK_EL1 : 56..56,
    nTPIDR2_EL0 : 55..55,
    nSMPRI_EL1 : 54..54,
    nGCS_EL1 : 53..53,
    nGCS_EL0 : 52..52,
    nACCDATA_EL1 : 50..50,
    ERXADDR_EL1 : 49..49,
    ERXPFGCDN_EL1 : 48..48,
    ERXPFGCTL_EL1 : 47..47,
    ERXPFGF_EL1 : 46..46,
    ERXMISCn_EL1 : 45..45,
    ERXSTATUS_EL1 : 44..44,
    ERXCTLR_EL1 : 43..43,
    ERXFR_EL1 : 42..42,
    ERRSELR_EL1 : 41..41,
    ERRIDR_EL1 : 40..40,
    ICC_IGRPENn_EL1 : 39..39,
    VBAR_EL1 : 38..38,
    TTBR1_EL1 : 37..37,
    TTBR0_EL1 : 36..36,
    TPIDR_EL0 : 35..35,
    TPIDRRO_EL0 : 34..34,
    TPIDR_EL1 : 33..33,
    TCR_EL1 : 32..32,
    SCXTNUM_EL0 : 31..31,
    SCXTNUM_EL1 : 30..30,
    SCTLR_EL1 : 29..29,
    REVIDR_EL1 : 28..28,
    PAR_EL1 : 27..27,
    MPIDR_EL1 : 26..26,
    MIDR_EL1 : 25..25,
    MAIR_EL1 : 24..24,
    LORSA_EL1 : 23..23,
    LORN_EL1 : 22..22,
    LORID_EL1 : 21..21,
    LOREA_EL1 : 20..20,
    LORC_EL1 : 19..19,
    ISR_EL1 : 18..18,
    FAR_EL1 : 17..17,
    ESR_EL1 : 16..16,
    DCZID_EL0 : 15..15,
    CTR_EL0 : 14..14,
    CSSELR_EL1 : 13..13,
    CPACR_EL1 : 12..12,
    CONTEXTIDR_EL1 : 11..11,
    CLIDR_EL1 : 10..10,
    CCSIDR_EL1 : 9..9,
    APIBKey : 8..8,
    APIAKey : 7..7,
    APGAKey : 6..6,
    APDBKey : 5..5,
    APDAKey : 4..4,
    AMAIR_EL1 : 3..3,
    AIDR_EL1 : 2..2,
    AFSR1_EL1 : 1..1,
    AFSR0_EL1 : 0..0
  }

register HFGRTR_EL2 : HFGRTR_EL2_Type

bitfield ID_DFR0_EL1_Type : bits(64) =
  {
    TraceFilt : 31..28,
    PerfMon : 27..24,
    MProfDbg : 23..20,
    MMapTrc : 19..16,
    CopTrc : 15..12,
    MMapDbg : 11..8,
    CopSDbg : 7..4,
    CopDbg : 3..0
  }

register ID_DFR0_EL1 : ID_DFR0_EL1_Type

bitfield ICV_IGRPEN1_EL1_Type : bits(64) = {Enable : 0..0}

register ICV_IGRPEN1_EL1 : ICV_IGRPEN1_EL1_Type

bitfield PMXEVCNTR_EL0_Type : bits(64) = {PMEVCNTR : 63..0}

register PMXEVCNTR_EL0 : PMXEVCNTR_EL0_Type

bitfield HFGWTR2_EL2_Type : bits(64) = {nRCWSMASK_EL1 : 2..2, nPFAR_EL1 : 0..0}

register HFGWTR2_EL2 : HFGWTR2_EL2_Type

bitfield ICC_SGI1R_EL1_Type : bits(64) =
  {
    Aff3 : 55..48,
    RS : 47..44,
    IRM : 40..40,
    Aff2 : 39..32,
    INTID : 27..24,
    Aff1 : 23..16,
    TargetList : 15..0
  }

register ICC_SGI1R_EL1 : ICC_SGI1R_EL1_Type

type HACR_EL2_Type = bits(64)

register HACR_EL2 : HACR_EL2_Type

bitfield MVFR2_EL1_Type : bits(64) = {FPMisc : 7..4, SIMDMisc : 3..0}

register MVFR2_EL1 : MVFR2_EL1_Type

bitfield DBGAUTHSTATUS_EL1_Type : bits(64) =
  {
    RTNID : 27..26,
    RTID : 25..24,
    RLNID : 15..14,
    RLID : 13..12,
    SNID : 7..6,
    SID : 5..4,
    NSNID : 3..2,
    NSID : 1..0
  }

register DBGAUTHSTATUS_EL1 : DBGAUTHSTATUS_EL1_Type

type AMAIR2_EL3_Type = bits(64)

register AMAIR2_EL3 : AMAIR2_EL3_Type

bitfield ICC_SRE_EL3_Type : bits(64) =
  {Enable : 3..3, DIB : 2..2, DFB : 1..1, SRE : 0..0}

register ICC_SRE_EL3 : ICC_SRE_EL3_Type

type AFSR1_EL3_Type = bits(64)

register AFSR1_EL3 : AFSR1_EL3_Type

bitfield ID_MMFR3_EL1_Type : bits(64) =
  {
    Supersec : 31..28,
    CMemSz : 27..24,
    CohWalk : 23..20,
    PAN : 19..16,
    MaintBcst : 15..12,
    BPMaint : 11..8,
    CMaintSW : 7..4,
    CMaintVA : 3..0
  }

register ID_MMFR3_EL1 : ID_MMFR3_EL1_Type

bitfield HDFGWTR_EL2_Type : bits(64) =
  {
    nPMSNEVFR_EL1 : 62..62,
    nBRBDATA : 61..61,
    nBRBCTL : 60..60,
    PMUSERENR_EL0 : 57..57,
    TRFCR_EL1 : 49..49,
    TRCVICTLR : 48..48,
    TRCSSCSRn : 46..46,
    TRCSEQSTR : 45..45,
    TRCPRGCTLR : 44..44,
    TRCOSLAR : 42..42,
    TRCIMSPECn : 41..41,
    TRCCNTVRn : 37..37,
    TRCCLAIM : 36..36,
    TRCAUXCTLR : 35..35,
    TRC : 33..33,
    PMSLATFR_EL1 : 32..32,
    PMSIRR_EL1 : 31..31,
    PMSICR_EL1 : 29..29,
    PMSFCR_EL1 : 28..28,
    PMSEVFR_EL1 : 27..27,
    PMSCR_EL1 : 26..26,
    PMBSR_EL1 : 25..25,
    PMBPTR_EL1 : 24..24,
    PMBLIMITR_EL1 : 23..23,
    PMCR_EL0 : 21..21,
    PMSWINC_EL0 : 20..20,
    PMSELR_EL0 : 19..19,
    PMOVS : 18..18,
    PMINTEN : 17..17,
    PMCNTEN : 16..16,
    PMCCNTR_EL0 : 15..15,
    PMCCFILTR_EL0 : 14..14,
    PMEVTYPERn_EL0 : 13..13,
    PMEVCNTRn_EL0 : 12..12,
    OSDLR_EL1 : 11..11,
    OSECCR_EL1 : 10..10,
    OSLAR_EL1 : 8..8,
    DBGPRCR_EL1 : 7..7,
    DBGCLAIM : 5..5,
    MDSCR_EL1 : 4..4,
    DBGWVRn_EL1 : 3..3,
    DBGWCRn_EL1 : 2..2,
    DBGBVRn_EL1 : 1..1,
    DBGBCRn_EL1 : 0..0
  }

register HDFGWTR_EL2 : HDFGWTR_EL2_Type

bitfield PMCEID1_EL0_Type : bits(64) =
  {
    IDhi31 : 63..63,
    IDhi30 : 62..62,
    IDhi29 : 61..61,
    IDhi28 : 60..60,
    IDhi27 : 59..59,
    IDhi26 : 58..58,
    IDhi25 : 57..57,
    IDhi24 : 56..56,
    IDhi23 : 55..55,
    IDhi22 : 54..54,
    IDhi21 : 53..53,
    IDhi20 : 52..52,
    IDhi19 : 51..51,
    IDhi18 : 50..50,
    IDhi17 : 49..49,
    IDhi16 : 48..48,
    IDhi15 : 47..47,
    IDhi14 : 46..46,
    IDhi13 : 45..45,
    IDhi12 : 44..44,
    IDhi11 : 43..43,
    IDhi10 : 42..42,
    IDhi9 : 41..41,
    IDhi8 : 40..40,
    IDhi7 : 39..39,
    IDhi6 : 38..38,
    IDhi5 : 37..37,
    IDhi4 : 36..36,
    IDhi3 : 35..35,
    IDhi2 : 34..34,
    IDhi1 : 33..33,
    IDhi0 : 32..32,
    ID31 : 31..31,
    ID30 : 30..30,
    ID29 : 29..29,
    ID28 : 28..28,
    ID27 : 27..27,
    ID26 : 26..26,
    ID25 : 25..25,
    ID24 : 24..24,
    ID23 : 23..23,
    ID22 : 22..22,
    ID21 : 21..21,
    ID20 : 20..20,
    ID19 : 19..19,
    ID18 : 18..18,
    ID17 : 17..17,
    ID16 : 16..16,
    ID15 : 15..15,
    ID14 : 14..14,
    ID13 : 13..13,
    ID12 : 12..12,
    ID11 : 11..11,
    ID10 : 10..10,
    ID9 : 9..9,
    ID8 : 8..8,
    ID7 : 7..7,
    ID6 : 6..6,
    ID5 : 5..5,
    ID4 : 4..4,
    ID3 : 3..3,
    ID2 : 2..2,
    ID1 : 1..1,
    ID0 : 0..0
  }

register PMCEID1_EL0 : PMCEID1_EL0_Type

bitfield CNTPS_TVAL_EL1_Type : bits(64) = {TimerValue : 31..0}

register CNTPS_TVAL_EL1 : CNTPS_TVAL_EL1_Type

type ID_AA64AFR1_EL1_Type = bits(64)

register ID_AA64AFR1_EL1 : ID_AA64AFR1_EL1_Type

bitfield ICV_AP1R_EL1_Type : bits(64) = {NMI : 63..63}

register ICV_AP1R_EL1 : vector(4, ICV_AP1R_EL1_Type)

bitfield LOREA_EL1_Type : bits(64) = {EA : (55..52 @ (51..48 @ 47..16))}

register LOREA_EL1 : LOREA_EL1_Type

bitfield CNTV_TVAL_EL0_Type : bits(64) = {TimerValue : 31..0}

register CNTV_TVAL_EL0 : CNTV_TVAL_EL0_Type

bitfield ICV_DIR_EL1_Type : bits(64) = {INTID : 23..0}

register ICV_DIR_EL1 : ICV_DIR_EL1_Type

bitfield ICC_IAR1_EL1_Type : bits(64) = {INTID : 23..0}

register ICC_IAR1_EL1 : ICC_IAR1_EL1_Type

bitfield MPIDR_EL1_Type : bits(64) =
  {
    Aff3 : 39..32,
    U : 30..30,
    MT : 24..24,
    Aff2 : 23..16,
    Aff1 : 15..8,
    Aff0 : 7..0
  }

register MPIDR_EL1 : MPIDR_EL1_Type

bitfield DBGCLAIMCLR_EL1_Type : bits(64) = {CLAIM : 7..0}

register DBGCLAIMCLR_EL1 : DBGCLAIMCLR_EL1_Type

bitfield PMCEID0_EL0_Type : bits(64) =
  {
    IDhi31 : 63..63,
    IDhi30 : 62..62,
    IDhi29 : 61..61,
    IDhi28 : 60..60,
    IDhi27 : 59..59,
    IDhi26 : 58..58,
    IDhi25 : 57..57,
    IDhi24 : 56..56,
    IDhi23 : 55..55,
    IDhi22 : 54..54,
    IDhi21 : 53..53,
    IDhi20 : 52..52,
    IDhi19 : 51..51,
    IDhi18 : 50..50,
    IDhi17 : 49..49,
    IDhi16 : 48..48,
    IDhi15 : 47..47,
    IDhi14 : 46..46,
    IDhi13 : 45..45,
    IDhi12 : 44..44,
    IDhi11 : 43..43,
    IDhi10 : 42..42,
    IDhi9 : 41..41,
    IDhi8 : 40..40,
    IDhi7 : 39..39,
    IDhi6 : 38..38,
    IDhi5 : 37..37,
    IDhi4 : 36..36,
    IDhi3 : 35..35,
    IDhi2 : 34..34,
    IDhi1 : 33..33,
    IDhi0 : 32..32,
    ID31 : 31..31,
    ID30 : 30..30,
    ID29 : 29..29,
    ID28 : 28..28,
    ID27 : 27..27,
    ID26 : 26..26,
    ID25 : 25..25,
    ID24 : 24..24,
    ID23 : 23..23,
    ID22 : 22..22,
    ID21 : 21..21,
    ID20 : 20..20,
    ID19 : 19..19,
    ID18 : 18..18,
    ID17 : 17..17,
    ID16 : 16..16,
    ID15 : 15..15,
    ID14 : 14..14,
    ID13 : 13..13,
    ID12 : 12..12,
    ID11 : 11..11,
    ID10 : 10..10,
    ID9 : 9..9,
    ID8 : 8..8,
    ID7 : 7..7,
    ID6 : 6..6,
    ID5 : 5..5,
    ID4 : 4..4,
    ID3 : 3..3,
    ID2 : 2..2,
    ID1 : 1..1,
    ID0 : 0..0
  }

register PMCEID0_EL0 : PMCEID0_EL0_Type

bitfield ICV_HPPIR1_EL1_Type : bits(64) = {INTID : 23..0}

register ICV_HPPIR1_EL1 : ICV_HPPIR1_EL1_Type

type ID_AA64AFR0_EL1_Type = bits(64)

register ID_AA64AFR0_EL1 : ID_AA64AFR0_EL1_Type

type AFSR0_EL2_Type = bits(64)

register AFSR0_EL2 : AFSR0_EL2_Type

type AMAIR2_EL1_Type = bits(64)

register AMAIR2_EL1 : AMAIR2_EL1_Type

bitfield ID_PFR2_EL1_Type : bits(64) =
  {RAS_frac : 11..8, SSBS : 7..4, CSV3 : 3..0}

register ID_PFR2_EL1 : ID_PFR2_EL1_Type

bitfield SPMACCESSR_EL3_Type : bits(64) =
  {
    P31 : 63..62,
    P30 : 61..60,
    P29 : 59..58,
    P28 : 57..56,
    P27 : 55..54,
    P26 : 53..52,
    P25 : 51..50,
    P24 : 49..48,
    P23 : 47..46,
    P22 : 45..44,
    P21 : 43..42,
    P20 : 41..40,
    P19 : 39..38,
    P18 : 37..36,
    P17 : 35..34,
    P16 : 33..32,
    P15 : 31..30,
    P14 : 29..28,
    P13 : 27..26,
    P12 : 25..24,
    P11 : 23..22,
    P10 : 21..20,
    P9 : 19..18,
    P8 : 17..16,
    P7 : 15..14,
    P6 : 13..12,
    P5 : 11..10,
    P4 : 9..8,
    P3 : 7..6,
    P2 : 5..4,
    P1 : 3..2,
    P0 : 1..0
  }

register SPMACCESSR_EL3 : SPMACCESSR_EL3_Type

val __get_selected_SPMACCESSR_EL3_field : unit -> bits(2)

function __get_selected_SPMACCESSR_EL3_field () = {
    let 'idx = UInt(SPMSELR_EL0[SYSPMUSEL]) * 2;
    return(Slice(SPMACCESSR_EL3.bits, idx, 2))
}

val __set_CNTHV_CTL_EL2 : CNTHV_CTL_EL2_Type -> unit

function __set_CNTHV_CTL_EL2 value_name = {
    let r : CNTHV_CTL_EL2_Type = value_name;
    CNTHV_CTL_EL2.bits[1 .. 0] = Slice(r.bits, 0, 2);
    CNTHV_CTL_EL2.bits[63 .. 3] = Slice(r.bits, 3, 61);
    return()
}

bitfield ICC_EOIR0_EL1_Type : bits(64) = {INTID : 23..0}

register ICC_EOIR0_EL1 : ICC_EOIR0_EL1_Type

bitfield ID_AA64ZFR0_EL1_Type : bits(64) =
  {
    F64MM : 59..56,
    F32MM : 55..52,
    I8MM : 47..44,
    SM4 : 43..40,
    SHA3 : 35..32,
    B16B16 : 27..24,
    BF16 : 23..20,
    BitPerm : 19..16,
    AES : 7..4,
    SVEver : 3..0
  }

register ID_AA64ZFR0_EL1 : ID_AA64ZFR0_EL1_Type

bitfield ICC_SGI1R_Type : bits(64) =
  {
    Aff3 : 55..48,
    RS : 47..44,
    IRM : 40..40,
    Aff2 : 39..32,
    INTID : 27..24,
    Aff1 : 23..16,
    TargetList : 15..0
  }

register _ICC_SGI1R : ICC_SGI1R_Type

val ICC_SGI1R_read : unit -> ICC_SGI1R_Type

function ICC_SGI1R_read () = {
    r : ICC_SGI1R_Type = _ICC_SGI1R;
    r.bits[63 .. 0] = Slice(ICC_SGI1R_EL1.bits, 0, 64);
    return(r)
}

val ICC_SGI1R_write : ICC_SGI1R_Type -> unit

function ICC_SGI1R_write value_name = {
    let r : ICC_SGI1R_Type = value_name;
    ICC_SGI1R_EL1.bits[63 .. 0] = Slice(r.bits, 0, 64);
    _ICC_SGI1R = r;
    return()
}

type DBGDSAR_Type = bits(64)

register DBGDSAR : DBGDSAR_Type

bitfield ICC_SGI0R_Type : bits(64) =
  {
    Aff3 : 55..48,
    RS : 47..44,
    IRM : 40..40,
    Aff2 : 39..32,
    INTID : 27..24,
    Aff1 : 23..16,
    TargetList : 15..0
  }

register _ICC_SGI0R : ICC_SGI0R_Type

val ICC_SGI0R_read : unit -> ICC_SGI0R_Type

function ICC_SGI0R_read () = {
    r : ICC_SGI0R_Type = _ICC_SGI0R;
    r.bits[63 .. 0] = Slice(ICC_SGI0R_EL1.bits, 0, 64);
    return(r)
}

val ICC_SGI0R_write : ICC_SGI0R_Type -> unit

function ICC_SGI0R_write value_name = {
    let r : ICC_SGI0R_Type = value_name;
    ICC_SGI0R_EL1.bits[63 .. 0] = Slice(r.bits, 0, 64);
    _ICC_SGI0R = r;
    return()
}

type CNTVOFF_Type = bits(64)

register _CNTVOFF : CNTVOFF_Type

val CNTVOFF_read : unit -> CNTVOFF_Type

function CNTVOFF_read () = {
    r : CNTVOFF_Type = _CNTVOFF;
    r[63 .. 0] = Slice(CNTVOFF_EL2, 0, 64);
    return(r)
}

val CNTVOFF_write : CNTVOFF_Type -> unit

function CNTVOFF_write value_name = {
    let r : CNTVOFF_Type = value_name;
    CNTVOFF_EL2[63 .. 0] = Slice(r, 0, 64);
    _CNTVOFF = r;
    return()
}

bitfield ICC_ASGI1R_Type : bits(64) =
  {
    Aff3 : 55..48,
    RS : 47..44,
    IRM : 40..40,
    Aff2 : 39..32,
    INTID : 27..24,
    Aff1 : 23..16,
    TargetList : 15..0
  }

register _ICC_ASGI1R : ICC_ASGI1R_Type

val ICC_ASGI1R_read : unit -> ICC_ASGI1R_Type

function ICC_ASGI1R_read () = {
    r : ICC_ASGI1R_Type = _ICC_ASGI1R;
    r.bits[63 .. 0] = Slice(ICC_ASGI1R_EL1.bits, 0, 64);
    return(r)
}

val ICC_ASGI1R_write : ICC_ASGI1R_Type -> unit

function ICC_ASGI1R_write value_name = {
    let r : ICC_ASGI1R_Type = value_name;
    ICC_ASGI1R_EL1.bits[63 .. 0] = Slice(r.bits, 0, 64);
    _ICC_ASGI1R = r;
    return()
}

val CNTHP_CVAL_write : CNTHP_CVAL_Type -> unit

function CNTHP_CVAL_write value_name = {
    let r : CNTHP_CVAL_Type = value_name;
    CNTHP_CVAL_EL2.bits[63 .. 0] = Slice(r.bits, 0, 64);
    _CNTHP_CVAL = r;
    return()
}

bitfield CNTV_CVAL_Type : bits(64) = {CompareValue : 63..0}

register _CNTV_CVAL : CNTV_CVAL_Type

val CNTV_CVAL_read : unit -> CNTV_CVAL_Type

function CNTV_CVAL_read () = {
    r : CNTV_CVAL_Type = _CNTV_CVAL;
    r.bits[63 .. 0] = Slice(CNTV_CVAL_EL0.bits, 0, 64);
    return(r)
}

val CNTV_CVAL_write : CNTV_CVAL_Type -> unit

function CNTV_CVAL_write value_name = {
    let r : CNTV_CVAL_Type = value_name;
    CNTV_CVAL_EL0.bits[63 .. 0] = Slice(r.bits, 0, 64);
    _CNTV_CVAL = r;
    return()
}

val TTBR1_write : TTBR1_Type -> unit

function TTBR1_write value_name = {
    let r : TTBR1_Type = value_name;
    if ELUsingAArch32(EL3) & CurrentSecurityState() == SS_Secure then {
        TTBR1_S = r
    } else {
        TTBR1_NS = r
    };
    return()
}

val TTBR0_write : TTBR0_Type -> unit

function TTBR0_write value_name = {
    let r : TTBR0_Type = value_name;
    if ELUsingAArch32(EL3) & CurrentSecurityState() == SS_Secure then {
        TTBR0_S = r
    } else {
        TTBR0_NS = r
    };
    return()
}

bitfield DBGDRAR_Type : bits(64) = {ROMADDR : 47..12, Valid : 1..0}

register _DBGDRAR : DBGDRAR_Type

val DBGDRAR_read : unit -> DBGDRAR_Type

function DBGDRAR_read () = {
    r : DBGDRAR_Type = _DBGDRAR;
    r.bits[63 .. 0] = Slice(MDRAR_EL1.bits, 0, 64);
    return(r)
}

val DBGDRAR_write : DBGDRAR_Type -> unit

function DBGDRAR_write value_name = {
    let r : DBGDRAR_Type = value_name;
    MDRAR_EL1.bits[63 .. 0] = Slice(r.bits, 0, 64);
    _DBGDRAR = r;
    return()
}

val CNTP_CVAL_NS_write : CNTP_CVAL_Type -> unit

function CNTP_CVAL_NS_write value_name = {
    let r : CNTP_CVAL_Type = value_name;
    CNTP_CVAL_EL0.bits[63 .. 0] = Slice(r.bits, 0, 64);
    _CNTP_CVAL_NS = r;
    return()
}

val CNTP_CVAL_write : CNTP_CVAL_Type -> unit

function CNTP_CVAL_write value_name = {
    let r : CNTP_CVAL_Type = value_name;
    if ELUsingAArch32(EL3) & CurrentSecurityState() == SS_Secure then {
        CNTP_CVAL_S = r
    } else {
        CNTP_CVAL_NS_write() = r
    };
    return()
}

bitfield ID_AA64SMFR0_EL1_Type : bits(64) =
  {
    FA64 : 63..63,
    SMEver : 59..56,
    I16I64 : 55..52,
    F64F64 : 48..48,
    I16I32 : 47..44,
    B16B16 : 43..43,
    F16F16 : 42..42,
    I8I32 : 39..36,
    F16F32 : 35..35,
    B16F32 : 34..34,
    BI32I32 : 33..33,
    F32F32 : 32..32
  }

register ID_AA64SMFR0_EL1 : ID_AA64SMFR0_EL1_Type

val __set_MPAM2_EL2 : MPAM2_EL2_Type -> unit

function __set_MPAM2_EL2 value_name = {
    let r : MPAM2_EL2_Type = value_name;
    MPAM2_EL2.bits[53 .. 0] = Slice(r.bits, 0, 54);
    MPAM2_EL2.bits[62 .. 55] = Slice(r.bits, 55, 8);
    if not_bool(HaveEL(EL3)) then {
        MPAM2_EL2[MPAMEN] = r[MPAMEN]
    };
    return()
}

val MPAM3_EL3_write : MPAM3_EL3_Type -> unit

function MPAM3_EL3_write value_name = {
    let r : MPAM3_EL3_Type = value_name;
    MPAM2_EL2.bits[63] = Bit(Slice(r.bits, 63, 1));
    _MPAM3_EL3 = r;
    return()
}

val __set_MPAM3_EL3 : MPAM3_EL3_Type -> unit

function __set_MPAM3_EL3 value_name = {
    let r : MPAM3_EL3_Type = value_name;
    MPAM3_EL3_write() = Mk_MPAM3_EL3_Type(SetSlice(63, MPAM3_EL3_read().bits, 0, Slice(r.bits, 0, 63)));
    MPAM3_EL3_write() = [MPAM3_EL3_read() with MPAMEN = r[MPAMEN]];
    return()
}

val MPAM1_EL1_write : MPAM1_EL1_Type -> unit

function MPAM1_EL1_write value_name = {
    let r : MPAM1_EL1_Type = value_name;
    if HaveEL(EL3) then {
        MPAM3_EL3_write() = Mk_MPAM3_EL3_Type(SetSlice(1, MPAM3_EL3_read().bits, 63, Slice(r.bits, 63, 1)))
    } else {
        MPAM2_EL2.bits[63] = Bit(Slice(r.bits, 63, 1))
    };
    _MPAM1_EL1 = r;
    return()
}

val __set_MPAM1_EL1 : MPAM1_EL1_Type -> unit

function __set_MPAM1_EL1 value_name = {
    let r : MPAM1_EL1_Type = value_name;
    MPAM1_EL1_write() = Mk_MPAM1_EL1_Type(SetSlice(54, MPAM1_EL1_read().bits, 0, Slice(r.bits, 0, 54)));
    MPAM1_EL1_write() = Mk_MPAM1_EL1_Type(SetSlice(5, MPAM1_EL1_read().bits, 55, Slice(r.bits, 55, 5)));
    MPAM1_EL1_write() = Mk_MPAM1_EL1_Type(SetSlice(2, MPAM1_EL1_read().bits, 61, Slice(r.bits, 61, 2)));
    if not_bool(HaveEL(EL3)) & not_bool(HaveEL(EL2)) then {
        MPAM1_EL1_write() = [MPAM1_EL1_read() with MPAMEN = r[MPAMEN]]
    };
    return()
}

bitfield GMID_EL1_Type : bits(64) = {BS : 3..0}

register GMID_EL1 : GMID_EL1_Type

bitfield AMEVCNTR1_EL0_Type : bits(64) = {ACNT : 63..0}

register AMEVCNTR1_EL0 : vector(16, AMEVCNTR1_EL0_Type)

type AMEVCNTVOFF0_EL2_Type = bits(64)

register AMEVCNTVOFF0_EL2 : vector(16, AMEVCNTVOFF0_EL2_Type)

bitfield AMEVCNTR0_Type : bits(64) = {ACNT : 63..0}

register AMEVCNTR0 : vector(4, AMEVCNTR0_Type)

bitfield AMEVCNTR1_Type : bits(64) = {ACNT : 63..0}

register _AMEVCNTR1 : vector(16, AMEVCNTR1_Type)

val AMEVCNTR1_read : forall 'n, (0 <= 'n & 'n < 16). int('n) -> AMEVCNTR1_Type

function AMEVCNTR1_read n = {
    r : AMEVCNTR1_Type = _AMEVCNTR1[n];
    r.bits[63 .. 0] = Slice(AMEVCNTR1_EL0[n].bits, 0, 64);
    return(r)
}

val AMEVCNTR1_set : forall 'n, (0 <= 'n & 'n < 16).
  (int('n), AMEVCNTR1_Type) -> unit

function AMEVCNTR1_set (n, value_name) = {
    let r : AMEVCNTR1_Type = value_name;
    AMEVCNTR1_EL0[n].bits[63 .. 0] = Slice(r.bits, 0, 64);
    _AMEVCNTR1[n] = r;
    return()
}

bitfield AMCR_EL0_Type : bits(64) = {CG1RZ : 17..17, HDBG : 10..10}

register AMCR_EL0 : AMCR_EL0_Type

bitfield AMCNTENSET0_EL0_Type : bits(64) =
  {P3 : 3..3, P2 : 2..2, P1 : 1..1, P0 : 0..0}

register AMCNTENSET0_EL0 : AMCNTENSET0_EL0_Type

bitfield AMCNTENCLR0_EL0_Type : bits(64) =
  {P3 : 3..3, P2 : 2..2, P1 : 1..1, P0 : 0..0}

register AMCNTENCLR0_EL0 : AMCNTENCLR0_EL0_Type

bitfield AMEVTYPER0_EL0_Type : bits(64) = {evtCount : 15..0}

register AMEVTYPER0_EL0 : vector(4, AMEVTYPER0_EL0_Type)

bitfield AMCNTENSET1_EL0_Type : bits(64) =
  {
    P15 : 15..15,
    P14 : 14..14,
    P13 : 13..13,
    P12 : 12..12,
    P11 : 11..11,
    P10 : 10..10,
    P9 : 9..9,
    P8 : 8..8,
    P7 : 7..7,
    P6 : 6..6,
    P5 : 5..5,
    P4 : 4..4,
    P3 : 3..3,
    P2 : 2..2,
    P1 : 1..1,
    P0 : 0..0
  }

register AMCNTENSET1_EL0 : AMCNTENSET1_EL0_Type

bitfield AMCNTENCLR1_EL0_Type : bits(64) =
  {
    P15 : 15..15,
    P14 : 14..14,
    P13 : 13..13,
    P12 : 12..12,
    P11 : 11..11,
    P10 : 10..10,
    P9 : 9..9,
    P8 : 8..8,
    P7 : 7..7,
    P6 : 6..6,
    P5 : 5..5,
    P4 : 4..4,
    P3 : 3..3,
    P2 : 2..2,
    P1 : 1..1,
    P0 : 0..0
  }

register AMCNTENCLR1_EL0 : AMCNTENCLR1_EL0_Type

bitfield AMEVCNTR0_EL0_Type : bits(64) = {ACNT : 63..0}

register _AMEVCNTR0_EL0 : vector(4, AMEVCNTR0_EL0_Type)

val AMEVCNTR0_EL0_read : forall 'n, (0 <= 'n & 'n < 4).
  int('n) -> AMEVCNTR0_EL0_Type

function AMEVCNTR0_EL0_read n = {
    r : AMEVCNTR0_EL0_Type = _AMEVCNTR0_EL0[n];
    r.bits[63 .. 0] = Slice(AMEVCNTR0[n].bits, 0, 64);
    return(r)
}

val AMEVCNTR0_EL0_set : forall 'n, (0 <= 'n & 'n < 4).
  (int('n), AMEVCNTR0_EL0_Type) -> unit

function AMEVCNTR0_EL0_set (n, value_name) = {
    let r : AMEVCNTR0_EL0_Type = value_name;
    AMEVCNTR0[n].bits[63 .. 0] = Slice(r.bits, 0, 64);
    _AMEVCNTR0_EL0[n] = r;
    return()
}

bitfield AMCFGR_EL0_Type : bits(64) =
  {NCG : 31..28, HDBG : 24..24, SIZE : 13..8, N : 7..0}

register AMCFGR_EL0 : AMCFGR_EL0_Type

type AMEVCNTVOFF1_EL2_Type = bits(64)

register AMEVCNTVOFF1_EL2 : vector(16, AMEVCNTVOFF1_EL2_Type)

bitfield AMUSERENR_EL0_Type : bits(64) = {EN : 0..0}

register AMUSERENR_EL0 : AMUSERENR_EL0_Type

bitfield AMCG1IDR_EL0_Type : bits(64) =
  {
    AMEVCNTOFF115_EL2 : 31..31,
    AMEVCNTOFF114_EL2 : 30..30,
    AMEVCNTOFF113_EL2 : 29..29,
    AMEVCNTOFF112_EL2 : 28..28,
    AMEVCNTOFF111_EL2 : 27..27,
    AMEVCNTOFF110_EL2 : 26..26,
    AMEVCNTOFF19_EL2 : 25..25,
    AMEVCNTOFF18_EL2 : 24..24,
    AMEVCNTOFF17_EL2 : 23..23,
    AMEVCNTOFF16_EL2 : 22..22,
    AMEVCNTOFF15_EL2 : 21..21,
    AMEVCNTOFF14_EL2 : 20..20,
    AMEVCNTOFF13_EL2 : 19..19,
    AMEVCNTOFF12_EL2 : 18..18,
    AMEVCNTOFF11_EL2 : 17..17,
    AMEVCNTOFF10_EL2 : 16..16,
    AMEVCNTR115_EL0 : 15..15,
    AMEVCNTR114_EL0 : 14..14,
    AMEVCNTR113_EL0 : 13..13,
    AMEVCNTR112_EL0 : 12..12,
    AMEVCNTR111_EL0 : 11..11,
    AMEVCNTR110_EL0 : 10..10,
    AMEVCNTR19_EL0 : 9..9,
    AMEVCNTR18_EL0 : 8..8,
    AMEVCNTR17_EL0 : 7..7,
    AMEVCNTR16_EL0 : 6..6,
    AMEVCNTR15_EL0 : 5..5,
    AMEVCNTR14_EL0 : 4..4,
    AMEVCNTR13_EL0 : 3..3,
    AMEVCNTR12_EL0 : 2..2,
    AMEVCNTR11_EL0 : 1..1,
    AMEVCNTR10_EL0 : 0..0
  }

register AMCG1IDR_EL0 : AMCG1IDR_EL0_Type

bitfield AMEVTYPER1_EL0_Type : bits(64) = {evtCount : 15..0}

register AMEVTYPER1_EL0 : vector(16, AMEVTYPER1_EL0_Type)

bitfield AMCGCR_EL0_Type : bits(64) = {CG1NC : 15..8, CG0NC : 7..0}

register AMCGCR_EL0 : AMCGCR_EL0_Type

val __set_PMSNEVFR_EL1 : PMSNEVFR_EL1_Type -> unit

function __set_PMSNEVFR_EL1 value_name = {
    r : PMSNEVFR_EL1_Type = value_name;
    if not_bool(__IMPDEF_boolean("event 63 is not implemented, or filtering on event 63 is not supported")) then {
        r[E63] = PMSNEVFR_EL1[E63]
    };
    if not_bool(__IMPDEF_boolean("event 62 is not implemented, or filtering on event 62 is not supported")) then {
        r[E62] = PMSNEVFR_EL1[E62]
    };
    if not_bool(__IMPDEF_boolean("event 61 is not implemented, or filtering on event 61 is not supported")) then {
        r[E61] = PMSNEVFR_EL1[E61]
    };
    if not_bool(__IMPDEF_boolean("event 60 is not implemented, or filtering on event 60 is not supported")) then {
        r[E60] = PMSNEVFR_EL1[E60]
    };
    if not_bool(__IMPDEF_boolean("event 59 is not implemented, or filtering on event 59 is not supported")) then {
        r[E59] = PMSNEVFR_EL1[E59]
    };
    if not_bool(__IMPDEF_boolean("event 58 is not implemented, or filtering on event 58 is not supported")) then {
        r[E58] = PMSNEVFR_EL1[E58]
    };
    if not_bool(__IMPDEF_boolean("event 57 is not implemented, or filtering on event 57 is not supported")) then {
        r[E57] = PMSNEVFR_EL1[E57]
    };
    if not_bool(__IMPDEF_boolean("event 56 is not implemented, or filtering on event 56 is not supported")) then {
        r[E56] = PMSNEVFR_EL1[E56]
    };
    if not_bool(__IMPDEF_boolean("event 55 is not implemented, or filtering on event 55 is not supported")) then {
        r[E55] = PMSNEVFR_EL1[E55]
    };
    if not_bool(__IMPDEF_boolean("event 54 is not implemented, or filtering on event 54 is not supported")) then {
        r[E54] = PMSNEVFR_EL1[E54]
    };
    if not_bool(__IMPDEF_boolean("event 53 is not implemented, or filtering on event 53 is not supported")) then {
        r[E53] = PMSNEVFR_EL1[E53]
    };
    if not_bool(__IMPDEF_boolean("event 52 is not implemented, or filtering on event 52 is not supported")) then {
        r[E52] = PMSNEVFR_EL1[E52]
    };
    if not_bool(__IMPDEF_boolean("event 51 is not implemented, or filtering on event 51 is not supported")) then {
        r[E51] = PMSNEVFR_EL1[E51]
    };
    if not_bool(__IMPDEF_boolean("event 50 is not implemented, or filtering on event 50 is not supported")) then {
        r[E50] = PMSNEVFR_EL1[E50]
    };
    if not_bool(__IMPDEF_boolean("event 49 is not implemented, or filtering on event 49 is not supported")) then {
        r[E49] = PMSNEVFR_EL1[E49]
    };
    if not_bool(__IMPDEF_boolean("event 48 is not implemented, or filtering on event 48 is not supported")) then {
        r[E48] = PMSNEVFR_EL1[E48]
    };
    if not_bool(__IMPDEF_boolean("event 31 is not implemented, or filtering on event 31 is not supported")) then {
        r[E31] = PMSNEVFR_EL1[E31]
    };
    if not_bool(__IMPDEF_boolean("event 30 is not implemented, or filtering on event 30 is not supported")) then {
        r[E30] = PMSNEVFR_EL1[E30]
    };
    if not_bool(__IMPDEF_boolean("event 29 is not implemented, or filtering on event 29 is not supported")) then {
        r[E29] = PMSNEVFR_EL1[E29]
    };
    if not_bool(__IMPDEF_boolean("event 28 is not implemented, or filtering on event 28 is not supported")) then {
        r[E28] = PMSNEVFR_EL1[E28]
    };
    if not_bool(__IMPDEF_boolean("event 27 is not implemented, or filtering on event 27 is not supported")) then {
        r[E27] = PMSNEVFR_EL1[E27]
    };
    if not_bool(__IMPDEF_boolean("event 26 is not implemented, or filtering on event 26 is not supported")) then {
        r[E26] = PMSNEVFR_EL1[E26]
    };
    if not_bool(__IMPDEF_boolean("event 25 is not implemented, or filtering on event 25 is not supported")) then {
        r[E25] = PMSNEVFR_EL1[E25]
    };
    if not_bool(__IMPDEF_boolean("event 24 is not implemented, or filtering on event 24 is not supported")) then {
        r[E24] = PMSNEVFR_EL1[E24]
    };
    if not_bool(__IMPDEF_boolean("event 15 is not implemented, or filtering on event 15 is not supported")) then {
        r[E15] = PMSNEVFR_EL1[E15]
    };
    if not_bool(__IMPDEF_boolean("event 14 is not implemented, or filtering on event 14 is not supported")) then {
        r[E14] = PMSNEVFR_EL1[E14]
    };
    if not_bool(__IMPDEF_boolean("event 13 is not implemented, or filtering on event 13 is not supported")) then {
        r[E13] = PMSNEVFR_EL1[E13]
    };
    if not_bool(__IMPDEF_boolean("event 12 is not implemented, or filtering on event 12 is not supported")) then {
        r[E12] = PMSNEVFR_EL1[E12]
    };
    PMSNEVFR_EL1 = r;
    return()
}

type ERXADDR_EL1_Type = bits(64)

register ERXADDR_EL1 : ERXADDR_EL1_Type

type ERXMISC0_EL1_Type = bits(64)

register ERXMISC0_EL1 : ERXMISC0_EL1_Type

bitfield ERRIDR_EL1_Type : bits(64) = {NUM : 15..0}

register ERRIDR_EL1 : ERRIDR_EL1_Type

type ERXPFGCDN_EL1_Type = bits(64)

register ERXPFGCDN_EL1 : ERXPFGCDN_EL1_Type

type ERXPFGF_EL1_Type = bits(64)

register ERXPFGF_EL1 : ERXPFGF_EL1_Type

bitfield ERRSELR_EL1_Type : bits(64) = {SEL : 15..0}

register ERRSELR_EL1 : ERRSELR_EL1_Type

type ERXMISC1_EL1_Type = bits(64)

register ERXMISC1_EL1 : ERXMISC1_EL1_Type

type ERXCTLR_EL1_Type = bits(64)

register ERXCTLR_EL1 : ERXCTLR_EL1_Type

type ERXSTATUS_EL1_Type = bits(64)

register ERXSTATUS_EL1 : ERXSTATUS_EL1_Type

type ERXFR_EL1_Type = bits(64)

register ERXFR_EL1 : ERXFR_EL1_Type

bitfield ERXGSR_EL1_Type : bits(64) =
  {
    S63 : 63..63,
    S62 : 62..62,
    S61 : 61..61,
    S60 : 60..60,
    S59 : 59..59,
    S58 : 58..58,
    S57 : 57..57,
    S56 : 56..56,
    S55 : 55..55,
    S54 : 54..54,
    S53 : 53..53,
    S52 : 52..52,
    S51 : 51..51,
    S50 : 50..50,
    S49 : 49..49,
    S48 : 48..48,
    S47 : 47..47,
    S46 : 46..46,
    S45 : 45..45,
    S44 : 44..44,
    S43 : 43..43,
    S42 : 42..42,
    S41 : 41..41,
    S40 : 40..40,
    S39 : 39..39,
    S38 : 38..38,
    S37 : 37..37,
    S36 : 36..36,
    S35 : 35..35,
    S34 : 34..34,
    S33 : 33..33,
    S32 : 32..32,
    S31 : 31..31,
    S30 : 30..30,
    S29 : 29..29,
    S28 : 28..28,
    S27 : 27..27,
    S26 : 26..26,
    S25 : 25..25,
    S24 : 24..24,
    S23 : 23..23,
    S22 : 22..22,
    S21 : 21..21,
    S20 : 20..20,
    S19 : 19..19,
    S18 : 18..18,
    S17 : 17..17,
    S16 : 16..16,
    S15 : 15..15,
    S14 : 14..14,
    S13 : 13..13,
    S12 : 12..12,
    S11 : 11..11,
    S10 : 10..10,
    S9 : 9..9,
    S8 : 8..8,
    S7 : 7..7,
    S6 : 6..6,
    S5 : 5..5,
    S4 : 4..4,
    S3 : 3..3,
    S2 : 2..2,
    S1 : 1..1,
    S0 : 0..0
  }

register ERXGSR_EL1 : ERXGSR_EL1_Type

type ERXMISC3_EL1_Type = bits(64)

register ERXMISC3_EL1 : ERXMISC3_EL1_Type

type ERXMISC2_EL1_Type = bits(64)

register ERXMISC2_EL1 : ERXMISC2_EL1_Type

type ERXPFGCTL_EL1_Type = bits(64)

register ERXPFGCTL_EL1 : ERXPFGCTL_EL1_Type

bitfield BRBINF_EL1_Type : bits(64) =
  {
    CCU : 46..46,
    CC : 45..32,
    LASTFAILED : 17..17,
    T : 16..16,
    TYPE : 13..8,
    EL : 7..6,
    MPRED : 5..5,
    VALID : 1..0
  }

register BRBINF_EL1 : vector(32, BRBINF_EL1_Type)

bitfield BRBTGT_EL1_Type : bits(64) = {ADDRESS : 63..0}

register BRBTGT_EL1 : vector(32, BRBTGT_EL1_Type)

bitfield BRBSRC_EL1_Type : bits(64) = {ADDRESS : 63..0}

register BRBSRC_EL1 : vector(32, BRBSRC_EL1_Type)

val __set_BRBSRCINJ_EL1 : BRBSRCINJ_EL1_Type -> unit

function __set_BRBSRCINJ_EL1 value_name = {
    let r : BRBSRCINJ_EL1_Type = value_name;
    if not_bool(BRBINFINJ_EL1[VALID] == 0b00 | BRBINFINJ_EL1[VALID] == 0b01) then {
        BRBSRCINJ_EL1[ADDRESS] = r[ADDRESS]
    };
    return()
}

val __set_BRBINFINJ_EL1 : BRBINFINJ_EL1_Type -> unit

function __set_BRBINFINJ_EL1 value_name = {
    let r : BRBINFINJ_EL1_Type = value_name;
    BRBINFINJ_EL1.bits[4 .. 0] = Slice(r.bits, 0, 5);
    BRBINFINJ_EL1.bits[15 .. 14] = Slice(r.bits, 14, 2);
    BRBINFINJ_EL1.bits[31 .. 18] = Slice(r.bits, 18, 14);
    BRBINFINJ_EL1.bits[63 .. 47] = Slice(r.bits, 47, 17);
    if not_bool(BRBINFINJ_EL1[VALID] == 0b00) then {
        BRBINFINJ_EL1[CCU] = r[CCU]
    };
    if not_bool(BRBINFINJ_EL1[CCU] == 0b1 | BRBINFINJ_EL1[VALID] == 0b00) then {
        BRBINFINJ_EL1[CC] = r[CC]
    };
    if not_bool(BRBINFINJ_EL1[VALID] == 0b00) then {
        BRBINFINJ_EL1[LASTFAILED] = r[LASTFAILED]
    };
    if not_bool(BRBINFINJ_EL1[VALID] == 0b00 | BRBINFINJ_EL1[VALID] == 0b01) then {
        BRBINFINJ_EL1[T] = r[T]
    };
    if not_bool(BRBINFINJ_EL1[VALID] == 0b00) then {
        BRBINFINJ_EL1[TYPE] = r[TYPE]
    };
    if not_bool(BRBINFINJ_EL1[VALID] == 0b00 | BRBINFINJ_EL1[VALID] == 0b10) then {
        BRBINFINJ_EL1[EL] = r[EL]
    };
    if not_bool((BRBINFINJ_EL1[VALID] == 0b00 | BRBINFINJ_EL1[VALID] == 0b01) | [BRBINFINJ_EL1[TYPE][5]] == 0b1) then {
        BRBINFINJ_EL1[MPRED] = r[MPRED]
    };
    return()
}

val __set_BRBTGTINJ_EL1 : BRBTGTINJ_EL1_Type -> unit

function __set_BRBTGTINJ_EL1 value_name = {
    let r : BRBTGTINJ_EL1_Type = value_name;
    if not_bool(BRBINFINJ_EL1[VALID] == 0b00 | BRBINFINJ_EL1[VALID] == 0b10) then {
        BRBTGTINJ_EL1[ADDRESS] = r[ADDRESS]
    };
    return()
}

bitfield GITS_CREADR_Type : bits(64) = {Offset : 19..5, Stalled : 0..0}

register GITS_CREADR : GITS_CREADR_Type

bitfield GICR_PENDBASER_Type : bits(64) =
  {
    PTZ : 62..62,
    OuterCache : 58..56,
    Physical_Address : 51..16,
    Shareability : 11..10,
    InnerCache : 9..7
  }

register GICR_PENDBASER : GICR_PENDBASER_Type

bitfield GICR_PROPBASER_Type : bits(64) =
  {
    OuterCache : 58..56,
    Physical_Address : 51..12,
    Shareability : 11..10,
    InnerCache : 9..7,
    IDbits : 4..0
  }

register GICR_PROPBASER : GICR_PROPBASER_Type

bitfield GICR_VPROPBASER_Type : bits(64) =
  {
    Valid : 63..63,
    Entry_Size : 61..59,
    OuterCache : 58..56,
    Indirect : 55..55,
    Page_Size : 54..53,
    Z : 52..52,
    Physical_Address : 51..12,
    Shareability : 11..10,
    InnerCache : 9..7,
    IDbits : 4..0,
    Size : 6..0
  }

register GICR_VPROPBASER : GICR_VPROPBASER_Type

bitfield EDPFR_Type : bits(64) =
  {
    AMU : 47..44,
    SEL2 : 39..36,
    SVE : 35..32,
    GIC : 27..24,
    AdvSIMD : 23..20,
    FP : 19..16,
    EL3 : 15..12,
    EL2 : 11..8,
    EL1 : 7..4,
    EL0 : 3..0
  }

register EDPFR : EDPFR_Type

bitfield GICR_CLRLPIR_Type : bits(64) = {pINTID : 31..0}

register GICR_CLRLPIR : GICR_CLRLPIR_Type

bitfield GICR_INVALLR_Type : bits(64) = {V : 63..63, vPEID : 47..32}

register GICR_INVALLR : GICR_INVALLR_Type

bitfield EDHSR_Type : bits(64) =
  {
    GCS : 40..40,
    WPT : 23..18,
    WPTV : 17..17,
    WPF : 16..16,
    FnP : 15..15,
    VNCR : 13..13,
    FnV : 10..10,
    CM : 8..8,
    WnR : 6..6
  }

register EDHSR : EDHSR_Type

bitfield EDPCSR_Type : bits(64) = {NS : 63..63, EL : 62..61}

register EDPCSR : EDPCSR_Type

bitfield GICR_VPENDBASER_Type : bits(64) =
  {
    Valid : 63..63,
    IDAI : 62..62,
    Doorbell : 62..62,
    PendingLast : 61..61,
    Dirty : 60..60,
    VGrp0En : 59..59,
    VGrp1En : 58..58,
    OuterCache : 58..56,
    Physical_Address : 51..16,
    Shareability : 11..10,
    InnerCache : 9..7,
    vPEID : 15..0
  }

register GICR_VPENDBASER : GICR_VPENDBASER_Type

bitfield GITS_TYPER_Type : bits(64) =
  {
    INV : 46..46,
    UMSIirq : 45..45,
    UMSI : 44..44,
    nID : 43..43,
    SVPET : 42..41,
    VMAPP : 40..40,
    VSGI : 39..39,
    MPAM : 38..38,
    VMOVP : 37..37,
    CIL : 36..36,
    CIDbits : 35..32,
    HCC : 31..24,
    PTA : 19..19,
    SEIS : 18..18,
    Devbits : 17..13,
    ID_bits : 12..8,
    ITT_entry_size : 7..4,
    CCT : 2..2,
    Virtual : 1..1,
    Physical : 0..0
  }

register GITS_TYPER : GITS_TYPER_Type

bitfield GITS_SGIR_Type : bits(64) = {vPEID : 47..32, vINTID : 3..0}

register GITS_SGIR : GITS_SGIR_Type

bitfield EDDFR1_Type : bits(64) =
  {
    ABL_CMPs : 63..56,
    EBEP : 51..48,
    ITE : 47..44,
    ABLE : 43..40,
    PMICNTR : 39..36,
    SPMU : 35..32,
    CTX_CMPs : 31..24,
    WRPs : 23..16,
    BRPs : 15..8,
    SYSPMUID : 7..0
  }

register EDDFR1 : EDDFR1_Type

bitfield GITS_CWRITER_Type : bits(64) = {Offset : 19..5, Retry : 0..0}

register GITS_CWRITER : GITS_CWRITER_Type

bitfield EDDFR_Type : bits(64) =
  {
    ExtTrcBuff : 59..56,
    TraceFilt : 43..40,
    CTX_CMPs : 31..28,
    SEBEP : 27..24,
    WRPs : 23..20,
    PMSS : 19..16,
    BRPs : 15..12,
    PMUVer : 11..8,
    TraceVer : 7..4
  }

register EDDFR : EDDFR_Type

bitfield GICR_INVLPIR_Type : bits(64) =
  {V : 63..63, vPEID : 47..32, INTID : 31..0}

register GICR_INVLPIR : GICR_INVLPIR_Type

bitfield EDAA32PFR_Type : bits(64) =
  {MSA_frac : 19..16, EL3 : 15..12, EL2 : 11..8, PMSA : 7..4, VMSA : 3..0}

register EDAA32PFR : EDAA32PFR_Type

bitfield GITS_CBASER_Type : bits(64) =
  {
    Valid : 63..63,
    InnerCache : 61..59,
    OuterCache : 55..53,
    Physical_Address : 51..12,
    Shareability : 11..10,
    Size : 7..0
  }

register GITS_CBASER : GITS_CBASER_Type

bitfield GICR_SETLPIR_Type : bits(64) = {pINTID : 31..0}

register GICR_SETLPIR : GICR_SETLPIR_Type

bitfield PMCFGR_Type : bits(64) =
  {
    NCG : 31..28,
    SS : 22..22,
    FZO : 21..21,
    UEN : 19..19,
    WT : 18..18,
    NA : 17..17,
    EX : 16..16,
    CCD : 15..15,
    CC : 14..14,
    SIZE : 13..8,
    N : 7..0
  }

register PMCFGR : PMCFGR_Type

bitfield PMCNTEN_Type : bits(64) =
  {
    F0 : 32..32,
    C : 31..31,
    P30 : 30..30,
    P29 : 29..29,
    P28 : 28..28,
    P27 : 27..27,
    P26 : 26..26,
    P25 : 25..25,
    P24 : 24..24,
    P23 : 23..23,
    P22 : 22..22,
    P21 : 21..21,
    P20 : 20..20,
    P19 : 19..19,
    P18 : 18..18,
    P17 : 17..17,
    P16 : 16..16,
    P15 : 15..15,
    P14 : 14..14,
    P13 : 13..13,
    P12 : 12..12,
    P11 : 11..11,
    P10 : 10..10,
    P9 : 9..9,
    P8 : 8..8,
    P7 : 7..7,
    P6 : 6..6,
    P5 : 5..5,
    P4 : 4..4,
    P3 : 3..3,
    P2 : 2..2,
    P1 : 1..1,
    P0 : 0..0
  }

register _PMCNTEN : PMCNTEN_Type

val PMCNTEN_read : unit -> PMCNTEN_Type

function PMCNTEN_read () = {
    r : PMCNTEN_Type = _PMCNTEN;
    r.bits[63 .. 0] = Slice(PMCNTENSET_EL0.bits, 0, 64);
    return(r)
}

val PMCNTEN_write : PMCNTEN_Type -> unit

function PMCNTEN_write value_name = {
    let r : PMCNTEN_Type = value_name;
    PMCNTENSET_EL0.bits[63 .. 0] = Slice(r.bits, 0, 64);
    _PMCNTEN = r;
    return()
}

bitfield PMIIDR_Type : bits(64) =
  {ProductID : 31..20, Variant : 19..16, Revision : 15..12}

register PMIIDR : PMIIDR_Type

bitfield PMINTEN_Type : bits(64) =
  {
    F0 : 32..32,
    C : 31..31,
    P30 : 30..30,
    P29 : 29..29,
    P28 : 28..28,
    P27 : 27..27,
    P26 : 26..26,
    P25 : 25..25,
    P24 : 24..24,
    P23 : 23..23,
    P22 : 22..22,
    P21 : 21..21,
    P20 : 20..20,
    P19 : 19..19,
    P18 : 18..18,
    P17 : 17..17,
    P16 : 16..16,
    P15 : 15..15,
    P14 : 14..14,
    P13 : 13..13,
    P12 : 12..12,
    P11 : 11..11,
    P10 : 10..10,
    P9 : 9..9,
    P8 : 8..8,
    P7 : 7..7,
    P6 : 6..6,
    P5 : 5..5,
    P4 : 4..4,
    P3 : 3..3,
    P2 : 2..2,
    P1 : 1..1,
    P0 : 0..0
  }

register _PMINTEN : PMINTEN_Type

val PMINTEN_read : unit -> PMINTEN_Type

function PMINTEN_read () = {
    r : PMINTEN_Type = _PMINTEN;
    r.bits[63 .. 0] = Slice(PMINTENSET_EL1.bits, 0, 64);
    return(r)
}

val PMINTEN_write : PMINTEN_Type -> unit

function PMINTEN_write value_name = {
    let r : PMINTEN_Type = value_name;
    PMINTENSET_EL1.bits[63 .. 0] = Slice(r.bits, 0, 64);
    _PMINTEN = r;
    return()
}

bitfield PMOVS_Type : bits(64) =
  {
    F0 : 32..32,
    C : 31..31,
    P30 : 30..30,
    P29 : 29..29,
    P28 : 28..28,
    P27 : 27..27,
    P26 : 26..26,
    P25 : 25..25,
    P24 : 24..24,
    P23 : 23..23,
    P22 : 22..22,
    P21 : 21..21,
    P20 : 20..20,
    P19 : 19..19,
    P18 : 18..18,
    P17 : 17..17,
    P16 : 16..16,
    P15 : 15..15,
    P14 : 14..14,
    P13 : 13..13,
    P12 : 12..12,
    P11 : 11..11,
    P10 : 10..10,
    P9 : 9..9,
    P8 : 8..8,
    P7 : 7..7,
    P6 : 6..6,
    P5 : 5..5,
    P4 : 4..4,
    P3 : 3..3,
    P2 : 2..2,
    P1 : 1..1,
    P0 : 0..0
  }

register _PMOVS : PMOVS_Type

val PMOVS_read : unit -> PMOVS_Type

function PMOVS_read () = {
    r : PMOVS_Type = _PMOVS;
    r.bits[63 .. 0] = Slice(PMOVSSET_EL0.bits, 0, 64);
    return(r)
}

val PMOVS_write : PMOVS_Type -> unit

function PMOVS_write value_name = {
    let r : PMOVS_Type = value_name;
    PMOVSSET_EL0.bits[63 .. 0] = Slice(r.bits, 0, 64);
    _PMOVS = r;
    return()
}

bitfield PMPCSCTL_Type : bits(64) = {SS : 4..4, IMP : 1..1, EN : 0..0}

register PMPCSCTL : PMPCSCTL_Type

bitfield PMVCIDSR_Type : bits(64) =
  {VMID : (47..40 @ 39..32), CONTEXTIDR_EL1 : 31..0}

register PMVCIDSR : PMVCIDSR_Type

val TTBCR_NS_write : TTBCR_Type -> unit

function TTBCR_NS_write value_name = {
    let r : TTBCR_Type = value_name;
    TCR_EL1.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _TTBCR_NS = r;
    return()
}

val TTBCR_write : TTBCR_Type -> unit

function TTBCR_write value_name = {
    let r : TTBCR_Type = value_name;
    if ELUsingAArch32(EL3) & CurrentSecurityState() == SS_Secure then {
        TTBCR_S = r
    } else {
        TTBCR_NS_write() = r
    };
    return()
}

val DBGOSDLR_write : DBGOSDLR_Type -> unit

function DBGOSDLR_write value_name = {
    let r : DBGOSDLR_Type = value_name;
    OSDLR_EL1.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _DBGOSDLR = r;
    return()
}

bitfield ICH_ELRSR_Type : bits(32) =
  {
    Status15 : 15..15,
    Status14 : 14..14,
    Status13 : 13..13,
    Status12 : 12..12,
    Status11 : 11..11,
    Status10 : 10..10,
    Status9 : 9..9,
    Status8 : 8..8,
    Status7 : 7..7,
    Status6 : 6..6,
    Status5 : 5..5,
    Status4 : 4..4,
    Status3 : 3..3,
    Status2 : 2..2,
    Status1 : 1..1,
    Status0 : 0..0
  }

register _ICH_ELRSR : ICH_ELRSR_Type

val ICH_ELRSR_read : unit -> ICH_ELRSR_Type

function ICH_ELRSR_read () = {
    r : ICH_ELRSR_Type = _ICH_ELRSR;
    r.bits[31 .. 0] = Slice(ICH_ELRSR_EL2.bits, 0, 32);
    return(r)
}

val ICH_ELRSR_write : ICH_ELRSR_Type -> unit

function ICH_ELRSR_write value_name = {
    let r : ICH_ELRSR_Type = value_name;
    ICH_ELRSR_EL2.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _ICH_ELRSR = r;
    return()
}

bitfield ICC_IAR1_Type : bits(32) = {INTID : 23..0}

register _ICC_IAR1 : ICC_IAR1_Type

val ICC_IAR1_read : unit -> ICC_IAR1_Type

function ICC_IAR1_read () = {
    r : ICC_IAR1_Type = _ICC_IAR1;
    r.bits[31 .. 0] = Slice(ICC_IAR1_EL1.bits, 0, 32);
    return(r)
}

val ICC_IAR1_write : ICC_IAR1_Type -> unit

function ICC_IAR1_write value_name = {
    let r : ICC_IAR1_Type = value_name;
    ICC_IAR1_EL1.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _ICC_IAR1 = r;
    return()
}

type AIFSR_Type = bits(32)

register AIFSR_S : AIFSR_Type

register _AIFSR_NS : AIFSR_Type

val AIFSR_NS_read : unit -> AIFSR_Type

function AIFSR_NS_read () = {
    r : AIFSR_Type = _AIFSR_NS;
    r[31 .. 0] = Slice(AFSR1_EL1, 0, 32);
    return(r)
}

val AIFSR_NS_write : AIFSR_Type -> unit

function AIFSR_NS_write value_name = {
    let r : AIFSR_Type = value_name;
    AFSR1_EL1[31 .. 0] = Slice(r, 0, 32);
    _AIFSR_NS = r;
    return()
}

val AIFSR_read : unit -> AIFSR_Type

function AIFSR_read () = {
    r : AIFSR_Type = undefined;
    if ELUsingAArch32(EL3) & CurrentSecurityState() == SS_Secure then {
        r = AIFSR_S
    } else {
        r = AIFSR_NS_read()
    };
    return(r)
}

val AIFSR_write : AIFSR_Type -> unit

function AIFSR_write value_name = {
    let r : AIFSR_Type = value_name;
    if ELUsingAArch32(EL3) & CurrentSecurityState() == SS_Secure then {
        AIFSR_S = r
    } else {
        AIFSR_NS_write() = r
    };
    return()
}

bitfield ID_DFR0_Type : bits(32) =
  {
    TraceFilt : 31..28,
    PerfMon : 27..24,
    MProfDbg : 23..20,
    MMapTrc : 19..16,
    CopTrc : 15..12,
    MMapDbg : 11..8,
    CopSDbg : 7..4,
    CopDbg : 3..0
  }

register _ID_DFR0 : ID_DFR0_Type

val ID_DFR0_read : unit -> ID_DFR0_Type

function ID_DFR0_read () = {
    r : ID_DFR0_Type = _ID_DFR0;
    r.bits[31 .. 0] = Slice(ID_DFR0_EL1.bits, 0, 32);
    return(r)
}

val ID_DFR0_write : ID_DFR0_Type -> unit

function ID_DFR0_write value_name = {
    let r : ID_DFR0_Type = value_name;
    ID_DFR0_EL1.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _ID_DFR0 = r;
    return()
}

bitfield CLIDR_Type : bits(32) =
  {
    ICB : 31..30,
    LoUU : 29..27,
    LoC : 26..24,
    LoUIS : 23..21,
    Ctype7 : 20..18,
    Ctype6 : 17..15,
    Ctype5 : 14..12,
    Ctype4 : 11..9,
    Ctype3 : 8..6,
    Ctype2 : 5..3,
    Ctype1 : 2..0
  }

register _CLIDR : CLIDR_Type

val CLIDR_read : unit -> CLIDR_Type

function CLIDR_read () = {
    r : CLIDR_Type = _CLIDR;
    r.bits[31 .. 0] = Slice(CLIDR_EL1.bits, 0, 32);
    return(r)
}

val CLIDR_write : CLIDR_Type -> unit

function CLIDR_write value_name = {
    let r : CLIDR_Type = value_name;
    CLIDR_EL1.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _CLIDR = r;
    return()
}

type HACR_Type = bits(32)

register _HACR : HACR_Type

val HACR_read : unit -> HACR_Type

function HACR_read () = {
    r : HACR_Type = _HACR;
    r[31 .. 0] = Slice(HACR_EL2, 0, 32);
    return(r)
}

val HACR_write : HACR_Type -> unit

function HACR_write value_name = {
    let r : HACR_Type = value_name;
    HACR_EL2[31 .. 0] = Slice(r, 0, 32);
    _HACR = r;
    return()
}

type JOSCR_Type = bits(32)

register JOSCR : JOSCR_Type

val HCPTR_write : HCPTR_Type -> unit

function HCPTR_write value_name = {
    let r : HCPTR_Type = value_name;
    CPTR_EL2.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _HCPTR = r;
    return()
}

val __set_HCPTR : HCPTR_Type -> unit

function __set_HCPTR value_name = {
    let r : HCPTR_Type = value_name;
    HCPTR_write() = Mk_HCPTR_Type(SetSlice(10, HCPTR_read().bits, 0, Slice(r.bits, 0, 10)));
    HCPTR_write() = Mk_HCPTR_Type(SetSlice(20, HCPTR_read().bits, 12, Slice(r.bits, 12, 20)));
    if not_bool(((HaveEL(EL3) & ELUsingAArch32(EL3)) & not_bool(IsCurrentSecurityState(SS_Secure))) & NSACR[cp10] == 0b0) then {
        HCPTR_write() = [HCPTR_read() with TCP11 = r[TCP11]]
    };
    if not_bool(((HaveEL(EL3) & ELUsingAArch32(EL3)) & not_bool(IsCurrentSecurityState(SS_Secure))) & NSACR[cp10] == 0b0) then {
        HCPTR_write() = [HCPTR_read() with TCP10 = r[TCP10]]
    };
    return()
}

bitfield ICV_IGRPEN1_Type : bits(32) = {Enable : 0..0}

register _ICV_IGRPEN1 : ICV_IGRPEN1_Type

val ICV_IGRPEN1_read : unit -> ICV_IGRPEN1_Type

function ICV_IGRPEN1_read () = {
    r : ICV_IGRPEN1_Type = _ICV_IGRPEN1;
    r.bits[31 .. 0] = Slice(ICV_IGRPEN1_EL1.bits, 0, 32);
    return(r)
}

val ICV_IGRPEN1_write : ICV_IGRPEN1_Type -> unit

function ICV_IGRPEN1_write value_name = {
    let r : ICV_IGRPEN1_Type = value_name;
    ICV_IGRPEN1_EL1.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _ICV_IGRPEN1 = r;
    return()
}

bitfield CTR_Type : bits(32) =
  {
    DIC : 29..29,
    IDC : 28..28,
    CWG : 27..24,
    ERG : 23..20,
    DminLine : 19..16,
    L1Ip : 15..14,
    IminLine : 3..0
  }

register _CTR : CTR_Type

val CTR_read : unit -> CTR_Type

function CTR_read () = {
    r : CTR_Type = _CTR;
    r.bits[31 .. 0] = Slice(CTR_EL0.bits, 0, 32);
    return(r)
}

val CTR_write : CTR_Type -> unit

function CTR_write value_name = {
    let r : CTR_Type = value_name;
    CTR_EL0.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _CTR = r;
    return()
}

bitfield PMUSERENR_Type : bits(32) =
  {TID : 6..6, ER : 3..3, CR : 2..2, SW : 1..1, EN : 0..0}

register _PMUSERENR : PMUSERENR_Type

val PMUSERENR_read : unit -> PMUSERENR_Type

function PMUSERENR_read () = {
    r : PMUSERENR_Type = _PMUSERENR;
    r.bits[31 .. 0] = Slice(PMUSERENR_EL0.bits, 0, 32);
    return(r)
}

val PMUSERENR_write : PMUSERENR_Type -> unit

function PMUSERENR_write value_name = {
    let r : PMUSERENR_Type = value_name;
    PMUSERENR_EL0.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _PMUSERENR = r;
    return()
}

bitfield CNTHPS_CTL_Type : bits(32) =
  {ISTATUS : 2..2, IMASK : 1..1, ENABLE : 0..0}

register _CNTHPS_CTL : CNTHPS_CTL_Type

val CNTHPS_CTL_read : unit -> CNTHPS_CTL_Type

function CNTHPS_CTL_read () = {
    r : CNTHPS_CTL_Type = _CNTHPS_CTL;
    r.bits[31 .. 0] = Slice(CNTHPS_CTL_EL2.bits, 0, 32);
    return(r)
}

val CNTHPS_CTL_write : CNTHPS_CTL_Type -> unit

function CNTHPS_CTL_write value_name = {
    let r : CNTHPS_CTL_Type = value_name;
    CNTHPS_CTL_EL2.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _CNTHPS_CTL = r;
    return()
}

val DBGBVR_set : forall 'n, (0 <= 'n & 'n < 16). (int('n), DBGBVR_Type) -> unit

function DBGBVR_set (n, value_name) = {
    let r : DBGBVR_Type = value_name;
    DBGBVR_EL1[n].bits[31 .. 0] = Slice(r.bits, 0, 32);
    _DBGBVR[n] = r;
    return()
}

bitfield PMCEID1_Type : bits(32) =
  {
    ID31 : 31..31,
    ID30 : 30..30,
    ID29 : 29..29,
    ID28 : 28..28,
    ID27 : 27..27,
    ID26 : 26..26,
    ID25 : 25..25,
    ID24 : 24..24,
    ID23 : 23..23,
    ID22 : 22..22,
    ID21 : 21..21,
    ID20 : 20..20,
    ID19 : 19..19,
    ID18 : 18..18,
    ID17 : 17..17,
    ID16 : 16..16,
    ID15 : 15..15,
    ID14 : 14..14,
    ID13 : 13..13,
    ID12 : 12..12,
    ID11 : 11..11,
    ID10 : 10..10,
    ID9 : 9..9,
    ID8 : 8..8,
    ID7 : 7..7,
    ID6 : 6..6,
    ID5 : 5..5,
    ID4 : 4..4,
    ID3 : 3..3,
    ID2 : 2..2,
    ID1 : 1..1,
    ID0 : 0..0
  }

register _PMCEID1 : PMCEID1_Type

val PMCEID1_read : unit -> PMCEID1_Type

function PMCEID1_read () = {
    r : PMCEID1_Type = _PMCEID1;
    r.bits[31 .. 0] = Slice(PMCEID1_EL0.bits, 0, 32);
    return(r)
}

val PMCEID1_write : PMCEID1_Type -> unit

function PMCEID1_write value_name = {
    let r : PMCEID1_Type = value_name;
    PMCEID1_EL0.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _PMCEID1 = r;
    return()
}

bitfield DBGAUTHSTATUS_Type : bits(32) =
  {SNID : 7..6, SID : 5..4, NSNID : 3..2, NSID : 1..0}

register _DBGAUTHSTATUS : DBGAUTHSTATUS_Type

val DBGAUTHSTATUS_read : unit -> DBGAUTHSTATUS_Type

function DBGAUTHSTATUS_read () = {
    r : DBGAUTHSTATUS_Type = _DBGAUTHSTATUS;
    r.bits[31 .. 0] = Slice(DBGAUTHSTATUS_EL1.bits, 0, 32);
    return(r)
}

val DBGAUTHSTATUS_write : DBGAUTHSTATUS_Type -> unit

function DBGAUTHSTATUS_write value_name = {
    let r : DBGAUTHSTATUS_Type = value_name;
    DBGAUTHSTATUS_EL1.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _DBGAUTHSTATUS = r;
    return()
}

bitfield ICC_IAR0_Type : bits(32) = {INTID : 23..0}

register _ICC_IAR0 : ICC_IAR0_Type

val ICC_IAR0_read : unit -> ICC_IAR0_Type

function ICC_IAR0_read () = {
    r : ICC_IAR0_Type = _ICC_IAR0;
    r.bits[31 .. 0] = Slice(ICC_IAR0_EL1.bits, 0, 32);
    return(r)
}

val ICC_IAR0_write : ICC_IAR0_Type -> unit

function ICC_IAR0_write value_name = {
    let r : ICC_IAR0_Type = value_name;
    ICC_IAR0_EL1.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _ICC_IAR0 = r;
    return()
}

val PMCNTENSET_write : PMCNTENSET_Type -> unit

function PMCNTENSET_write value_name = {
    let r : PMCNTENSET_Type = value_name;
    PMCNTENSET_EL0.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _PMCNTENSET = r;
    return()
}

bitfield ICV_IGRPEN0_Type : bits(32) = {Enable : 0..0}

register _ICV_IGRPEN0 : ICV_IGRPEN0_Type

val ICV_IGRPEN0_read : unit -> ICV_IGRPEN0_Type

function ICV_IGRPEN0_read () = {
    r : ICV_IGRPEN0_Type = _ICV_IGRPEN0;
    r.bits[31 .. 0] = Slice(ICV_IGRPEN0_EL1.bits, 0, 32);
    return(r)
}

val ICV_IGRPEN0_write : ICV_IGRPEN0_Type -> unit

function ICV_IGRPEN0_write value_name = {
    let r : ICV_IGRPEN0_Type = value_name;
    ICV_IGRPEN0_EL1.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _ICV_IGRPEN0 = r;
    return()
}

bitfield ID_MMFR3_Type : bits(32) =
  {
    Supersec : 31..28,
    CMemSz : 27..24,
    CohWalk : 23..20,
    PAN : 19..16,
    MaintBcst : 15..12,
    BPMaint : 11..8,
    CMaintSW : 7..4,
    CMaintVA : 3..0
  }

register _ID_MMFR3 : ID_MMFR3_Type

val ID_MMFR3_read : unit -> ID_MMFR3_Type

function ID_MMFR3_read () = {
    r : ID_MMFR3_Type = _ID_MMFR3;
    r.bits[31 .. 0] = Slice(ID_MMFR3_EL1.bits, 0, 32);
    return(r)
}

val ID_MMFR3_write : ID_MMFR3_Type -> unit

function ID_MMFR3_write value_name = {
    let r : ID_MMFR3_Type = value_name;
    ID_MMFR3_EL1.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _ID_MMFR3 = r;
    return()
}

val PRRR_NS_write : PRRR_Type -> unit

function PRRR_NS_write value_name = {
    let r : PRRR_Type = value_name;
    MAIR_EL1.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _PRRR_NS = r;
    return()
}

val PRRR_write : PRRR_Type -> unit

function PRRR_write value_name = {
    let r : PRRR_Type = value_name;
    if ELUsingAArch32(EL3) & CurrentSecurityState() == SS_Secure then {
        PRRR_S = r
    } else {
        PRRR_NS_write() = r
    };
    return()
}

bitfield PMCEID0_Type : bits(32) =
  {
    ID31 : 31..31,
    ID30 : 30..30,
    ID29 : 29..29,
    ID28 : 28..28,
    ID27 : 27..27,
    ID26 : 26..26,
    ID25 : 25..25,
    ID24 : 24..24,
    ID23 : 23..23,
    ID22 : 22..22,
    ID21 : 21..21,
    ID20 : 20..20,
    ID19 : 19..19,
    ID18 : 18..18,
    ID17 : 17..17,
    ID16 : 16..16,
    ID15 : 15..15,
    ID14 : 14..14,
    ID13 : 13..13,
    ID12 : 12..12,
    ID11 : 11..11,
    ID10 : 10..10,
    ID9 : 9..9,
    ID8 : 8..8,
    ID7 : 7..7,
    ID6 : 6..6,
    ID5 : 5..5,
    ID4 : 4..4,
    ID3 : 3..3,
    ID2 : 2..2,
    ID1 : 1..1,
    ID0 : 0..0
  }

register _PMCEID0 : PMCEID0_Type

val PMCEID0_read : unit -> PMCEID0_Type

function PMCEID0_read () = {
    r : PMCEID0_Type = _PMCEID0;
    r.bits[31 .. 0] = Slice(PMCEID0_EL0.bits, 0, 32);
    return(r)
}

val PMCEID0_write : PMCEID0_Type -> unit

function PMCEID0_write value_name = {
    let r : PMCEID0_Type = value_name;
    PMCEID0_EL0.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _PMCEID0 = r;
    return()
}

bitfield ICV_CTLR_Type : bits(32) =
  {
    ExtRange : 19..19,
    RSS : 18..18,
    A3V : 15..15,
    SEIS : 14..14,
    IDbits : 13..11,
    PRIbits : 10..8,
    EOImode : 1..1,
    CBPR : 0..0
  }

register _ICV_CTLR : ICV_CTLR_Type

val ICV_CTLR_read : unit -> ICV_CTLR_Type

function ICV_CTLR_read () = {
    r : ICV_CTLR_Type = _ICV_CTLR;
    r.bits[31 .. 0] = Slice(ICV_CTLR_EL1.bits, 0, 32);
    return(r)
}

val ICV_CTLR_write : ICV_CTLR_Type -> unit

function ICV_CTLR_write value_name = {
    let r : ICV_CTLR_Type = value_name;
    ICV_CTLR_EL1.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _ICV_CTLR = r;
    return()
}

val DBGBXVR_set : forall 'n, (0 <= 'n & 'n < 16).
  (int('n), DBGBXVR_Type) -> unit

function DBGBXVR_set (n, value_name) = {
    let r : DBGBXVR_Type = value_name;
    DBGBVR_EL1[n].bits[63 .. 32] = Slice(r.bits, 0, 32);
    _DBGBXVR[n] = r;
    return()
}

bitfield ID_ISAR6_Type : bits(32) =
  {
    CLRBHB : 31..28,
    I8MM : 27..24,
    BF16 : 23..20,
    SPECRES : 19..16,
    SB : 15..12,
    FHM : 11..8,
    DP : 7..4,
    JSCVT : 3..0
  }

register _ID_ISAR6 : ID_ISAR6_Type

val ID_ISAR6_read : unit -> ID_ISAR6_Type

function ID_ISAR6_read () = {
    r : ID_ISAR6_Type = _ID_ISAR6;
    r.bits[31 .. 0] = Slice(ID_ISAR6_EL1.bits, 0, 32);
    return(r)
}

val ID_ISAR6_write : ID_ISAR6_Type -> unit

function ID_ISAR6_write value_name = {
    let r : ID_ISAR6_Type = value_name;
    ID_ISAR6_EL1.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _ID_ISAR6 = r;
    return()
}

type HACTLR_Type = bits(32)

register _HACTLR : HACTLR_Type

val HACTLR_read : unit -> HACTLR_Type

function HACTLR_read () = {
    r : HACTLR_Type = _HACTLR;
    r[31 .. 0] = Slice(ACTLR_EL2, 0, 32);
    return(r)
}

val HACTLR_write : HACTLR_Type -> unit

function HACTLR_write value_name = {
    let r : HACTLR_Type = value_name;
    ACTLR_EL2[31 .. 0] = Slice(r, 0, 32);
    _HACTLR = r;
    return()
}

bitfield DBGCLAIMCLR_Type : bits(32) = {CLAIM : 7..0}

register _DBGCLAIMCLR : DBGCLAIMCLR_Type

val DBGCLAIMCLR_read : unit -> DBGCLAIMCLR_Type

function DBGCLAIMCLR_read () = {
    r : DBGCLAIMCLR_Type = _DBGCLAIMCLR;
    r.bits[31 .. 0] = Slice(DBGCLAIMCLR_EL1.bits, 0, 32);
    return(r)
}

val DBGCLAIMCLR_write : DBGCLAIMCLR_Type -> unit

function DBGCLAIMCLR_write value_name = {
    let r : DBGCLAIMCLR_Type = value_name;
    DBGCLAIMCLR_EL1.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _DBGCLAIMCLR = r;
    return()
}

type TCMTR_Type = bits(32)

register TCMTR : TCMTR_Type

val DBGWVR_set : forall 'n, (0 <= 'n & 'n < 16). (int('n), DBGWVR_Type) -> unit

function DBGWVR_set (n, value_name) = {
    let r : DBGWVR_Type = value_name;
    DBGWVR_EL1[n].bits[31 .. 0] = Slice(r.bits, 0, 32);
    _DBGWVR[n] = r;
    return()
}

bitfield ICV_HPPIR1_Type : bits(32) = {INTID : 23..0}

register _ICV_HPPIR1 : ICV_HPPIR1_Type

val ICV_HPPIR1_read : unit -> ICV_HPPIR1_Type

function ICV_HPPIR1_read () = {
    r : ICV_HPPIR1_Type = _ICV_HPPIR1;
    r.bits[31 .. 0] = Slice(ICV_HPPIR1_EL1.bits, 0, 32);
    return(r)
}

val ICV_HPPIR1_write : ICV_HPPIR1_Type -> unit

function ICV_HPPIR1_write value_name = {
    let r : ICV_HPPIR1_Type = value_name;
    ICV_HPPIR1_EL1.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _ICV_HPPIR1 = r;
    return()
}

bitfield ID_MMFR5_Type : bits(32) = {nTLBPA : 7..4, ETS : 3..0}

register _ID_MMFR5 : ID_MMFR5_Type

val ID_MMFR5_read : unit -> ID_MMFR5_Type

function ID_MMFR5_read () = {
    r : ID_MMFR5_Type = _ID_MMFR5;
    r.bits[31 .. 0] = Slice(ID_MMFR5_EL1.bits, 0, 32);
    return(r)
}

val ID_MMFR5_write : ID_MMFR5_Type -> unit

function ID_MMFR5_write value_name = {
    let r : ID_MMFR5_Type = value_name;
    ID_MMFR5_EL1.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _ID_MMFR5 = r;
    return()
}

type ICV_AP0R_Type = bits(32)

register _ICV_AP0R : vector(4, ICV_AP0R_Type)

val ICV_AP0R_read : forall 'n, (0 <= 'n & 'n < 4). int('n) -> ICV_AP0R_Type

function ICV_AP0R_read n = {
    r : ICV_AP0R_Type = _ICV_AP0R[n];
    r[31 .. 0] = Slice(ICV_AP0R_EL1[n], 0, 32);
    return(r)
}

val ICV_AP0R_set : forall 'n, (0 <= 'n & 'n < 4).
  (int('n), ICV_AP0R_Type) -> unit

function ICV_AP0R_set (n, value_name) = {
    let r : ICV_AP0R_Type = value_name;
    ICV_AP0R_EL1[n][31 .. 0] = Slice(r, 0, 32);
    _ICV_AP0R[n] = r;
    return()
}

bitfield HRMR_Type : bits(32) = {RR : 1..1, AA64 : 0..0}

register _HRMR : HRMR_Type

val HRMR_read : unit -> HRMR_Type

function HRMR_read () = {
    r : HRMR_Type = _HRMR;
    r.bits[31 .. 0] = Slice(RMR_EL2.bits, 0, 32);
    return(r)
}

val HRMR_write : HRMR_Type -> unit

function HRMR_write value_name = {
    let r : HRMR_Type = value_name;
    RMR_EL2.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _HRMR = r;
    return()
}

val HCR2_write : HCR2_Type -> unit

function HCR2_write value_name = {
    let r : HCR2_Type = value_name;
    HCR_EL2.bits[63 .. 32] = Slice(r.bits, 0, 32);
    _HCR2 = r;
    return()
}

bitfield ID_PFR2_Type : bits(32) = {RAS_frac : 11..8, SSBS : 7..4, CSV3 : 3..0}

register _ID_PFR2 : ID_PFR2_Type

val ID_PFR2_read : unit -> ID_PFR2_Type

function ID_PFR2_read () = {
    r : ID_PFR2_Type = _ID_PFR2;
    r.bits[31 .. 0] = Slice(ID_PFR2_EL1.bits, 0, 32);
    return(r)
}

val ID_PFR2_write : ID_PFR2_Type -> unit

function ID_PFR2_write value_name = {
    let r : ID_PFR2_Type = value_name;
    ID_PFR2_EL1.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _ID_PFR2 = r;
    return()
}

val HMAIR0_write : HMAIR0_Type -> unit

function HMAIR0_write value_name = {
    let r : HMAIR0_Type = value_name;
    MAIR_EL2.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _HMAIR0 = r;
    return()
}

bitfield ICV_EOIR0_Type : bits(32) = {INTID : 23..0}

register _ICV_EOIR0 : ICV_EOIR0_Type

val ICV_EOIR0_read : unit -> ICV_EOIR0_Type

function ICV_EOIR0_read () = {
    r : ICV_EOIR0_Type = _ICV_EOIR0;
    r.bits[31 .. 0] = Slice(ICV_EOIR0_EL1.bits, 0, 32);
    return(r)
}

val ICV_EOIR0_write : ICV_EOIR0_Type -> unit

function ICV_EOIR0_write value_name = {
    let r : ICV_EOIR0_Type = value_name;
    ICV_EOIR0_EL1.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _ICV_EOIR0 = r;
    return()
}

val DACR_NS_write : DACR_Type -> unit

function DACR_NS_write value_name = {
    let r : DACR_Type = value_name;
    DACR32_EL2.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _DACR_NS = r;
    return()
}

val DACR_write : DACR_Type -> unit

function DACR_write value_name = {
    let r : DACR_Type = value_name;
    if ELUsingAArch32(EL3) & CurrentSecurityState() == SS_Secure then {
        DACR_S = r
    } else {
        DACR_NS_write() = r
    };
    return()
}

bitfield ICH_VTR_Type : bits(32) =
  {
    PRIbits : 31..29,
    PREbits : 28..26,
    IDbits : 25..23,
    SEIS : 22..22,
    A3V : 21..21,
    nV4 : 20..20,
    TDS : 19..19,
    ListRegs : 4..0
  }

register _ICH_VTR : ICH_VTR_Type

val ICH_VTR_read : unit -> ICH_VTR_Type

function ICH_VTR_read () = {
    r : ICH_VTR_Type = _ICH_VTR;
    r.bits[31 .. 0] = Slice(ICH_VTR_EL2.bits, 0, 32);
    return(r)
}

val ICH_VTR_write : ICH_VTR_Type -> unit

function ICH_VTR_write value_name = {
    let r : ICH_VTR_Type = value_name;
    ICH_VTR_EL2.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _ICH_VTR = r;
    return()
}

bitfield CSSELR_Type : bits(32) = {Level : 3..1, InD : 0..0}

register CSSELR_S : CSSELR_Type

register _CSSELR_NS : CSSELR_Type

val CSSELR_NS_read : unit -> CSSELR_Type

function CSSELR_NS_read () = {
    r : CSSELR_Type = _CSSELR_NS;
    r.bits[31 .. 0] = Slice(CSSELR_EL1.bits, 0, 32);
    return(r)
}

val CSSELR_NS_write : CSSELR_Type -> unit

function CSSELR_NS_write value_name = {
    let r : CSSELR_Type = value_name;
    CSSELR_EL1.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _CSSELR_NS = r;
    return()
}

val CSSELR_read : unit -> CSSELR_Type

function CSSELR_read () = {
    r : CSSELR_Type = undefined;
    if ELUsingAArch32(EL3) & CurrentSecurityState() == SS_Secure then {
        r = CSSELR_S
    } else {
        r = CSSELR_NS_read()
    };
    return(r)
}

val CSSELR_write : CSSELR_Type -> unit

function CSSELR_write value_name = {
    let r : CSSELR_Type = value_name;
    if ELUsingAArch32(EL3) & CurrentSecurityState() == SS_Secure then {
        CSSELR_S = r
    } else {
        CSSELR_NS_write() = r
    };
    return()
}

type JIDR_Type = bits(32)

register JIDR : JIDR_Type

val PMCR_write : PMCR_Type -> unit

function PMCR_write value_name = {
    let r : PMCR_Type = value_name;
    PMCR_EL0.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _PMCR = r;
    return()
}

val __set_PMCR : PMCR_Type -> unit

function __set_PMCR value_name = {
    let r : PMCR_Type = value_name;
    PMCR_write() = Mk_PMCR_Type(SetSlice(1, PMCR_read().bits, 0, Slice(r.bits, 0, 1)));
    PMCR_write() = Mk_PMCR_Type(SetSlice(13, PMCR_read().bits, 3, Slice(r.bits, 3, 13)));
    if not_bool(not_bool(IsFeatureImplemented(FEAT_PMUv3p7))) then {
        PMCR_write() = [PMCR_read() with IMP = r[IMP]]
    };
    if not_bool(PMCR_read()[IMP] != 0b00000000) then {
        PMCR_write() = [PMCR_read() with IDCODE = r[IDCODE]]
    };
    PMCR_write() = [PMCR_read() with C = r[C]];
    PMCR_write() = [PMCR_read() with P = r[P]];
    return()
}

val DBGWCR_set : forall 'n, (0 <= 'n & 'n < 16). (int('n), DBGWCR_Type) -> unit

function DBGWCR_set (n, value_name) = {
    let r : DBGWCR_Type = value_name;
    DBGWCR_EL1[n].bits[31 .. 0] = Slice(r.bits, 0, 32);
    _DBGWCR[n] = r;
    return()
}

bitfield ICH_VMCR_Type : bits(32) =
  {
    VPMR : 31..24,
    VBPR0 : 23..21,
    VBPR1 : 20..18,
    VEOIM : 9..9,
    VCBPR : 4..4,
    VFIQEn : 3..3,
    VAckCtl : 2..2,
    VENG1 : 1..1,
    VENG0 : 0..0
  }

register _ICH_VMCR : ICH_VMCR_Type

val ICH_VMCR_read : unit -> ICH_VMCR_Type

function ICH_VMCR_read () = {
    r : ICH_VMCR_Type = _ICH_VMCR;
    r.bits[31 .. 0] = Slice(ICH_VMCR_EL2.bits, 0, 32);
    return(r)
}

val ICH_VMCR_write : ICH_VMCR_Type -> unit

function ICH_VMCR_write value_name = {
    let r : ICH_VMCR_Type = value_name;
    ICH_VMCR_EL2.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _ICH_VMCR = r;
    return()
}

bitfield DBGDEVID1_Type : bits(32) = {PCSROffset : 3..0}

register DBGDEVID1 : DBGDEVID1_Type

bitfield ICC_BPR1_Type : bits(32) = {BinaryPoint : 2..0}

register _ICC_BPR1_S : ICC_BPR1_Type

val ICC_BPR1_S_read : unit -> ICC_BPR1_Type

function ICC_BPR1_S_read () = {
    r : ICC_BPR1_Type = _ICC_BPR1_S;
    r.bits[31 .. 0] = Slice(ICC_BPR1_EL1_S.bits, 0, 32);
    return(r)
}

val ICC_BPR1_S_write : ICC_BPR1_Type -> unit

function ICC_BPR1_S_write value_name = {
    let r : ICC_BPR1_Type = value_name;
    ICC_BPR1_EL1_S.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _ICC_BPR1_S = r;
    return()
}

register _ICC_BPR1_NS : ICC_BPR1_Type

val ICC_BPR1_NS_read : unit -> ICC_BPR1_Type

function ICC_BPR1_NS_read () = {
    r : ICC_BPR1_Type = _ICC_BPR1_NS;
    r.bits[31 .. 0] = Slice(ICC_BPR1_EL1_NS.bits, 0, 32);
    return(r)
}

val ICC_BPR1_NS_write : ICC_BPR1_Type -> unit

function ICC_BPR1_NS_write value_name = {
    let r : ICC_BPR1_Type = value_name;
    ICC_BPR1_EL1_NS.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _ICC_BPR1_NS = r;
    return()
}

val ICC_BPR1_read : unit -> ICC_BPR1_Type

function ICC_BPR1_read () = {
    r : ICC_BPR1_Type = undefined;
    if ELUsingAArch32(EL3) & CurrentSecurityState() == SS_Secure then {
        r = ICC_BPR1_S_read()
    } else {
        r = ICC_BPR1_NS_read()
    };
    return(r)
}

val ICC_BPR1_write : ICC_BPR1_Type -> unit

function ICC_BPR1_write value_name = {
    let r : ICC_BPR1_Type = value_name;
    if ELUsingAArch32(EL3) & CurrentSecurityState() == SS_Secure then {
        ICC_BPR1_S_write() = r
    } else {
        ICC_BPR1_NS_write() = r
    };
    return()
}

bitfield ICV_RPR_Type : bits(32) = {Priority : 7..0}

register _ICV_RPR : ICV_RPR_Type

val ICV_RPR_read : unit -> ICV_RPR_Type

function ICV_RPR_read () = {
    r : ICV_RPR_Type = _ICV_RPR;
    r.bits[31 .. 0] = Slice(ICV_RPR_EL1.bits, 0, 32);
    return(r)
}

val ICV_RPR_write : ICV_RPR_Type -> unit

function ICV_RPR_write value_name = {
    let r : ICV_RPR_Type = value_name;
    ICV_RPR_EL1.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _ICV_RPR = r;
    return()
}

val VBAR_NS_write : VBAR_Type -> unit

function VBAR_NS_write value_name = {
    let r : VBAR_Type = value_name;
    VBAR_EL1[31 .. 0] = Slice(r, 0, 32);
    _VBAR_NS = r;
    return()
}

val VBAR_write : VBAR_Type -> unit

function VBAR_write value_name = {
    let r : VBAR_Type = value_name;
    if ELUsingAArch32(EL3) & CurrentSecurityState() == SS_Secure then {
        VBAR_S = r
    } else {
        VBAR_NS_write() = r
    };
    return()
}

bitfield ID_ISAR0_Type : bits(32) =
  {
    Divide : 27..24,
    Debug : 23..20,
    Coproc : 19..16,
    CmpBranch : 15..12,
    BitField : 11..8,
    BitCount : 7..4,
    Swap : 3..0
  }

register _ID_ISAR0 : ID_ISAR0_Type

val ID_ISAR0_read : unit -> ID_ISAR0_Type

function ID_ISAR0_read () = {
    r : ID_ISAR0_Type = _ID_ISAR0;
    r.bits[31 .. 0] = Slice(ID_ISAR0_EL1.bits, 0, 32);
    return(r)
}

val ID_ISAR0_write : ID_ISAR0_Type -> unit

function ID_ISAR0_write value_name = {
    let r : ID_ISAR0_Type = value_name;
    ID_ISAR0_EL1.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _ID_ISAR0 = r;
    return()
}

val PMINTENCLR_write : PMINTENCLR_Type -> unit

function PMINTENCLR_write value_name = {
    let r : PMINTENCLR_Type = value_name;
    PMINTENCLR_EL1.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _PMINTENCLR = r;
    return()
}

bitfield ICV_IAR1_Type : bits(32) = {INTID : 23..0}

register _ICV_IAR1 : ICV_IAR1_Type

val ICV_IAR1_read : unit -> ICV_IAR1_Type

function ICV_IAR1_read () = {
    r : ICV_IAR1_Type = _ICV_IAR1;
    r.bits[31 .. 0] = Slice(ICV_IAR1_EL1.bits, 0, 32);
    return(r)
}

val ICV_IAR1_write : ICV_IAR1_Type -> unit

function ICV_IAR1_write value_name = {
    let r : ICV_IAR1_Type = value_name;
    ICV_IAR1_EL1.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _ICV_IAR1 = r;
    return()
}

val DBGPRCR_write : DBGPRCR_Type -> unit

function DBGPRCR_write value_name = {
    let r : DBGPRCR_Type = value_name;
    DBGPRCR_EL1.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _DBGPRCR = r;
    return()
}

val SDER_write : SDER_Type -> unit

function SDER_write value_name = {
    let r : SDER_Type = value_name;
    if HaveEL(EL3) then {
        SDER32_EL3_write() = Mk_SDER32_EL3_Type(SetSlice(32, SDER32_EL3_read().bits, 0, Slice(r.bits, 0, 32)))
    } else {
        SDER32_EL2.bits[31 .. 0] = Slice(r.bits, 0, 32)
    };
    _SDER = r;
    return()
}

bitfield ID_MMFR4_Type : bits(32) =
  {
    EVT : 31..28,
    CCIDX : 27..24,
    LSM : 23..20,
    HPDS : 19..16,
    CnP : 15..12,
    XNX : 11..8,
    AC2 : 7..4,
    SpecSEI : 3..0
  }

register _ID_MMFR4 : ID_MMFR4_Type

val ID_MMFR4_read : unit -> ID_MMFR4_Type

function ID_MMFR4_read () = {
    r : ID_MMFR4_Type = _ID_MMFR4;
    r.bits[31 .. 0] = Slice(ID_MMFR4_EL1.bits, 0, 32);
    return(r)
}

val ID_MMFR4_write : ID_MMFR4_Type -> unit

function ID_MMFR4_write value_name = {
    let r : ID_MMFR4_Type = value_name;
    ID_MMFR4_EL1.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _ID_MMFR4 = r;
    return()
}

bitfield ICC_EOIR1_Type : bits(32) = {INTID : 23..0}

register _ICC_EOIR1 : ICC_EOIR1_Type

val ICC_EOIR1_read : unit -> ICC_EOIR1_Type

function ICC_EOIR1_read () = {
    r : ICC_EOIR1_Type = _ICC_EOIR1;
    r.bits[31 .. 0] = Slice(ICC_EOIR1_EL1.bits, 0, 32);
    return(r)
}

val ICC_EOIR1_write : ICC_EOIR1_Type -> unit

function ICC_EOIR1_write value_name = {
    let r : ICC_EOIR1_Type = value_name;
    ICC_EOIR1_EL1.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _ICC_EOIR1 = r;
    return()
}

type TPIDRURW_Type = bits(32)

register TPIDRURW_S : TPIDRURW_Type

register _TPIDRURW_NS : TPIDRURW_Type

val TPIDRURW_NS_read : unit -> TPIDRURW_Type

function TPIDRURW_NS_read () = {
    r : TPIDRURW_Type = _TPIDRURW_NS;
    r[31 .. 0] = Slice(TPIDR_EL0, 0, 32);
    return(r)
}

val TPIDRURW_NS_write : TPIDRURW_Type -> unit

function TPIDRURW_NS_write value_name = {
    let r : TPIDRURW_Type = value_name;
    TPIDR_EL0[31 .. 0] = Slice(r, 0, 32);
    _TPIDRURW_NS = r;
    return()
}

val TPIDRURW_read : unit -> TPIDRURW_Type

function TPIDRURW_read () = {
    r : TPIDRURW_Type = undefined;
    if ELUsingAArch32(EL3) & CurrentSecurityState() == SS_Secure then {
        r = TPIDRURW_S
    } else {
        r = TPIDRURW_NS_read()
    };
    return(r)
}

val TPIDRURW_write : TPIDRURW_Type -> unit

function TPIDRURW_write value_name = {
    let r : TPIDRURW_Type = value_name;
    if ELUsingAArch32(EL3) & CurrentSecurityState() == SS_Secure then {
        TPIDRURW_S = r
    } else {
        TPIDRURW_NS_write() = r
    };
    return()
}

bitfield ICC_BPR0_Type : bits(32) = {BinaryPoint : 2..0}

register _ICC_BPR0 : ICC_BPR0_Type

val ICC_BPR0_read : unit -> ICC_BPR0_Type

function ICC_BPR0_read () = {
    r : ICC_BPR0_Type = _ICC_BPR0;
    r.bits[31 .. 0] = Slice(ICC_BPR0_EL1.bits, 0, 32);
    return(r)
}

val ICC_BPR0_write : ICC_BPR0_Type -> unit

function ICC_BPR0_write value_name = {
    let r : ICC_BPR0_Type = value_name;
    ICC_BPR0_EL1.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _ICC_BPR0 = r;
    return()
}

type ICV_AP1R_Type = bits(32)

register _ICV_AP1R : vector(4, ICV_AP1R_Type)

val ICV_AP1R_read : forall 'n, (0 <= 'n & 'n < 4). int('n) -> ICV_AP1R_Type

function ICV_AP1R_read n = {
    r : ICV_AP1R_Type = _ICV_AP1R[n];
    r[31 .. 0] = Slice(ICV_AP1R_EL1[n].bits, 0, 32);
    return(r)
}

val ICV_AP1R_set : forall 'n, (0 <= 'n & 'n < 4).
  (int('n), ICV_AP1R_Type) -> unit

function ICV_AP1R_set (n, value_name) = {
    let r : ICV_AP1R_Type = value_name;
    ICV_AP1R_EL1[n].bits[31 .. 0] = Slice(r, 0, 32);
    _ICV_AP1R[n] = r;
    return()
}

type ADFSR_Type = bits(32)

register ADFSR_S : ADFSR_Type

register _ADFSR_NS : ADFSR_Type

val ADFSR_NS_read : unit -> ADFSR_Type

function ADFSR_NS_read () = {
    r : ADFSR_Type = _ADFSR_NS;
    r[31 .. 0] = Slice(AFSR0_EL1, 0, 32);
    return(r)
}

val ADFSR_NS_write : ADFSR_Type -> unit

function ADFSR_NS_write value_name = {
    let r : ADFSR_Type = value_name;
    AFSR0_EL1[31 .. 0] = Slice(r, 0, 32);
    _ADFSR_NS = r;
    return()
}

val ADFSR_read : unit -> ADFSR_Type

function ADFSR_read () = {
    r : ADFSR_Type = undefined;
    if ELUsingAArch32(EL3) & CurrentSecurityState() == SS_Secure then {
        r = ADFSR_S
    } else {
        r = ADFSR_NS_read()
    };
    return(r)
}

val ADFSR_write : ADFSR_Type -> unit

function ADFSR_write value_name = {
    let r : ADFSR_Type = value_name;
    if ELUsingAArch32(EL3) & CurrentSecurityState() == SS_Secure then {
        ADFSR_S = r
    } else {
        ADFSR_NS_write() = r
    };
    return()
}

bitfield CNTHCTL_Type : bits(32) =
  {
    EVNTIS : 17..17,
    EVNTI : 7..4,
    EVNTDIR : 3..3,
    EVNTEN : 2..2,
    PL1PCEN : 1..1,
    PL1PCTEN : 0..0
  }

register _CNTHCTL : CNTHCTL_Type

val CNTHCTL_read : unit -> CNTHCTL_Type

function CNTHCTL_read () = {
    r : CNTHCTL_Type = _CNTHCTL;
    r.bits[31 .. 0] = Slice(CNTHCTL_EL2.bits, 0, 32);
    return(r)
}

val CNTHCTL_write : CNTHCTL_Type -> unit

function CNTHCTL_write value_name = {
    let r : CNTHCTL_Type = value_name;
    CNTHCTL_EL2.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _CNTHCTL = r;
    return()
}

val DBGVCR_write : DBGVCR_Type -> unit

function DBGVCR_write value_name = {
    let r : DBGVCR_Type = value_name;
    DBGVCR32_EL2.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _DBGVCR = r;
    return()
}

bitfield ICC_EOIR0_Type : bits(32) = {INTID : 23..0}

register _ICC_EOIR0 : ICC_EOIR0_Type

val ICC_EOIR0_read : unit -> ICC_EOIR0_Type

function ICC_EOIR0_read () = {
    r : ICC_EOIR0_Type = _ICC_EOIR0;
    r.bits[31 .. 0] = Slice(ICC_EOIR0_EL1.bits, 0, 32);
    return(r)
}

val ICC_EOIR0_write : ICC_EOIR0_Type -> unit

function ICC_EOIR0_write value_name = {
    let r : ICC_EOIR0_Type = value_name;
    ICC_EOIR0_EL1.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _ICC_EOIR0 = r;
    return()
}

type REVIDR_Type = bits(32)

register _REVIDR : REVIDR_Type

val REVIDR_read : unit -> REVIDR_Type

function REVIDR_read () = {
    r : REVIDR_Type = _REVIDR;
    r[31 .. 0] = Slice(REVIDR_EL1, 0, 32);
    return(r)
}

bitfield ID_MMFR1_Type : bits(32) =
  {
    BPred : 31..28,
    L1TstCln : 27..24,
    L1Uni : 23..20,
    L1Hvd : 19..16,
    L1UniSW : 15..12,
    L1HvdSW : 11..8,
    L1UniVA : 7..4,
    L1HvdVA : 3..0
  }

register _ID_MMFR1 : ID_MMFR1_Type

val ID_MMFR1_read : unit -> ID_MMFR1_Type

function ID_MMFR1_read () = {
    r : ID_MMFR1_Type = _ID_MMFR1;
    r.bits[31 .. 0] = Slice(ID_MMFR1_EL1.bits, 0, 32);
    return(r)
}

val ID_MMFR1_write : ID_MMFR1_Type -> unit

function ID_MMFR1_write value_name = {
    let r : ID_MMFR1_Type = value_name;
    ID_MMFR1_EL1.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _ID_MMFR1 = r;
    return()
}

bitfield ICV_BPR1_Type : bits(32) = {BinaryPoint : 2..0}

register _ICV_BPR1 : ICV_BPR1_Type

val ICV_BPR1_read : unit -> ICV_BPR1_Type

function ICV_BPR1_read () = {
    r : ICV_BPR1_Type = _ICV_BPR1;
    r.bits[31 .. 0] = Slice(ICV_BPR1_EL1.bits, 0, 32);
    return(r)
}

val ICV_BPR1_write : ICV_BPR1_Type -> unit

function ICV_BPR1_write value_name = {
    let r : ICV_BPR1_Type = value_name;
    ICV_BPR1_EL1.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _ICV_BPR1 = r;
    return()
}

bitfield ICC_RPR_Type : bits(32) = {Priority : 7..0}

register _ICC_RPR : ICC_RPR_Type

val ICC_RPR_read : unit -> ICC_RPR_Type

function ICC_RPR_read () = {
    r : ICC_RPR_Type = _ICC_RPR;
    r.bits[31 .. 0] = Slice(ICC_RPR_EL1.bits, 0, 32);
    return(r)
}

val ICC_RPR_write : ICC_RPR_Type -> unit

function ICC_RPR_write value_name = {
    let r : ICC_RPR_Type = value_name;
    ICC_RPR_EL1.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _ICC_RPR = r;
    return()
}

bitfield MVFR2_Type : bits(32) = {FPMisc : 7..4, SIMDMisc : 3..0}

register _MVFR2 : MVFR2_Type

val MVFR2_read : unit -> MVFR2_Type

function MVFR2_read () = {
    r : MVFR2_Type = _MVFR2;
    r.bits[31 .. 0] = Slice(MVFR2_EL1.bits, 0, 32);
    return(r)
}

val MVFR2_write : MVFR2_Type -> unit

function MVFR2_write value_name = {
    let r : MVFR2_Type = value_name;
    MVFR2_EL1.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _MVFR2 = r;
    return()
}

bitfield ICC_MSRE_Type : bits(32) =
  {Enable : 3..3, DIB : 2..2, DFB : 1..1, SRE : 0..0}

register ICC_MSRE : ICC_MSRE_Type

bitfield PMMIR_Type : bits(32) =
  {
    EDGE : 27..24,
    THWIDTH : 23..20,
    BUS_WIDTH : 19..16,
    BUS_SLOTS : 15..8,
    SLOTS : 7..0
  }

register PMMIR : PMMIR_Type

bitfield VMPIDR_Type : bits(32) =
  {
    M : 31..31,
    U : 30..30,
    MT : 24..24,
    Aff2 : 23..16,
    Aff1 : 15..8,
    Aff0 : 7..0
  }

register _VMPIDR : VMPIDR_Type

val VMPIDR_read : unit -> VMPIDR_Type

function VMPIDR_read () = {
    r : VMPIDR_Type = _VMPIDR;
    r.bits[31 .. 0] = Slice(VMPIDR_EL2.bits, 0, 32);
    return(r)
}

val VMPIDR_write : VMPIDR_Type -> unit

function VMPIDR_write value_name = {
    let r : VMPIDR_Type = value_name;
    VMPIDR_EL2.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _VMPIDR = r;
    return()
}

bitfield ICC_IGRPEN1_Type : bits(32) = {Enable : 0..0}

register _ICC_IGRPEN1_S : ICC_IGRPEN1_Type

val ICC_IGRPEN1_S_read : unit -> ICC_IGRPEN1_Type

function ICC_IGRPEN1_S_read () = {
    r : ICC_IGRPEN1_Type = _ICC_IGRPEN1_S;
    r.bits[31 .. 0] = Slice(ICC_IGRPEN1_EL1_S.bits, 0, 32);
    return(r)
}

val ICC_IGRPEN1_S_write : ICC_IGRPEN1_Type -> unit

function ICC_IGRPEN1_S_write value_name = {
    let r : ICC_IGRPEN1_Type = value_name;
    ICC_IGRPEN1_EL1_S.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _ICC_IGRPEN1_S = r;
    return()
}

register _ICC_IGRPEN1_NS : ICC_IGRPEN1_Type

val ICC_IGRPEN1_NS_read : unit -> ICC_IGRPEN1_Type

function ICC_IGRPEN1_NS_read () = {
    r : ICC_IGRPEN1_Type = _ICC_IGRPEN1_NS;
    r.bits[31 .. 0] = Slice(ICC_IGRPEN1_EL1_NS.bits, 0, 32);
    return(r)
}

val ICC_IGRPEN1_NS_write : ICC_IGRPEN1_Type -> unit

function ICC_IGRPEN1_NS_write value_name = {
    let r : ICC_IGRPEN1_Type = value_name;
    ICC_IGRPEN1_EL1_NS.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _ICC_IGRPEN1_NS = r;
    return()
}

val ICC_IGRPEN1_read : unit -> ICC_IGRPEN1_Type

function ICC_IGRPEN1_read () = {
    r : ICC_IGRPEN1_Type = undefined;
    if ELUsingAArch32(EL3) & CurrentSecurityState() == SS_Secure then {
        r = ICC_IGRPEN1_S_read()
    } else {
        r = ICC_IGRPEN1_NS_read()
    };
    return(r)
}

val ICC_IGRPEN1_write : ICC_IGRPEN1_Type -> unit

function ICC_IGRPEN1_write value_name = {
    let r : ICC_IGRPEN1_Type = value_name;
    if ELUsingAArch32(EL3) & CurrentSecurityState() == SS_Secure then {
        ICC_IGRPEN1_S_write() = r
    } else {
        ICC_IGRPEN1_NS_write() = r
    };
    return()
}

val MAIR0_S_write : MAIR0_Type -> unit

function MAIR0_S_write value_name = {
    let r : MAIR0_Type = value_name;
    PRRR_S.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _MAIR0_S = r;
    return()
}

val MAIR0_NS_write : MAIR0_Type -> unit

function MAIR0_NS_write value_name = {
    let r : MAIR0_Type = value_name;
    if ELUsingAArch32(EL3) then {
        PRRR_NS_write() = Mk_PRRR_Type(SetSlice(32, PRRR_NS_read().bits, 0, Slice(r.bits, 0, 32)))
    } else {
        if not_bool(HaveEL(EL3)) | not_bool(ELUsingAArch32(EL3)) then {
            MAIR_EL1.bits[31 .. 0] = Slice(r.bits, 0, 32)
        } else {
            PRRR_write() = Mk_PRRR_Type(SetSlice(32, PRRR_read().bits, 0, Slice(r.bits, 0, 32)))
        }
    };
    _MAIR0_NS = r;
    return()
}

val MAIR0_write : MAIR0_Type -> unit

function MAIR0_write value_name = {
    let r : MAIR0_Type = value_name;
    if ELUsingAArch32(EL3) & CurrentSecurityState() == SS_Secure then {
        MAIR0_S_write() = r
    } else {
        MAIR0_NS_write() = r
    };
    return()
}

bitfield FPSID_Type : bits(32) =
  {
    Implementer : 31..24,
    SW : 23..23,
    Subarchitecture : 22..16,
    PartNum : 15..8,
    Variant : 7..4,
    Revision : 3..0
  }

register FPSID : FPSID_Type

val HVBAR_write : HVBAR_Type -> unit

function HVBAR_write value_name = {
    let r : HVBAR_Type = value_name;
    VBAR_EL2[31 .. 0] = Slice(r, 0, 32);
    _HVBAR = r;
    return()
}

val HSTR_write : HSTR_Type -> unit

function HSTR_write value_name = {
    let r : HSTR_Type = value_name;
    HSTR_EL2.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _HSTR = r;
    return()
}

bitfield ICC_MCTLR_Type : bits(32) =
  {
    ExtRange : 19..19,
    RSS : 18..18,
    nDS : 17..17,
    A3V : 15..15,
    SEIS : 14..14,
    IDbits : 13..11,
    PRIbits : 10..8,
    PMHE : 6..6,
    RM : 5..5,
    EOImode_EL1NS : 4..4,
    EOImode_EL1S : 3..3,
    EOImode_EL3 : 2..2,
    CBPR_EL1NS : 1..1,
    CBPR_EL1S : 0..0
  }

register ICC_MCTLR : ICC_MCTLR_Type

bitfield ICC_DIR_Type : bits(32) = {INTID : 23..0}

register _ICC_DIR : ICC_DIR_Type

val ICC_DIR_read : unit -> ICC_DIR_Type

function ICC_DIR_read () = {
    r : ICC_DIR_Type = _ICC_DIR;
    r.bits[31 .. 0] = Slice(ICC_DIR_EL1.bits, 0, 32);
    return(r)
}

val ICC_DIR_write : ICC_DIR_Type -> unit

function ICC_DIR_write value_name = {
    let r : ICC_DIR_Type = value_name;
    ICC_DIR_EL1.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _ICC_DIR = r;
    return()
}

bitfield PMSELR_Type : bits(32) = {SEL : 4..0}

register _PMSELR : PMSELR_Type

val PMSELR_read : unit -> PMSELR_Type

function PMSELR_read () = {
    r : PMSELR_Type = _PMSELR;
    r.bits[31 .. 0] = Slice(PMSELR_EL0.bits, 0, 32);
    return(r)
}

val PMSELR_write : PMSELR_Type -> unit

function PMSELR_write value_name = {
    let r : PMSELR_Type = value_name;
    PMSELR_EL0.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _PMSELR = r;
    return()
}

type ID_AFR0_Type = bits(32)

register _ID_AFR0 : ID_AFR0_Type

val ID_AFR0_read : unit -> ID_AFR0_Type

function ID_AFR0_read () = {
    r : ID_AFR0_Type = _ID_AFR0;
    r[31 .. 0] = Slice(ID_AFR0_EL1, 0, 32);
    return(r)
}

val ID_AFR0_write : ID_AFR0_Type -> unit

function ID_AFR0_write value_name = {
    let r : ID_AFR0_Type = value_name;
    ID_AFR0_EL1[31 .. 0] = Slice(r, 0, 32);
    _ID_AFR0 = r;
    return()
}

bitfield DBGCLAIMSET_Type : bits(32) = {CLAIM : 7..0}

register _DBGCLAIMSET : DBGCLAIMSET_Type

val DBGCLAIMSET_read : unit -> DBGCLAIMSET_Type

function DBGCLAIMSET_read () = {
    r : DBGCLAIMSET_Type = _DBGCLAIMSET;
    r.bits[31 .. 0] = Slice(DBGCLAIMSET_EL1.bits, 0, 32);
    return(r)
}

val DBGCLAIMSET_write : DBGCLAIMSET_Type -> unit

function DBGCLAIMSET_write value_name = {
    let r : DBGCLAIMSET_Type = value_name;
    DBGCLAIMSET_EL1.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _DBGCLAIMSET = r;
    return()
}

val NMRR_NS_write : NMRR_Type -> unit

function NMRR_NS_write value_name = {
    let r : NMRR_Type = value_name;
    MAIR_EL1.bits[63 .. 32] = Slice(r.bits, 0, 32);
    _NMRR_NS = r;
    return()
}

val NMRR_write : NMRR_Type -> unit

function NMRR_write value_name = {
    let r : NMRR_Type = value_name;
    if ELUsingAArch32(EL3) & CurrentSecurityState() == SS_Secure then {
        NMRR_S = r
    } else {
        NMRR_NS_write() = r
    };
    return()
}

type TPIDRURO_Type = bits(32)

register TPIDRURO_S : TPIDRURO_Type

register _TPIDRURO_NS : TPIDRURO_Type

val TPIDRURO_NS_read : unit -> TPIDRURO_Type

function TPIDRURO_NS_read () = {
    r : TPIDRURO_Type = _TPIDRURO_NS;
    r[31 .. 0] = Slice(TPIDRRO_EL0, 0, 32);
    return(r)
}

val TPIDRURO_NS_write : TPIDRURO_Type -> unit

function TPIDRURO_NS_write value_name = {
    let r : TPIDRURO_Type = value_name;
    TPIDRRO_EL0[31 .. 0] = Slice(r, 0, 32);
    _TPIDRURO_NS = r;
    return()
}

val TPIDRURO_read : unit -> TPIDRURO_Type

function TPIDRURO_read () = {
    r : TPIDRURO_Type = undefined;
    if ELUsingAArch32(EL3) & CurrentSecurityState() == SS_Secure then {
        r = TPIDRURO_S
    } else {
        r = TPIDRURO_NS_read()
    };
    return(r)
}

val TPIDRURO_write : TPIDRURO_Type -> unit

function TPIDRURO_write value_name = {
    let r : TPIDRURO_Type = value_name;
    if ELUsingAArch32(EL3) & CurrentSecurityState() == SS_Secure then {
        TPIDRURO_S = r
    } else {
        TPIDRURO_NS_write() = r
    };
    return()
}

val __get_selected_PMEVCNTR : unit -> PMEVCNTR_Type

function __get_selected_PMEVCNTR () = {
    let 'idx = UInt(PMSELR_read()[SEL]);
    assert(idx <= 30);
    return(PMEVCNTR_read(idx))
}

val __set_selected_PMEVCNTR : PMEVCNTR_Type -> unit

function __set_selected_PMEVCNTR value_name = {
    let 'idx = UInt(PMSELR_read()[SEL]);
    assert(idx <= 30);
    PMEVCNTR_set(idx) = value_name;
    return()
}

bitfield ICC_IGRPEN0_Type : bits(32) = {Enable : 0..0}

register _ICC_IGRPEN0 : ICC_IGRPEN0_Type

val ICC_IGRPEN0_read : unit -> ICC_IGRPEN0_Type

function ICC_IGRPEN0_read () = {
    r : ICC_IGRPEN0_Type = _ICC_IGRPEN0;
    r.bits[31 .. 0] = Slice(ICC_IGRPEN0_EL1.bits, 0, 32);
    return(r)
}

val ICC_IGRPEN0_write : ICC_IGRPEN0_Type -> unit

function ICC_IGRPEN0_write value_name = {
    let r : ICC_IGRPEN0_Type = value_name;
    ICC_IGRPEN0_EL1.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _ICC_IGRPEN0 = r;
    return()
}

bitfield DBGDTRTXext_Type : bits(32) = {DTRTX : 31..0}

register _DBGDTRTXext : DBGDTRTXext_Type

val DBGDTRTXext_read : unit -> DBGDTRTXext_Type

function DBGDTRTXext_read () = {
    r : DBGDTRTXext_Type = _DBGDTRTXext;
    r.bits[31 .. 0] = Slice(OSDTRTX_EL1, 0, 32);
    return(r)
}

val DBGDTRTXext_write : DBGDTRTXext_Type -> unit

function DBGDTRTXext_write value_name = {
    let r : DBGDTRTXext_Type = value_name;
    OSDTRTX_EL1[31 .. 0] = Slice(r.bits, 0, 32);
    _DBGDTRTXext = r;
    return()
}

type ACTLR_Type = bits(32)

register ACTLR_S : ACTLR_Type

register _ACTLR_NS : ACTLR_Type

val ACTLR_NS_read : unit -> ACTLR_Type

function ACTLR_NS_read () = {
    r : ACTLR_Type = _ACTLR_NS;
    r[31 .. 0] = Slice(ACTLR_EL1, 0, 32);
    return(r)
}

val ACTLR_NS_write : ACTLR_Type -> unit

function ACTLR_NS_write value_name = {
    let r : ACTLR_Type = value_name;
    ACTLR_EL1[31 .. 0] = Slice(r, 0, 32);
    _ACTLR_NS = r;
    return()
}

val ACTLR_read : unit -> ACTLR_Type

function ACTLR_read () = {
    r : ACTLR_Type = undefined;
    if ELUsingAArch32(EL3) & CurrentSecurityState() == SS_Secure then {
        r = ACTLR_S
    } else {
        r = ACTLR_NS_read()
    };
    return(r)
}

val ACTLR_write : ACTLR_Type -> unit

function ACTLR_write value_name = {
    let r : ACTLR_Type = value_name;
    if ELUsingAArch32(EL3) & CurrentSecurityState() == SS_Secure then {
        ACTLR_S = r
    } else {
        ACTLR_NS_write() = r
    };
    return()
}

bitfield MVFR1_Type : bits(32) =
  {
    SIMDFMAC : 31..28,
    FPHP : 27..24,
    SIMDHP : 23..20,
    SIMDSP : 19..16,
    SIMDInt : 15..12,
    SIMDLS : 11..8,
    FPDNaN : 7..4,
    FPFtZ : 3..0
  }

register _MVFR1 : MVFR1_Type

val MVFR1_read : unit -> MVFR1_Type

function MVFR1_read () = {
    r : MVFR1_Type = _MVFR1;
    r.bits[31 .. 0] = Slice(MVFR1_EL1.bits, 0, 32);
    return(r)
}

val MVFR1_write : MVFR1_Type -> unit

function MVFR1_write value_name = {
    let r : MVFR1_Type = value_name;
    MVFR1_EL1.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _MVFR1 = r;
    return()
}

bitfield ICC_CTLR_Type : bits(32) =
  {
    ExtRange : 19..19,
    RSS : 18..18,
    A3V : 15..15,
    SEIS : 14..14,
    IDbits : 13..11,
    PRIbits : 10..8,
    PMHE : 6..6,
    EOImode : 1..1,
    CBPR : 0..0
  }

register _ICC_CTLR_S : ICC_CTLR_Type

val ICC_CTLR_S_read : unit -> ICC_CTLR_Type

function ICC_CTLR_S_read () = {
    r : ICC_CTLR_Type = _ICC_CTLR_S;
    r.bits[31 .. 0] = Slice(ICC_CTLR_EL1_S.bits, 0, 32);
    return(r)
}

val ICC_CTLR_S_write : ICC_CTLR_Type -> unit

function ICC_CTLR_S_write value_name = {
    let r : ICC_CTLR_Type = value_name;
    ICC_CTLR_EL1_S.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _ICC_CTLR_S = r;
    return()
}

register _ICC_CTLR_NS : ICC_CTLR_Type

val ICC_CTLR_NS_read : unit -> ICC_CTLR_Type

function ICC_CTLR_NS_read () = {
    r : ICC_CTLR_Type = _ICC_CTLR_NS;
    r.bits[31 .. 0] = Slice(ICC_CTLR_EL1_NS.bits, 0, 32);
    return(r)
}

val ICC_CTLR_NS_write : ICC_CTLR_Type -> unit

function ICC_CTLR_NS_write value_name = {
    let r : ICC_CTLR_Type = value_name;
    ICC_CTLR_EL1_NS.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _ICC_CTLR_NS = r;
    return()
}

val ICC_CTLR_read : unit -> ICC_CTLR_Type

function ICC_CTLR_read () = {
    r : ICC_CTLR_Type = undefined;
    if ELUsingAArch32(EL3) & CurrentSecurityState() == SS_Secure then {
        r = ICC_CTLR_S_read()
    } else {
        r = ICC_CTLR_NS_read()
    };
    return(r)
}

val ICC_CTLR_write : ICC_CTLR_Type -> unit

function ICC_CTLR_write value_name = {
    let r : ICC_CTLR_Type = value_name;
    if ELUsingAArch32(EL3) & CurrentSecurityState() == SS_Secure then {
        ICC_CTLR_S_write() = r
    } else {
        ICC_CTLR_NS_write() = r
    };
    return()
}

bitfield DBGOSLAR_Type : bits(32) = {OSLA : 31..0}

register DBGOSLAR : DBGOSLAR_Type

bitfield DBGDTRRXext_Type : bits(32) = {DTRRX : 31..0}

register _DBGDTRRXext : DBGDTRRXext_Type

val DBGDTRRXext_read : unit -> DBGDTRRXext_Type

function DBGDTRRXext_read () = {
    r : DBGDTRRXext_Type = _DBGDTRRXext;
    r.bits[31 .. 0] = Slice(OSDTRRX_EL1, 0, 32);
    return(r)
}

val DBGDTRRXext_write : DBGDTRRXext_Type -> unit

function DBGDTRRXext_write value_name = {
    let r : DBGDTRRXext_Type = value_name;
    OSDTRRX_EL1[31 .. 0] = Slice(r.bits, 0, 32);
    _DBGDTRRXext = r;
    return()
}

type ICC_AP1R_Type = bits(32)

register _ICC_AP1R_S : vector(4, ICC_AP1R_Type)

val ICC_AP1R_S_read : forall 'n, (0 <= 'n & 'n < 4). int('n) -> ICC_AP1R_Type

function ICC_AP1R_S_read n = {
    r : ICC_AP1R_Type = _ICC_AP1R_S[n];
    r[31 .. 0] = Slice(ICC_AP1R_EL1_S[n].bits, 0, 32);
    return(r)
}

val ICC_AP1R_S_set : forall 'n, (0 <= 'n & 'n < 4).
  (int('n), ICC_AP1R_Type) -> unit

function ICC_AP1R_S_set (n, value_name) = {
    let r : ICC_AP1R_Type = value_name;
    ICC_AP1R_EL1_S[n].bits[31 .. 0] = Slice(r, 0, 32);
    _ICC_AP1R_S[n] = r;
    return()
}

register _ICC_AP1R_NS : vector(4, ICC_AP1R_Type)

val ICC_AP1R_NS_read : forall 'n, (0 <= 'n & 'n < 4). int('n) -> ICC_AP1R_Type

function ICC_AP1R_NS_read n = {
    r : ICC_AP1R_Type = _ICC_AP1R_NS[n];
    r[31 .. 0] = Slice(ICC_AP1R_EL1_NS[n].bits, 0, 32);
    return(r)
}

val ICC_AP1R_NS_set : forall 'n, (0 <= 'n & 'n < 4).
  (int('n), ICC_AP1R_Type) -> unit

function ICC_AP1R_NS_set (n, value_name) = {
    let r : ICC_AP1R_Type = value_name;
    ICC_AP1R_EL1_NS[n].bits[31 .. 0] = Slice(r, 0, 32);
    _ICC_AP1R_NS[n] = r;
    return()
}

val ICC_AP1R_read : forall 'n. int('n) -> ICC_AP1R_Type

function ICC_AP1R_read n = {
    r : ICC_AP1R_Type = undefined;
    if ELUsingAArch32(EL3) & CurrentSecurityState() == SS_Secure then {
        assert(constraint((0 <= 'n & 'n < 4)));
        r = ICC_AP1R_S_read(n)
    } else {
        assert(constraint((0 <= 'n & 'n < 4)));
        r = ICC_AP1R_NS_read(n)
    };
    return(r)
}

val ICC_AP1R_set : forall 'n. (int('n), ICC_AP1R_Type) -> unit

function ICC_AP1R_set (n, value_name) = {
    let r : ICC_AP1R_Type = value_name;
    if ELUsingAArch32(EL3) & CurrentSecurityState() == SS_Secure then {
        assert(constraint((0 <= 'n & 'n < 4)));
        ICC_AP1R_S_set(n) = r
    } else {
        assert(constraint((0 <= 'n & 'n < 4)));
        ICC_AP1R_NS_set(n) = r
    };
    return()
}

bitfield CNTHVS_CTL_Type : bits(32) =
  {ISTATUS : 2..2, IMASK : 1..1, ENABLE : 0..0}

register _CNTHVS_CTL : CNTHVS_CTL_Type

val CNTHVS_CTL_read : unit -> CNTHVS_CTL_Type

function CNTHVS_CTL_read () = {
    r : CNTHVS_CTL_Type = _CNTHVS_CTL;
    r.bits[31 .. 0] = Slice(CNTHVS_CTL_EL2.bits, 0, 32);
    return(r)
}

val CNTHVS_CTL_write : CNTHVS_CTL_Type -> unit

function CNTHVS_CTL_write value_name = {
    let r : CNTHVS_CTL_Type = value_name;
    CNTHVS_CTL_EL2.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _CNTHVS_CTL = r;
    return()
}

bitfield ICH_AP1R_Type : bits(32) =
  {
    P31 : 31..31,
    P30 : 30..30,
    P29 : 29..29,
    P28 : 28..28,
    P27 : 27..27,
    P26 : 26..26,
    P25 : 25..25,
    P24 : 24..24,
    P23 : 23..23,
    P22 : 22..22,
    P21 : 21..21,
    P20 : 20..20,
    P19 : 19..19,
    P18 : 18..18,
    P17 : 17..17,
    P16 : 16..16,
    P15 : 15..15,
    P14 : 14..14,
    P13 : 13..13,
    P12 : 12..12,
    P11 : 11..11,
    P10 : 10..10,
    P9 : 9..9,
    P8 : 8..8,
    P7 : 7..7,
    P6 : 6..6,
    P5 : 5..5,
    P4 : 4..4,
    P3 : 3..3,
    P2 : 2..2,
    P1 : 1..1,
    P0 : 0..0
  }

register _ICH_AP1R : vector(4, ICH_AP1R_Type)

val ICH_AP1R_read : forall 'n, (0 <= 'n & 'n < 4). int('n) -> ICH_AP1R_Type

function ICH_AP1R_read n = {
    r : ICH_AP1R_Type = _ICH_AP1R[n];
    r.bits[31 .. 0] = Slice(ICH_AP1R_EL2[n].bits, 0, 32);
    return(r)
}

val ICH_AP1R_set : forall 'n, (0 <= 'n & 'n < 4).
  (int('n), ICH_AP1R_Type) -> unit

function ICH_AP1R_set (n, value_name) = {
    let r : ICH_AP1R_Type = value_name;
    ICH_AP1R_EL2[n].bits[31 .. 0] = Slice(r.bits, 0, 32);
    _ICH_AP1R[n] = r;
    return()
}

bitfield ID_MMFR0_Type : bits(32) =
  {
    InnerShr : 31..28,
    FCSE : 27..24,
    AuxReg : 23..20,
    TCM : 19..16,
    ShareLvl : 15..12,
    OuterShr : 11..8,
    PMSA : 7..4,
    VMSA : 3..0
  }

register _ID_MMFR0 : ID_MMFR0_Type

val ID_MMFR0_read : unit -> ID_MMFR0_Type

function ID_MMFR0_read () = {
    r : ID_MMFR0_Type = _ID_MMFR0;
    r.bits[31 .. 0] = Slice(ID_MMFR0_EL1.bits, 0, 32);
    return(r)
}

val ID_MMFR0_write : ID_MMFR0_Type -> unit

function ID_MMFR0_write value_name = {
    let r : ID_MMFR0_Type = value_name;
    ID_MMFR0_EL1.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _ID_MMFR0 = r;
    return()
}

bitfield ICV_BPR0_Type : bits(32) = {BinaryPoint : 2..0}

register _ICV_BPR0 : ICV_BPR0_Type

val ICV_BPR0_read : unit -> ICV_BPR0_Type

function ICV_BPR0_read () = {
    r : ICV_BPR0_Type = _ICV_BPR0;
    r.bits[31 .. 0] = Slice(ICV_BPR0_EL1.bits, 0, 32);
    return(r)
}

val ICV_BPR0_write : ICV_BPR0_Type -> unit

function ICV_BPR0_write value_name = {
    let r : ICV_BPR0_Type = value_name;
    ICV_BPR0_EL1.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _ICV_BPR0 = r;
    return()
}

bitfield ICH_EISR_Type : bits(32) =
  {
    Status15 : 15..15,
    Status14 : 14..14,
    Status13 : 13..13,
    Status12 : 12..12,
    Status11 : 11..11,
    Status10 : 10..10,
    Status9 : 9..9,
    Status8 : 8..8,
    Status7 : 7..7,
    Status6 : 6..6,
    Status5 : 5..5,
    Status4 : 4..4,
    Status3 : 3..3,
    Status2 : 2..2,
    Status1 : 1..1,
    Status0 : 0..0
  }

register _ICH_EISR : ICH_EISR_Type

val ICH_EISR_read : unit -> ICH_EISR_Type

function ICH_EISR_read () = {
    r : ICH_EISR_Type = _ICH_EISR;
    r.bits[31 .. 0] = Slice(ICH_EISR_EL2.bits, 0, 32);
    return(r)
}

val ICH_EISR_write : ICH_EISR_Type -> unit

function ICH_EISR_write value_name = {
    let r : ICH_EISR_Type = value_name;
    ICH_EISR_EL2.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _ICH_EISR = r;
    return()
}

type AMAIR0_Type = bits(32)

register AMAIR0_S : AMAIR0_Type

register _AMAIR0_NS : AMAIR0_Type

val AMAIR0_NS_read : unit -> AMAIR0_Type

function AMAIR0_NS_read () = {
    r : AMAIR0_Type = _AMAIR0_NS;
    r[31 .. 0] = Slice(AMAIR_EL1, 0, 32);
    return(r)
}

val AMAIR0_NS_write : AMAIR0_Type -> unit

function AMAIR0_NS_write value_name = {
    let r : AMAIR0_Type = value_name;
    AMAIR_EL1[31 .. 0] = Slice(r, 0, 32);
    _AMAIR0_NS = r;
    return()
}

val AMAIR0_read : unit -> AMAIR0_Type

function AMAIR0_read () = {
    r : AMAIR0_Type = undefined;
    if ELUsingAArch32(EL3) & CurrentSecurityState() == SS_Secure then {
        r = AMAIR0_S
    } else {
        r = AMAIR0_NS_read()
    };
    return(r)
}

val AMAIR0_write : AMAIR0_Type -> unit

function AMAIR0_write value_name = {
    let r : AMAIR0_Type = value_name;
    if ELUsingAArch32(EL3) & CurrentSecurityState() == SS_Secure then {
        AMAIR0_S = r
    } else {
        AMAIR0_NS_write() = r
    };
    return()
}

val HDCR_write : HDCR_Type -> unit

function HDCR_write value_name = {
    let r : HDCR_Type = value_name;
    MDCR_EL2.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _HDCR = r;
    return()
}

bitfield MVFR0_Type : bits(32) =
  {
    FPRound : 31..28,
    FPShVec : 27..24,
    FPSqrt : 23..20,
    FPDivide : 19..16,
    FPTrap : 15..12,
    FPDP : 11..8,
    FPSP : 7..4,
    SIMDReg : 3..0
  }

register _MVFR0 : MVFR0_Type

val MVFR0_read : unit -> MVFR0_Type

function MVFR0_read () = {
    r : MVFR0_Type = _MVFR0;
    r.bits[31 .. 0] = Slice(MVFR0_EL1.bits, 0, 32);
    return(r)
}

val MVFR0_write : MVFR0_Type -> unit

function MVFR0_write value_name = {
    let r : MVFR0_Type = value_name;
    MVFR0_EL1.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _MVFR0 = r;
    return()
}

type HAMAIR0_Type = bits(32)

register _HAMAIR0 : HAMAIR0_Type

val HAMAIR0_read : unit -> HAMAIR0_Type

function HAMAIR0_read () = {
    r : HAMAIR0_Type = _HAMAIR0;
    r[31 .. 0] = Slice(AMAIR_EL2, 0, 32);
    return(r)
}

val HAMAIR0_write : HAMAIR0_Type -> unit

function HAMAIR0_write value_name = {
    let r : HAMAIR0_Type = value_name;
    AMAIR_EL2[31 .. 0] = Slice(r, 0, 32);
    _HAMAIR0 = r;
    return()
}

bitfield ICC_HSRE_Type : bits(32) =
  {Enable : 3..3, DIB : 2..2, DFB : 1..1, SRE : 0..0}

register _ICC_HSRE : ICC_HSRE_Type

val ICC_HSRE_read : unit -> ICC_HSRE_Type

function ICC_HSRE_read () = {
    r : ICC_HSRE_Type = _ICC_HSRE;
    r.bits[31 .. 0] = Slice(ICC_SRE_EL2.bits, 0, 32);
    return(r)
}

val ICC_HSRE_write : ICC_HSRE_Type -> unit

function ICC_HSRE_write value_name = {
    let r : ICC_HSRE_Type = value_name;
    ICC_SRE_EL2.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _ICC_HSRE = r;
    return()
}

val PMCCFILTR_write : PMCCFILTR_Type -> unit

function PMCCFILTR_write value_name = {
    let r : PMCCFILTR_Type = value_name;
    PMCCFILTR_EL0.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _PMCCFILTR = r;
    return()
}

bitfield ICH_AP0R_Type : bits(32) =
  {
    P31 : 31..31,
    P30 : 30..30,
    P29 : 29..29,
    P28 : 28..28,
    P27 : 27..27,
    P26 : 26..26,
    P25 : 25..25,
    P24 : 24..24,
    P23 : 23..23,
    P22 : 22..22,
    P21 : 21..21,
    P20 : 20..20,
    P19 : 19..19,
    P18 : 18..18,
    P17 : 17..17,
    P16 : 16..16,
    P15 : 15..15,
    P14 : 14..14,
    P13 : 13..13,
    P12 : 12..12,
    P11 : 11..11,
    P10 : 10..10,
    P9 : 9..9,
    P8 : 8..8,
    P7 : 7..7,
    P6 : 6..6,
    P5 : 5..5,
    P4 : 4..4,
    P3 : 3..3,
    P2 : 2..2,
    P1 : 1..1,
    P0 : 0..0
  }

register _ICH_AP0R : vector(4, ICH_AP0R_Type)

val ICH_AP0R_read : forall 'n, (0 <= 'n & 'n < 4). int('n) -> ICH_AP0R_Type

function ICH_AP0R_read n = {
    r : ICH_AP0R_Type = _ICH_AP0R[n];
    r.bits[31 .. 0] = Slice(ICH_AP0R_EL2[n].bits, 0, 32);
    return(r)
}

val ICH_AP0R_set : forall 'n, (0 <= 'n & 'n < 4).
  (int('n), ICH_AP0R_Type) -> unit

function ICH_AP0R_set (n, value_name) = {
    let r : ICH_AP0R_Type = value_name;
    ICH_AP0R_EL2[n].bits[31 .. 0] = Slice(r.bits, 0, 32);
    _ICH_AP0R[n] = r;
    return()
}

bitfield ID_ISAR5_Type : bits(32) =
  {
    VCMA : 31..28,
    RDM : 27..24,
    CRC32 : 19..16,
    SHA2 : 15..12,
    SHA1 : 11..8,
    AES : 7..4,
    SEVL : 3..0
  }

register _ID_ISAR5 : ID_ISAR5_Type

val ID_ISAR5_read : unit -> ID_ISAR5_Type

function ID_ISAR5_read () = {
    r : ID_ISAR5_Type = _ID_ISAR5;
    r.bits[31 .. 0] = Slice(ID_ISAR5_EL1.bits, 0, 32);
    return(r)
}

val ID_ISAR5_write : ID_ISAR5_Type -> unit

function ID_ISAR5_write value_name = {
    let r : ID_ISAR5_Type = value_name;
    ID_ISAR5_EL1.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _ID_ISAR5 = r;
    return()
}

val HTCR_write : HTCR_Type -> unit

function HTCR_write value_name = {
    let r : HTCR_Type = value_name;
    TCR_EL2.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _HTCR = r;
    return()
}

type AIDR_Type = bits(32)

register _AIDR : AIDR_Type

val AIDR_read : unit -> AIDR_Type

function AIDR_read () = {
    r : AIDR_Type = _AIDR;
    r[31 .. 0] = Slice(AIDR_EL1, 0, 32);
    return(r)
}

bitfield ICC_PMR_Type : bits(32) = {Priority : 7..0}

register _ICC_PMR : ICC_PMR_Type

val ICC_PMR_read : unit -> ICC_PMR_Type

function ICC_PMR_read () = {
    r : ICC_PMR_Type = _ICC_PMR;
    r.bits[31 .. 0] = Slice(ICC_PMR_EL1.bits, 0, 32);
    return(r)
}

val ICC_PMR_write : ICC_PMR_Type -> unit

function ICC_PMR_write value_name = {
    let r : ICC_PMR_Type = value_name;
    ICC_PMR_EL1.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _ICC_PMR = r;
    return()
}

bitfield ICV_EOIR1_Type : bits(32) = {INTID : 23..0}

register _ICV_EOIR1 : ICV_EOIR1_Type

val ICV_EOIR1_read : unit -> ICV_EOIR1_Type

function ICV_EOIR1_read () = {
    r : ICV_EOIR1_Type = _ICV_EOIR1;
    r.bits[31 .. 0] = Slice(ICV_EOIR1_EL1.bits, 0, 32);
    return(r)
}

val ICV_EOIR1_write : ICV_EOIR1_Type -> unit

function ICV_EOIR1_write value_name = {
    let r : ICV_EOIR1_Type = value_name;
    ICV_EOIR1_EL1.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _ICV_EOIR1 = r;
    return()
}

bitfield ID_PFR1_Type : bits(32) =
  {
    GIC : 31..28,
    Virt_frac : 27..24,
    Sec_frac : 23..20,
    GenTimer : 19..16,
    Virtualization : 15..12,
    MProgMod : 11..8,
    Security : 7..4,
    ProgMod : 3..0
  }

register _ID_PFR1 : ID_PFR1_Type

val ID_PFR1_read : unit -> ID_PFR1_Type

function ID_PFR1_read () = {
    r : ID_PFR1_Type = _ID_PFR1;
    r.bits[31 .. 0] = Slice(ID_PFR1_EL1.bits, 0, 32);
    return(r)
}

val ID_PFR1_write : ID_PFR1_Type -> unit

function ID_PFR1_write value_name = {
    let r : ID_PFR1_Type = value_name;
    ID_PFR1_EL1.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _ID_PFR1 = r;
    return()
}

bitfield ICH_HCR_Type : bits(32) =
  {
    EOIcount : 31..27,
    TDIR : 14..14,
    TSEI : 13..13,
    TALL1 : 12..12,
    TALL0 : 11..11,
    TC : 10..10,
    vSGIEOICount : 8..8,
    VGrp1DIE : 7..7,
    VGrp1EIE : 6..6,
    VGrp0DIE : 5..5,
    VGrp0EIE : 4..4,
    NPIE : 3..3,
    LRENPIE : 2..2,
    UIE : 1..1,
    En : 0..0
  }

register _ICH_HCR : ICH_HCR_Type

val ICH_HCR_read : unit -> ICH_HCR_Type

function ICH_HCR_read () = {
    r : ICH_HCR_Type = _ICH_HCR;
    r.bits[31 .. 0] = Slice(ICH_HCR_EL2.bits, 0, 32);
    return(r)
}

val ICH_HCR_write : ICH_HCR_Type -> unit

function ICH_HCR_write value_name = {
    let r : ICH_HCR_Type = value_name;
    ICH_HCR_EL2.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _ICH_HCR = r;
    return()
}

bitfield RMR_Type : bits(32) = {RR : 1..1, AA64 : 0..0}

register _RMR : RMR_Type

val RMR_read : unit -> RMR_Type

function RMR_read () = {
    r : RMR_Type = _RMR;
    if HaveEL(EL3) then {
        r.bits[31 .. 0] = Slice(RMR_EL3.bits, 0, 32)
    } else {
        r.bits[31 .. 0] = Slice(RMR_EL1.bits, 0, 32)
    };
    return(r)
}

val RMR_write : RMR_Type -> unit

function RMR_write value_name = {
    let r : RMR_Type = value_name;
    if HaveEL(EL3) then {
        RMR_EL3.bits[31 .. 0] = Slice(r.bits, 0, 32)
    } else {
        RMR_EL1.bits[31 .. 0] = Slice(r.bits, 0, 32)
    };
    _RMR = r;
    return()
}

val HMAIR1_write : HMAIR1_Type -> unit

function HMAIR1_write value_name = {
    let r : HMAIR1_Type = value_name;
    MAIR_EL2.bits[63 .. 32] = Slice(r.bits, 0, 32);
    _HMAIR1 = r;
    return()
}

bitfield PMCEID3_Type : bits(32) =
  {
    IDhi31 : 31..31,
    IDhi30 : 30..30,
    IDhi29 : 29..29,
    IDhi28 : 28..28,
    IDhi27 : 27..27,
    IDhi26 : 26..26,
    IDhi25 : 25..25,
    IDhi24 : 24..24,
    IDhi23 : 23..23,
    IDhi22 : 22..22,
    IDhi21 : 21..21,
    IDhi20 : 20..20,
    IDhi19 : 19..19,
    IDhi18 : 18..18,
    IDhi17 : 17..17,
    IDhi16 : 16..16,
    IDhi15 : 15..15,
    IDhi14 : 14..14,
    IDhi13 : 13..13,
    IDhi12 : 12..12,
    IDhi11 : 11..11,
    IDhi10 : 10..10,
    IDhi9 : 9..9,
    IDhi8 : 8..8,
    IDhi7 : 7..7,
    IDhi6 : 6..6,
    IDhi5 : 5..5,
    IDhi4 : 4..4,
    IDhi3 : 3..3,
    IDhi2 : 2..2,
    IDhi1 : 1..1,
    IDhi0 : 0..0
  }

register _PMCEID3 : PMCEID3_Type

val PMCEID3_read : unit -> PMCEID3_Type

function PMCEID3_read () = {
    r : PMCEID3_Type = _PMCEID3;
    r.bits[31 .. 0] = Slice(PMCEID1_EL0.bits, 32, 32);
    return(r)
}

val PMCEID3_write : PMCEID3_Type -> unit

function PMCEID3_write value_name = {
    let r : PMCEID3_Type = value_name;
    PMCEID1_EL0.bits[63 .. 32] = Slice(r.bits, 0, 32);
    _PMCEID3 = r;
    return()
}

bitfield ICC_HPPIR0_Type : bits(32) = {INTID : 23..0}

register _ICC_HPPIR0 : ICC_HPPIR0_Type

val ICC_HPPIR0_read : unit -> ICC_HPPIR0_Type

function ICC_HPPIR0_read () = {
    r : ICC_HPPIR0_Type = _ICC_HPPIR0;
    r.bits[31 .. 0] = Slice(ICC_HPPIR0_EL1.bits, 0, 32);
    return(r)
}

val ICC_HPPIR0_write : ICC_HPPIR0_Type -> unit

function ICC_HPPIR0_write value_name = {
    let r : ICC_HPPIR0_Type = value_name;
    ICC_HPPIR0_EL1.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _ICC_HPPIR0 = r;
    return()
}

val TTBCR2_NS_write : TTBCR2_Type -> unit

function TTBCR2_NS_write value_name = {
    let r : TTBCR2_Type = value_name;
    TCR_EL1.bits[63 .. 32] = Slice(r.bits, 0, 32);
    _TTBCR2_NS = r;
    return()
}

val TTBCR2_write : TTBCR2_Type -> unit

function TTBCR2_write value_name = {
    let r : TTBCR2_Type = value_name;
    if ELUsingAArch32(EL3) & CurrentSecurityState() == SS_Secure then {
        TTBCR2_S = r
    } else {
        TTBCR2_NS_write() = r
    };
    return()
}

bitfield ID_ISAR4_Type : bits(32) =
  {
    SWP_frac : 31..28,
    PSR_M : 27..24,
    SynchPrim_frac : 23..20,
    Barrier : 19..16,
    SMC : 15..12,
    Writeback : 11..8,
    WithShifts : 7..4,
    Unpriv : 3..0
  }

register _ID_ISAR4 : ID_ISAR4_Type

val ID_ISAR4_read : unit -> ID_ISAR4_Type

function ID_ISAR4_read () = {
    r : ID_ISAR4_Type = _ID_ISAR4;
    r.bits[31 .. 0] = Slice(ID_ISAR4_EL1.bits, 0, 32);
    return(r)
}

val ID_ISAR4_write : ID_ISAR4_Type -> unit

function ID_ISAR4_write value_name = {
    let r : ID_ISAR4_Type = value_name;
    ID_ISAR4_EL1.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _ID_ISAR4 = r;
    return()
}

bitfield PMCEID2_Type : bits(32) =
  {
    IDhi31 : 31..31,
    IDhi30 : 30..30,
    IDhi29 : 29..29,
    IDhi28 : 28..28,
    IDhi27 : 27..27,
    IDhi26 : 26..26,
    IDhi25 : 25..25,
    IDhi24 : 24..24,
    IDhi23 : 23..23,
    IDhi22 : 22..22,
    IDhi21 : 21..21,
    IDhi20 : 20..20,
    IDhi19 : 19..19,
    IDhi18 : 18..18,
    IDhi17 : 17..17,
    IDhi16 : 16..16,
    IDhi15 : 15..15,
    IDhi14 : 14..14,
    IDhi13 : 13..13,
    IDhi12 : 12..12,
    IDhi11 : 11..11,
    IDhi10 : 10..10,
    IDhi9 : 9..9,
    IDhi8 : 8..8,
    IDhi7 : 7..7,
    IDhi6 : 6..6,
    IDhi5 : 5..5,
    IDhi4 : 4..4,
    IDhi3 : 3..3,
    IDhi2 : 2..2,
    IDhi1 : 1..1,
    IDhi0 : 0..0
  }

register _PMCEID2 : PMCEID2_Type

val PMCEID2_read : unit -> PMCEID2_Type

function PMCEID2_read () = {
    r : PMCEID2_Type = _PMCEID2;
    r.bits[31 .. 0] = Slice(PMCEID0_EL0.bits, 32, 32);
    return(r)
}

val PMCEID2_write : PMCEID2_Type -> unit

function PMCEID2_write value_name = {
    let r : PMCEID2_Type = value_name;
    PMCEID0_EL0.bits[63 .. 32] = Slice(r.bits, 0, 32);
    _PMCEID2 = r;
    return()
}

val HSR_read : unit -> HSR_Type

function HSR_read () = {
    r : HSR_Type = _HSR;
    r.bits[31 .. 0] = Slice(ESR_EL2.bits, 0, 32);
    return(r)
}

type FCSEIDR_Type = bits(32)

register FCSEIDR : FCSEIDR_Type

bitfield ID_DFR1_Type : bits(32) = {HPMN0 : 7..4, MTPMU : 3..0}

register _ID_DFR1 : ID_DFR1_Type

val ID_DFR1_read : unit -> ID_DFR1_Type

function ID_DFR1_read () = {
    r : ID_DFR1_Type = _ID_DFR1;
    r.bits[31 .. 0] = Slice(ID_DFR1_EL1.bits, 0, 32);
    return(r)
}

val ID_DFR1_write : ID_DFR1_Type -> unit

function ID_DFR1_write value_name = {
    let r : ID_DFR1_Type = value_name;
    ID_DFR1_EL1.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _ID_DFR1 = r;
    return()
}

bitfield ICH_LR_Type : bits(32) = {vINTID : 31..0}

register _ICH_LR : vector(16, ICH_LR_Type)

val ICH_LR_read : forall 'n, (0 <= 'n & 'n < 16). int('n) -> ICH_LR_Type

function ICH_LR_read n = {
    r : ICH_LR_Type = _ICH_LR[n];
    r.bits[31 .. 0] = Slice(ICH_LR_EL2[n].bits, 0, 32);
    return(r)
}

val ICH_LR_set : forall 'n, (0 <= 'n & 'n < 16). (int('n), ICH_LR_Type) -> unit

function ICH_LR_set (n, value_name) = {
    let r : ICH_LR_Type = value_name;
    ICH_LR_EL2[n].bits[31 .. 0] = Slice(r.bits, 0, 32);
    _ICH_LR[n] = r;
    return()
}

type HADFSR_Type = bits(32)

register _HADFSR : HADFSR_Type

val HADFSR_read : unit -> HADFSR_Type

function HADFSR_read () = {
    r : HADFSR_Type = _HADFSR;
    r[31 .. 0] = Slice(AFSR0_EL2, 0, 32);
    return(r)
}

val HADFSR_write : HADFSR_Type -> unit

function HADFSR_write value_name = {
    let r : HADFSR_Type = value_name;
    AFSR0_EL2[31 .. 0] = Slice(r, 0, 32);
    _HADFSR = r;
    return()
}

type JMCR_Type = bits(32)

register JMCR : JMCR_Type

val CNTKCTL_write : CNTKCTL_Type -> unit

function CNTKCTL_write value_name = {
    let r : CNTKCTL_Type = value_name;
    CNTKCTL_EL1.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _CNTKCTL = r;
    return()
}

bitfield ICV_PMR_Type : bits(32) = {Priority : 7..0}

register _ICV_PMR : ICV_PMR_Type

val ICV_PMR_read : unit -> ICV_PMR_Type

function ICV_PMR_read () = {
    r : ICV_PMR_Type = _ICV_PMR;
    r.bits[31 .. 0] = Slice(ICV_PMR_EL1.bits, 0, 32);
    return(r)
}

val ICV_PMR_write : ICV_PMR_Type -> unit

function ICV_PMR_write value_name = {
    let r : ICV_PMR_Type = value_name;
    ICV_PMR_EL1.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _ICV_PMR = r;
    return()
}

bitfield ICV_HPPIR0_Type : bits(32) = {INTID : 23..0}

register _ICV_HPPIR0 : ICV_HPPIR0_Type

val ICV_HPPIR0_read : unit -> ICV_HPPIR0_Type

function ICV_HPPIR0_read () = {
    r : ICV_HPPIR0_Type = _ICV_HPPIR0;
    r.bits[31 .. 0] = Slice(ICV_HPPIR0_EL1.bits, 0, 32);
    return(r)
}

val ICV_HPPIR0_write : ICV_HPPIR0_Type -> unit

function ICV_HPPIR0_write value_name = {
    let r : ICV_HPPIR0_Type = value_name;
    ICV_HPPIR0_EL1.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _ICV_HPPIR0 = r;
    return()
}

val DBGBCR_set : forall 'n, (0 <= 'n & 'n < 16). (int('n), DBGBCR_Type) -> unit

function DBGBCR_set (n, value_name) = {
    let r : DBGBCR_Type = value_name;
    DBGBCR_EL1[n].bits[31 .. 0] = Slice(r.bits, 0, 32);
    _DBGBCR[n] = r;
    return()
}

type DBGWFAR_Type = bits(32)

register DBGWFAR : DBGWFAR_Type

val HSCTLR_write : HSCTLR_Type -> unit

function HSCTLR_write value_name = {
    let r : HSCTLR_Type = value_name;
    SCTLR_EL2.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _HSCTLR = r;
    return()
}

val __set_HSCTLR : HSCTLR_Type -> unit

function __set_HSCTLR value_name = {
    let r : HSCTLR_Type = value_name;
    HSCTLR_write() = Mk_HSCTLR_Type(SetSlice(5, HSCTLR_read().bits, 0, Slice(r.bits, 0, 5)));
    HSCTLR_write() = Mk_HSCTLR_Type(SetSlice(1, HSCTLR_read().bits, 6, Slice(r.bits, 6, 1)));
    HSCTLR_write() = Mk_HSCTLR_Type(SetSlice(24, HSCTLR_read().bits, 8, Slice(r.bits, 8, 24)));
    if not_bool(not_bool(__IMPDEF_boolean("IMPLEMENTED_ITD"))) then {
        HSCTLR_write() = [HSCTLR_read() with ITD = r[ITD]]
    };
    if not_bool(not_bool(__IMPDEF_boolean("IMPLEMENTED_CP15BEN"))) then {
        HSCTLR_write() = [HSCTLR_read() with CP15BEN = r[CP15BEN]]
    };
    return()
}

bitfield ID_ISAR3_Type : bits(32) =
  {
    T32EE : 31..28,
    TrueNOP : 27..24,
    T32Copy : 23..20,
    TabBranch : 19..16,
    SynchPrim : 15..12,
    SVC : 11..8,
    SIMD : 7..4,
    Saturate : 3..0
  }

register _ID_ISAR3 : ID_ISAR3_Type

val ID_ISAR3_read : unit -> ID_ISAR3_Type

function ID_ISAR3_read () = {
    r : ID_ISAR3_Type = _ID_ISAR3;
    r.bits[31 .. 0] = Slice(ID_ISAR3_EL1.bits, 0, 32);
    return(r)
}

val ID_ISAR3_write : ID_ISAR3_Type -> unit

function ID_ISAR3_write value_name = {
    let r : ID_ISAR3_Type = value_name;
    ID_ISAR3_EL1.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _ID_ISAR3 = r;
    return()
}

val VTCR_write : VTCR_Type -> unit

function VTCR_write value_name = {
    let r : VTCR_Type = value_name;
    VTCR_EL2.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _VTCR = r;
    return()
}

bitfield ICC_MGRPEN1_Type : bits(32) = {EnableGrp1S : 1..1, EnableGrp1NS : 0..0}

register ICC_MGRPEN1 : ICC_MGRPEN1_Type

bitfield TLBTR_Type : bits(32) = {nU : 0..0}

register TLBTR : TLBTR_Type

type CNTFRQ_Type = bits(32)

register _CNTFRQ : CNTFRQ_Type

val CNTFRQ_read : unit -> CNTFRQ_Type

function CNTFRQ_read () = {
    r : CNTFRQ_Type = _CNTFRQ;
    r[31 .. 0] = Slice(CNTFRQ_EL0, 0, 32);
    return(r)
}

val CNTFRQ_write : CNTFRQ_Type -> unit

function CNTFRQ_write value_name = {
    let r : CNTFRQ_Type = value_name;
    CNTFRQ_EL0[31 .. 0] = Slice(r, 0, 32);
    _CNTFRQ = r;
    return()
}

bitfield PMINTENSET_Type : bits(32) =
  {
    C : 31..31,
    P30 : 30..30,
    P29 : 29..29,
    P28 : 28..28,
    P27 : 27..27,
    P26 : 26..26,
    P25 : 25..25,
    P24 : 24..24,
    P23 : 23..23,
    P22 : 22..22,
    P21 : 21..21,
    P20 : 20..20,
    P19 : 19..19,
    P18 : 18..18,
    P17 : 17..17,
    P16 : 16..16,
    P15 : 15..15,
    P14 : 14..14,
    P13 : 13..13,
    P12 : 12..12,
    P11 : 11..11,
    P10 : 10..10,
    P9 : 9..9,
    P8 : 8..8,
    P7 : 7..7,
    P6 : 6..6,
    P5 : 5..5,
    P4 : 4..4,
    P3 : 3..3,
    P2 : 2..2,
    P1 : 1..1,
    P0 : 0..0
  }

register _PMINTENSET : PMINTENSET_Type

val PMINTENSET_read : unit -> PMINTENSET_Type

function PMINTENSET_read () = {
    r : PMINTENSET_Type = _PMINTENSET;
    r.bits[31 .. 0] = Slice(PMINTENSET_EL1.bits, 0, 32);
    return(r)
}

val PMINTENSET_write : PMINTENSET_Type -> unit

function PMINTENSET_write value_name = {
    let r : PMINTENSET_Type = value_name;
    PMINTENSET_EL1.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _PMINTENSET = r;
    return()
}

bitfield DBGDEVID_Type : bits(32) =
  {
    CIDMask : 31..28,
    AuxRegs : 27..24,
    DoubleLock : 23..20,
    VirtExtns : 19..16,
    VectorCatch : 15..12,
    BPAddrMask : 11..8,
    WPAddrMask : 7..4,
    PCSample : 3..0
  }

register DBGDEVID : DBGDEVID_Type

val DFSR_NS_read : unit -> DFSR_Type

function DFSR_NS_read () = {
    r : DFSR_Type = _DFSR_NS;
    r.bits[31 .. 0] = Slice(ESR_EL1.bits, 0, 32);
    return(r)
}

val DFSR_read : unit -> DFSR_Type

function DFSR_read () = {
    r : DFSR_Type = undefined;
    if ELUsingAArch32(EL3) & CurrentSecurityState() == SS_Secure then {
        r = DFSR_S
    } else {
        r = DFSR_NS_read()
    };
    return(r)
}

bitfield DBGOSECCR_Type : bits(32) = {EDECCR : 31..0}

register _DBGOSECCR : DBGOSECCR_Type

val DBGOSECCR_read : unit -> DBGOSECCR_Type

function DBGOSECCR_read () = {
    r : DBGOSECCR_Type = _DBGOSECCR;
    r.bits[31 .. 0] = Slice(OSECCR_EL1.bits, 0, 32);
    return(r)
}

val DBGOSECCR_write : DBGOSECCR_Type -> unit

function DBGOSECCR_write value_name = {
    let r : DBGOSECCR_Type = value_name;
    OSECCR_EL1.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _DBGOSECCR = r;
    return()
}

bitfield CCSIDR2_Type : bits(32) = {NumSets : 23..0}

register _CCSIDR2 : CCSIDR2_Type

val CCSIDR2_read : unit -> CCSIDR2_Type

function CCSIDR2_read () = {
    r : CCSIDR2_Type = _CCSIDR2;
    r.bits[31 .. 0] = Slice(CCSIDR2_EL1.bits, 0, 32);
    return(r)
}

val CCSIDR2_write : CCSIDR2_Type -> unit

function CCSIDR2_write value_name = {
    let r : CCSIDR2_Type = value_name;
    CCSIDR2_EL1.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _CCSIDR2 = r;
    return()
}

bitfield CNTHV_CTL_Type : bits(32) =
  {ISTATUS : 2..2, IMASK : 1..1, ENABLE : 0..0}

register _CNTHV_CTL : CNTHV_CTL_Type

val CNTHV_CTL_read : unit -> CNTHV_CTL_Type

function CNTHV_CTL_read () = {
    r : CNTHV_CTL_Type = _CNTHV_CTL;
    r.bits[31 .. 0] = Slice(CNTHV_CTL_EL2.bits, 0, 32);
    return(r)
}

val CNTHV_CTL_write : CNTHV_CTL_Type -> unit

function CNTHV_CTL_write value_name = {
    let r : CNTHV_CTL_Type = value_name;
    CNTHV_CTL_EL2.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _CNTHV_CTL = r;
    return()
}

bitfield ICH_MISR_Type : bits(32) =
  {
    VGrp1D : 7..7,
    VGrp1E : 6..6,
    VGrp0D : 5..5,
    VGrp0E : 4..4,
    NP : 3..3,
    LRENP : 2..2,
    U : 1..1,
    EOI : 0..0
  }

register _ICH_MISR : ICH_MISR_Type

val ICH_MISR_read : unit -> ICH_MISR_Type

function ICH_MISR_read () = {
    r : ICH_MISR_Type = _ICH_MISR;
    r.bits[31 .. 0] = Slice(ICH_MISR_EL2.bits, 0, 32);
    return(r)
}

val ICH_MISR_write : ICH_MISR_Type -> unit

function ICH_MISR_write value_name = {
    let r : ICH_MISR_Type = value_name;
    ICH_MISR_EL2.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _ICH_MISR = r;
    return()
}

type ACTLR2_Type = bits(32)

register ACTLR2_S : ACTLR2_Type

register _ACTLR2_NS : ACTLR2_Type

val ACTLR2_NS_read : unit -> ACTLR2_Type

function ACTLR2_NS_read () = {
    r : ACTLR2_Type = _ACTLR2_NS;
    r[31 .. 0] = Slice(ACTLR_EL1, 32, 32);
    return(r)
}

val ACTLR2_NS_write : ACTLR2_Type -> unit

function ACTLR2_NS_write value_name = {
    let r : ACTLR2_Type = value_name;
    ACTLR_EL1[63 .. 32] = Slice(r, 0, 32);
    _ACTLR2_NS = r;
    return()
}

val ACTLR2_read : unit -> ACTLR2_Type

function ACTLR2_read () = {
    r : ACTLR2_Type = undefined;
    if ELUsingAArch32(EL3) & CurrentSecurityState() == SS_Secure then {
        r = ACTLR2_S
    } else {
        r = ACTLR2_NS_read()
    };
    return(r)
}

val ACTLR2_write : ACTLR2_Type -> unit

function ACTLR2_write value_name = {
    let r : ACTLR2_Type = value_name;
    if ELUsingAArch32(EL3) & CurrentSecurityState() == SS_Secure then {
        ACTLR2_S = r
    } else {
        ACTLR2_NS_write() = r
    };
    return()
}

val CPACR_write : CPACR_Type -> unit

function CPACR_write value_name = {
    let r : CPACR_Type = value_name;
    CPACR_EL1.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _CPACR = r;
    return()
}

val __set_CPACR : CPACR_Type -> unit

function __set_CPACR value_name = {
    let r : CPACR_Type = value_name;
    CPACR_write() = Mk_CPACR_Type(SetSlice(20, CPACR_read__1().bits, 0, Slice(r.bits, 0, 20)));
    CPACR_write() = Mk_CPACR_Type(SetSlice(8, CPACR_read__1().bits, 24, Slice(r.bits, 24, 8)));
    if not_bool(((HaveEL(EL3) & ELUsingAArch32(EL3)) & not_bool(IsCurrentSecurityState(SS_Secure))) & NSACR[cp10] == 0b0) then {
        CPACR_write() = [CPACR_read__1() with cp11 = r[cp11]]
    };
    if not_bool(((HaveEL(EL3) & ELUsingAArch32(EL3)) & not_bool(IsCurrentSecurityState(SS_Secure))) & NSACR[cp10] == 0b0) then {
        CPACR_write() = [CPACR_read__1() with cp10 = r[cp10]]
    };
    return()
}

bitfield ICV_IAR0_Type : bits(32) = {INTID : 23..0}

register _ICV_IAR0 : ICV_IAR0_Type

val ICV_IAR0_read : unit -> ICV_IAR0_Type

function ICV_IAR0_read () = {
    r : ICV_IAR0_Type = _ICV_IAR0;
    r.bits[31 .. 0] = Slice(ICV_IAR0_EL1.bits, 0, 32);
    return(r)
}

val ICV_IAR0_write : ICV_IAR0_Type -> unit

function ICV_IAR0_write value_name = {
    let r : ICV_IAR0_Type = value_name;
    ICV_IAR0_EL1.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _ICV_IAR0 = r;
    return()
}

bitfield ID_MMFR2_Type : bits(32) =
  {
    HWAccFlg : 31..28,
    WFIStall : 27..24,
    MemBarr : 23..20,
    UniTLB : 19..16,
    HvdTLB : 15..12,
    L1HvdRng : 11..8,
    L1HvdBG : 7..4,
    L1HvdFG : 3..0
  }

register _ID_MMFR2 : ID_MMFR2_Type

val ID_MMFR2_read : unit -> ID_MMFR2_Type

function ID_MMFR2_read () = {
    r : ID_MMFR2_Type = _ID_MMFR2;
    r.bits[31 .. 0] = Slice(ID_MMFR2_EL1.bits, 0, 32);
    return(r)
}

val ID_MMFR2_write : ID_MMFR2_Type -> unit

function ID_MMFR2_write value_name = {
    let r : ID_MMFR2_Type = value_name;
    ID_MMFR2_EL1.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _ID_MMFR2 = r;
    return()
}

type HAMAIR1_Type = bits(32)

register _HAMAIR1 : HAMAIR1_Type

val HAMAIR1_read : unit -> HAMAIR1_Type

function HAMAIR1_read () = {
    r : HAMAIR1_Type = _HAMAIR1;
    r[31 .. 0] = Slice(AMAIR_EL2, 32, 32);
    return(r)
}

val HAMAIR1_write : HAMAIR1_Type -> unit

function HAMAIR1_write value_name = {
    let r : HAMAIR1_Type = value_name;
    AMAIR_EL2[63 .. 32] = Slice(r, 0, 32);
    _HAMAIR1 = r;
    return()
}

bitfield ISR_Type : bits(32) = {A : 8..8, I : 7..7, F : 6..6}

register _ISR : ISR_Type

val ISR_read : unit -> ISR_Type

function ISR_read () = {
    r : ISR_Type = _ISR;
    r.bits[31 .. 0] = Slice(ISR_EL1.bits, 0, 32);
    return(r)
}

val ISR_write : ISR_Type -> unit

function ISR_write value_name = {
    let r : ISR_Type = value_name;
    ISR_EL1.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _ISR = r;
    return()
}

type HAIFSR_Type = bits(32)

register _HAIFSR : HAIFSR_Type

val HAIFSR_read : unit -> HAIFSR_Type

function HAIFSR_read () = {
    r : HAIFSR_Type = _HAIFSR;
    r[31 .. 0] = Slice(AFSR1_EL2, 0, 32);
    return(r)
}

val HAIFSR_write : HAIFSR_Type -> unit

function HAIFSR_write value_name = {
    let r : HAIFSR_Type = value_name;
    AFSR1_EL2[31 .. 0] = Slice(r, 0, 32);
    _HAIFSR = r;
    return()
}

val __set_SCTLR_S : SCTLR_Type -> unit

function __set_SCTLR_S value_name = {
    let r : SCTLR_Type = value_name;
    SCTLR_S.bits[4 .. 0] = Slice(r.bits, 0, 5);
    SCTLR_S.bits[6] = Bit(Slice(r.bits, 6, 1));
    SCTLR_S.bits[31 .. 8] = Slice(r.bits, 8, 24);
    if not_bool(not_bool(__IMPDEF_boolean("IMPLEMENTED_ITD"))) then {
        SCTLR_S[ITD] = r[ITD]
    };
    if not_bool(not_bool(__IMPDEF_boolean("IMPLEMENTED_CP15BEN"))) then {
        SCTLR_S[CP15BEN] = r[CP15BEN]
    };
    return()
}

val SCTLR_NS_write : SCTLR_Type -> unit

function SCTLR_NS_write value_name = {
    let r : SCTLR_Type = value_name;
    SCTLR_EL1.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _SCTLR_NS = r;
    return()
}

val __set_SCTLR_NS : SCTLR_Type -> unit

function __set_SCTLR_NS value_name = {
    let r : SCTLR_Type = value_name;
    SCTLR_NS_write() = Mk_SCTLR_Type(SetSlice(5, SCTLR_NS_read().bits, 0, Slice(r.bits, 0, 5)));
    SCTLR_NS_write() = Mk_SCTLR_Type(SetSlice(1, SCTLR_NS_read().bits, 6, Slice(r.bits, 6, 1)));
    SCTLR_NS_write() = Mk_SCTLR_Type(SetSlice(24, SCTLR_NS_read().bits, 8, Slice(r.bits, 8, 24)));
    if not_bool(not_bool(__IMPDEF_boolean("IMPLEMENTED_ITD"))) then {
        SCTLR_NS_write() = [SCTLR_NS_read() with ITD = r[ITD]]
    };
    if not_bool(not_bool(__IMPDEF_boolean("IMPLEMENTED_CP15BEN"))) then {
        SCTLR_NS_write() = [SCTLR_NS_read() with CP15BEN = r[CP15BEN]]
    };
    return()
}

val SCTLR_write : SCTLR_Type -> unit

function SCTLR_write value_name = {
    let r : SCTLR_Type = value_name;
    if ELUsingAArch32(EL3) & CurrentSecurityState() == SS_Secure then {
        SCTLR_S = r
    } else {
        SCTLR_NS_write() = r
    };
    return()
}

val __set_SCTLR : SCTLR_Type -> unit

function __set_SCTLR value_name = {
    let r : SCTLR_Type = value_name;
    if ELUsingAArch32(EL3) & CurrentSecurityState() == SS_Secure then {
        __set_SCTLR_S(r)
    } else {
        __set_SCTLR_NS(r)
    };
    return()
}

bitfield ID_PFR0_Type : bits(32) =
  {
    RAS : 31..28,
    DIT : 27..24,
    AMU : 23..20,
    CSV2 : 19..16,
    State3 : 15..12,
    State2 : 11..8,
    State1 : 7..4,
    State0 : 3..0
  }

register _ID_PFR0 : ID_PFR0_Type

val ID_PFR0_read : unit -> ID_PFR0_Type

function ID_PFR0_read () = {
    r : ID_PFR0_Type = _ID_PFR0;
    r.bits[31 .. 0] = Slice(ID_PFR0_EL1.bits, 0, 32);
    return(r)
}

val ID_PFR0_write : ID_PFR0_Type -> unit

function ID_PFR0_write value_name = {
    let r : ID_PFR0_Type = value_name;
    ID_PFR0_EL1.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _ID_PFR0 = r;
    return()
}

val DBGDCCINT_write : DBGDCCINT_Type -> unit

function DBGDCCINT_write value_name = {
    let r : DBGDCCINT_Type = value_name;
    MDCCINT_EL1.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _DBGDCCINT = r;
    return()
}

val __set_DBGDSCRext : DBGDSCRext_Type -> unit

function __set_DBGDSCRext value_name = {
    let r : DBGDSCRext_Type = value_name;
    DBGDSCRext_write() = Mk_DBGDSCRext_Type(SetSlice(6, DBGDSCRext_read().bits, 0, Slice(r.bits, 0, 6)));
    DBGDSCRext_write() = Mk_DBGDSCRext_Type(SetSlice(7, DBGDSCRext_read().bits, 7, Slice(r.bits, 7, 7)));
    DBGDSCRext_write() = Mk_DBGDSCRext_Type(SetSlice(1, DBGDSCRext_read().bits, 15, Slice(r.bits, 15, 1)));
    DBGDSCRext_write() = Mk_DBGDSCRext_Type(SetSlice(1, DBGDSCRext_read().bits, 20, Slice(r.bits, 20, 1)));
    DBGDSCRext_write() = Mk_DBGDSCRext_Type(SetSlice(2, DBGDSCRext_read().bits, 24, Slice(r.bits, 24, 2)));
    DBGDSCRext_write() = Mk_DBGDSCRext_Type(SetSlice(1, DBGDSCRext_read().bits, 28, Slice(r.bits, 28, 1)));
    if DBGOSLSR_read()[OSLK] == 0b1 then {
        DBGDSCRext_write() = [DBGDSCRext_read() with TFO = r[TFO]]
    };
    if DBGOSLSR_read()[OSLK] == 0b1 then {
        DBGDSCRext_write() = [DBGDSCRext_read() with RXfull = r[RXfull]]
    };
    if DBGOSLSR_read()[OSLK] == 0b1 then {
        DBGDSCRext_write() = [DBGDSCRext_read() with TXfull = r[TXfull]]
    };
    if DBGOSLSR_read()[OSLK] == 0b1 then {
        DBGDSCRext_write() = [DBGDSCRext_read() with RXO = r[RXO]]
    };
    if DBGOSLSR_read()[OSLK] == 0b1 then {
        DBGDSCRext_write() = [DBGDSCRext_read() with TXU = r[TXU]]
    };
    if DBGOSLSR_read()[OSLK] == 0b1 then {
        DBGDSCRext_write() = [DBGDSCRext_read() with INTdis = r[INTdis]]
    };
    if DBGOSLSR_read()[OSLK] == 0b1 then {
        DBGDSCRext_write() = [DBGDSCRext_read() with TDA = r[TDA]]
    };
    if DBGOSLSR_read()[OSLK] == 0b1 then {
        DBGDSCRext_write() = [DBGDSCRext_read() with SC2 = r[SC2]]
    };
    if DBGOSLSR_read()[OSLK] == 0b1 then {
        DBGDSCRext_write() = [DBGDSCRext_read() with HDE = r[HDE]]
    };
    if DBGOSLSR_read()[OSLK] == 0b1 then {
        DBGDSCRext_write() = [DBGDSCRext_read() with ERR = r[ERR]]
    };
    return()
}

val IFSR_NS_read : unit -> IFSR_Type

function IFSR_NS_read () = {
    r : IFSR_Type = _IFSR_NS;
    r.bits[31 .. 0] = Slice(IFSR32_EL2.bits, 0, 32);
    return(r)
}

val IFSR_read : unit -> IFSR_Type

function IFSR_read () = {
    r : IFSR_Type = undefined;
    if ELUsingAArch32(EL3) & CurrentSecurityState() == SS_Secure then {
        r = IFSR_S
    } else {
        r = IFSR_NS_read()
    };
    return(r)
}

val ELR_hyp_read : unit -> ELR_hyp_Type

function ELR_hyp_read () = {
    r : ELR_hyp_Type = _ELR_hyp;
    r[31 .. 0] = Slice(ELR_EL2, 0, 32);
    return(r)
}

bitfield MIDR_Type : bits(32) =
  {
    Implementer : 31..24,
    Variant : 23..20,
    Architecture : 19..16,
    PartNum : 15..4,
    Revision : 3..0
  }

register _MIDR : MIDR_Type

val MIDR_read : unit -> MIDR_Type

function MIDR_read () = {
    r : MIDR_Type = _MIDR;
    r.bits[31 .. 0] = Slice(MIDR_EL1.bits, 0, 32);
    return(r)
}

val MIDR_write : MIDR_Type -> unit

function MIDR_write value_name = {
    let r : MIDR_Type = value_name;
    MIDR_EL1.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _MIDR = r;
    return()
}

type ICC_AP0R_Type = bits(32)

register _ICC_AP0R : vector(4, ICC_AP0R_Type)

val ICC_AP0R_read : forall 'n, (0 <= 'n & 'n < 4). int('n) -> ICC_AP0R_Type

function ICC_AP0R_read n = {
    r : ICC_AP0R_Type = _ICC_AP0R[n];
    r[31 .. 0] = Slice(ICC_AP0R_EL1[n], 0, 32);
    return(r)
}

val ICC_AP0R_set : forall 'n, (0 <= 'n & 'n < 4).
  (int('n), ICC_AP0R_Type) -> unit

function ICC_AP0R_set (n, value_name) = {
    let r : ICC_AP0R_Type = value_name;
    ICC_AP0R_EL1[n][31 .. 0] = Slice(r, 0, 32);
    _ICC_AP0R[n] = r;
    return()
}

bitfield DBGDIDR_Type : bits(32) =
  {
    WRPs : 31..28,
    BRPs : 27..24,
    CTX_CMPs : 23..20,
    Version : 19..16,
    nSUHD_imp : 14..14,
    SE_imp : 12..12
  }

register DBGDIDR : DBGDIDR_Type

val __set_CNTP_CTL_S : CNTP_CTL_Type -> unit

function __set_CNTP_CTL_S value_name = {
    let r : CNTP_CTL_Type = value_name;
    CNTP_CTL_S.bits[1 .. 0] = Slice(r.bits, 0, 2);
    CNTP_CTL_S.bits[31 .. 3] = Slice(r.bits, 3, 29);
    return()
}

val __set_CNTP_CTL_NS : CNTP_CTL_Type -> unit

function __set_CNTP_CTL_NS value_name = {
    let r : CNTP_CTL_Type = value_name;
    CNTP_CTL_NS_write() = Mk_CNTP_CTL_Type(SetSlice(2, CNTP_CTL_NS_read().bits, 0, Slice(r.bits, 0, 2)));
    CNTP_CTL_NS_write() = Mk_CNTP_CTL_Type(SetSlice(29, CNTP_CTL_NS_read().bits, 3, Slice(r.bits, 3, 29)));
    return()
}

val __set_CNTP_CTL : CNTP_CTL_Type -> unit

function __set_CNTP_CTL value_name = {
    let r : CNTP_CTL_Type = value_name;
    if ELUsingAArch32(EL3) & CurrentSecurityState() == SS_Secure then {
        __set_CNTP_CTL_S(r)
    } else {
        __set_CNTP_CTL_NS(r)
    };
    return()
}

type TPIDRPRW_Type = bits(32)

register TPIDRPRW_S : TPIDRPRW_Type

register _TPIDRPRW_NS : TPIDRPRW_Type

val TPIDRPRW_NS_read : unit -> TPIDRPRW_Type

function TPIDRPRW_NS_read () = {
    r : TPIDRPRW_Type = _TPIDRPRW_NS;
    r[31 .. 0] = Slice(TPIDR_EL1, 0, 32);
    return(r)
}

val TPIDRPRW_NS_write : TPIDRPRW_Type -> unit

function TPIDRPRW_NS_write value_name = {
    let r : TPIDRPRW_Type = value_name;
    TPIDR_EL1[31 .. 0] = Slice(r, 0, 32);
    _TPIDRPRW_NS = r;
    return()
}

val TPIDRPRW_read : unit -> TPIDRPRW_Type

function TPIDRPRW_read () = {
    r : TPIDRPRW_Type = undefined;
    if ELUsingAArch32(EL3) & CurrentSecurityState() == SS_Secure then {
        r = TPIDRPRW_S
    } else {
        r = TPIDRPRW_NS_read()
    };
    return(r)
}

val TPIDRPRW_write : TPIDRPRW_Type -> unit

function TPIDRPRW_write value_name = {
    let r : TPIDRPRW_Type = value_name;
    if ELUsingAArch32(EL3) & CurrentSecurityState() == SS_Secure then {
        TPIDRPRW_S = r
    } else {
        TPIDRPRW_NS_write() = r
    };
    return()
}

val IFAR_S_read : unit -> IFAR_Type

function IFAR_S_read () = {
    r : IFAR_Type = _IFAR_S;
    if HaveEL(EL2) then {
        r[31 .. 0] = Slice(FAR_EL2, 32, 32)
    } else {
        r[31 .. 0] = Slice(HIFAR_read(), 0, 32)
    };
    return(r)
}

val IFAR_NS_read : unit -> IFAR_Type

function IFAR_NS_read () = {
    r : IFAR_Type = _IFAR_NS;
    r[31 .. 0] = Slice(FAR_EL1, 32, 32);
    return(r)
}

val IFAR_read : unit -> IFAR_Type

function IFAR_read () = {
    r : IFAR_Type = undefined;
    if ELUsingAArch32(EL3) & CurrentSecurityState() == SS_Secure then {
        r = IFAR_S_read()
    } else {
        r = IFAR_NS_read()
    };
    return(r)
}

val HTRFCR_write : HTRFCR_Type -> unit

function HTRFCR_write value_name = {
    let r : HTRFCR_Type = value_name;
    TRFCR_EL2.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _HTRFCR = r;
    return()
}

bitfield DBGDTRRXint_Type : bits(32) = {DTRRX : 31..0}

register _DBGDTRRXint : DBGDTRRXint_Type

val DBGDTRRXint_read : unit -> DBGDTRRXint_Type

function DBGDTRRXint_read () = {
    r : DBGDTRRXint_Type = _DBGDTRRXint;
    r.bits[31 .. 0] = Slice(DBGDTRRX_EL0, 0, 32);
    return(r)
}

bitfield VPIDR_Type : bits(32) =
  {
    Implementer : 31..24,
    Variant : 23..20,
    Architecture : 19..16,
    PartNum : 15..4,
    Revision : 3..0
  }

register _VPIDR : VPIDR_Type

val VPIDR_read : unit -> VPIDR_Type

function VPIDR_read () = {
    r : VPIDR_Type = _VPIDR;
    r.bits[31 .. 0] = Slice(VPIDR_EL2.bits, 0, 32);
    return(r)
}

val VPIDR_write : VPIDR_Type -> unit

function VPIDR_write value_name = {
    let r : VPIDR_Type = value_name;
    VPIDR_EL2.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _VPIDR = r;
    return()
}

bitfield PMSWINC_Type : bits(32) =
  {
    P30 : 30..30,
    P29 : 29..29,
    P28 : 28..28,
    P27 : 27..27,
    P26 : 26..26,
    P25 : 25..25,
    P24 : 24..24,
    P23 : 23..23,
    P22 : 22..22,
    P21 : 21..21,
    P20 : 20..20,
    P19 : 19..19,
    P18 : 18..18,
    P17 : 17..17,
    P16 : 16..16,
    P15 : 15..15,
    P14 : 14..14,
    P13 : 13..13,
    P12 : 12..12,
    P11 : 11..11,
    P10 : 10..10,
    P9 : 9..9,
    P8 : 8..8,
    P7 : 7..7,
    P6 : 6..6,
    P5 : 5..5,
    P4 : 4..4,
    P3 : 3..3,
    P2 : 2..2,
    P1 : 1..1,
    P0 : 0..0
  }

register _PMSWINC : PMSWINC_Type

val PMSWINC_read : unit -> PMSWINC_Type

function PMSWINC_read () = {
    r : PMSWINC_Type = _PMSWINC;
    r.bits[31 .. 0] = Slice(PMSWINC_EL0.bits, 0, 32);
    return(r)
}

val PMSWINC_write : PMSWINC_Type -> unit

function PMSWINC_write value_name = {
    let r : PMSWINC_Type = value_name;
    PMSWINC_EL0.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _PMSWINC = r;
    return()
}

val PMEVTYPER_set : forall 'n, (0 <= 'n & 'n < 31).
  (int('n), PMEVTYPER_Type) -> unit

function PMEVTYPER_set (n, value_name) = {
    let r : PMEVTYPER_Type = value_name;
    PMEVTYPER_EL0[n].bits[31 .. 0] = Slice(r.bits, 0, 32);
    _PMEVTYPER[n] = r;
    return()
}

val __get_selected_PMEVTYPER : unit -> PMEVTYPER_Type

function __get_selected_PMEVTYPER () = {
    let 'idx = UInt(PMSELR_read()[SEL]);
    assert(idx <= 30);
    return(PMEVTYPER_read(idx))
}

val __set_selected_PMEVTYPER : PMEVTYPER_Type -> unit

function __set_selected_PMEVTYPER value_name = {
    let 'idx = UInt(PMSELR_read()[SEL]);
    assert(idx <= 30);
    PMEVTYPER_set(idx) = value_name;
    return()
}

bitfield CNTV_CTL_Type : bits(32) =
  {ISTATUS : 2..2, IMASK : 1..1, ENABLE : 0..0}

register _CNTV_CTL : CNTV_CTL_Type

val CNTV_CTL_read : unit -> CNTV_CTL_Type

function CNTV_CTL_read () = {
    r : CNTV_CTL_Type = _CNTV_CTL;
    r.bits[31 .. 0] = Slice(CNTV_CTL_EL0.bits, 0, 32);
    return(r)
}

val CNTV_CTL_write : CNTV_CTL_Type -> unit

function CNTV_CTL_write value_name = {
    let r : CNTV_CTL_Type = value_name;
    CNTV_CTL_EL0.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _CNTV_CTL = r;
    return()
}

val __set_CNTV_CTL : CNTV_CTL_Type -> unit

function __set_CNTV_CTL value_name = {
    let r : CNTV_CTL_Type = value_name;
    CNTV_CTL_write() = Mk_CNTV_CTL_Type(SetSlice(2, CNTV_CTL_read().bits, 0, Slice(r.bits, 0, 2)));
    CNTV_CTL_write() = Mk_CNTV_CTL_Type(SetSlice(29, CNTV_CTL_read().bits, 3, Slice(r.bits, 3, 29)));
    return()
}

type HTPIDR_Type = bits(32)

register _HTPIDR : HTPIDR_Type

val HTPIDR_read : unit -> HTPIDR_Type

function HTPIDR_read () = {
    r : HTPIDR_Type = _HTPIDR;
    r[31 .. 0] = Slice(TPIDR_EL2, 0, 32);
    return(r)
}

val HTPIDR_write : HTPIDR_Type -> unit

function HTPIDR_write value_name = {
    let r : HTPIDR_Type = value_name;
    TPIDR_EL2[31 .. 0] = Slice(r, 0, 32);
    _HTPIDR = r;
    return()
}

val CONTEXTIDR_NS_write : CONTEXTIDR_Type -> unit

function CONTEXTIDR_NS_write value_name = {
    let r : CONTEXTIDR_Type = value_name;
    CONTEXTIDR_EL1.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _CONTEXTIDR_NS = r;
    return()
}

val CONTEXTIDR_write : CONTEXTIDR_Type -> unit

function CONTEXTIDR_write value_name = {
    let r : CONTEXTIDR_Type = value_name;
    if ELUsingAArch32(EL3) & CurrentSecurityState() == SS_Secure then {
        CONTEXTIDR_S = r
    } else {
        CONTEXTIDR_NS_write() = r
    };
    return()
}

val DFAR_S_read : unit -> DFAR_Type

function DFAR_S_read () = {
    r : DFAR_Type = _DFAR_S;
    r[31 .. 0] = Slice(HDFAR_read(), 0, 32);
    return(r)
}

val DFAR_NS_read : unit -> DFAR_Type

function DFAR_NS_read () = {
    r : DFAR_Type = _DFAR_NS;
    r[31 .. 0] = Slice(FAR_EL1, 0, 32);
    return(r)
}

val DFAR_read : unit -> DFAR_Type

function DFAR_read () = {
    r : DFAR_Type = undefined;
    if ELUsingAArch32(EL3) & CurrentSecurityState() == SS_Secure then {
        r = DFAR_S_read()
    } else {
        r = DFAR_NS_read()
    };
    return(r)
}

val PMCNTENCLR_write : PMCNTENCLR_Type -> unit

function PMCNTENCLR_write value_name = {
    let r : PMCNTENCLR_Type = value_name;
    PMCNTENCLR_EL0.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _PMCNTENCLR = r;
    return()
}

bitfield ID_ISAR2_Type : bits(32) =
  {
    Reversal : 31..28,
    PSR_AR : 27..24,
    MultU : 23..20,
    MultS : 19..16,
    Mult : 15..12,
    MultiAccessInt : 11..8,
    MemHint : 7..4,
    LoadStore : 3..0
  }

register _ID_ISAR2 : ID_ISAR2_Type

val ID_ISAR2_read : unit -> ID_ISAR2_Type

function ID_ISAR2_read () = {
    r : ID_ISAR2_Type = _ID_ISAR2;
    r.bits[31 .. 0] = Slice(ID_ISAR2_EL1.bits, 0, 32);
    return(r)
}

val ID_ISAR2_write : ID_ISAR2_Type -> unit

function ID_ISAR2_write value_name = {
    let r : ID_ISAR2_Type = value_name;
    ID_ISAR2_EL1.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _ID_ISAR2 = r;
    return()
}

val DBGOSLSR_write : DBGOSLSR_Type -> unit

function DBGOSLSR_write value_name = {
    let r : DBGOSLSR_Type = value_name;
    OSLSR_EL1.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _DBGOSLSR = r;
    return()
}

bitfield DBGDTRTXint_Type : bits(32) = {DTRTX : 31..0}

register _DBGDTRTXint : DBGDTRTXint_Type

val DBGDTRTXint_write : DBGDTRTXint_Type -> unit

function DBGDTRTXint_write value_name = {
    let r : DBGDTRTXint_Type = value_name;
    DBGDTRTX_EL0[31 .. 0] = Slice(r.bits, 0, 32);
    _DBGDTRTXint = r;
    return()
}

val TRFCR_write : TRFCR_Type -> unit

function TRFCR_write value_name = {
    let r : TRFCR_Type = value_name;
    TRFCR_EL1.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _TRFCR = r;
    return()
}

val __set_CNTHP_CTL : CNTHP_CTL_Type -> unit

function __set_CNTHP_CTL value_name = {
    let r : CNTHP_CTL_Type = value_name;
    CNTHP_CTL_write() = Mk_CNTHP_CTL_Type(SetSlice(2, CNTHP_CTL_read().bits, 0, Slice(r.bits, 0, 2)));
    CNTHP_CTL_write() = Mk_CNTHP_CTL_Type(SetSlice(29, CNTHP_CTL_read().bits, 3, Slice(r.bits, 3, 29)));
    return()
}

type AMAIR1_Type = bits(32)

register AMAIR1_S : AMAIR1_Type

register _AMAIR1_NS : AMAIR1_Type

val AMAIR1_NS_read : unit -> AMAIR1_Type

function AMAIR1_NS_read () = {
    r : AMAIR1_Type = _AMAIR1_NS;
    r[31 .. 0] = Slice(AMAIR_EL1, 32, 32);
    return(r)
}

val AMAIR1_NS_write : AMAIR1_Type -> unit

function AMAIR1_NS_write value_name = {
    let r : AMAIR1_Type = value_name;
    AMAIR_EL1[63 .. 32] = Slice(r, 0, 32);
    _AMAIR1_NS = r;
    return()
}

val AMAIR1_read : unit -> AMAIR1_Type

function AMAIR1_read () = {
    r : AMAIR1_Type = undefined;
    if ELUsingAArch32(EL3) & CurrentSecurityState() == SS_Secure then {
        r = AMAIR1_S
    } else {
        r = AMAIR1_NS_read()
    };
    return(r)
}

val AMAIR1_write : AMAIR1_Type -> unit

function AMAIR1_write value_name = {
    let r : AMAIR1_Type = value_name;
    if ELUsingAArch32(EL3) & CurrentSecurityState() == SS_Secure then {
        AMAIR1_S = r
    } else {
        AMAIR1_NS_write() = r
    };
    return()
}

bitfield CCSIDR_Type : bits(32) =
  {NumSets : 27..13, Associativity : 23..3, LineSize : 2..0}

register _CCSIDR : CCSIDR_Type

val CCSIDR_read : unit -> CCSIDR_Type

function CCSIDR_read () = {
    r : CCSIDR_Type = _CCSIDR;
    r.bits[31 .. 0] = Slice(CCSIDR_EL1.bits, 0, 32);
    return(r)
}

val CCSIDR_write : CCSIDR_Type -> unit

function CCSIDR_write value_name = {
    let r : CCSIDR_Type = value_name;
    CCSIDR_EL1.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _CCSIDR = r;
    return()
}

type DBGDEVID2_Type = bits(32)

register DBGDEVID2 : DBGDEVID2_Type

bitfield ICV_DIR_Type : bits(32) = {INTID : 23..0}

register _ICV_DIR : ICV_DIR_Type

val ICV_DIR_read : unit -> ICV_DIR_Type

function ICV_DIR_read () = {
    r : ICV_DIR_Type = _ICV_DIR;
    r.bits[31 .. 0] = Slice(ICV_DIR_EL1.bits, 0, 32);
    return(r)
}

val ICV_DIR_write : ICV_DIR_Type -> unit

function ICV_DIR_write value_name = {
    let r : ICV_DIR_Type = value_name;
    ICV_DIR_EL1.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _ICV_DIR = r;
    return()
}

bitfield MPIDR_Type : bits(32) =
  {
    M : 31..31,
    U : 30..30,
    MT : 24..24,
    Aff2 : 23..16,
    Aff1 : 15..8,
    Aff0 : 7..0
  }

register _MPIDR : MPIDR_Type

val MPIDR_read : unit -> MPIDR_Type

function MPIDR_read () = {
    r : MPIDR_Type = _MPIDR;
    r.bits[31 .. 0] = Slice(MPIDR_EL1.bits, 0, 32);
    return(r)
}

val MPIDR_write : MPIDR_Type -> unit

function MPIDR_write value_name = {
    let r : MPIDR_Type = value_name;
    MPIDR_EL1.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _MPIDR = r;
    return()
}

bitfield ICH_LRC_Type : bits(32) =
  {
    State : 31..30,
    HW : 29..29,
    Group : 28..28,
    Priority : 23..16,
    pINTID : 12..0
  }

register _ICH_LRC : vector(16, ICH_LRC_Type)

val ICH_LRC_read : forall 'n, (0 <= 'n & 'n < 16). int('n) -> ICH_LRC_Type

function ICH_LRC_read n = {
    r : ICH_LRC_Type = _ICH_LRC[n];
    r.bits[31 .. 0] = Slice(ICH_LR_EL2[n].bits, 32, 32);
    return(r)
}

val ICH_LRC_set : forall 'n, (0 <= 'n & 'n < 16).
  (int('n), ICH_LRC_Type) -> unit

function ICH_LRC_set (n, value_name) = {
    let r : ICH_LRC_Type = value_name;
    ICH_LR_EL2[n].bits[63 .. 32] = Slice(r.bits, 0, 32);
    _ICH_LRC[n] = r;
    return()
}

val MAIR1_S_write : MAIR1_Type -> unit

function MAIR1_S_write value_name = {
    let r : MAIR1_Type = value_name;
    NMRR_S.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _MAIR1_S = r;
    return()
}

val MAIR1_NS_write : MAIR1_Type -> unit

function MAIR1_NS_write value_name = {
    let r : MAIR1_Type = value_name;
    if ELUsingAArch32(EL3) then {
        NMRR_NS_write() = Mk_NMRR_Type(SetSlice(32, NMRR_NS_read().bits, 0, Slice(r.bits, 0, 32)))
    } else {
        if not_bool(HaveEL(EL3)) | not_bool(ELUsingAArch32(EL3)) then {
            MAIR_EL1.bits[63 .. 32] = Slice(r.bits, 0, 32)
        } else {
            NMRR_write() = Mk_NMRR_Type(SetSlice(32, NMRR_read().bits, 0, Slice(r.bits, 0, 32)))
        }
    };
    _MAIR1_NS = r;
    return()
}

val MAIR1_write : MAIR1_Type -> unit

function MAIR1_write value_name = {
    let r : MAIR1_Type = value_name;
    if ELUsingAArch32(EL3) & CurrentSecurityState() == SS_Secure then {
        MAIR1_S_write() = r
    } else {
        MAIR1_NS_write() = r
    };
    return()
}

bitfield ICC_HPPIR1_Type : bits(32) = {INTID : 23..0}

register _ICC_HPPIR1 : ICC_HPPIR1_Type

val ICC_HPPIR1_read : unit -> ICC_HPPIR1_Type

function ICC_HPPIR1_read () = {
    r : ICC_HPPIR1_Type = _ICC_HPPIR1;
    r.bits[31 .. 0] = Slice(ICC_HPPIR1_EL1.bits, 0, 32);
    return(r)
}

val ICC_HPPIR1_write : ICC_HPPIR1_Type -> unit

function ICC_HPPIR1_write value_name = {
    let r : ICC_HPPIR1_Type = value_name;
    ICC_HPPIR1_EL1.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _ICC_HPPIR1 = r;
    return()
}

bitfield ICC_SRE_Type : bits(32) = {DIB : 2..2, DFB : 1..1, SRE : 0..0}

register _ICC_SRE_S : ICC_SRE_Type

val ICC_SRE_S_read : unit -> ICC_SRE_Type

function ICC_SRE_S_read () = {
    r : ICC_SRE_Type = _ICC_SRE_S;
    r.bits[31 .. 0] = Slice(ICC_SRE_EL1_S.bits, 0, 32);
    return(r)
}

val ICC_SRE_S_write : ICC_SRE_Type -> unit

function ICC_SRE_S_write value_name = {
    let r : ICC_SRE_Type = value_name;
    ICC_SRE_EL1_S.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _ICC_SRE_S = r;
    return()
}

register _ICC_SRE_NS : ICC_SRE_Type

val ICC_SRE_NS_read : unit -> ICC_SRE_Type

function ICC_SRE_NS_read () = {
    r : ICC_SRE_Type = _ICC_SRE_NS;
    r.bits[31 .. 0] = Slice(ICC_SRE_EL1_NS.bits, 0, 32);
    return(r)
}

val ICC_SRE_NS_write : ICC_SRE_Type -> unit

function ICC_SRE_NS_write value_name = {
    let r : ICC_SRE_Type = value_name;
    ICC_SRE_EL1_NS.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _ICC_SRE_NS = r;
    return()
}

val ICC_SRE_read : unit -> ICC_SRE_Type

function ICC_SRE_read () = {
    r : ICC_SRE_Type = undefined;
    if ELUsingAArch32(EL3) & CurrentSecurityState() == SS_Secure then {
        r = ICC_SRE_S_read()
    } else {
        r = ICC_SRE_NS_read()
    };
    return(r)
}

val ICC_SRE_write : ICC_SRE_Type -> unit

function ICC_SRE_write value_name = {
    let r : ICC_SRE_Type = value_name;
    if ELUsingAArch32(EL3) & CurrentSecurityState() == SS_Secure then {
        ICC_SRE_S_write() = r
    } else {
        ICC_SRE_NS_write() = r
    };
    return()
}

bitfield ID_ISAR1_Type : bits(32) =
  {
    Jazelle : 31..28,
    Interwork : 27..24,
    Immediate : 23..20,
    IfThen : 19..16,
    Extend : 15..12,
    Except_AR : 11..8,
    Except : 7..4,
    Endian : 3..0
  }

register _ID_ISAR1 : ID_ISAR1_Type

val ID_ISAR1_read : unit -> ID_ISAR1_Type

function ID_ISAR1_read () = {
    r : ID_ISAR1_Type = _ID_ISAR1;
    r.bits[31 .. 0] = Slice(ID_ISAR1_EL1.bits, 0, 32);
    return(r)
}

val ID_ISAR1_write : ID_ISAR1_Type -> unit

function ID_ISAR1_write value_name = {
    let r : ID_ISAR1_Type = value_name;
    ID_ISAR1_EL1.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _ID_ISAR1 = r;
    return()
}

bitfield AMEVTYPER0_Type : bits(32) = {evtCount : 15..0}

register _AMEVTYPER0 : vector(4, AMEVTYPER0_Type)

val AMEVTYPER0_read : forall 'n, (0 <= 'n & 'n < 4). int('n) -> AMEVTYPER0_Type

function AMEVTYPER0_read n = {
    r : AMEVTYPER0_Type = _AMEVTYPER0[n];
    r.bits[31 .. 0] = Slice(AMEVTYPER0_EL0[n].bits, 0, 32);
    return(r)
}

bitfield AMUSERENR_Type : bits(32) = {EN : 0..0}

register _AMUSERENR : AMUSERENR_Type

val AMUSERENR_read : unit -> AMUSERENR_Type

function AMUSERENR_read () = {
    r : AMUSERENR_Type = _AMUSERENR;
    r.bits[31 .. 0] = Slice(AMUSERENR_EL0.bits, 0, 32);
    return(r)
}

val AMUSERENR_write : AMUSERENR_Type -> unit

function AMUSERENR_write value_name = {
    let r : AMUSERENR_Type = value_name;
    AMUSERENR_EL0.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _AMUSERENR = r;
    return()
}

bitfield AMEVTYPER1_Type : bits(32) = {evtCount : 15..0}

register _AMEVTYPER1 : vector(16, AMEVTYPER1_Type)

val AMEVTYPER1_read : forall 'n, (0 <= 'n & 'n < 16). int('n) -> AMEVTYPER1_Type

function AMEVTYPER1_read n = {
    r : AMEVTYPER1_Type = _AMEVTYPER1[n];
    r.bits[31 .. 0] = Slice(AMEVTYPER1_EL0[n].bits, 0, 32);
    return(r)
}

val AMEVTYPER1_set : forall 'n, (0 <= 'n & 'n < 16).
  (int('n), AMEVTYPER1_Type) -> unit

function AMEVTYPER1_set (n, value_name) = {
    let r : AMEVTYPER1_Type = value_name;
    AMEVTYPER1_EL0[n].bits[31 .. 0] = Slice(r.bits, 0, 32);
    _AMEVTYPER1[n] = r;
    return()
}

bitfield AMCGCR_Type : bits(32) = {CG1NC : 15..8, CG0NC : 7..0}

register _AMCGCR : AMCGCR_Type

val AMCGCR_read : unit -> AMCGCR_Type

function AMCGCR_read () = {
    r : AMCGCR_Type = _AMCGCR;
    r.bits[31 .. 0] = Slice(AMCGCR_EL0.bits, 0, 32);
    return(r)
}

val AMCGCR_write : AMCGCR_Type -> unit

function AMCGCR_write value_name = {
    let r : AMCGCR_Type = value_name;
    AMCGCR_EL0.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _AMCGCR = r;
    return()
}

bitfield AMCFGR_Type : bits(32) =
  {NCG : 31..28, HDBG : 24..24, SIZE : 13..8, N : 7..0}

register _AMCFGR : AMCFGR_Type

val AMCFGR_read : unit -> AMCFGR_Type

function AMCFGR_read () = {
    r : AMCFGR_Type = _AMCFGR;
    r.bits[31 .. 0] = Slice(AMCFGR_EL0.bits, 0, 32);
    return(r)
}

val AMCFGR_write : AMCFGR_Type -> unit

function AMCFGR_write value_name = {
    let r : AMCFGR_Type = value_name;
    AMCFGR_EL0.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _AMCFGR = r;
    return()
}

bitfield AMCNTENCLR1_Type : bits(32) =
  {
    P15 : 15..15,
    P14 : 14..14,
    P13 : 13..13,
    P12 : 12..12,
    P11 : 11..11,
    P10 : 10..10,
    P9 : 9..9,
    P8 : 8..8,
    P7 : 7..7,
    P6 : 6..6,
    P5 : 5..5,
    P4 : 4..4,
    P3 : 3..3,
    P2 : 2..2,
    P1 : 1..1,
    P0 : 0..0
  }

register _AMCNTENCLR1 : AMCNTENCLR1_Type

val AMCNTENCLR1_read : unit -> AMCNTENCLR1_Type

function AMCNTENCLR1_read () = {
    r : AMCNTENCLR1_Type = _AMCNTENCLR1;
    r.bits[31 .. 0] = Slice(AMCNTENCLR1_EL0.bits, 0, 32);
    return(r)
}

val AMCNTENCLR1_write : AMCNTENCLR1_Type -> unit

function AMCNTENCLR1_write value_name = {
    let r : AMCNTENCLR1_Type = value_name;
    AMCNTENCLR1_EL0.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _AMCNTENCLR1 = r;
    return()
}

bitfield AMCNTENSET0_Type : bits(32) =
  {P3 : 3..3, P2 : 2..2, P1 : 1..1, P0 : 0..0}

register _AMCNTENSET0 : AMCNTENSET0_Type

val AMCNTENSET0_read : unit -> AMCNTENSET0_Type

function AMCNTENSET0_read () = {
    r : AMCNTENSET0_Type = _AMCNTENSET0;
    r.bits[31 .. 0] = Slice(AMCNTENSET0_EL0.bits, 0, 32);
    return(r)
}

val AMCNTENSET0_write : AMCNTENSET0_Type -> unit

function AMCNTENSET0_write value_name = {
    let r : AMCNTENSET0_Type = value_name;
    AMCNTENSET0_EL0.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _AMCNTENSET0 = r;
    return()
}

bitfield AMCNTENCLR0_Type : bits(32) =
  {P3 : 3..3, P2 : 2..2, P1 : 1..1, P0 : 0..0}

register _AMCNTENCLR0 : AMCNTENCLR0_Type

val AMCNTENCLR0_read : unit -> AMCNTENCLR0_Type

function AMCNTENCLR0_read () = {
    r : AMCNTENCLR0_Type = _AMCNTENCLR0;
    r.bits[31 .. 0] = Slice(AMCNTENCLR0_EL0.bits, 0, 32);
    return(r)
}

val AMCNTENCLR0_write : AMCNTENCLR0_Type -> unit

function AMCNTENCLR0_write value_name = {
    let r : AMCNTENCLR0_Type = value_name;
    AMCNTENCLR0_EL0.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _AMCNTENCLR0 = r;
    return()
}

bitfield AMCNTENSET1_Type : bits(32) =
  {
    P15 : 15..15,
    P14 : 14..14,
    P13 : 13..13,
    P12 : 12..12,
    P11 : 11..11,
    P10 : 10..10,
    P9 : 9..9,
    P8 : 8..8,
    P7 : 7..7,
    P6 : 6..6,
    P5 : 5..5,
    P4 : 4..4,
    P3 : 3..3,
    P2 : 2..2,
    P1 : 1..1,
    P0 : 0..0
  }

register _AMCNTENSET1 : AMCNTENSET1_Type

val AMCNTENSET1_read : unit -> AMCNTENSET1_Type

function AMCNTENSET1_read () = {
    r : AMCNTENSET1_Type = _AMCNTENSET1;
    r.bits[31 .. 0] = Slice(AMCNTENSET1_EL0.bits, 0, 32);
    return(r)
}

val AMCNTENSET1_write : AMCNTENSET1_Type -> unit

function AMCNTENSET1_write value_name = {
    let r : AMCNTENSET1_Type = value_name;
    AMCNTENSET1_EL0.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _AMCNTENSET1 = r;
    return()
}

bitfield AMCR_Type : bits(32) = {CG1RZ : 17..17, HDBG : 10..10}

register _AMCR : AMCR_Type

val AMCR_read : unit -> AMCR_Type

function AMCR_read () = {
    r : AMCR_Type = _AMCR;
    r.bits[31 .. 0] = Slice(AMCR_EL0.bits, 0, 32);
    return(r)
}

val AMCR_write : AMCR_Type -> unit

function AMCR_write value_name = {
    let r : AMCR_Type = value_name;
    AMCR_EL0.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _AMCR = r;
    return()
}

bitfield ERRIDR_Type : bits(32) = {NUM : 15..0}

register _ERRIDR : ERRIDR_Type

val ERRIDR_read : unit -> ERRIDR_Type

function ERRIDR_read () = {
    r : ERRIDR_Type = _ERRIDR;
    r.bits[31 .. 0] = Slice(ERRIDR_EL1.bits, 0, 32);
    return(r)
}

val ERRIDR_write : ERRIDR_Type -> unit

function ERRIDR_write value_name = {
    let r : ERRIDR_Type = value_name;
    ERRIDR_EL1.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _ERRIDR = r;
    return()
}

type ERXFR2_Type = bits(32)

register _ERXFR2 : ERXFR2_Type

val ERXFR2_read : unit -> ERXFR2_Type

function ERXFR2_read () = {
    r : ERXFR2_Type = _ERXFR2;
    r[31 .. 0] = Slice(ERXFR_EL1, 32, 32);
    return(r)
}

type ERXMISC2_Type = bits(32)

register _ERXMISC2 : ERXMISC2_Type

val ERXMISC2_read : unit -> ERXMISC2_Type

function ERXMISC2_read () = {
    r : ERXMISC2_Type = _ERXMISC2;
    r[31 .. 0] = Slice(ERXMISC1_EL1, 0, 32);
    return(r)
}

val ERXMISC2_write : ERXMISC2_Type -> unit

function ERXMISC2_write value_name = {
    let r : ERXMISC2_Type = value_name;
    ERXMISC1_EL1[31 .. 0] = Slice(r, 0, 32);
    _ERXMISC2 = r;
    return()
}

type ERXFR_Type = bits(32)

register _ERXFR : ERXFR_Type

val ERXFR_read : unit -> ERXFR_Type

function ERXFR_read () = {
    r : ERXFR_Type = _ERXFR;
    r[31 .. 0] = Slice(ERXFR_EL1, 0, 32);
    return(r)
}

type ERXADDR_Type = bits(32)

register _ERXADDR : ERXADDR_Type

val ERXADDR_read : unit -> ERXADDR_Type

function ERXADDR_read () = {
    r : ERXADDR_Type = _ERXADDR;
    r[31 .. 0] = Slice(ERXADDR_EL1, 0, 32);
    return(r)
}

val ERXADDR_write : ERXADDR_Type -> unit

function ERXADDR_write value_name = {
    let r : ERXADDR_Type = value_name;
    ERXADDR_EL1[31 .. 0] = Slice(r, 0, 32);
    _ERXADDR = r;
    return()
}

type ERXMISC0_Type = bits(32)

register _ERXMISC0 : ERXMISC0_Type

val ERXMISC0_read : unit -> ERXMISC0_Type

function ERXMISC0_read () = {
    r : ERXMISC0_Type = _ERXMISC0;
    r[31 .. 0] = Slice(ERXMISC0_EL1, 0, 32);
    return(r)
}

val ERXMISC0_write : ERXMISC0_Type -> unit

function ERXMISC0_write value_name = {
    let r : ERXMISC0_Type = value_name;
    ERXMISC0_EL1[31 .. 0] = Slice(r, 0, 32);
    _ERXMISC0 = r;
    return()
}

type ERXMISC5_Type = bits(32)

register _ERXMISC5 : ERXMISC5_Type

val ERXMISC5_read : unit -> ERXMISC5_Type

function ERXMISC5_read () = {
    r : ERXMISC5_Type = _ERXMISC5;
    r[31 .. 0] = Slice(ERXMISC2_EL1, 32, 32);
    return(r)
}

val ERXMISC5_write : ERXMISC5_Type -> unit

function ERXMISC5_write value_name = {
    let r : ERXMISC5_Type = value_name;
    ERXMISC2_EL1[63 .. 32] = Slice(r, 0, 32);
    _ERXMISC5 = r;
    return()
}

bitfield ERRSELR_Type : bits(32) = {SEL : 15..0}

register _ERRSELR : ERRSELR_Type

val ERRSELR_read : unit -> ERRSELR_Type

function ERRSELR_read () = {
    r : ERRSELR_Type = _ERRSELR;
    r.bits[31 .. 0] = Slice(ERRSELR_EL1.bits, 0, 32);
    return(r)
}

val ERRSELR_write : ERRSELR_Type -> unit

function ERRSELR_write value_name = {
    let r : ERRSELR_Type = value_name;
    ERRSELR_EL1.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _ERRSELR = r;
    return()
}

type ERXCTLR2_Type = bits(32)

register _ERXCTLR2 : ERXCTLR2_Type

val ERXCTLR2_read : unit -> ERXCTLR2_Type

function ERXCTLR2_read () = {
    r : ERXCTLR2_Type = _ERXCTLR2;
    r[31 .. 0] = Slice(ERXCTLR_EL1, 32, 32);
    return(r)
}

val ERXCTLR2_write : ERXCTLR2_Type -> unit

function ERXCTLR2_write value_name = {
    let r : ERXCTLR2_Type = value_name;
    ERXCTLR_EL1[63 .. 32] = Slice(r, 0, 32);
    _ERXCTLR2 = r;
    return()
}

val DISR_read : unit -> DISR_Type

function DISR_read () = {
    r : DISR_Type = _DISR;
    r.bits[31 .. 0] = Slice(DISR_EL1.bits, 0, 32);
    return(r)
}

val VDFSR_write : VDFSR_Type -> unit

function VDFSR_write value_name = {
    let r : VDFSR_Type = value_name;
    VSESR_EL2.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _VDFSR = r;
    return()
}

type ERXMISC1_Type = bits(32)

register _ERXMISC1 : ERXMISC1_Type

val ERXMISC1_read : unit -> ERXMISC1_Type

function ERXMISC1_read () = {
    r : ERXMISC1_Type = _ERXMISC1;
    r[31 .. 0] = Slice(ERXMISC0_EL1, 32, 32);
    return(r)
}

val ERXMISC1_write : ERXMISC1_Type -> unit

function ERXMISC1_write value_name = {
    let r : ERXMISC1_Type = value_name;
    ERXMISC0_EL1[63 .. 32] = Slice(r, 0, 32);
    _ERXMISC1 = r;
    return()
}

type ERXCTLR_Type = bits(32)

register _ERXCTLR : ERXCTLR_Type

val ERXCTLR_read : unit -> ERXCTLR_Type

function ERXCTLR_read () = {
    r : ERXCTLR_Type = _ERXCTLR;
    r[31 .. 0] = Slice(ERXCTLR_EL1, 0, 32);
    return(r)
}

val ERXCTLR_write : ERXCTLR_Type -> unit

function ERXCTLR_write value_name = {
    let r : ERXCTLR_Type = value_name;
    ERXCTLR_EL1[31 .. 0] = Slice(r, 0, 32);
    _ERXCTLR = r;
    return()
}

type ERXMISC6_Type = bits(32)

register _ERXMISC6 : ERXMISC6_Type

val ERXMISC6_read : unit -> ERXMISC6_Type

function ERXMISC6_read () = {
    r : ERXMISC6_Type = _ERXMISC6;
    r[31 .. 0] = Slice(ERXMISC3_EL1, 0, 32);
    return(r)
}

val ERXMISC6_write : ERXMISC6_Type -> unit

function ERXMISC6_write value_name = {
    let r : ERXMISC6_Type = value_name;
    ERXMISC3_EL1[31 .. 0] = Slice(r, 0, 32);
    _ERXMISC6 = r;
    return()
}

type ERXMISC4_Type = bits(32)

register _ERXMISC4 : ERXMISC4_Type

val ERXMISC4_read : unit -> ERXMISC4_Type

function ERXMISC4_read () = {
    r : ERXMISC4_Type = _ERXMISC4;
    r[31 .. 0] = Slice(ERXMISC2_EL1, 0, 32);
    return(r)
}

val ERXMISC4_write : ERXMISC4_Type -> unit

function ERXMISC4_write value_name = {
    let r : ERXMISC4_Type = value_name;
    ERXMISC2_EL1[31 .. 0] = Slice(r, 0, 32);
    _ERXMISC4 = r;
    return()
}

type ERXADDR2_Type = bits(32)

register _ERXADDR2 : ERXADDR2_Type

val ERXADDR2_read : unit -> ERXADDR2_Type

function ERXADDR2_read () = {
    r : ERXADDR2_Type = _ERXADDR2;
    r[31 .. 0] = Slice(ERXADDR_EL1, 32, 32);
    return(r)
}

val ERXADDR2_write : ERXADDR2_Type -> unit

function ERXADDR2_write value_name = {
    let r : ERXADDR2_Type = value_name;
    ERXADDR_EL1[63 .. 32] = Slice(r, 0, 32);
    _ERXADDR2 = r;
    return()
}

type ERXMISC7_Type = bits(32)

register _ERXMISC7 : ERXMISC7_Type

val ERXMISC7_read : unit -> ERXMISC7_Type

function ERXMISC7_read () = {
    r : ERXMISC7_Type = _ERXMISC7;
    r[31 .. 0] = Slice(ERXMISC3_EL1, 32, 32);
    return(r)
}

val ERXMISC7_write : ERXMISC7_Type -> unit

function ERXMISC7_write value_name = {
    let r : ERXMISC7_Type = value_name;
    ERXMISC3_EL1[63 .. 32] = Slice(r, 0, 32);
    _ERXMISC7 = r;
    return()
}

type ERXMISC3_Type = bits(32)

register _ERXMISC3 : ERXMISC3_Type

val ERXMISC3_read : unit -> ERXMISC3_Type

function ERXMISC3_read () = {
    r : ERXMISC3_Type = _ERXMISC3;
    r[31 .. 0] = Slice(ERXMISC1_EL1, 32, 32);
    return(r)
}

val ERXMISC3_write : ERXMISC3_Type -> unit

function ERXMISC3_write value_name = {
    let r : ERXMISC3_Type = value_name;
    ERXMISC1_EL1[63 .. 32] = Slice(r, 0, 32);
    _ERXMISC3 = r;
    return()
}

val VDISR_read : unit -> VDISR_Type

function VDISR_read () = {
    r : VDISR_Type = _VDISR;
    r.bits[31 .. 0] = Slice(VDISR_EL2.bits, 0, 32);
    return(r)
}

type ERXSTATUS_Type = bits(32)

register _ERXSTATUS : ERXSTATUS_Type

val ERXSTATUS_read : unit -> ERXSTATUS_Type

function ERXSTATUS_read () = {
    r : ERXSTATUS_Type = _ERXSTATUS;
    r[31 .. 0] = Slice(ERXSTATUS_EL1, 0, 32);
    return(r)
}

val ERXSTATUS_write : ERXSTATUS_Type -> unit

function ERXSTATUS_write value_name = {
    let r : ERXSTATUS_Type = value_name;
    ERXSTATUS_EL1[31 .. 0] = Slice(r, 0, 32);
    _ERXSTATUS = r;
    return()
}

bitfield GICD_CTLR_Type : bits(32) =
  {
    RWP : 31..31,
    nASSGIreq : 8..8,
    E1NWF : 7..7,
    DS : 6..6,
    ARE : 4..4,
    ARE_S : 4..4,
    EnableGrp1S : 2..2,
    EnableGrp1A : 1..1,
    EnableGrp1NS : 1..1,
    EnableGrp0 : 0..0
  }

register GICD_CTLR : GICD_CTLR_Type

bitfield GICC_IAR_Type : bits(32) = {INTID : 23..0}

register GICC_IAR : GICC_IAR_Type

bitfield CTILAR_Type : bits(32) = {KEY : 31..0}

register CTILAR : CTILAR_Type

bitfield CTIPIDR2_Type : bits(32) =
  {REVISION : 7..4, JEDEC : 3..3, DES_1 : 2..0}

register CTIPIDR2 : CTIPIDR2_Type

bitfield CTICIDR1_Type : bits(32) = {CLASS : 7..4, PRMBL_1 : 3..0}

register CTICIDR1 : CTICIDR1_Type

bitfield GICH_MISR_Type : bits(32) =
  {
    VGrp1D : 7..7,
    VGrp1E : 6..6,
    VGrp0D : 5..5,
    VGrp0E : 4..4,
    NP : 3..3,
    LRENP : 2..2,
    U : 1..1,
    EOI : 0..0
  }

register GICH_MISR : GICH_MISR_Type

bitfield CTIDEVTYPE_Type : bits(32) = {SUB : 7..4, MAJOR : 3..0}

register CTIDEVTYPE : CTIDEVTYPE_Type

bitfield GITS_CTLR_Type : bits(32) =
  {
    Quiescent : 31..31,
    UMSIirq : 8..8,
    ITS_Number : 7..4,
    ImDe : 1..1,
    Enabled : 0..0
  }

register GITS_CTLR : GITS_CTLR_Type

bitfield GICR_IIDR_Type : bits(32) =
  {ProductID : 31..24, Variant : 19..16, Revision : 15..12, Implementer : 11..0}

register GICR_IIDR : GICR_IIDR_Type

bitfield EDDEVARCH_Type : bits(32) =
  {
    ARCHITECT : 31..21,
    PRESENT : 20..20,
    REVISION : 19..16,
    ARCHVER : 15..12,
    ARCHPART : 11..0
  }

register EDDEVARCH : EDDEVARCH_Type

bitfield CTIPIDR1_Type : bits(32) = {DES_0 : 7..4, PART_1 : 3..0}

register CTIPIDR1 : CTIPIDR1_Type

bitfield GICV_IAR_Type : bits(32) = {INTID : 24..0}

register GICV_IAR : GICV_IAR_Type

bitfield CNTSR_Type : bits(32) = {FCACK : 17..8, DBGH : 1..1}

register CNTSR : CNTSR_Type

bitfield EDCIDR3_Type : bits(32) = {PRMBL_3 : 7..0}

register EDCIDR3 : EDCIDR3_Type

bitfield GICM_SETSPI_NSR_Type : bits(32) = {INTID : 12..0}

register GICM_SETSPI_NSR : GICM_SETSPI_NSR_Type

bitfield GICR_WAKER_Type : bits(32) =
  {ChildrenAsleep : 2..2, ProcessorSleep : 1..1}

register GICR_WAKER : GICR_WAKER_Type

bitfield GITS_PARTIDR_Type : bits(32) = {PMG : 23..16, PARTID : 15..0}

register GITS_PARTIDR : GITS_PARTIDR_Type

bitfield GICV_HPPIR_Type : bits(32) = {INTID : 24..0}

register GICV_HPPIR : GICV_HPPIR_Type

bitfield CTIPIDR0_Type : bits(32) = {PART_0 : 7..0}

register CTIPIDR0 : CTIPIDR0_Type

bitfield GICM_SETSPI_SR_Type : bits(32) = {INTID : 12..0}

register GICM_SETSPI_SR : GICM_SETSPI_SR_Type

bitfield GICV_DIR_Type : bits(32) = {INTID : 24..0}

register GICV_DIR : GICV_DIR_Type

type CTIDEVID2_Type = bits(32)

register CTIDEVID2 : CTIDEVID2_Type

bitfield EDPIDR3_Type : bits(32) = {REVAND : 7..4, CMOD : 3..0}

register EDPIDR3 : EDPIDR3_Type

bitfield GICC_STATUSR_Type : bits(32) =
  {ASV : 4..4, WROD : 3..3, RWOD : 2..2, WRD : 1..1, RRD : 0..0}

register GICC_STATUSR : GICC_STATUSR_Type

bitfield GICM_IIDR_Type : bits(32) =
  {ProductID : 31..24, Variant : 19..16, Revision : 15..12, Implementer : 11..0}

register GICM_IIDR : GICM_IIDR_Type

val EDSCR2_write : EDSCR2_Type -> unit

function EDSCR2_write value_name = {
    let r : EDSCR2_Type = value_name;
    MDSCR_EL1.bits[63 .. 32] = Slice(r.bits, 0, 32);
    _EDSCR2 = r;
    return()
}

bitfield GICR_VSGIR_Type : bits(32) = {vPEID : 15..0}

register GICR_VSGIR : GICR_VSGIR_Type

bitfield EDDEVTYPE_Type : bits(32) = {SUB : 7..4, MAJOR : 3..0}

register EDDEVTYPE : EDDEVTYPE_Type

bitfield GICM_TYPER_Type : bits(32) =
  {Valid : 31..31, CLR : 30..30, SR : 29..29, INTID : 28..16, NumSPIs : 10..0}

register GICM_TYPER : GICM_TYPER_Type

bitfield GICD_TYPER2_Type : bits(32) =
  {nASSGIcap : 8..8, VIL : 7..7, VID : 4..0}

register GICD_TYPER2 : GICD_TYPER2_Type

bitfield GICH_EISR_Type : bits(32) =
  {
    Status15 : 15..15,
    Status14 : 14..14,
    Status13 : 13..13,
    Status12 : 12..12,
    Status11 : 11..11,
    Status10 : 10..10,
    Status9 : 9..9,
    Status8 : 8..8,
    Status7 : 7..7,
    Status6 : 6..6,
    Status5 : 5..5,
    Status4 : 4..4,
    Status3 : 3..3,
    Status2 : 2..2,
    Status1 : 1..1,
    Status0 : 0..0
  }

register GICH_EISR : GICH_EISR_Type

bitfield GICH_ELRSR_Type : bits(32) =
  {
    Status15 : 15..15,
    Status14 : 14..14,
    Status13 : 13..13,
    Status12 : 12..12,
    Status11 : 11..11,
    Status10 : 10..10,
    Status9 : 9..9,
    Status8 : 8..8,
    Status7 : 7..7,
    Status6 : 6..6,
    Status5 : 5..5,
    Status4 : 4..4,
    Status3 : 3..3,
    Status2 : 2..2,
    Status1 : 1..1,
    Status0 : 0..0
  }

register GICH_ELRSR : GICH_ELRSR_Type

bitfield GICM_CLRSPI_NSR_Type : bits(32) = {INTID : 12..0}

register GICM_CLRSPI_NSR : GICM_CLRSPI_NSR_Type

bitfield GICV_STATUSR_Type : bits(32) =
  {WROD : 3..3, RWOD : 2..2, WRD : 1..1, RRD : 0..0}

register GICV_STATUSR : GICV_STATUSR_Type

bitfield EDPIDR1_Type : bits(32) = {DES_0 : 7..4, PART_1 : 3..0}

register EDPIDR1 : EDPIDR1_Type

bitfield GICM_CLRSPI_SR_Type : bits(32) = {INTID : 12..0}

register GICM_CLRSPI_SR : GICM_CLRSPI_SR_Type

val EDECCR_write : EDECCR_Type -> unit

function EDECCR_write value_name = {
    let r : EDECCR_Type = value_name;
    OSECCR_EL1.bits[31 .. 0] = Slice(r.bits, 0, 32);
    _EDECCR = r;
    return()
}

bitfield GICV_AEOIR_Type : bits(32) = {INTID : 24..0}

register GICV_AEOIR : GICV_AEOIR_Type

bitfield GICC_PMR_Type : bits(32) = {Priority : 7..0}

register GICC_PMR : GICC_PMR_Type

bitfield GICV_ABPR_Type : bits(32) = {Binary_Point : 2..0}

register GICV_ABPR : GICV_ABPR_Type

bitfield CTIDEVARCH_Type : bits(32) =
  {ARCHITECT : 31..21, PRESENT : 20..20, REVISION : 19..16, ARCHID : 15..0}

register CTIDEVARCH : CTIDEVARCH_Type

bitfield GICR_MPAMIDR_Type : bits(32) = {PMGmax : 23..16, PARTIDmax : 15..0}

register GICR_MPAMIDR : GICR_MPAMIDR_Type

bitfield CTICIDR3_Type : bits(32) = {PRMBL_3 : 7..0}

register CTICIDR3 : CTICIDR3_Type

bitfield GICC_RPR_Type : bits(32) = {Priority : 7..0}

register GICC_RPR : GICC_RPR_Type

bitfield GICV_AIAR_Type : bits(32) = {INTID : 24..0}

register GICV_AIAR : GICV_AIAR_Type

bitfield GICV_RPR_Type : bits(32) = {Priority : 7..0}

register GICV_RPR : GICV_RPR_Type

bitfield GICV_AHPPIR_Type : bits(32) = {INTID : 24..0}

register GICV_AHPPIR : GICV_AHPPIR_Type

bitfield GICR_CTLR_Type : bits(32) =
  {
    UWP : 31..31,
    DPG1S : 26..26,
    DPG1NS : 25..25,
    DPG0 : 24..24,
    RWP : 3..3,
    IR : 2..2,
    CES : 1..1,
    EnableLPIs : 0..0
  }

register GICR_CTLR : GICR_CTLR_Type

bitfield CNTEL0ACR_Type : bits(32) =
  {EL0PTEN : 9..9, EL0VTEN : 8..8, EL0VCTEN : 1..1, EL0PCTEN : 0..0}

register CNTEL0ACR : CNTEL0ACR_Type

bitfield GICV_BPR_Type : bits(32) = {Binary_Point : 2..0}

register GICV_BPR : GICV_BPR_Type

type EDDEVID2_Type = bits(32)

register EDDEVID2 : EDDEVID2_Type

bitfield GICV_EOIR_Type : bits(32) = {INTID : 24..0}

register GICV_EOIR : GICV_EOIR_Type

bitfield CNTFID0_Type : bits(32) = {Frequency : 31..0}

register CNTFID0 : CNTFID0_Type

bitfield GICD_TYPER_Type : bits(32) =
  {
    ESPI_range : 31..27,
    RSS : 26..26,
    No1N : 25..25,
    A3V : 24..24,
    IDbits : 23..19,
    DVIS : 18..18,
    LPIS : 17..17,
    MBIS : 16..16,
    num_LPIs : 15..11,
    SecurityExtn : 10..10,
    NMI : 9..9,
    ESPI : 8..8,
    CPUNumber : 7..5,
    ITLinesNumber : 4..0
  }

register GICD_TYPER : GICD_TYPER_Type

bitfield CTICIDR0_Type : bits(32) = {PRMBL_0 : 7..0}

register CTICIDR0 : CTICIDR0_Type

bitfield GICC_HPPIR_Type : bits(32) = {INTID : 23..0}

register GICC_HPPIR : GICC_HPPIR_Type

bitfield GICD_CLRSPI_NSR_Type : bits(32) = {INTID : 12..0}

register GICD_CLRSPI_NSR : GICD_CLRSPI_NSR_Type

bitfield CTIITCTRL_Type : bits(32) = {IME : 0..0}

register CTIITCTRL : CTIITCTRL_Type

bitfield GITS_STATUSR_Type : bits(32) =
  {
    Syndrome : 9..6,
    Overflow : 5..5,
    UMSI : 4..4,
    WROD : 3..3,
    RWOD : 2..2,
    WRD : 1..1,
    RRD : 0..0
  }

register GITS_STATUSR : GITS_STATUSR_Type

bitfield GICH_VTR_Type : bits(32) =
  {
    PRIbits : 31..29,
    PREbits : 28..26,
    IDbits : 25..23,
    SEIS : 22..22,
    A3V : 21..21,
    ListRegs : 4..0
  }

register GICH_VTR : GICH_VTR_Type

bitfield CTIPIDR3_Type : bits(32) = {REVAND : 7..4, CMOD : 3..0}

register CTIPIDR3 : CTIPIDR3_Type

bitfield GICC_CTLR_Type : bits(32) =
  {
    EOImode : 9..9,
    EOImodeS : 9..9,
    IRQBypDisGrp0 : 6..6,
    FIQBypDisGrp0 : 5..5,
    CBPR : 4..4,
    FIQEn : 3..3,
    EnableGrp0 : 0..0
  }

register GICC_CTLR : GICC_CTLR_Type

bitfield EDPIDR4_Type : bits(32) = {SIZE : 7..4, DES_2 : 3..0}

register EDPIDR4 : EDPIDR4_Type

bitfield CTICONTROL_Type : bits(32) = {GLBEN : 0..0}

register CTICONTROL : CTICONTROL_Type

bitfield GICR_INMIR0_Type : bits(32) =
  {
    nmi31 : 31..31,
    nmi30 : 30..30,
    nmi29 : 29..29,
    nmi28 : 28..28,
    nmi27 : 27..27,
    nmi26 : 26..26,
    nmi25 : 25..25,
    nmi24 : 24..24,
    nmi23 : 23..23,
    nmi22 : 22..22,
    nmi21 : 21..21,
    nmi20 : 20..20,
    nmi19 : 19..19,
    nmi18 : 18..18,
    nmi17 : 17..17,
    nmi16 : 16..16,
    nmi15 : 15..15,
    nmi14 : 14..14,
    nmi13 : 13..13,
    nmi12 : 12..12,
    nmi11 : 11..11,
    nmi10 : 10..10,
    nmi9 : 9..9,
    nmi8 : 8..8,
    nmi7 : 7..7,
    nmi6 : 6..6,
    nmi5 : 5..5,
    nmi4 : 4..4,
    nmi3 : 3..3,
    nmi2 : 2..2,
    nmi1 : 1..1,
    nmi0 : 0..0
  }

register GICR_INMIR0 : GICR_INMIR0_Type

bitfield GICD_CLRSPI_SR_Type : bits(32) = {INTID : 12..0}

register GICD_CLRSPI_SR : GICD_CLRSPI_SR_Type

bitfield GICV_CTLR_Type : bits(32) =
  {
    EOImode : 9..9,
    CBPR : 4..4,
    FIQEn : 3..3,
    AckCtl : 2..2,
    EnableGrp1 : 1..1,
    EnableGrp0 : 0..0
  }

register GICV_CTLR : GICV_CTLR_Type

bitfield GICR_PARTIDR_Type : bits(32) = {PMG : 23..16, PARTID : 15..0}

register GICR_PARTIDR : GICR_PARTIDR_Type

bitfield EDDEVID1_Type : bits(32) = {HSR : 7..4, PCSROffset : 3..0}

register EDDEVID1 : EDDEVID1_Type

bitfield EDPRCR_Type : bits(32) =
  {COREPURQ : 3..3, CWRR : 1..1, CORENPDRQ : 0..0}

register EDPRCR : EDPRCR_Type

bitfield GICR_VSGIPENDR_Type : bits(32) = {Busy : 31..31, Pending : 15..0}

register GICR_VSGIPENDR : GICR_VSGIPENDR_Type

bitfield GICD_STATUSR_Type : bits(32) =
  {WROD : 3..3, RWOD : 2..2, WRD : 1..1, RRD : 0..0}

register GICD_STATUSR : GICD_STATUSR_Type

bitfield GICR_ISENABLER0_Type : bits(32) =
  {
    Set_enable_bit31 : 31..31,
    Set_enable_bit30 : 30..30,
    Set_enable_bit29 : 29..29,
    Set_enable_bit28 : 28..28,
    Set_enable_bit27 : 27..27,
    Set_enable_bit26 : 26..26,
    Set_enable_bit25 : 25..25,
    Set_enable_bit24 : 24..24,
    Set_enable_bit23 : 23..23,
    Set_enable_bit22 : 22..22,
    Set_enable_bit21 : 21..21,
    Set_enable_bit20 : 20..20,
    Set_enable_bit19 : 19..19,
    Set_enable_bit18 : 18..18,
    Set_enable_bit17 : 17..17,
    Set_enable_bit16 : 16..16,
    Set_enable_bit15 : 15..15,
    Set_enable_bit14 : 14..14,
    Set_enable_bit13 : 13..13,
    Set_enable_bit12 : 12..12,
    Set_enable_bit11 : 11..11,
    Set_enable_bit10 : 10..10,
    Set_enable_bit9 : 9..9,
    Set_enable_bit8 : 8..8,
    Set_enable_bit7 : 7..7,
    Set_enable_bit6 : 6..6,
    Set_enable_bit5 : 5..5,
    Set_enable_bit4 : 4..4,
    Set_enable_bit3 : 3..3,
    Set_enable_bit2 : 2..2,
    Set_enable_bit1 : 1..1,
    Set_enable_bit0 : 0..0
  }

register GICR_ISENABLER0 : GICR_ISENABLER0_Type

bitfield CTICIDR2_Type : bits(32) = {PRMBL_2 : 7..0}

register CTICIDR2 : CTICIDR2_Type

bitfield EDRCR_Type : bits(32) = {CBRRQ : 4..4, CSPA : 3..3, CSE : 2..2}

register EDRCR : EDRCR_Type

bitfield GICV_PMR_Type : bits(32) = {Priority : 7..0}

register GICV_PMR : GICV_PMR_Type

bitfield EDDEVID_Type : bits(32) =
  {AuxRegs : 27..24, DebugPower : 7..4, PCSample : 3..0}

register EDDEVID : EDDEVID_Type

bitfield GICC_DIR_Type : bits(32) = {INTID : 23..0}

register GICC_DIR : GICC_DIR_Type

bitfield EDCIDR0_Type : bits(32) = {PRMBL_0 : 7..0}

register EDCIDR0 : EDCIDR0_Type

bitfield GITS_MPAMIDR_Type : bits(32) = {PMGmax : 23..16, PARTIDmax : 15..0}

register GITS_MPAMIDR : GITS_MPAMIDR_Type

bitfield GICD_SGIR_Type : bits(32) =
  {
    TargetListFilter : 25..24,
    CPUTargetList : 23..16,
    NSATT : 15..15,
    INTID : 3..0
  }

register GICD_SGIR : GICD_SGIR_Type

bitfield GICH_VMCR_Type : bits(32) =
  {
    VPMR : 31..24,
    VBPR0 : 23..21,
    VBPR1 : 20..18,
    VEOIM : 9..9,
    VCBPR : 4..4,
    VFIQEn : 3..3,
    VAckCtl : 2..2,
    VENG1 : 1..1,
    VENG0 : 0..0
  }

register GICH_VMCR : GICH_VMCR_Type

bitfield EDLAR_Type : bits(32) = {KEY : 31..0}

register EDLAR : EDLAR_Type

bitfield GICC_AEOIR_Type : bits(32) = {INTID : 23..0}

register GICC_AEOIR : GICC_AEOIR_Type

bitfield GICC_AHPPIR_Type : bits(32) = {INTID : 23..0}

register GICC_AHPPIR : GICC_AHPPIR_Type

bitfield GICR_SYNCR_Type : bits(32) = {Busy : 0..0}

register GICR_SYNCR : GICR_SYNCR_Type

bitfield GICC_ABPR_Type : bits(32) = {Binary_Point : 2..0}

register GICC_ABPR : GICC_ABPR_Type

bitfield CTIPIDR4_Type : bits(32) = {SIZE : 7..4, DES_2 : 3..0}

register CTIPIDR4 : CTIPIDR4_Type

type CTIDEVID1_Type = bits(32)

register CTIDEVID1 : CTIDEVID1_Type

bitfield GITS_MPIDR_Type : bits(32) =
  {Aff3 : 31..24, Aff2 : 23..16, Aff1 : 15..8}

register GITS_MPIDR : GITS_MPIDR_Type

bitfield EDCIDR2_Type : bits(32) = {PRMBL_2 : 7..0}

register EDCIDR2 : EDCIDR2_Type

bitfield GICD_SETSPI_NSR_Type : bits(32) = {INTID : 12..0}

register GICD_SETSPI_NSR : GICD_SETSPI_NSR_Type

bitfield CNTID_Type : bits(32) = {CNTSC : 3..0}

register CNTID : CNTID_Type

bitfield GITS_IIDR_Type : bits(32) =
  {ProductID : 31..24, Variant : 19..16, Revision : 15..12, Implementer : 11..0}

register GITS_IIDR : GITS_IIDR_Type

bitfield EDPIDR0_Type : bits(32) = {PART_0 : 7..0}

register EDPIDR0 : EDPIDR0_Type

bitfield CTIAUTHSTATUS_Type : bits(32) = {NSNID : 3..2, NSID : 1..0}

register CTIAUTHSTATUS : CTIAUTHSTATUS_Type

bitfield GICH_HCR_Type : bits(32) =
  {
    EOICount : 31..27,
    VGrp1DIE : 7..7,
    VGrp1EIE : 6..6,
    VGrp0DIE : 5..5,
    VGrp0EIE : 4..4,
    NPIE : 3..3,
    LRENPIE : 2..2,
    UIE : 1..1,
    En : 0..0
  }

register GICH_HCR : GICH_HCR_Type

bitfield GICC_BPR_Type : bits(32) = {Binary_Point : 2..0}

register GICC_BPR : GICC_BPR_Type

bitfield CTIDEVID_Type : bits(32) =
  {INOUT : 25..24, NUMCHAN : 21..16, NUMTRIG : 13..8, EXTMUXNUM : 4..0}

register CTIDEVID : CTIDEVID_Type

bitfield GICD_SETSPI_SR_Type : bits(32) = {INTID : 12..0}

register GICD_SETSPI_SR : GICD_SETSPI_SR_Type

bitfield GICR_STATUSR_Type : bits(32) =
  {WROD : 3..3, RWOD : 2..2, WRD : 1..1, RRD : 0..0}

register GICR_STATUSR : GICR_STATUSR_Type

bitfield GICC_EOIR_Type : bits(32) = {INTID : 23..0}

register GICC_EOIR : GICC_EOIR_Type

bitfield EDPIDR2_Type : bits(32) = {REVISION : 7..4, JEDEC : 3..3, DES_1 : 2..0}

register EDPIDR2 : EDPIDR2_Type

bitfield CNTNSAR_Type : bits(32) =
  {
    NS7 : 7..7,
    NS6 : 6..6,
    NS5 : 5..5,
    NS4 : 4..4,
    NS3 : 3..3,
    NS2 : 2..2,
    NS1 : 1..1,
    NS0 : 0..0
  }

register CNTNSAR : CNTNSAR_Type

bitfield EDITCTRL_Type : bits(32) = {IME : 0..0}

register EDITCTRL : EDITCTRL_Type

bitfield GICD_IIDR_Type : bits(32) =
  {ProductID : 31..24, Variant : 19..16, Revision : 15..12, Implementer : 11..0}

register GICD_IIDR : GICD_IIDR_Type

bitfield EDCIDR1_Type : bits(32) = {CLASS : 7..4, PRMBL_1 : 3..0}

register EDCIDR1 : EDCIDR1_Type

bitfield GICC_AIAR_Type : bits(32) = {INTID : 23..0}

register GICC_AIAR : GICC_AIAR_Type

bitfield AMPIDR2_Type : bits(32) = {REVISION : 7..4, JEDEC : 3..3, DES_1 : 2..0}

register AMPIDR2 : AMPIDR2_Type

bitfield AMPIDR4_Type : bits(32) = {SIZE : 7..4, DES_2 : 3..0}

register AMPIDR4 : AMPIDR4_Type

bitfield AMIIDR_Type : bits(32) =
  {ProductID : 31..20, Variant : 19..16, Revision : 15..12, Implementer : 11..0}

register AMIIDR : AMIIDR_Type

bitfield AMPIDR3_Type : bits(32) = {REVAND : 7..4, CMOD : 3..0}

register AMPIDR3 : AMPIDR3_Type

bitfield AMCIDR3_Type : bits(32) = {PRMBL_3 : 7..0}

register AMCIDR3 : AMCIDR3_Type

bitfield AMDEVARCH_Type : bits(32) =
  {ARCHITECT : 31..21, PRESENT : 20..20, REVISION : 19..16, ARCHID : 15..0}

register AMDEVARCH : AMDEVARCH_Type

bitfield AMPIDR0_Type : bits(32) = {PART_0 : 7..0}

register AMPIDR0 : AMPIDR0_Type

bitfield AMCIDR2_Type : bits(32) = {PRMBL_2 : 7..0}

register AMCIDR2 : AMCIDR2_Type

bitfield AMCIDR0_Type : bits(32) = {PRMBL_0 : 7..0}

register AMCIDR0 : AMCIDR0_Type

bitfield AMPIDR1_Type : bits(32) = {DES_0 : 7..4, PART_1 : 3..0}

register AMPIDR1 : AMPIDR1_Type

bitfield AMCIDR1_Type : bits(32) = {CLASS : 7..4, PRMBL_1 : 3..0}

register AMCIDR1 : AMCIDR1_Type

bitfield AMDEVTYPE_Type : bits(32) = {SUB : 7..4, MAJOR : 3..0}

register AMDEVTYPE : AMDEVTYPE_Type

type HACTLR2_Type = bits(32)

register _HACTLR2 : HACTLR2_Type

val HACTLR2_read : unit -> HACTLR2_Type

function HACTLR2_read () = {
    r : HACTLR2_Type = _HACTLR2;
    r[31 .. 0] = Slice(ACTLR_EL2, 32, 32);
    return(r)
}

val HACTLR2_write : HACTLR2_Type -> unit

function HACTLR2_write value_name = {
    let r : HACTLR2_Type = value_name;
    ACTLR_EL2[63 .. 32] = Slice(r, 0, 32);
    _HACTLR2 = r;
    return()
}

bitfield PMAUTHSTATUS_Type : bits(32) =
  {
    RTNID : 27..26,
    RTID : 25..24,
    RLNID : 15..14,
    RLID : 13..12,
    SNID : 7..6,
    SID : 5..4,
    NSNID : 3..2,
    NSID : 1..0
  }

register PMAUTHSTATUS : PMAUTHSTATUS_Type

bitfield PMCGCR0_Type : bits(32) = {CG1NC : 15..8, CG0NC : 7..0}

register PMCGCR0 : PMCGCR0_Type

bitfield PMCIDR0_Type : bits(32) = {PRMBL_0 : 7..0}

register PMCIDR0 : PMCIDR0_Type

bitfield PMCIDR1_Type : bits(32) = {CLASS : 7..4, PRMBL_1 : 3..0}

register PMCIDR1 : PMCIDR1_Type

bitfield PMCIDR2_Type : bits(32) = {PRMBL_2 : 7..0}

register PMCIDR2 : PMCIDR2_Type

bitfield PMCIDR3_Type : bits(32) = {PRMBL_3 : 7..0}

register PMCIDR3 : PMCIDR3_Type

bitfield PMDEVID_Type : bits(32) = {PMSS : 7..4, PCSample : 3..0}

register PMDEVID : PMDEVID_Type

bitfield PMDEVTYPE_Type : bits(32) = {SUB : 7..4, MAJOR : 3..0}

register PMDEVTYPE : PMDEVTYPE_Type

bitfield PMITCTRL_Type : bits(32) = {IME : 0..0}

register PMITCTRL : PMITCTRL_Type

bitfield PMLAR_Type : bits(32) = {KEY : 31..0}

register PMLAR : PMLAR_Type

bitfield PMPIDR0_Type : bits(32) = {PART_0 : 7..0}

register PMPIDR0 : PMPIDR0_Type

bitfield PMPIDR1_Type : bits(32) = {DES_0 : 7..4, PART_1 : 3..0}

register PMPIDR1 : PMPIDR1_Type

bitfield PMPIDR2_Type : bits(32) = {REVISION : 7..4, JEDEC : 3..3, DES_1 : 2..0}

register PMPIDR2 : PMPIDR2_Type

bitfield PMPIDR3_Type : bits(32) = {REVAND : 7..4, CMOD : 3..0}

register PMPIDR3 : PMPIDR3_Type

bitfield PMPIDR4_Type : bits(32) = {SIZE : 7..4, DES_2 : 3..0}

register PMPIDR4 : PMPIDR4_Type

val TTBR1_EL1_write : TTBR1_EL1_Type -> unit

function TTBR1_EL1_write value_name = {
    let r : TTBR1_EL1_Type = value_name;
    TTBR1_write() = Mk_TTBR1_Type(SetSlice(64, TTBR1_read().bits, 0, Slice(r.bits, 0, 64)));
    _TTBR1_EL1 = r;
    return()
}

val TTBR0_EL2_write : TTBR0_EL2_Type -> unit

function TTBR0_EL2_write value_name = {
    let r : TTBR0_EL2_Type = value_name;
    HTTBR.bits[47 .. 1] = Slice(r.bits, 1, 47);
    _TTBR0_EL2 = r;
    return()
}

val VTTBR_EL2_write : VTTBR_EL2_Type -> unit

function VTTBR_EL2_write value_name = {
    let r : VTTBR_EL2_Type = value_name;
    VTTBR.bits[63 .. 0] = Slice(r.bits, 0, 64);
    _VTTBR_EL2 = r;
    return()
}

val TTBR0_EL1_write : TTBR0_EL1_Type -> unit

function TTBR0_EL1_write value_name = {
    let r : TTBR0_EL1_Type = value_name;
    TTBR0_write() = Mk_TTBR0_Type(SetSlice(64, TTBR0_read().bits, 0, Slice(r.bits, 0, 64)));
    _TTBR0_EL1 = r;
    return()
}

val __get_ID_AA64MMFR2_EL1 : ID_AA64MMFR2_EL1_Type -> ID_AA64MMFR2_EL1_Type

function __get_ID_AA64MMFR2_EL1 value_name = {
    tmp : ID_AA64MMFR2_EL1_Type = value_name;
    let tmp : ID_AA64MMFR2_EL1_Type = Mk_ID_AA64MMFR2_EL1_Type(tmp.bits & not_vec(ZeroExtend(0xf00000000000, 64)));
    return(tmp)
}

val __get_VTCR_EL2 : VTCR_EL2_Type -> VTCR_EL2_Type

function __get_VTCR_EL2 value_name = {
    tmp : VTCR_EL2_Type = value_name;
    let tmp : VTCR_EL2_Type = Mk_VTCR_EL2_Type(tmp.bits & not_vec(0xffffec8001900000) | ZeroExtend(0x80000000, 64));
    return(tmp)
}

val __get_HDFGRTR_EL2 : HDFGRTR_EL2_Type -> HDFGRTR_EL2_Type

function __get_HDFGRTR_EL2 value_name = {
    tmp : HDFGRTR_EL2_Type = value_name;
    let tmp : HDFGRTR_EL2_Type = Mk_HDFGRTR_EL2_Type(tmp.bits & not_vec(ZeroExtend(0x1fe04c000300100, 64)));
    return(tmp)
}

val __get_ICV_NMIAR1_EL1 : ICV_NMIAR1_EL1_Type -> ICV_NMIAR1_EL1_Type

function __get_ICV_NMIAR1_EL1 value_name = {
    tmp : ICV_NMIAR1_EL1_Type = value_name;
    let tmp : ICV_NMIAR1_EL1_Type = Mk_ICV_NMIAR1_EL1_Type(tmp.bits & not_vec(0xffffffffff000000));
    return(tmp)
}

val __get_SPSR_abt : SPSR_abt_Type -> SPSR_abt_Type

function __get_SPSR_abt value_name = {
    tmp : SPSR_abt_Type = value_name;
    let tmp : SPSR_abt_Type = Mk_SPSR_abt_Type(tmp.bits & not_vec(0xffffffff00000000));
    return(tmp)
}

val __get_ICH_LR_EL2 : ICH_LR_EL2_Type -> ICH_LR_EL2_Type

function __get_ICH_LR_EL2 value_name = {
    tmp : ICH_LR_EL2_Type = value_name;
    let tmp : ICH_LR_EL2_Type = Mk_ICH_LR_EL2_Type(tmp.bits & not_vec(ZeroExtend(0x700e00000000000, 64)));
    return(tmp)
}

val __get_MDCCINT_EL1 : MDCCINT_EL1_Type -> MDCCINT_EL1_Type

function __get_MDCCINT_EL1 value_name = {
    tmp : MDCCINT_EL1_Type = value_name;
    let tmp : MDCCINT_EL1_Type = Mk_MDCCINT_EL1_Type(tmp.bits & not_vec(0xffffffff9fffffff));
    return(tmp)
}

val __get_ICC_HPPIR1_EL1 : ICC_HPPIR1_EL1_Type -> ICC_HPPIR1_EL1_Type

function __get_ICC_HPPIR1_EL1 value_name = {
    tmp : ICC_HPPIR1_EL1_Type = value_name;
    let tmp : ICC_HPPIR1_EL1_Type = Mk_ICC_HPPIR1_EL1_Type(tmp.bits & not_vec(0xffffffffff000000));
    return(tmp)
}

val __get_ICC_AP0R_EL1 : ICC_AP0R_EL1_Type -> ICC_AP0R_EL1_Type

function __get_ICC_AP0R_EL1 value_name = {
    tmp : ICC_AP0R_EL1_Type = value_name;
    let tmp : ICC_AP0R_EL1_Type = tmp & not_vec(0xffffffff00000000);
    return(tmp)
}

val __get_TCR2_EL2 : TCR2_EL2_Type -> TCR2_EL2_Type

function __get_TCR2_EL2 value_name = {
    tmp : TCR2_EL2_Type = value_name;
    let tmp : TCR2_EL2_Type = Mk_TCR2_EL2_Type(tmp.bits & not_vec(0xffffffffffff0000));
    return(tmp)
}

val __get_ESR_EL1 : ESR_EL1_Type -> ESR_EL1_Type

function __get_ESR_EL1 value_name = {
    tmp : ESR_EL1_Type = value_name;
    let tmp : ESR_EL1_Type = Mk_ESR_EL1_Type(tmp.bits & not_vec(0xfffff88000000000));
    return(tmp)
}

val __get_ICV_BPR1_EL1 : ICV_BPR1_EL1_Type -> ICV_BPR1_EL1_Type

function __get_ICV_BPR1_EL1 value_name = {
    tmp : ICV_BPR1_EL1_Type = value_name;
    let tmp : ICV_BPR1_EL1_Type = Mk_ICV_BPR1_EL1_Type(tmp.bits & not_vec(0xfffffffffffffff8));
    return(tmp)
}

val __get_TCR_EL3 : TCR_EL3_Type -> TCR_EL3_Type

function __get_TCR_EL3 value_name = {
    tmp : TCR_EL3_Type = value_name;
    let tmp : TCR_EL3_Type = Mk_TCR_EL3_Type(tmp.bits & not_vec(0xfffff180000800c0) | ZeroExtend(0x80800000, 64));
    return(tmp)
}

val __get_PMECR_EL1 : PMECR_EL1_Type -> PMECR_EL1_Type

function __get_PMECR_EL1 value_name = {
    tmp : PMECR_EL1_Type = value_name;
    let tmp : PMECR_EL1_Type = Mk_PMECR_EL1_Type(tmp.bits & not_vec(0xffffffffffffffe0));
    return(tmp)
}

val __get_ICC_PMR_EL1 : ICC_PMR_EL1_Type -> ICC_PMR_EL1_Type

function __get_ICC_PMR_EL1 value_name = {
    tmp : ICC_PMR_EL1_Type = value_name;
    let tmp : ICC_PMR_EL1_Type = Mk_ICC_PMR_EL1_Type(tmp.bits & not_vec(0xffffffffffffff00));
    return(tmp)
}

val __get_RMR_EL1 : RMR_EL1_Type -> RMR_EL1_Type

function __get_RMR_EL1 value_name = {
    tmp : RMR_EL1_Type = value_name;
    let tmp : RMR_EL1_Type = Mk_RMR_EL1_Type(tmp.bits & not_vec(0xfffffffffffffffc));
    return(tmp)
}

val __get_PMICFILTR_EL0 : PMICFILTR_EL0_Type -> PMICFILTR_EL0_Type

function __get_PMICFILTR_EL0 value_name = {
    tmp : PMICFILTR_EL0_Type = value_name;
    let tmp : PMICFILTR_EL0_Type = Mk_PMICFILTR_EL0_Type(tmp.bits & not_vec(0xfbffffff020f0000));
    return(tmp)
}

val __get_ICC_HPPIR0_EL1 : ICC_HPPIR0_EL1_Type -> ICC_HPPIR0_EL1_Type

function __get_ICC_HPPIR0_EL1 value_name = {
    tmp : ICC_HPPIR0_EL1_Type = value_name;
    let tmp : ICC_HPPIR0_EL1_Type = Mk_ICC_HPPIR0_EL1_Type(tmp.bits & not_vec(0xffffffffff000000));
    return(tmp)
}

val __get_CNTHPS_CTL_EL2 : CNTHPS_CTL_EL2_Type -> CNTHPS_CTL_EL2_Type

function __get_CNTHPS_CTL_EL2 value_name = {
    tmp : CNTHPS_CTL_EL2_Type = value_name;
    let tmp : CNTHPS_CTL_EL2_Type = Mk_CNTHPS_CTL_EL2_Type(tmp.bits & not_vec(0xfffffffffffffff8));
    return(tmp)
}

val __get_VMECID_A_EL2 : VMECID_A_EL2_Type -> VMECID_A_EL2_Type

function __get_VMECID_A_EL2 value_name = {
    tmp : VMECID_A_EL2_Type = value_name;
    let tmp : VMECID_A_EL2_Type = Mk_VMECID_A_EL2_Type(tmp.bits & not_vec(0xffffffffffff0000));
    return(tmp)
}

val __get_MECID_RL_A_EL3 : MECID_RL_A_EL3_Type -> MECID_RL_A_EL3_Type

function __get_MECID_RL_A_EL3 value_name = {
    tmp : MECID_RL_A_EL3_Type = value_name;
    let tmp : MECID_RL_A_EL3_Type = Mk_MECID_RL_A_EL3_Type(tmp.bits & not_vec(0xffffffffffff0000));
    return(tmp)
}

val __get_HSTR_EL2 : HSTR_EL2_Type -> HSTR_EL2_Type

function __get_HSTR_EL2 value_name = {
    tmp : HSTR_EL2_Type = value_name;
    let tmp : HSTR_EL2_Type = Mk_HSTR_EL2_Type(tmp.bits & not_vec(0xffffffffffff4010));
    return(tmp)
}

val __get_PMOVSCLR_EL0 : PMOVSCLR_EL0_Type -> PMOVSCLR_EL0_Type

function __get_PMOVSCLR_EL0 value_name = {
    tmp : PMOVSCLR_EL0_Type = value_name;
    let tmp : PMOVSCLR_EL0_Type = Mk_PMOVSCLR_EL0_Type(tmp.bits & not_vec(0xfffffffe00000000));
    return(tmp)
}

val __get_HAFGRTR_EL2 : HAFGRTR_EL2_Type -> HAFGRTR_EL2_Type

function __get_HAFGRTR_EL2 value_name = {
    tmp : HAFGRTR_EL2_Type = value_name;
    let tmp : HAFGRTR_EL2_Type = Mk_HAFGRTR_EL2_Type(tmp.bits & not_vec(0xfffc00000001ffe0));
    return(tmp)
}

val __get_ICC_BPR0_EL1 : ICC_BPR0_EL1_Type -> ICC_BPR0_EL1_Type

function __get_ICC_BPR0_EL1 value_name = {
    tmp : ICC_BPR0_EL1_Type = value_name;
    let tmp : ICC_BPR0_EL1_Type = Mk_ICC_BPR0_EL1_Type(tmp.bits & not_vec(0xfffffffffffffff8));
    return(tmp)
}

val __get_ACCDATA_EL1 : ACCDATA_EL1_Type -> ACCDATA_EL1_Type

function __get_ACCDATA_EL1 value_name = {
    tmp : ACCDATA_EL1_Type = value_name;
    let tmp : ACCDATA_EL1_Type = Mk_ACCDATA_EL1_Type(tmp.bits & not_vec(0xffffffff00000000));
    return(tmp)
}

val __get_OSDLR_EL1 : OSDLR_EL1_Type -> OSDLR_EL1_Type

function __get_OSDLR_EL1 value_name = {
    tmp : OSDLR_EL1_Type = value_name;
    if not_bool(IsFeatureImplemented(FEAT_DoubleLock)) then {
        tmp = Mk_OSDLR_EL1_Type(tmp.bits & not_vec(ZeroExtend(0x1, 64)))
    };
    let tmp : OSDLR_EL1_Type = Mk_OSDLR_EL1_Type(tmp.bits & not_vec(0xfffffffffffffffe));
    return(tmp)
}

val __get_SCTLR_EL1 : SCTLR_EL1_Type -> SCTLR_EL1_Type

function __get_SCTLR_EL1 value_name = {
    tmp : SCTLR_EL1_Type = value_name;
    tmp : SCTLR_EL1_Type = Mk_SCTLR_EL1_Type(tmp.bits & not_vec(ZeroExtend(0x400020000, 64)));
    if not_bool(__IMPDEF_boolean("IMPLEMENTED_CP15BEN")) then {
        tmp = Mk_SCTLR_EL1_Type(tmp.bits & not_vec(ZeroExtend(0x0, 64)) | ZeroExtend(0x20, 64))
    };
    if not_bool(__IMPDEF_boolean("IMPLEMENTED_ITD")) then {
        tmp = Mk_SCTLR_EL1_Type(tmp.bits & not_vec(ZeroExtend(0x80, 64)))
    };
    return(tmp)
}

val __get_PMSSCR_EL1 : PMSSCR_EL1_Type -> PMSSCR_EL1_Type

function __get_PMSSCR_EL1 value_name = {
    tmp : PMSSCR_EL1_Type = value_name;
    let tmp : PMSSCR_EL1_Type = Mk_PMSSCR_EL1_Type(tmp.bits & not_vec(0xfffffffefffffffe));
    return(tmp)
}

val __get_LORID_EL1 : LORID_EL1_Type -> LORID_EL1_Type

function __get_LORID_EL1 value_name = {
    tmp : LORID_EL1_Type = value_name;
    let tmp : LORID_EL1_Type = Mk_LORID_EL1_Type(tmp.bits & not_vec(0xffffffffff00ff00));
    return(tmp)
}

val __get_CONTEXTIDR_EL2 : CONTEXTIDR_EL2_Type -> CONTEXTIDR_EL2_Type

function __get_CONTEXTIDR_EL2 value_name = {
    tmp : CONTEXTIDR_EL2_Type = value_name;
    let tmp : CONTEXTIDR_EL2_Type = Mk_CONTEXTIDR_EL2_Type(tmp.bits & not_vec(0xffffffff00000000));
    return(tmp)
}

val __get_FPSR : FPSR_Type -> FPSR_Type

function __get_FPSR value_name = {
    tmp : FPSR_Type = value_name;
    let tmp : FPSR_Type = Mk_FPSR_Type(tmp.bits & not_vec(0xffffffff07ffff60));
    return(tmp)
}

val __get_CNTP_TVAL_EL0 : CNTP_TVAL_EL0_Type -> CNTP_TVAL_EL0_Type

function __get_CNTP_TVAL_EL0 value_name = {
    tmp : CNTP_TVAL_EL0_Type = value_name;
    let tmp : CNTP_TVAL_EL0_Type = Mk_CNTP_TVAL_EL0_Type(tmp.bits & not_vec(0xffffffff00000000));
    return(tmp)
}

val __get_ID_AA64MMFR4_EL1 : ID_AA64MMFR4_EL1_Type -> ID_AA64MMFR4_EL1_Type

function __get_ID_AA64MMFR4_EL1 value_name = {
    tmp : ID_AA64MMFR4_EL1_Type = value_name;
    let tmp : ID_AA64MMFR4_EL1_Type = Mk_ID_AA64MMFR4_EL1_Type(tmp.bits & not_vec(0xffffffffffffff0f));
    return(tmp)
}

val __get_ICH_EISR_EL2 : ICH_EISR_EL2_Type -> ICH_EISR_EL2_Type

function __get_ICH_EISR_EL2 value_name = {
    tmp : ICH_EISR_EL2_Type = value_name;
    let tmp : ICH_EISR_EL2_Type = Mk_ICH_EISR_EL2_Type(tmp.bits & not_vec(0xffffffffffff0000));
    return(tmp)
}

val __get_MIDR_EL1 : MIDR_EL1_Type -> MIDR_EL1_Type

function __get_MIDR_EL1 value_name = {
    tmp : MIDR_EL1_Type = value_name;
    let tmp : MIDR_EL1_Type = Mk_MIDR_EL1_Type(tmp.bits & not_vec(0xffffffff00000000));
    return(tmp)
}

val __get_ICC_RPR_EL1 : ICC_RPR_EL1_Type -> ICC_RPR_EL1_Type

function __get_ICC_RPR_EL1 value_name = {
    tmp : ICC_RPR_EL1_Type = value_name;
    let tmp : ICC_RPR_EL1_Type = Mk_ICC_RPR_EL1_Type(tmp.bits & not_vec(0x3fffffffffffff00));
    return(tmp)
}

val __get_ICH_ELRSR_EL2 : ICH_ELRSR_EL2_Type -> ICH_ELRSR_EL2_Type

function __get_ICH_ELRSR_EL2 value_name = {
    tmp : ICH_ELRSR_EL2_Type = value_name;
    let tmp : ICH_ELRSR_EL2_Type = Mk_ICH_ELRSR_EL2_Type(tmp.bits & not_vec(0xffffffffffff0000));
    return(tmp)
}

val __get_VBAR_EL2 : VBAR_EL2_Type -> VBAR_EL2_Type

function __get_VBAR_EL2 value_name = {
    tmp : VBAR_EL2_Type = value_name;
    let tmp : VBAR_EL2_Type = tmp & not_vec(ZeroExtend(0x1f, 64));
    return(tmp)
}

val __get_HFGITR_EL2 : HFGITR_EL2_Type -> HFGITR_EL2_Type

function __get_HFGITR_EL2 value_name = {
    tmp : HFGITR_EL2_Type = value_name;
    let tmp : HFGITR_EL2_Type = Mk_HFGITR_EL2_Type(tmp.bits & not_vec(0xe000000000000000));
    return(tmp)
}

val __get_CNTHVS_CTL_EL2 : CNTHVS_CTL_EL2_Type -> CNTHVS_CTL_EL2_Type

function __get_CNTHVS_CTL_EL2 value_name = {
    tmp : CNTHVS_CTL_EL2_Type = value_name;
    let tmp : CNTHVS_CTL_EL2_Type = Mk_CNTHVS_CTL_EL2_Type(tmp.bits & not_vec(0xfffffffffffffff8));
    return(tmp)
}

val __get_ID_AA64PFR1_EL1 : ID_AA64PFR1_EL1_Type -> ID_AA64PFR1_EL1_Type

function __get_ID_AA64PFR1_EL1 value_name = {
    tmp : ID_AA64PFR1_EL1_Type = value_name;
    let tmp : ID_AA64PFR1_EL1_Type = Mk_ID_AA64PFR1_EL1_Type(tmp.bits & not_vec(ZeroExtend(0xf00000, 64)));
    return(tmp)
}

val __get_ICH_AP1R_EL2 : ICH_AP1R_EL2_Type -> ICH_AP1R_EL2_Type

function __get_ICH_AP1R_EL2 value_name = {
    tmp : ICH_AP1R_EL2_Type = value_name;
    let tmp : ICH_AP1R_EL2_Type = Mk_ICH_AP1R_EL2_Type(tmp.bits & not_vec(0x7fffffff00000000));
    return(tmp)
}

val __get_SDER32_EL2 : SDER32_EL2_Type -> SDER32_EL2_Type

function __get_SDER32_EL2 value_name = {
    tmp : SDER32_EL2_Type = value_name;
    let tmp : SDER32_EL2_Type = Mk_SDER32_EL2_Type(tmp.bits & not_vec(0xfffffffffffffffc));
    return(tmp)
}

val __get_VSTCR_EL2 : VSTCR_EL2_Type -> VSTCR_EL2_Type

function __get_VSTCR_EL2 value_name = {
    tmp : VSTCR_EL2_Type = value_name;
    let tmp : VSTCR_EL2_Type = Mk_VSTCR_EL2_Type(tmp.bits & not_vec(0xfffffffd1fff3f00) | ZeroExtend(0x80000000, 64));
    return(tmp)
}

val __get_ID_AA64ISAR0_EL1 : ID_AA64ISAR0_EL1_Type -> ID_AA64ISAR0_EL1_Type

function __get_ID_AA64ISAR0_EL1 value_name = {
    tmp : ID_AA64ISAR0_EL1_Type = value_name;
    tmp : ID_AA64ISAR0_EL1_Type = Mk_ID_AA64ISAR0_EL1_Type(tmp.bits & not_vec(ZeroExtend(0xf, 64)));
    if (PSTATE.EL == EL2 | PSTATE.EL == EL1) & SCR_EL3[TME] == 0b0 | (PSTATE.EL == EL1 & EL2Enabled()) & HCR_EL2[TME] == 0b0 then {
        tmp = Mk_ID_AA64ISAR0_EL1_Type(tmp.bits & not_vec(ZeroExtend(0xf000000, 64)))
    };
    return(tmp)
}

val __get_PMMIR_EL1 : PMMIR_EL1_Type -> PMMIR_EL1_Type

function __get_PMMIR_EL1 value_name = {
    tmp : PMMIR_EL1_Type = value_name;
    let tmp : PMMIR_EL1_Type = Mk_PMMIR_EL1_Type(tmp.bits & not_vec(0xfffffffff0000000));
    return(tmp)
}

val __get_ICV_IAR0_EL1 : ICV_IAR0_EL1_Type -> ICV_IAR0_EL1_Type

function __get_ICV_IAR0_EL1 value_name = {
    tmp : ICV_IAR0_EL1_Type = value_name;
    let tmp : ICV_IAR0_EL1_Type = Mk_ICV_IAR0_EL1_Type(tmp.bits & not_vec(0xffffffffff000000));
    return(tmp)
}

val __get_ICC_IGRPEN1_EL1 : ICC_IGRPEN1_EL1_Type -> ICC_IGRPEN1_EL1_Type

function __get_ICC_IGRPEN1_EL1 value_name = {
    tmp : ICC_IGRPEN1_EL1_Type = value_name;
    let tmp : ICC_IGRPEN1_EL1_Type = Mk_ICC_IGRPEN1_EL1_Type(tmp.bits & not_vec(0xfffffffffffffffe));
    return(tmp)
}

val __get_ICC_IGRPEN1_EL1_NS : ICC_IGRPEN1_EL1_Type -> ICC_IGRPEN1_EL1_Type

function __get_ICC_IGRPEN1_EL1_NS value_name = {
    tmp : ICC_IGRPEN1_EL1_Type = value_name;
    let tmp : ICC_IGRPEN1_EL1_Type = Mk_ICC_IGRPEN1_EL1_Type(tmp.bits & not_vec(0xfffffffffffffffe));
    return(tmp)
}

val __get_ICC_IGRPEN1_EL1_S : ICC_IGRPEN1_EL1_Type -> ICC_IGRPEN1_EL1_Type

function __get_ICC_IGRPEN1_EL1_S value_name = {
    tmp : ICC_IGRPEN1_EL1_Type = value_name;
    let tmp : ICC_IGRPEN1_EL1_Type = Mk_ICC_IGRPEN1_EL1_Type(tmp.bits & not_vec(0xfffffffffffffffe));
    return(tmp)
}

val __get_GPTBR_EL3 : GPTBR_EL3_Type -> GPTBR_EL3_Type

function __get_GPTBR_EL3 value_name = {
    tmp : GPTBR_EL3_Type = value_name;
    let tmp : GPTBR_EL3_Type = Mk_GPTBR_EL3_Type(tmp.bits & not_vec(0xffffff0000000000));
    return(tmp)
}

val __get_MDCCSR_EL0 : MDCCSR_EL0_Type -> MDCCSR_EL0_Type

function __get_MDCCSR_EL0 value_name = {
    tmp : MDCCSR_EL0_Type = value_name;
    let tmp : MDCCSR_EL0_Type = Mk_MDCCSR_EL0_Type(tmp.bits & not_vec(0xffffffff9fffffff));
    return(tmp)
}

val __get_TTBR0_EL3 : TTBR0_EL3_Type -> TTBR0_EL3_Type

function __get_TTBR0_EL3 value_name = {
    tmp : TTBR0_EL3_Type = value_name;
    let tmp : TTBR0_EL3_Type = Mk_TTBR0_EL3_Type(tmp.bits & not_vec(0xff00000000000000));
    return(tmp)
}

val __get_DBGBCR_EL1 : DBGBCR_EL1_Type -> DBGBCR_EL1_Type

function __get_DBGBCR_EL1 value_name = {
    tmp : DBGBCR_EL1_Type = value_name;
    let tmp : DBGBCR_EL1_Type = Mk_DBGBCR_EL1_Type(tmp.bits & not_vec(0xffffffff00001e10));
    return(tmp)
}

val __get_PMCCFILTR_EL0 : PMCCFILTR_EL0_Type -> PMCCFILTR_EL0_Type

function __get_PMCCFILTR_EL0 value_name = {
    tmp : PMCCFILTR_EL0_Type = value_name;
    let tmp : PMCCFILTR_EL0_Type = Mk_PMCCFILTR_EL0_Type(tmp.bits & not_vec(0xffffffff020fffff));
    return(tmp)
}

val __get_ICC_NMIAR1_EL1 : ICC_NMIAR1_EL1_Type -> ICC_NMIAR1_EL1_Type

function __get_ICC_NMIAR1_EL1 value_name = {
    tmp : ICC_NMIAR1_EL1_Type = value_name;
    let tmp : ICC_NMIAR1_EL1_Type = Mk_ICC_NMIAR1_EL1_Type(tmp.bits & not_vec(0xffffffffff000000));
    return(tmp)
}

val __get_DBGCLAIMSET_EL1 : DBGCLAIMSET_EL1_Type -> DBGCLAIMSET_EL1_Type

function __get_DBGCLAIMSET_EL1 value_name = {
    tmp : DBGCLAIMSET_EL1_Type = value_name;
    let tmp : DBGCLAIMSET_EL1_Type = Mk_DBGCLAIMSET_EL1_Type(tmp.bits & not_vec(0xffffffffffffff00));
    return(tmp)
}

val __get_ICC_SRE_EL1 : ICC_SRE_EL1_Type -> ICC_SRE_EL1_Type

function __get_ICC_SRE_EL1 value_name = {
    tmp : ICC_SRE_EL1_Type = value_name;
    let tmp : ICC_SRE_EL1_Type = Mk_ICC_SRE_EL1_Type(tmp.bits & not_vec(0xfffffffffffffff8));
    return(tmp)
}

val __get_ICC_SRE_EL1_NS : ICC_SRE_EL1_Type -> ICC_SRE_EL1_Type

function __get_ICC_SRE_EL1_NS value_name = {
    tmp : ICC_SRE_EL1_Type = value_name;
    let tmp : ICC_SRE_EL1_Type = Mk_ICC_SRE_EL1_Type(tmp.bits & not_vec(0xfffffffffffffff8));
    return(tmp)
}

val __get_ICC_SRE_EL1_S : ICC_SRE_EL1_Type -> ICC_SRE_EL1_Type

function __get_ICC_SRE_EL1_S value_name = {
    tmp : ICC_SRE_EL1_Type = value_name;
    let tmp : ICC_SRE_EL1_Type = Mk_ICC_SRE_EL1_Type(tmp.bits & not_vec(0xfffffffffffffff8));
    return(tmp)
}

val __get_ICH_AP0R_EL2 : ICH_AP0R_EL2_Type -> ICH_AP0R_EL2_Type

function __get_ICH_AP0R_EL2 value_name = {
    tmp : ICH_AP0R_EL2_Type = value_name;
    let tmp : ICH_AP0R_EL2_Type = Mk_ICH_AP0R_EL2_Type(tmp.bits & not_vec(0xffffffff00000000));
    return(tmp)
}

val __get_ICC_IAR0_EL1 : ICC_IAR0_EL1_Type -> ICC_IAR0_EL1_Type

function __get_ICC_IAR0_EL1 value_name = {
    tmp : ICC_IAR0_EL1_Type = value_name;
    let tmp : ICC_IAR0_EL1_Type = Mk_ICC_IAR0_EL1_Type(tmp.bits & not_vec(0xffffffffff000000));
    return(tmp)
}

val __get_ESR_EL2 : ESR_EL2_Type -> ESR_EL2_Type

function __get_ESR_EL2 value_name = {
    tmp : ESR_EL2_Type = value_name;
    let tmp : ESR_EL2_Type = Mk_ESR_EL2_Type(tmp.bits & not_vec(0xfffff80000000000));
    return(tmp)
}

val __get_CONTEXTIDR_EL1 : CONTEXTIDR_EL1_Type -> CONTEXTIDR_EL1_Type

function __get_CONTEXTIDR_EL1 value_name = {
    tmp : CONTEXTIDR_EL1_Type = value_name;
    let tmp : CONTEXTIDR_EL1_Type = Mk_CONTEXTIDR_EL1_Type(tmp.bits & not_vec(0xffffffff00000000));
    return(tmp)
}

val __get_PMUACR_EL1 : PMUACR_EL1_Type -> PMUACR_EL1_Type

function __get_PMUACR_EL1 value_name = {
    tmp : PMUACR_EL1_Type = value_name;
    let tmp : PMUACR_EL1_Type = Mk_PMUACR_EL1_Type(tmp.bits & not_vec(0xfffffffe00000000));
    return(tmp)
}

val __get_DSPSR_EL0 : DSPSR_EL0_Type -> DSPSR_EL0_Type

function __get_DSPSR_EL0 value_name = {
    tmp : DSPSR_EL0_Type = value_name;
    let tmp : DSPSR_EL0_Type = Mk_DSPSR_EL0_Type(tmp.bits & not_vec(0xfffffff800000000));
    return(tmp)
}

val __get_RMR_EL2 : RMR_EL2_Type -> RMR_EL2_Type

function __get_RMR_EL2 value_name = {
    tmp : RMR_EL2_Type = value_name;
    let tmp : RMR_EL2_Type = Mk_RMR_EL2_Type(tmp.bits & not_vec(0xfffffffffffffffc));
    return(tmp)
}

val __get_VNCR_EL2 : VNCR_EL2_Type -> VNCR_EL2_Type

function __get_VNCR_EL2 value_name = {
    tmp : VNCR_EL2_Type = value_name;
    let tmp : VNCR_EL2_Type = Mk_VNCR_EL2_Type(tmp.bits & not_vec(ZeroExtend(0xfff, 64)));
    return(tmp)
}

val __get_PMINTENCLR_EL1 : PMINTENCLR_EL1_Type -> PMINTENCLR_EL1_Type

function __get_PMINTENCLR_EL1 value_name = {
    tmp : PMINTENCLR_EL1_Type = value_name;
    let tmp : PMINTENCLR_EL1_Type = Mk_PMINTENCLR_EL1_Type(tmp.bits & not_vec(0xfffffffe00000000));
    return(tmp)
}

val __get_PMSELR_EL0 : PMSELR_EL0_Type -> PMSELR_EL0_Type

function __get_PMSELR_EL0 value_name = {
    tmp : PMSELR_EL0_Type = value_name;
    let tmp : PMSELR_EL0_Type = Mk_PMSELR_EL0_Type(tmp.bits & not_vec(0xffffffffffffffe0));
    return(tmp)
}

val __get_ICC_CTLR_EL1 : ICC_CTLR_EL1_Type -> ICC_CTLR_EL1_Type

function __get_ICC_CTLR_EL1 value_name = {
    tmp : ICC_CTLR_EL1_Type = value_name;
    let tmp : ICC_CTLR_EL1_Type = Mk_ICC_CTLR_EL1_Type(tmp.bits & not_vec(0xfffffffffff300bc));
    return(tmp)
}

val __get_ICC_CTLR_EL1_NS : ICC_CTLR_EL1_Type -> ICC_CTLR_EL1_Type

function __get_ICC_CTLR_EL1_NS value_name = {
    tmp : ICC_CTLR_EL1_Type = value_name;
    let tmp : ICC_CTLR_EL1_Type = Mk_ICC_CTLR_EL1_Type(tmp.bits & not_vec(0xfffffffffff300bc));
    return(tmp)
}

val __get_ICC_CTLR_EL1_S : ICC_CTLR_EL1_Type -> ICC_CTLR_EL1_Type

function __get_ICC_CTLR_EL1_S value_name = {
    tmp : ICC_CTLR_EL1_Type = value_name;
    let tmp : ICC_CTLR_EL1_Type = Mk_ICC_CTLR_EL1_Type(tmp.bits & not_vec(0xfffffffffff300bc));
    return(tmp)
}

val __get_ICC_AP1R_EL1 : ICC_AP1R_EL1_Type -> ICC_AP1R_EL1_Type

function __get_ICC_AP1R_EL1 value_name = {
    tmp : ICC_AP1R_EL1_Type = value_name;
    let tmp : ICC_AP1R_EL1_Type = Mk_ICC_AP1R_EL1_Type(tmp.bits & not_vec(0x7fffffff00000000));
    return(tmp)
}

val __get_ICC_AP1R_EL1_NS : ICC_AP1R_EL1_Type -> ICC_AP1R_EL1_Type

function __get_ICC_AP1R_EL1_NS value_name = {
    tmp : ICC_AP1R_EL1_Type = value_name;
    let tmp : ICC_AP1R_EL1_Type = Mk_ICC_AP1R_EL1_Type(tmp.bits & not_vec(0x7fffffff00000000));
    return(tmp)
}

val __get_ICC_AP1R_EL1_S : ICC_AP1R_EL1_Type -> ICC_AP1R_EL1_Type

function __get_ICC_AP1R_EL1_S value_name = {
    tmp : ICC_AP1R_EL1_Type = value_name;
    let tmp : ICC_AP1R_EL1_Type = Mk_ICC_AP1R_EL1_Type(tmp.bits & not_vec(0x7fffffff00000000));
    return(tmp)
}

val __get_CNTP_CTL_EL0 : CNTP_CTL_EL0_Type -> CNTP_CTL_EL0_Type

function __get_CNTP_CTL_EL0 value_name = {
    tmp : CNTP_CTL_EL0_Type = value_name;
    let tmp : CNTP_CTL_EL0_Type = Mk_CNTP_CTL_EL0_Type(tmp.bits & not_vec(0xfffffffffffffff8));
    return(tmp)
}

val __get_HFGITR2_EL2 : HFGITR2_EL2_Type -> HFGITR2_EL2_Type

function __get_HFGITR2_EL2 value_name = {
    tmp : HFGITR2_EL2_Type = value_name;
    let tmp : HFGITR2_EL2_Type = tmp & not_vec(0xffffffffffffffff);
    return(tmp)
}

val __get_CNTHV_TVAL_EL2 : CNTHV_TVAL_EL2_Type -> CNTHV_TVAL_EL2_Type

function __get_CNTHV_TVAL_EL2 value_name = {
    tmp : CNTHV_TVAL_EL2_Type = value_name;
    let tmp : CNTHV_TVAL_EL2_Type = Mk_CNTHV_TVAL_EL2_Type(tmp.bits & not_vec(0xffffffff00000000));
    return(tmp)
}

val __get_SPSR_irq : SPSR_irq_Type -> SPSR_irq_Type

function __get_SPSR_irq value_name = {
    tmp : SPSR_irq_Type = value_name;
    let tmp : SPSR_irq_Type = Mk_SPSR_irq_Type(tmp.bits & not_vec(0xffffffff00000000));
    return(tmp)
}

val __get_ICH_MISR_EL2 : ICH_MISR_EL2_Type -> ICH_MISR_EL2_Type

function __get_ICH_MISR_EL2 value_name = {
    tmp : ICH_MISR_EL2_Type = value_name;
    let tmp : ICH_MISR_EL2_Type = Mk_ICH_MISR_EL2_Type(tmp.bits & not_vec(0xffffffffffffff00));
    return(tmp)
}

val __get_CSSELR_EL1 : CSSELR_EL1_Type -> CSSELR_EL1_Type

function __get_CSSELR_EL1 value_name = {
    tmp : CSSELR_EL1_Type = value_name;
    let tmp : CSSELR_EL1_Type = Mk_CSSELR_EL1_Type(tmp.bits & not_vec(0xffffffffffffffe0));
    return(tmp)
}

val __get_ICV_RPR_EL1 : ICV_RPR_EL1_Type -> ICV_RPR_EL1_Type

function __get_ICV_RPR_EL1 value_name = {
    tmp : ICV_RPR_EL1_Type = value_name;
    let tmp : ICV_RPR_EL1_Type = Mk_ICV_RPR_EL1_Type(tmp.bits & not_vec(0x7fffffffffffff00));
    return(tmp)
}

val __get_PFAR_EL2 : PFAR_EL2_Type -> PFAR_EL2_Type

function __get_PFAR_EL2 value_name = {
    tmp : PFAR_EL2_Type = value_name;
    let tmp : PFAR_EL2_Type = Mk_PFAR_EL2_Type(tmp.bits & not_vec(0x3f00000000000000));
    return(tmp)
}

val __get_ICV_PMR_EL1 : ICV_PMR_EL1_Type -> ICV_PMR_EL1_Type

function __get_ICV_PMR_EL1 value_name = {
    tmp : ICV_PMR_EL1_Type = value_name;
    let tmp : ICV_PMR_EL1_Type = Mk_ICV_PMR_EL1_Type(tmp.bits & not_vec(0xffffffffffffff00));
    return(tmp)
}

val __get_MFAR_EL3 : MFAR_EL3_Type -> MFAR_EL3_Type

function __get_MFAR_EL3 value_name = {
    tmp : MFAR_EL3_Type = value_name;
    let tmp : MFAR_EL3_Type = Mk_MFAR_EL3_Type(tmp.bits & not_vec(0x3f00000000000000));
    return(tmp)
}

val __get_SPSR_EL2 : SPSR_EL2_Type -> SPSR_EL2_Type

function __get_SPSR_EL2 value_name = {
    tmp : SPSR_EL2_Type = value_name;
    let tmp : SPSR_EL2_Type = Mk_SPSR_EL2_Type(tmp.bits & not_vec(0xfffffff800000000));
    return(tmp)
}

val __get_TCR_EL1 : TCR_EL1_Type -> TCR_EL1_Type

function __get_TCR_EL1 value_name = {
    tmp : TCR_EL1_Type = value_name;
    let tmp : TCR_EL1_Type = Mk_TCR_EL1_Type(tmp.bits & not_vec(0xc000000800000000));
    return(tmp)
}

val __get_ICV_HPPIR0_EL1 : ICV_HPPIR0_EL1_Type -> ICV_HPPIR0_EL1_Type

function __get_ICV_HPPIR0_EL1 value_name = {
    tmp : ICV_HPPIR0_EL1_Type = value_name;
    let tmp : ICV_HPPIR0_EL1_Type = Mk_ICV_HPPIR0_EL1_Type(tmp.bits & not_vec(0xffffffffff000000));
    return(tmp)
}

val __get_SCTLR2_EL1 : SCTLR2_EL1_Type -> SCTLR2_EL1_Type

function __get_SCTLR2_EL1 value_name = {
    tmp : SCTLR2_EL1_Type = value_name;
    let tmp : SCTLR2_EL1_Type = Mk_SCTLR2_EL1_Type(tmp.bits & not_vec(0xffffffffffffff83));
    return(tmp)
}

val __get_ICV_BPR0_EL1 : ICV_BPR0_EL1_Type -> ICV_BPR0_EL1_Type

function __get_ICV_BPR0_EL1 value_name = {
    tmp : ICV_BPR0_EL1_Type = value_name;
    let tmp : ICV_BPR0_EL1_Type = Mk_ICV_BPR0_EL1_Type(tmp.bits & not_vec(0xfffffffffffffff8));
    return(tmp)
}

val __get_ISR_EL1 : ISR_EL1_Type -> ISR_EL1_Type

function __get_ISR_EL1 value_name = {
    tmp : ISR_EL1_Type = value_name;
    let tmp : ISR_EL1_Type = Mk_ISR_EL1_Type(tmp.bits & not_vec(0xfffffffffffff83f));
    return(tmp)
}

val __get_MECIDR_EL2 : MECIDR_EL2_Type -> MECIDR_EL2_Type

function __get_MECIDR_EL2 value_name = {
    tmp : MECIDR_EL2_Type = value_name;
    let tmp : MECIDR_EL2_Type = Mk_MECIDR_EL2_Type(tmp.bits & not_vec(0xfffffffffffffff0));
    return(tmp)
}

val __get_PMINTENSET_EL1 : PMINTENSET_EL1_Type -> PMINTENSET_EL1_Type

function __get_PMINTENSET_EL1 value_name = {
    tmp : PMINTENSET_EL1_Type = value_name;
    let tmp : PMINTENSET_EL1_Type = Mk_PMINTENSET_EL1_Type(tmp.bits & not_vec(0xfffffffe00000000));
    return(tmp)
}

val __get_SMIDR_EL1 : SMIDR_EL1_Type -> SMIDR_EL1_Type

function __get_SMIDR_EL1 value_name = {
    tmp : SMIDR_EL1_Type = value_name;
    let tmp : SMIDR_EL1_Type = Mk_SMIDR_EL1_Type(tmp.bits & not_vec(0xffffffff00007000));
    return(tmp)
}

val __get_HFGWTR_EL2 : HFGWTR_EL2_Type -> HFGWTR_EL2_Type

function __get_HFGWTR_EL2 value_name = {
    tmp : HFGWTR_EL2_Type = value_name;
    let tmp : HFGWTR_EL2_Type = Mk_HFGWTR_EL2_Type(tmp.bits & not_vec(ZeroExtend(0x845001624c604, 64)));
    return(tmp)
}

val __get_SMPRI_EL1 : SMPRI_EL1_Type -> SMPRI_EL1_Type

function __get_SMPRI_EL1 value_name = {
    tmp : SMPRI_EL1_Type = value_name;
    let tmp : SMPRI_EL1_Type = Mk_SMPRI_EL1_Type(tmp.bits & not_vec(0xfffffffffffffff0));
    return(tmp)
}

val __get_PMUSERENR_EL0 : PMUSERENR_EL0_Type -> PMUSERENR_EL0_Type

function __get_PMUSERENR_EL0 value_name = {
    tmp : PMUSERENR_EL0_Type = value_name;
    let tmp : PMUSERENR_EL0_Type = Mk_PMUSERENR_EL0_Type(tmp.bits & not_vec(0xffffffffffffff80));
    return(tmp)
}

val __get_SCTLR2_EL2 : SCTLR2_EL2_Type -> SCTLR2_EL2_Type

function __get_SCTLR2_EL2 value_name = {
    tmp : SCTLR2_EL2_Type = value_name;
    let tmp : SCTLR2_EL2_Type = Mk_SCTLR2_EL2_Type(tmp.bits & not_vec(0xffffffffffffff81));
    return(tmp)
}

val __get_PMOVSSET_EL0 : PMOVSSET_EL0_Type -> PMOVSSET_EL0_Type

function __get_PMOVSSET_EL0 value_name = {
    tmp : PMOVSSET_EL0_Type = value_name;
    let tmp : PMOVSSET_EL0_Type = Mk_PMOVSSET_EL0_Type(tmp.bits & not_vec(0xfffffffe00000000));
    return(tmp)
}

val __get_ICV_AP0R_EL1 : ICV_AP0R_EL1_Type -> ICV_AP0R_EL1_Type

function __get_ICV_AP0R_EL1 value_name = {
    tmp : ICV_AP0R_EL1_Type = value_name;
    let tmp : ICV_AP0R_EL1_Type = tmp & not_vec(0xffffffff00000000);
    return(tmp)
}

val __get_SCTLR_EL3 : SCTLR_EL3_Type -> SCTLR_EL3_Type

function __get_SCTLR_EL3 value_name = {
    tmp : SCTLR_EL3_Type = value_name;
    let tmp : SCTLR_EL3_Type = Mk_SCTLR_EL3_Type(tmp.bits & not_vec(0x97d7e4cf0512c780) | ZeroExtend(0x30850030, 64));
    return(tmp)
}

val __get_VBAR_EL1 : VBAR_EL1_Type -> VBAR_EL1_Type

function __get_VBAR_EL1 value_name = {
    tmp : VBAR_EL1_Type = value_name;
    let tmp : VBAR_EL1_Type = tmp & not_vec(ZeroExtend(0x1f, 64));
    return(tmp)
}

val __get_CNTFRQ_EL0 : CNTFRQ_EL0_Type -> CNTFRQ_EL0_Type

function __get_CNTFRQ_EL0 value_name = {
    tmp : CNTFRQ_EL0_Type = value_name;
    let tmp : CNTFRQ_EL0_Type = tmp & not_vec(0xffffffff00000000);
    return(tmp)
}

val __get_ICV_CTLR_EL1 : ICV_CTLR_EL1_Type -> ICV_CTLR_EL1_Type

function __get_ICV_CTLR_EL1 value_name = {
    tmp : ICV_CTLR_EL1_Type = value_name;
    let tmp : ICV_CTLR_EL1_Type = Mk_ICV_CTLR_EL1_Type(tmp.bits & not_vec(0xfffffffffff300fc));
    return(tmp)
}

val __get_MECID_A0_EL2 : MECID_A0_EL2_Type -> MECID_A0_EL2_Type

function __get_MECID_A0_EL2 value_name = {
    tmp : MECID_A0_EL2_Type = value_name;
    let tmp : MECID_A0_EL2_Type = Mk_MECID_A0_EL2_Type(tmp.bits & not_vec(0xffffffffffff0000));
    return(tmp)
}

val __get_ICV_IAR1_EL1 : ICV_IAR1_EL1_Type -> ICV_IAR1_EL1_Type

function __get_ICV_IAR1_EL1 value_name = {
    tmp : ICV_IAR1_EL1_Type = value_name;
    let tmp : ICV_IAR1_EL1_Type = Mk_ICV_IAR1_EL1_Type(tmp.bits & not_vec(0xffffffffff000000));
    return(tmp)
}

val __get_CPACR_EL1 : CPACR_EL1_Type -> CPACR_EL1_Type

function __get_CPACR_EL1 value_name = {
    tmp : CPACR_EL1_Type = value_name;
    let tmp : CPACR_EL1_Type = Mk_CPACR_EL1_Type(tmp.bits & not_vec(0xffffffff4cccffff));
    return(tmp)
}

val __get_DBGDTRRX_EL0 : DBGDTRRX_EL0_Type -> DBGDTRRX_EL0_Type

function __get_DBGDTRRX_EL0 value_name = {
    tmp : DBGDTRRX_EL0_Type = value_name;
    let tmp : DBGDTRRX_EL0_Type = tmp & not_vec(0xffffffff00000000);
    return(tmp)
}

val __get_SPSR_EL1 : SPSR_EL1_Type -> SPSR_EL1_Type

function __get_SPSR_EL1 value_name = {
    tmp : SPSR_EL1_Type = value_name;
    let tmp : SPSR_EL1_Type = Mk_SPSR_EL1_Type(tmp.bits & not_vec(0xfffffff800000000));
    return(tmp)
}

val __get_FPEXC32_EL2 : FPEXC32_EL2_Type -> FPEXC32_EL2_Type

function __get_FPEXC32_EL2 value_name = {
    tmp : FPEXC32_EL2_Type = value_name;
    if not_bool(__IMPDEF_boolean("IMPLEMENTED_trapping of Invalid Operation floating-point exceptions")) then {
        tmp = Mk_FPEXC32_EL2_Type(tmp.bits & not_vec(ZeroExtend(0x1, 64)))
    };
    if not_bool(__IMPDEF_boolean("IMPLEMENTED_trapping of Divide by Zero floating-point exceptions")) then {
        tmp = Mk_FPEXC32_EL2_Type(tmp.bits & not_vec(ZeroExtend(0x2, 64)))
    };
    if not_bool(__IMPDEF_boolean("IMPLEMENTED_trapping of Overflow floating-point exceptions")) then {
        tmp = Mk_FPEXC32_EL2_Type(tmp.bits & not_vec(ZeroExtend(0x4, 64)))
    };
    if not_bool(__IMPDEF_boolean("IMPLEMENTED_trapping of Underflow floating-point exceptions")) then {
        tmp = Mk_FPEXC32_EL2_Type(tmp.bits & not_vec(ZeroExtend(0x8, 64)))
    };
    if not_bool(__IMPDEF_boolean("IMPLEMENTED_trapping of Inexact floating-point exceptions")) then {
        tmp = Mk_FPEXC32_EL2_Type(tmp.bits & not_vec(ZeroExtend(0x10, 64)))
    };
    tmp : FPEXC32_EL2_Type = Mk_FPEXC32_EL2_Type(tmp.bits & not_vec(0xffffffff9bfff860) | ZeroExtend(0x700, 64));
    if not_bool(__IMPDEF_boolean("IMPLEMENTED_trapping of Input Denormal floating-point exceptions")) then {
        tmp = Mk_FPEXC32_EL2_Type(tmp.bits & not_vec(ZeroExtend(0x80, 64)))
    };
    if not_bool(__IMPDEF_boolean("IMPLEMENTED_trapping of floating-point exceptions")) then {
        tmp = Mk_FPEXC32_EL2_Type(tmp.bits & not_vec(ZeroExtend(0x4000000, 64)))
    };
    return(tmp)
}

val __get_MDSCR_EL1 : MDSCR_EL1_Type -> MDSCR_EL1_Type

function __get_MDSCR_EL1 value_name = {
    tmp : MDSCR_EL1_Type = value_name;
    let tmp : MDSCR_EL1_Type = Mk_MDSCR_EL1_Type(tmp.bits & not_vec(0xfffffff213100f82));
    return(tmp)
}

val __get_SPSR_fiq : SPSR_fiq_Type -> SPSR_fiq_Type

function __get_SPSR_fiq value_name = {
    tmp : SPSR_fiq_Type = value_name;
    let tmp : SPSR_fiq_Type = Mk_SPSR_fiq_Type(tmp.bits & not_vec(0xffffffff00000000));
    return(tmp)
}

val __get_MECID_P0_EL2 : MECID_P0_EL2_Type -> MECID_P0_EL2_Type

function __get_MECID_P0_EL2 value_name = {
    tmp : MECID_P0_EL2_Type = value_name;
    let tmp : MECID_P0_EL2_Type = Mk_MECID_P0_EL2_Type(tmp.bits & not_vec(0xffffffffffff0000));
    return(tmp)
}

val __get_GPCCR_EL3 : GPCCR_EL3_Type -> GPCCR_EL3_Type

function __get_GPCCR_EL3 value_name = {
    tmp : GPCCR_EL3_Type = value_name;
    let tmp : GPCCR_EL3_Type = Mk_GPCCR_EL3_Type(tmp.bits & not_vec(0xffffffffff0c00f8));
    return(tmp)
}

val __get_HDFGWTR2_EL2 : HDFGWTR2_EL2_Type -> HDFGWTR2_EL2_Type

function __get_HDFGWTR2_EL2 value_name = {
    tmp : HDFGWTR2_EL2_Type = value_name;
    let tmp : HDFGWTR2_EL2_Type = Mk_HDFGWTR2_EL2_Type(tmp.bits & not_vec(0xffffffffffd60040));
    return(tmp)
}

val __get_TCR2_EL1 : TCR2_EL1_Type -> TCR2_EL1_Type

function __get_TCR2_EL1 value_name = {
    tmp : TCR2_EL1_Type = value_name;
    let tmp : TCR2_EL1_Type = Mk_TCR2_EL1_Type(tmp.bits & not_vec(0xffffffffffff33c0));
    return(tmp)
}

val __get_DCZID_EL0 : DCZID_EL0_Type -> DCZID_EL0_Type

function __get_DCZID_EL0 value_name = {
    tmp : DCZID_EL0_Type = value_name;
    let tmp : DCZID_EL0_Type = Mk_DCZID_EL0_Type(tmp.bits & not_vec(0xffffffffffffffe0));
    return(tmp)
}

val __get_VSTTBR_EL2 : VSTTBR_EL2_Type -> VSTTBR_EL2_Type

function __get_VSTTBR_EL2 value_name = {
    tmp : VSTTBR_EL2_Type = value_name;
    let tmp : VSTTBR_EL2_Type = Mk_VSTTBR_EL2_Type(tmp.bits & not_vec(0xff00000000000000));
    return(tmp)
}

val __get_TRFCR_EL2 : TRFCR_EL2_Type -> TRFCR_EL2_Type

function __get_TRFCR_EL2 value_name = {
    tmp : TRFCR_EL2_Type = value_name;
    let tmp : TRFCR_EL2_Type = Mk_TRFCR_EL2_Type(tmp.bits & not_vec(0xffffffffffffff94));
    return(tmp)
}

val __get_CNTHP_CTL_EL2 : CNTHP_CTL_EL2_Type -> CNTHP_CTL_EL2_Type

function __get_CNTHP_CTL_EL2 value_name = {
    tmp : CNTHP_CTL_EL2_Type = value_name;
    let tmp : CNTHP_CTL_EL2_Type = Mk_CNTHP_CTL_EL2_Type(tmp.bits & not_vec(0xfffffffffffffff8));
    return(tmp)
}

val __get_CNTHVS_TVAL_EL2 : CNTHVS_TVAL_EL2_Type -> CNTHVS_TVAL_EL2_Type

function __get_CNTHVS_TVAL_EL2 value_name = {
    tmp : CNTHVS_TVAL_EL2_Type = value_name;
    let tmp : CNTHVS_TVAL_EL2_Type = Mk_CNTHVS_TVAL_EL2_Type(tmp.bits & not_vec(0xffffffff00000000));
    return(tmp)
}

val __get_CNTHP_TVAL_EL2 : CNTHP_TVAL_EL2_Type -> CNTHP_TVAL_EL2_Type

function __get_CNTHP_TVAL_EL2 value_name = {
    tmp : CNTHP_TVAL_EL2_Type = value_name;
    let tmp : CNTHP_TVAL_EL2_Type = Mk_CNTHP_TVAL_EL2_Type(tmp.bits & not_vec(0xffffffff00000000));
    return(tmp)
}

val __get_CNTHCTL_EL2 : CNTHCTL_EL2_Type -> CNTHCTL_EL2_Type

function __get_CNTHCTL_EL2 value_name = {
    tmp : CNTHCTL_EL2_Type = value_name;
    let tmp : CNTHCTL_EL2_Type = Mk_CNTHCTL_EL2_Type(tmp.bits & not_vec(0xfffffffffff00000));
    return(tmp)
}

val __get_MDRAR_EL1 : MDRAR_EL1_Type -> MDRAR_EL1_Type

function __get_MDRAR_EL1 value_name = {
    tmp : MDRAR_EL1_Type = value_name;
    let tmp : MDRAR_EL1_Type = Mk_MDRAR_EL1_Type(tmp.bits & not_vec(0xff00000000000ffc));
    return(tmp)
}

val __get_OSDTRRX_EL1 : OSDTRRX_EL1_Type -> OSDTRRX_EL1_Type

function __get_OSDTRRX_EL1 value_name = {
    tmp : OSDTRRX_EL1_Type = value_name;
    let tmp : OSDTRRX_EL1_Type = tmp & not_vec(0xffffffff00000000);
    return(tmp)
}

val __get_PFAR_EL1 : PFAR_EL1_Type -> PFAR_EL1_Type

function __get_PFAR_EL1 value_name = {
    tmp : PFAR_EL1_Type = value_name;
    let tmp : PFAR_EL1_Type = Mk_PFAR_EL1_Type(tmp.bits & not_vec(0x3f00000000000000));
    return(tmp)
}

val __get_IFSR32_EL2 : IFSR32_EL2_Type -> IFSR32_EL2_Type

function __get_IFSR32_EL2 value_name = {
    tmp : IFSR32_EL2_Type = value_name;
    let tmp : IFSR32_EL2_Type = Mk_IFSR32_EL2_Type(tmp.bits & not_vec(0xfffffffffffee9c0));
    return(tmp)
}

val __get_ICC_IGRPEN1_EL3 : ICC_IGRPEN1_EL3_Type -> ICC_IGRPEN1_EL3_Type

function __get_ICC_IGRPEN1_EL3 value_name = {
    tmp : ICC_IGRPEN1_EL3_Type = value_name;
    let tmp : ICC_IGRPEN1_EL3_Type = Mk_ICC_IGRPEN1_EL3_Type(tmp.bits & not_vec(0xfffffffffffffffc));
    return(tmp)
}

val __get_LORSA_EL1 : LORSA_EL1_Type -> LORSA_EL1_Type

function __get_LORSA_EL1 value_name = {
    tmp : LORSA_EL1_Type = value_name;
    let tmp : LORSA_EL1_Type = Mk_LORSA_EL1_Type(tmp.bits & not_vec(0xff0000000000fffe));
    return(tmp)
}

val __get_DBGWCR_EL1 : DBGWCR_EL1_Type -> DBGWCR_EL1_Type

function __get_DBGWCR_EL1 value_name = {
    tmp : DBGWCR_EL1_Type = value_name;
    let tmp : DBGWCR_EL1_Type = Mk_DBGWCR_EL1_Type(tmp.bits & not_vec(0xffffffff00e00000));
    return(tmp)
}

val __get_ESR_EL3 : ESR_EL3_Type -> ESR_EL3_Type

function __get_ESR_EL3 value_name = {
    tmp : ESR_EL3_Type = value_name;
    let tmp : ESR_EL3_Type = Mk_ESR_EL3_Type(tmp.bits & not_vec(0xfffff88000000000));
    return(tmp)
}

val __get_PMEVTYPER_EL0 : PMEVTYPER_EL0_Type -> PMEVTYPER_EL0_Type

function __get_PMEVTYPER_EL0 value_name = {
    tmp : PMEVTYPER_EL0_Type = value_name;
    let tmp : PMEVTYPER_EL0_Type = Mk_PMEVTYPER_EL0_Type(tmp.bits & not_vec(ZeroExtend(0xbfff000000f0000, 64)));
    return(tmp)
}

val __get_CNTV_CTL_EL0 : CNTV_CTL_EL0_Type -> CNTV_CTL_EL0_Type

function __get_CNTV_CTL_EL0 value_name = {
    tmp : CNTV_CTL_EL0_Type = value_name;
    let tmp : CNTV_CTL_EL0_Type = Mk_CNTV_CTL_EL0_Type(tmp.bits & not_vec(0xfffffffffffffff8));
    return(tmp)
}

val __get_TRFCR_EL1 : TRFCR_EL1_Type -> TRFCR_EL1_Type

function __get_TRFCR_EL1 value_name = {
    tmp : TRFCR_EL1_Type = value_name;
    let tmp : TRFCR_EL1_Type = Mk_TRFCR_EL1_Type(tmp.bits & not_vec(0xffffffffffffff9c));
    return(tmp)
}

val __get_OSDTRTX_EL1 : OSDTRTX_EL1_Type -> OSDTRTX_EL1_Type

function __get_OSDTRTX_EL1 value_name = {
    tmp : OSDTRTX_EL1_Type = value_name;
    let tmp : OSDTRTX_EL1_Type = tmp & not_vec(0xffffffff00000000);
    return(tmp)
}

val __get_ICH_VMCR_EL2 : ICH_VMCR_EL2_Type -> ICH_VMCR_EL2_Type

function __get_ICH_VMCR_EL2 value_name = {
    tmp : ICH_VMCR_EL2_Type = value_name;
    let tmp : ICH_VMCR_EL2_Type = Mk_ICH_VMCR_EL2_Type(tmp.bits & not_vec(0xffffffff0003fde0));
    return(tmp)
}

val __get_VPIDR_EL2 : VPIDR_EL2_Type -> VPIDR_EL2_Type

function __get_VPIDR_EL2 value_name = {
    tmp : VPIDR_EL2_Type = value_name;
    let tmp : VPIDR_EL2_Type = Mk_VPIDR_EL2_Type(tmp.bits & not_vec(0xffffffff00000000));
    return(tmp)
}

val __get_ICC_CTLR_EL3 : ICC_CTLR_EL3_Type -> ICC_CTLR_EL3_Type

function __get_ICC_CTLR_EL3 value_name = {
    tmp : ICC_CTLR_EL3_Type = value_name;
    let tmp : ICC_CTLR_EL3_Type = Mk_ICC_CTLR_EL3_Type(tmp.bits & not_vec(0xfffffffffff10080));
    return(tmp)
}

val __get_SCTLR_EL2 : SCTLR_EL2_Type -> SCTLR_EL2_Type

function __get_SCTLR_EL2 value_name = {
    tmp : SCTLR_EL2_Type = value_name;
    let tmp : SCTLR_EL2_Type = Mk_SCTLR_EL2_Type(tmp.bits & not_vec(ZeroExtend(0x400020200, 64)));
    return(tmp)
}

val __get_OSLSR_EL1 : OSLSR_EL1_Type -> OSLSR_EL1_Type

function __get_OSLSR_EL1 value_name = {
    tmp : OSLSR_EL1_Type = value_name;
    let tmp : OSLSR_EL1_Type = Mk_OSLSR_EL1_Type(tmp.bits & not_vec(0xfffffffffffffff0));
    return(tmp)
}

val __get_MDCR_EL3 : MDCR_EL3_Type -> MDCR_EL3_Type

function __get_MDCR_EL3 value_name = {
    tmp : MDCR_EL3_Type = value_name;
    let tmp : MDCR_EL3_Type = Mk_MDCR_EL3_Type(tmp.bits & not_vec(0xffff80802740012a));
    return(tmp)
}

val __get_SCTLR2_EL3 : SCTLR2_EL3_Type -> SCTLR2_EL3_Type

function __get_SCTLR2_EL3 value_name = {
    tmp : SCTLR2_EL3_Type = value_name;
    let tmp : SCTLR2_EL3_Type = Mk_SCTLR2_EL3_Type(tmp.bits & not_vec(0xffffffffffffffe5));
    return(tmp)
}

val __get_PMCNTENSET_EL0 : PMCNTENSET_EL0_Type -> PMCNTENSET_EL0_Type

function __get_PMCNTENSET_EL0 value_name = {
    tmp : PMCNTENSET_EL0_Type = value_name;
    let tmp : PMCNTENSET_EL0_Type = Mk_PMCNTENSET_EL0_Type(tmp.bits & not_vec(0xfffffffe00000000));
    return(tmp)
}

val __get_ICC_SRE_EL2 : ICC_SRE_EL2_Type -> ICC_SRE_EL2_Type

function __get_ICC_SRE_EL2 value_name = {
    tmp : ICC_SRE_EL2_Type = value_name;
    let tmp : ICC_SRE_EL2_Type = Mk_ICC_SRE_EL2_Type(tmp.bits & not_vec(0xfffffffffffffff0));
    return(tmp)
}

val __get_CNTPS_CTL_EL1 : CNTPS_CTL_EL1_Type -> CNTPS_CTL_EL1_Type

function __get_CNTPS_CTL_EL1 value_name = {
    tmp : CNTPS_CTL_EL1_Type = value_name;
    let tmp : CNTPS_CTL_EL1_Type = Mk_CNTPS_CTL_EL1_Type(tmp.bits & not_vec(0xfffffffffffffff8));
    return(tmp)
}

val __get_DACR32_EL2 : DACR32_EL2_Type -> DACR32_EL2_Type

function __get_DACR32_EL2 value_name = {
    tmp : DACR32_EL2_Type = value_name;
    let tmp : DACR32_EL2_Type = Mk_DACR32_EL2_Type(tmp.bits & not_vec(0xffffffff00000000));
    return(tmp)
}

val __get_LORC_EL1 : LORC_EL1_Type -> LORC_EL1_Type

function __get_LORC_EL1 value_name = {
    tmp : LORC_EL1_Type = value_name;
    let tmp : LORC_EL1_Type = Mk_LORC_EL1_Type(tmp.bits & not_vec(0xfffffffffffffc02));
    return(tmp)
}

val __get_ID_AA64PFR2_EL1 : ID_AA64PFR2_EL1_Type -> ID_AA64PFR2_EL1_Type

function __get_ID_AA64PFR2_EL1 value_name = {
    tmp : ID_AA64PFR2_EL1_Type = value_name;
    let tmp : ID_AA64PFR2_EL1_Type = Mk_ID_AA64PFR2_EL1_Type(tmp.bits & not_vec(0xfffffffffffff000));
    return(tmp)
}

val __get_TCR_EL2 : TCR_EL2_Type -> TCR_EL2_Type

function __get_TCR_EL2 value_name = {
    tmp : TCR_EL2_Type = value_name;
    let tmp : TCR_EL2_Type = Mk_TCR_EL2_Type(tmp.bits & not_vec(0xc000000800000040));
    return(tmp)
}

val __get_CCSIDR2_EL1 : CCSIDR2_EL1_Type -> CCSIDR2_EL1_Type

function __get_CCSIDR2_EL1 value_name = {
    tmp : CCSIDR2_EL1_Type = value_name;
    let tmp : CCSIDR2_EL1_Type = Mk_CCSIDR2_EL1_Type(tmp.bits & not_vec(0xffffffffff000000));
    return(tmp)
}

val __get_CTR_EL0 : CTR_EL0_Type -> CTR_EL0_Type

function __get_CTR_EL0 value_name = {
    tmp : CTR_EL0_Type = value_name;
    let tmp : CTR_EL0_Type = Mk_CTR_EL0_Type(tmp.bits & not_vec(0xffffffc040003ff0) | ZeroExtend(0x80000000, 64));
    return(tmp)
}

val __get_SPSR_und : SPSR_und_Type -> SPSR_und_Type

function __get_SPSR_und value_name = {
    tmp : SPSR_und_Type = value_name;
    let tmp : SPSR_und_Type = Mk_SPSR_und_Type(tmp.bits & not_vec(0xffffffff00000000));
    return(tmp)
}

val __get_ID_AA64ISAR2_EL1 : ID_AA64ISAR2_EL1_Type -> ID_AA64ISAR2_EL1_Type

function __get_ID_AA64ISAR2_EL1 value_name = {
    tmp : ID_AA64ISAR2_EL1_Type = value_name;
    let tmp : ID_AA64ISAR2_EL1_Type = Mk_ID_AA64ISAR2_EL1_Type(tmp.bits & not_vec(0xff00f00000000000));
    return(tmp)
}

val __get_CPTR_EL3 : CPTR_EL3_Type -> CPTR_EL3_Type

function __get_CPTR_EL3 value_name = {
    tmp : CPTR_EL3_Type = value_name;
    let tmp : CPTR_EL3_Type = Mk_CPTR_EL3_Type(tmp.bits & not_vec(0xffffffff3fefeaff));
    return(tmp)
}

val __get_HFGRTR2_EL2 : HFGRTR2_EL2_Type -> HFGRTR2_EL2_Type

function __get_HFGRTR2_EL2 value_name = {
    tmp : HFGRTR2_EL2_Type = value_name;
    let tmp : HFGRTR2_EL2_Type = Mk_HFGRTR2_EL2_Type(tmp.bits & not_vec(0xfffffffffffffff8));
    return(tmp)
}

val __get_RMR_EL3 : RMR_EL3_Type -> RMR_EL3_Type

function __get_RMR_EL3 value_name = {
    tmp : RMR_EL3_Type = value_name;
    let tmp : RMR_EL3_Type = Mk_RMR_EL3_Type(tmp.bits & not_vec(0xfffffffffffffffc));
    return(tmp)
}

val __get_ICH_HCR_EL2 : ICH_HCR_EL2_Type -> ICH_HCR_EL2_Type

function __get_ICH_HCR_EL2 value_name = {
    tmp : ICH_HCR_EL2_Type = value_name;
    let tmp : ICH_HCR_EL2_Type = Mk_ICH_HCR_EL2_Type(tmp.bits & not_vec(0xffffffff07ff0200));
    return(tmp)
}

val __get_ICC_IGRPEN0_EL1 : ICC_IGRPEN0_EL1_Type -> ICC_IGRPEN0_EL1_Type

function __get_ICC_IGRPEN0_EL1 value_name = {
    tmp : ICC_IGRPEN0_EL1_Type = value_name;
    let tmp : ICC_IGRPEN0_EL1_Type = Mk_ICC_IGRPEN0_EL1_Type(tmp.bits & not_vec(0xfffffffffffffffe));
    return(tmp)
}

val __get_CNTHPS_TVAL_EL2 : CNTHPS_TVAL_EL2_Type -> CNTHPS_TVAL_EL2_Type

function __get_CNTHPS_TVAL_EL2 value_name = {
    tmp : CNTHPS_TVAL_EL2_Type = value_name;
    let tmp : CNTHPS_TVAL_EL2_Type = Mk_CNTHPS_TVAL_EL2_Type(tmp.bits & not_vec(0xffffffff00000000));
    return(tmp)
}

val __get_ICC_BPR1_EL1 : ICC_BPR1_EL1_Type -> ICC_BPR1_EL1_Type

function __get_ICC_BPR1_EL1 value_name = {
    tmp : ICC_BPR1_EL1_Type = value_name;
    let tmp : ICC_BPR1_EL1_Type = Mk_ICC_BPR1_EL1_Type(tmp.bits & not_vec(0xfffffffffffffff8));
    return(tmp)
}

val __get_ICC_BPR1_EL1_NS : ICC_BPR1_EL1_Type -> ICC_BPR1_EL1_Type

function __get_ICC_BPR1_EL1_NS value_name = {
    tmp : ICC_BPR1_EL1_Type = value_name;
    let tmp : ICC_BPR1_EL1_Type = Mk_ICC_BPR1_EL1_Type(tmp.bits & not_vec(0xfffffffffffffff8));
    return(tmp)
}

val __get_ICC_BPR1_EL1_S : ICC_BPR1_EL1_Type -> ICC_BPR1_EL1_Type

function __get_ICC_BPR1_EL1_S value_name = {
    tmp : ICC_BPR1_EL1_Type = value_name;
    let tmp : ICC_BPR1_EL1_Type = Mk_ICC_BPR1_EL1_Type(tmp.bits & not_vec(0xfffffffffffffff8));
    return(tmp)
}

val __get_MECID_A1_EL2 : MECID_A1_EL2_Type -> MECID_A1_EL2_Type

function __get_MECID_A1_EL2 value_name = {
    tmp : MECID_A1_EL2_Type = value_name;
    let tmp : MECID_A1_EL2_Type = Mk_MECID_A1_EL2_Type(tmp.bits & not_vec(0xffffffffffff0000));
    return(tmp)
}

val __get_ID_AA64MMFR0_EL1 : ID_AA64MMFR0_EL1_Type -> ID_AA64MMFR0_EL1_Type

function __get_ID_AA64MMFR0_EL1 value_name = {
    tmp : ID_AA64MMFR0_EL1_Type = value_name;
    let tmp : ID_AA64MMFR0_EL1_Type = Mk_ID_AA64MMFR0_EL1_Type(tmp.bits & not_vec(ZeroExtend(0xff000000000000, 64)));
    return(tmp)
}

val __get_PMCR_EL0 : PMCR_EL0_Type -> PMCR_EL0_Type

function __get_PMCR_EL0 value_name = {
    tmp : PMCR_EL0_Type = value_name;
    tmp : PMCR_EL0_Type = Mk_PMCR_EL0_Type(tmp.bits & not_vec(0xfffffffe00000506));
    if not_bool(__IMPDEF_boolean("the implementation includes a PMU event export bus")) then {
        tmp = Mk_PMCR_EL0_Type(tmp.bits & not_vec(ZeroExtend(0x10, 64)))
    };
    if not_bool(not_bool(IsFeatureImplemented(FEAT_PMUv3p7))) then {
        tmp = Mk_PMCR_EL0_Type(tmp.bits & not_vec(ZeroExtend(0xff000000, 64)))
    };
    return(tmp)
}

val __get_HDFGRTR2_EL2 : HDFGRTR2_EL2_Type -> HDFGRTR2_EL2_Type

function __get_HDFGRTR2_EL2 value_name = {
    tmp : HDFGRTR2_EL2_Type = value_name;
    let tmp : HDFGRTR2_EL2_Type = Mk_HDFGRTR2_EL2_Type(tmp.bits & not_vec(0xfffffffffff00000));
    return(tmp)
}

val __get_DBGPRCR_EL1 : DBGPRCR_EL1_Type -> DBGPRCR_EL1_Type

function __get_DBGPRCR_EL1 value_name = {
    tmp : DBGPRCR_EL1_Type = value_name;
    let tmp : DBGPRCR_EL1_Type = Mk_DBGPRCR_EL1_Type(tmp.bits & not_vec(0xfffffffffffffffe));
    return(tmp)
}

val __get_PMCNTENCLR_EL0 : PMCNTENCLR_EL0_Type -> PMCNTENCLR_EL0_Type

function __get_PMCNTENCLR_EL0 value_name = {
    tmp : PMCNTENCLR_EL0_Type = value_name;
    let tmp : PMCNTENCLR_EL0_Type = Mk_PMCNTENCLR_EL0_Type(tmp.bits & not_vec(0xfffffffe00000000));
    return(tmp)
}

val __get_SDER32_EL3 : SDER32_EL3_Type -> SDER32_EL3_Type

function __get_SDER32_EL3 value_name = {
    tmp : SDER32_EL3_Type = value_name;
    let tmp : SDER32_EL3_Type = Mk_SDER32_EL3_Type(tmp.bits & not_vec(0xfffffffffffffffc));
    return(tmp)
}

val __get_HPFAR_EL2 : HPFAR_EL2_Type -> HPFAR_EL2_Type

function __get_HPFAR_EL2 value_name = {
    tmp : HPFAR_EL2_Type = value_name;
    let tmp : HPFAR_EL2_Type = Mk_HPFAR_EL2_Type(tmp.bits & not_vec(0x7fff00000000000f));
    return(tmp)
}

val __get_VMPIDR_EL2 : VMPIDR_EL2_Type -> VMPIDR_EL2_Type

function __get_VMPIDR_EL2 value_name = {
    tmp : VMPIDR_EL2_Type = value_name;
    let tmp : VMPIDR_EL2_Type = Mk_VMPIDR_EL2_Type(tmp.bits & not_vec(0xffffff003e000000) | ZeroExtend(0x80000000, 64));
    return(tmp)
}

val __get_ID_AA64MMFR3_EL1 : ID_AA64MMFR3_EL1_Type -> ID_AA64MMFR3_EL1_Type

function __get_ID_AA64MMFR3_EL1 value_name = {
    tmp : ID_AA64MMFR3_EL1_Type = value_name;
    let tmp : ID_AA64MMFR3_EL1_Type = Mk_ID_AA64MMFR3_EL1_Type(tmp.bits & not_vec(ZeroExtend(0xf000000000000, 64)));
    return(tmp)
}

val __get_ICH_VTR_EL2 : ICH_VTR_EL2_Type -> ICH_VTR_EL2_Type

function __get_ICH_VTR_EL2 value_name = {
    tmp : ICH_VTR_EL2_Type = value_name;
    let tmp : ICH_VTR_EL2_Type = Mk_ICH_VTR_EL2_Type(tmp.bits & not_vec(0xffffffff0003ffe0));
    return(tmp)
}

val __get_MDSELR_EL1 : MDSELR_EL1_Type -> MDSELR_EL1_Type

function __get_MDSELR_EL1 value_name = {
    tmp : MDSELR_EL1_Type = value_name;
    let tmp : MDSELR_EL1_Type = Mk_MDSELR_EL1_Type(tmp.bits & not_vec(0xffffffffffffffcf));
    return(tmp)
}

val __get_VBAR_EL3 : VBAR_EL3_Type -> VBAR_EL3_Type

function __get_VBAR_EL3 value_name = {
    tmp : VBAR_EL3_Type = value_name;
    let tmp : VBAR_EL3_Type = tmp & not_vec(ZeroExtend(0x7ff, 64));
    return(tmp)
}

val __get_MDCR_EL2 : MDCR_EL2_Type -> MDCR_EL2_Type

function __get_MDCR_EL2 value_name = {
    tmp : MDCR_EL2_Type = value_name;
    let tmp : MDCR_EL2_Type = Mk_MDCR_EL2_Type(tmp.bits & not_vec(0xfffff4ef03750000));
    return(tmp)
}

val __get_CNTKCTL_EL1 : CNTKCTL_EL1_Type -> CNTKCTL_EL1_Type

function __get_CNTKCTL_EL1 value_name = {
    tmp : CNTKCTL_EL1_Type = value_name;
    let tmp : CNTKCTL_EL1_Type = Mk_CNTKCTL_EL1_Type(tmp.bits & not_vec(0xfffffffffffdfc00));
    return(tmp)
}

val __get_LORN_EL1 : LORN_EL1_Type -> LORN_EL1_Type

function __get_LORN_EL1 value_name = {
    tmp : LORN_EL1_Type = value_name;
    let tmp : LORN_EL1_Type = Mk_LORN_EL1_Type(tmp.bits & not_vec(0xffffffffffffff00));
    return(tmp)
}

val __get_ICV_IGRPEN0_EL1 : ICV_IGRPEN0_EL1_Type -> ICV_IGRPEN0_EL1_Type

function __get_ICV_IGRPEN0_EL1 value_name = {
    tmp : ICV_IGRPEN0_EL1_Type = value_name;
    let tmp : ICV_IGRPEN0_EL1_Type = Mk_ICV_IGRPEN0_EL1_Type(tmp.bits & not_vec(0xfffffffffffffffe));
    return(tmp)
}

val __get_SPSR_EL3 : SPSR_EL3_Type -> SPSR_EL3_Type

function __get_SPSR_EL3 value_name = {
    tmp : SPSR_EL3_Type = value_name;
    let tmp : SPSR_EL3_Type = Mk_SPSR_EL3_Type(tmp.bits & not_vec(0xfffffff800000000));
    return(tmp)
}

val __get_CCSIDR_EL1 : CCSIDR_EL1_Type -> CCSIDR_EL1_Type

function __get_CCSIDR_EL1 value_name = {
    tmp : CCSIDR_EL1_Type = value_name;
    let tmp : CCSIDR_EL1_Type = Mk_CCSIDR_EL1_Type(tmp.bits & not_vec(0xff00000000000000));
    return(tmp)
}

val __get_VMECID_P_EL2 : VMECID_P_EL2_Type -> VMECID_P_EL2_Type

function __get_VMECID_P_EL2 value_name = {
    tmp : VMECID_P_EL2_Type = value_name;
    let tmp : VMECID_P_EL2_Type = Mk_VMECID_P_EL2_Type(tmp.bits & not_vec(0xffffffffffff0000));
    return(tmp)
}

val __get_OSECCR_EL1 : OSECCR_EL1_Type -> OSECCR_EL1_Type

function __get_OSECCR_EL1 value_name = {
    tmp : OSECCR_EL1_Type = value_name;
    let tmp : OSECCR_EL1_Type = Mk_OSECCR_EL1_Type(tmp.bits & not_vec(0xffffffff00000000));
    return(tmp)
}

val __get_DBGVCR32_EL2 : DBGVCR32_EL2_Type -> DBGVCR32_EL2_Type

function __get_DBGVCR32_EL2 value_name = {
    tmp : DBGVCR32_EL2_Type = value_name;
    let tmp : DBGVCR32_EL2_Type = Mk_DBGVCR32_EL2_Type(tmp.bits & not_vec(0xffffffff21ff2321));
    return(tmp)
}

val __get_HFGRTR_EL2 : HFGRTR_EL2_Type -> HFGRTR_EL2_Type

function __get_HFGRTR_EL2 value_name = {
    tmp : HFGRTR_EL2_Type = value_name;
    let tmp : HFGRTR_EL2_Type = Mk_HFGRTR_EL2_Type(tmp.bits & not_vec(ZeroExtend(0x8000000000000, 64)));
    return(tmp)
}

val __get_CPTR_EL2 : CPTR_EL2_Type -> CPTR_EL2_Type

function __get_CPTR_EL2 value_name = {
    tmp : CPTR_EL2_Type = value_name;
    let tmp : CPTR_EL2_Type = Mk_CPTR_EL2_Type(tmp.bits & not_vec(0xffffffff0ccc4000));
    return(tmp)
}

val __get_CLIDR_EL1 : CLIDR_EL1_Type -> CLIDR_EL1_Type

function __get_CLIDR_EL1 value_name = {
    tmp : CLIDR_EL1_Type = value_name;
    let tmp : CLIDR_EL1_Type = Mk_CLIDR_EL1_Type(tmp.bits & not_vec(0xffff800000000000));
    return(tmp)
}

val __get_HCRX_EL2 : HCRX_EL2_Type -> HCRX_EL2_Type

function __get_HCRX_EL2 value_name = {
    tmp : HCRX_EL2_Type = value_name;
    let tmp : HCRX_EL2_Type = Mk_HCRX_EL2_Type(tmp.bits & not_vec(0xffffffffff803000));
    return(tmp)
}

val __get_ICV_IGRPEN1_EL1 : ICV_IGRPEN1_EL1_Type -> ICV_IGRPEN1_EL1_Type

function __get_ICV_IGRPEN1_EL1 value_name = {
    tmp : ICV_IGRPEN1_EL1_Type = value_name;
    let tmp : ICV_IGRPEN1_EL1_Type = Mk_ICV_IGRPEN1_EL1_Type(tmp.bits & not_vec(0xfffffffffffffffe));
    return(tmp)
}

val __get_HFGWTR2_EL2 : HFGWTR2_EL2_Type -> HFGWTR2_EL2_Type

function __get_HFGWTR2_EL2 value_name = {
    tmp : HFGWTR2_EL2_Type = value_name;
    let tmp : HFGWTR2_EL2_Type = Mk_HFGWTR2_EL2_Type(tmp.bits & not_vec(0xfffffffffffffffa));
    return(tmp)
}

val __get_MECID_P1_EL2 : MECID_P1_EL2_Type -> MECID_P1_EL2_Type

function __get_MECID_P1_EL2 value_name = {
    tmp : MECID_P1_EL2_Type = value_name;
    let tmp : MECID_P1_EL2_Type = Mk_MECID_P1_EL2_Type(tmp.bits & not_vec(0xffffffffffff0000));
    return(tmp)
}

val __get_SPMSELR_EL0 : SPMSELR_EL0_Type -> SPMSELR_EL0_Type

function __get_SPMSELR_EL0 value_name = {
    tmp : SPMSELR_EL0_Type = value_name;
    let tmp : SPMSELR_EL0_Type = Mk_SPMSELR_EL0_Type(tmp.bits & not_vec(0xfffffffffffffc0c));
    return(tmp)
}

val __get_DBGAUTHSTATUS_EL1 : DBGAUTHSTATUS_EL1_Type -> DBGAUTHSTATUS_EL1_Type

function __get_DBGAUTHSTATUS_EL1 value_name = {
    tmp : DBGAUTHSTATUS_EL1_Type = value_name;
    let tmp : DBGAUTHSTATUS_EL1_Type = Mk_DBGAUTHSTATUS_EL1_Type(tmp.bits & not_vec(0xfffffffff0ff0f00));
    return(tmp)
}

val __get_SCR_EL3 : SCR_EL3_Type -> SCR_EL3_Type

function __get_SCR_EL3 value_name = {
    tmp : SCR_EL3_Type = value_name;
    tmp : SCR_EL3_Type = Mk_SCR_EL3_Type(tmp.bits & not_vec(0xb744000001c00040) | ZeroExtend(0x30, 64));
    if not_bool(HaveAArch32EL(EL1) | HaveAArch32EL(EL2)) then {
        tmp = Mk_SCR_EL3_Type(tmp.bits & not_vec(ZeroExtend(0x0, 64)) | ZeroExtend(0x400, 64))
    };
    return(tmp)
}

val __get_ICC_SRE_EL3 : ICC_SRE_EL3_Type -> ICC_SRE_EL3_Type

function __get_ICC_SRE_EL3 value_name = {
    tmp : ICC_SRE_EL3_Type = value_name;
    let tmp : ICC_SRE_EL3_Type = Mk_ICC_SRE_EL3_Type(tmp.bits & not_vec(0xfffffffffffffff0));
    return(tmp)
}

val __get_HDFGWTR_EL2 : HDFGWTR_EL2_Type -> HDFGWTR_EL2_Type

function __get_HDFGWTR_EL2 value_name = {
    tmp : HDFGWTR_EL2_Type = value_name;
    let tmp : HDFGWTR_EL2_Type = Mk_HDFGWTR_EL2_Type(tmp.bits & not_vec(0x8dfc89c440400240));
    return(tmp)
}

val __get_CNTPS_TVAL_EL1 : CNTPS_TVAL_EL1_Type -> CNTPS_TVAL_EL1_Type

function __get_CNTPS_TVAL_EL1 value_name = {
    tmp : CNTPS_TVAL_EL1_Type = value_name;
    let tmp : CNTPS_TVAL_EL1_Type = Mk_CNTPS_TVAL_EL1_Type(tmp.bits & not_vec(0xffffffff00000000));
    return(tmp)
}

val __get_ID_AA64AFR1_EL1 : ID_AA64AFR1_EL1_Type -> ID_AA64AFR1_EL1_Type

function __get_ID_AA64AFR1_EL1 value_name = {
    tmp : ID_AA64AFR1_EL1_Type = value_name;
    let tmp : ID_AA64AFR1_EL1_Type = tmp & not_vec(0xffffffffffffffff);
    return(tmp)
}

val __get_ICV_AP1R_EL1 : ICV_AP1R_EL1_Type -> ICV_AP1R_EL1_Type

function __get_ICV_AP1R_EL1 value_name = {
    tmp : ICV_AP1R_EL1_Type = value_name;
    let tmp : ICV_AP1R_EL1_Type = Mk_ICV_AP1R_EL1_Type(tmp.bits & not_vec(0x7fffffff00000000));
    return(tmp)
}

val __get_LOREA_EL1 : LOREA_EL1_Type -> LOREA_EL1_Type

function __get_LOREA_EL1 value_name = {
    tmp : LOREA_EL1_Type = value_name;
    let tmp : LOREA_EL1_Type = Mk_LOREA_EL1_Type(tmp.bits & not_vec(0xff0000000000ffff));
    return(tmp)
}

val __get_CNTV_TVAL_EL0 : CNTV_TVAL_EL0_Type -> CNTV_TVAL_EL0_Type

function __get_CNTV_TVAL_EL0 value_name = {
    tmp : CNTV_TVAL_EL0_Type = value_name;
    let tmp : CNTV_TVAL_EL0_Type = Mk_CNTV_TVAL_EL0_Type(tmp.bits & not_vec(0xffffffff00000000));
    return(tmp)
}

val __get_ICC_IAR1_EL1 : ICC_IAR1_EL1_Type -> ICC_IAR1_EL1_Type

function __get_ICC_IAR1_EL1 value_name = {
    tmp : ICC_IAR1_EL1_Type = value_name;
    let tmp : ICC_IAR1_EL1_Type = Mk_ICC_IAR1_EL1_Type(tmp.bits & not_vec(0xffffffffff000000));
    return(tmp)
}

val __get_MPIDR_EL1 : MPIDR_EL1_Type -> MPIDR_EL1_Type

function __get_MPIDR_EL1 value_name = {
    tmp : MPIDR_EL1_Type = value_name;
    let tmp : MPIDR_EL1_Type = Mk_MPIDR_EL1_Type(tmp.bits & not_vec(0xffffff003e000000) | ZeroExtend(0x80000000, 64));
    return(tmp)
}

val __get_DBGCLAIMCLR_EL1 : DBGCLAIMCLR_EL1_Type -> DBGCLAIMCLR_EL1_Type

function __get_DBGCLAIMCLR_EL1 value_name = {
    tmp : DBGCLAIMCLR_EL1_Type = value_name;
    let tmp : DBGCLAIMCLR_EL1_Type = Mk_DBGCLAIMCLR_EL1_Type(tmp.bits & not_vec(0xffffffffffffff00));
    return(tmp)
}

val __get_DBGWVR_EL1 : DBGWVR_EL1_Type -> DBGWVR_EL1_Type

function __get_DBGWVR_EL1 value_name = {
    tmp : DBGWVR_EL1_Type = value_name;
    let tmp : DBGWVR_EL1_Type = Mk_DBGWVR_EL1_Type(tmp.bits & not_vec(ZeroExtend(0x3, 64)));
    return(tmp)
}

val __get_ICV_HPPIR1_EL1 : ICV_HPPIR1_EL1_Type -> ICV_HPPIR1_EL1_Type

function __get_ICV_HPPIR1_EL1 value_name = {
    tmp : ICV_HPPIR1_EL1_Type = value_name;
    let tmp : ICV_HPPIR1_EL1_Type = Mk_ICV_HPPIR1_EL1_Type(tmp.bits & not_vec(0xffffffffff000000));
    return(tmp)
}

val __get_ID_AA64AFR0_EL1 : ID_AA64AFR0_EL1_Type -> ID_AA64AFR0_EL1_Type

function __get_ID_AA64AFR0_EL1 value_name = {
    tmp : ID_AA64AFR0_EL1_Type = value_name;
    let tmp : ID_AA64AFR0_EL1_Type = tmp & not_vec(0xffffffff00000000);
    return(tmp)
}

val __get_CNTHV_CTL_EL2 : CNTHV_CTL_EL2_Type -> CNTHV_CTL_EL2_Type

function __get_CNTHV_CTL_EL2 value_name = {
    tmp : CNTHV_CTL_EL2_Type = value_name;
    let tmp : CNTHV_CTL_EL2_Type = Mk_CNTHV_CTL_EL2_Type(tmp.bits & not_vec(0xfffffffffffffff8));
    return(tmp)
}

val __get_ID_AA64ZFR0_EL1 : ID_AA64ZFR0_EL1_Type -> ID_AA64ZFR0_EL1_Type

function __get_ID_AA64ZFR0_EL1 value_name = {
    tmp : ID_AA64ZFR0_EL1_Type = value_name;
    let tmp : ID_AA64ZFR0_EL1_Type = Mk_ID_AA64ZFR0_EL1_Type(tmp.bits & not_vec(0xf00f00f0f000ff00));
    return(tmp)
}

val __get_DBGDSAR : DBGDSAR_Type -> DBGDSAR_Type

function __get_DBGDSAR value_name = {
    tmp : DBGDSAR_Type = value_name;
    let tmp : DBGDSAR_Type = tmp & not_vec(0xffffffffffffffff);
    return(tmp)
}

val __get_DBGDRAR : DBGDRAR_Type -> DBGDRAR_Type

function __get_DBGDRAR value_name = {
    tmp : DBGDRAR_Type = value_name;
    let tmp : DBGDRAR_Type = Mk_DBGDRAR_Type(tmp.bits & not_vec(0xff00000000000ffc));
    return(tmp)
}

val __get_ZCR_EL3 : ZCR_EL3_Type -> ZCR_EL3_Type

function __get_ZCR_EL3 value_name = {
    tmp : ZCR_EL3_Type = value_name;
    let tmp : ZCR_EL3_Type = Mk_ZCR_EL3_Type(tmp.bits & not_vec(0xfffffffffffffff0));
    return(tmp)
}

val __get_ZCR_EL1 : ZCR_EL1_Type -> ZCR_EL1_Type

function __get_ZCR_EL1 value_name = {
    tmp : ZCR_EL1_Type = value_name;
    let tmp : ZCR_EL1_Type = Mk_ZCR_EL1_Type(tmp.bits & not_vec(0xfffffffffffffff0));
    return(tmp)
}

val __get_ZCR_EL2 : ZCR_EL2_Type -> ZCR_EL2_Type

function __get_ZCR_EL2 value_name = {
    tmp : ZCR_EL2_Type = value_name;
    let tmp : ZCR_EL2_Type = Mk_ZCR_EL2_Type(tmp.bits & not_vec(0xfffffffffffffff0));
    return(tmp)
}

val __get_SMCR_EL3 : SMCR_EL3_Type -> SMCR_EL3_Type

function __get_SMCR_EL3 value_name = {
    tmp : SMCR_EL3_Type = value_name;
    let tmp : SMCR_EL3_Type = Mk_SMCR_EL3_Type(tmp.bits & not_vec(0xffffffff3ffffff0));
    return(tmp)
}

val __get_SMCR_EL1 : SMCR_EL1_Type -> SMCR_EL1_Type

function __get_SMCR_EL1 value_name = {
    tmp : SMCR_EL1_Type = value_name;
    let tmp : SMCR_EL1_Type = Mk_SMCR_EL1_Type(tmp.bits & not_vec(0xffffffff3ffffff0));
    return(tmp)
}

val __get_SMCR_EL2 : SMCR_EL2_Type -> SMCR_EL2_Type

function __get_SMCR_EL2 value_name = {
    tmp : SMCR_EL2_Type = value_name;
    let tmp : SMCR_EL2_Type = Mk_SMCR_EL2_Type(tmp.bits & not_vec(0xffffffff3ffffff0));
    return(tmp)
}

val __get_ID_AA64SMFR0_EL1 : ID_AA64SMFR0_EL1_Type -> ID_AA64SMFR0_EL1_Type

function __get_ID_AA64SMFR0_EL1 value_name = {
    tmp : ID_AA64SMFR0_EL1_Type = value_name;
    let tmp : ID_AA64SMFR0_EL1_Type = Mk_ID_AA64SMFR0_EL1_Type(tmp.bits & not_vec(0x700e0300ffffffff));
    return(tmp)
}

val __get_MPAMHCR_EL2 : MPAMHCR_EL2_Type -> MPAMHCR_EL2_Type

function __get_MPAMHCR_EL2 value_name = {
    tmp : MPAMHCR_EL2_Type = value_name;
    let tmp : MPAMHCR_EL2_Type = Mk_MPAMHCR_EL2_Type(tmp.bits & not_vec(0xffffffff7ffffefc));
    return(tmp)
}

val __get_MPAMIDR_EL1 : MPAMIDR_EL1_Type -> MPAMIDR_EL1_Type

function __get_MPAMIDR_EL1 value_name = {
    tmp : MPAMIDR_EL1_Type = value_name;
    tmp : MPAMIDR_EL1_Type = Mk_MPAMIDR_EL1_Type(tmp.bits & not_vec(0xc1ffff00ffe10000));
    if not_bool(MPAMIDR_EL1[HAS_HCR] == 0b1) then {
        tmp = Mk_MPAMIDR_EL1_Type(tmp.bits & not_vec(ZeroExtend(0x1c0000, 64)))
    };
    return(tmp)
}

val __get_MPAM2_EL2 : MPAM2_EL2_Type -> MPAM2_EL2_Type

function __get_MPAM2_EL2 value_name = {
    tmp : MPAM2_EL2_Type = value_name;
    let tmp : MPAM2_EL2_Type = Mk_MPAM2_EL2_Type(tmp.bits & not_vec(0x7a38000000000000));
    return(tmp)
}

val __get_MPAM3_EL3 : MPAM3_EL3_Type -> MPAM3_EL3_Type

function __get_MPAM3_EL3 value_name = {
    tmp : MPAM3_EL3_Type = value_name;
    let tmp : MPAM3_EL3_Type = Mk_MPAM3_EL3_Type(tmp.bits & not_vec(ZeroExtend(0xc6f000000000000, 64)));
    return(tmp)
}

val __get_MPAM0_EL1 : MPAM0_EL1_Type -> MPAM0_EL1_Type

function __get_MPAM0_EL1 value_name = {
    tmp : MPAM0_EL1_Type = value_name;
    let tmp : MPAM0_EL1_Type = Mk_MPAM0_EL1_Type(tmp.bits & not_vec(0xffff000000000000));
    return(tmp)
}

val __get_MPAMSM_EL1 : MPAMSM_EL1_Type -> MPAMSM_EL1_Type

function __get_MPAMSM_EL1 value_name = {
    tmp : MPAMSM_EL1_Type = value_name;
    let tmp : MPAMSM_EL1_Type = Mk_MPAMSM_EL1_Type(tmp.bits & not_vec(0xffff00ff0000ffff));
    return(tmp)
}

val __get_MPAM1_EL1 : MPAM1_EL1_Type -> MPAM1_EL1_Type

function __get_MPAM1_EL1 value_name = {
    tmp : MPAM1_EL1_Type = value_name;
    let tmp : MPAM1_EL1_Type = Mk_MPAM1_EL1_Type(tmp.bits & not_vec(0x6fbf000000000000));
    return(tmp)
}

val __get_MPAMVPMV_EL2 : MPAMVPMV_EL2_Type -> MPAMVPMV_EL2_Type

function __get_MPAMVPMV_EL2 value_name = {
    tmp : MPAMVPMV_EL2_Type = value_name;
    let tmp : MPAMVPMV_EL2_Type = Mk_MPAMVPMV_EL2_Type(tmp.bits & not_vec(0xffffffff00000000));
    return(tmp)
}

val __get_GMID_EL1 : GMID_EL1_Type -> GMID_EL1_Type

function __get_GMID_EL1 value_name = {
    tmp : GMID_EL1_Type = value_name;
    let tmp : GMID_EL1_Type = Mk_GMID_EL1_Type(tmp.bits & not_vec(0xfffffffffffffff0));
    return(tmp)
}

val __get_TFSR_EL3 : TFSR_EL3_Type -> TFSR_EL3_Type

function __get_TFSR_EL3 value_name = {
    tmp : TFSR_EL3_Type = value_name;
    let tmp : TFSR_EL3_Type = Mk_TFSR_EL3_Type(tmp.bits & not_vec(0xfffffffffffffffe));
    return(tmp)
}

val __get_TFSRE0_EL1 : TFSRE0_EL1_Type -> TFSRE0_EL1_Type

function __get_TFSRE0_EL1 value_name = {
    tmp : TFSRE0_EL1_Type = value_name;
    let tmp : TFSRE0_EL1_Type = Mk_TFSRE0_EL1_Type(tmp.bits & not_vec(0xfffffffffffffffc));
    return(tmp)
}

val __get_TFSR_EL2 : TFSR_EL2_Type -> TFSR_EL2_Type

function __get_TFSR_EL2 value_name = {
    tmp : TFSR_EL2_Type = value_name;
    let tmp : TFSR_EL2_Type = Mk_TFSR_EL2_Type(tmp.bits & not_vec(0xfffffffffffffffc));
    return(tmp)
}

val __get_TFSR_EL1 : TFSR_EL1_Type -> TFSR_EL1_Type

function __get_TFSR_EL1 value_name = {
    tmp : TFSR_EL1_Type = value_name;
    let tmp : TFSR_EL1_Type = Mk_TFSR_EL1_Type(tmp.bits & not_vec(0xfffffffffffffffc));
    return(tmp)
}

val __get_RGSR_EL1 : RGSR_EL1_Type -> RGSR_EL1_Type

function __get_RGSR_EL1 value_name = {
    tmp : RGSR_EL1_Type = value_name;
    let tmp : RGSR_EL1_Type = Mk_RGSR_EL1_Type(tmp.bits & not_vec(0xff000000000000f0));
    return(tmp)
}

val __get_GCR_EL1 : GCR_EL1_Type -> GCR_EL1_Type

function __get_GCR_EL1 value_name = {
    tmp : GCR_EL1_Type = value_name;
    let tmp : GCR_EL1_Type = Mk_GCR_EL1_Type(tmp.bits & not_vec(0xfffffffffffe0000));
    return(tmp)
}

val __get_AMCR_EL0 : AMCR_EL0_Type -> AMCR_EL0_Type

function __get_AMCR_EL0 value_name = {
    tmp : AMCR_EL0_Type = value_name;
    let tmp : AMCR_EL0_Type = Mk_AMCR_EL0_Type(tmp.bits & not_vec(0xfffffffffffdfbff));
    return(tmp)
}

val __get_AMCNTENSET0_EL0 : AMCNTENSET0_EL0_Type -> AMCNTENSET0_EL0_Type

function __get_AMCNTENSET0_EL0 value_name = {
    tmp : AMCNTENSET0_EL0_Type = value_name;
    let tmp : AMCNTENSET0_EL0_Type = Mk_AMCNTENSET0_EL0_Type(tmp.bits & not_vec(0xfffffffffffffff0));
    return(tmp)
}

val __get_AMCNTENCLR0_EL0 : AMCNTENCLR0_EL0_Type -> AMCNTENCLR0_EL0_Type

function __get_AMCNTENCLR0_EL0 value_name = {
    tmp : AMCNTENCLR0_EL0_Type = value_name;
    let tmp : AMCNTENCLR0_EL0_Type = Mk_AMCNTENCLR0_EL0_Type(tmp.bits & not_vec(0xfffffffffffffff0));
    return(tmp)
}

val __get_AMEVTYPER0_EL0 : AMEVTYPER0_EL0_Type -> AMEVTYPER0_EL0_Type

function __get_AMEVTYPER0_EL0 value_name = {
    tmp : AMEVTYPER0_EL0_Type = value_name;
    let tmp : AMEVTYPER0_EL0_Type = Mk_AMEVTYPER0_EL0_Type(tmp.bits & not_vec(0xffffffffffff0000));
    return(tmp)
}

val __get_AMCNTENSET1_EL0 : AMCNTENSET1_EL0_Type -> AMCNTENSET1_EL0_Type

function __get_AMCNTENSET1_EL0 value_name = {
    tmp : AMCNTENSET1_EL0_Type = value_name;
    let tmp : AMCNTENSET1_EL0_Type = Mk_AMCNTENSET1_EL0_Type(tmp.bits & not_vec(0xffffffffffff0000));
    return(tmp)
}

val __get_AMCNTENCLR1_EL0 : AMCNTENCLR1_EL0_Type -> AMCNTENCLR1_EL0_Type

function __get_AMCNTENCLR1_EL0 value_name = {
    tmp : AMCNTENCLR1_EL0_Type = value_name;
    let tmp : AMCNTENCLR1_EL0_Type = Mk_AMCNTENCLR1_EL0_Type(tmp.bits & not_vec(0xffffffffffff0000));
    return(tmp)
}

val __get_AMCFGR_EL0 : AMCFGR_EL0_Type -> AMCFGR_EL0_Type

function __get_AMCFGR_EL0 value_name = {
    tmp : AMCFGR_EL0_Type = value_name;
    let tmp : AMCFGR_EL0_Type = Mk_AMCFGR_EL0_Type(tmp.bits & not_vec(0xffffffff0effc000));
    return(tmp)
}

val __get_AMUSERENR_EL0 : AMUSERENR_EL0_Type -> AMUSERENR_EL0_Type

function __get_AMUSERENR_EL0 value_name = {
    tmp : AMUSERENR_EL0_Type = value_name;
    let tmp : AMUSERENR_EL0_Type = Mk_AMUSERENR_EL0_Type(tmp.bits & not_vec(0xfffffffffffffffe));
    return(tmp)
}

val __get_AMCG1IDR_EL0 : AMCG1IDR_EL0_Type -> AMCG1IDR_EL0_Type

function __get_AMCG1IDR_EL0 value_name = {
    tmp : AMCG1IDR_EL0_Type = value_name;
    let tmp : AMCG1IDR_EL0_Type = Mk_AMCG1IDR_EL0_Type(tmp.bits & not_vec(0xffffffff00000000));
    return(tmp)
}

val __get_AMEVTYPER1_EL0 : AMEVTYPER1_EL0_Type -> AMEVTYPER1_EL0_Type

function __get_AMEVTYPER1_EL0 value_name = {
    tmp : AMEVTYPER1_EL0_Type = value_name;
    let tmp : AMEVTYPER1_EL0_Type = Mk_AMEVTYPER1_EL0_Type(tmp.bits & not_vec(0xffffffffffff0000));
    return(tmp)
}

val __get_AMCGCR_EL0 : AMCGCR_EL0_Type -> AMCGCR_EL0_Type

function __get_AMCGCR_EL0 value_name = {
    tmp : AMCGCR_EL0_Type = value_name;
    let tmp : AMCGCR_EL0_Type = Mk_AMCGCR_EL0_Type(tmp.bits & not_vec(0xffffffffffff0000));
    return(tmp)
}

val __get_PMSFCR_EL1 : PMSFCR_EL1_Type -> PMSFCR_EL1_Type

function __get_PMSFCR_EL1 value_name = {
    tmp : PMSFCR_EL1_Type = value_name;
    let tmp : PMSFCR_EL1_Type = Mk_PMSFCR_EL1_Type(tmp.bits & not_vec(0xfffffffffff8ffe0));
    return(tmp)
}

val __get_PMSIRR_EL1 : PMSIRR_EL1_Type -> PMSIRR_EL1_Type

function __get_PMSIRR_EL1 value_name = {
    tmp : PMSIRR_EL1_Type = value_name;
    let tmp : PMSIRR_EL1_Type = Mk_PMSIRR_EL1_Type(tmp.bits & not_vec(0xffffffff000000fe));
    return(tmp)
}

val __get_PMSICR_EL1 : PMSICR_EL1_Type -> PMSICR_EL1_Type

function __get_PMSICR_EL1 value_name = {
    tmp : PMSICR_EL1_Type = value_name;
    let tmp : PMSICR_EL1_Type = Mk_PMSICR_EL1_Type(tmp.bits & not_vec(ZeroExtend(0xffffff00000000, 64)));
    return(tmp)
}

val __get_PMSDSFR_EL1 : PMSDSFR_EL1_Type -> PMSDSFR_EL1_Type

function __get_PMSDSFR_EL1 value_name = {
    tmp : PMSDSFR_EL1_Type = value_name;
    if not_bool(__IMPDEF_boolean("filtering on Data Source [m] is supported")) then {
        tmp = Mk_PMSDSFR_EL1_Type(tmp.bits & not_vec(0xffffffffffffffff))
    };
    return(tmp)
}

val __get_PMSEVFR_EL1 : PMSEVFR_EL1_Type -> PMSEVFR_EL1_Type

function __get_PMSEVFR_EL1 value_name = {
    tmp : PMSEVFR_EL1_Type = value_name;
    tmp : PMSEVFR_EL1_Type = Mk_PMSEVFR_EL1_Type(tmp.bits & not_vec(ZeroExtend(0xffff00000001, 64)));
    if not_bool(IsFeatureImplemented(FEAT_SPEv1p4) | __IMPDEF_boolean("filtering on event 2 is optionally supported")) then {
        tmp = Mk_PMSEVFR_EL1_Type(tmp.bits & not_vec(ZeroExtend(0x4, 64)))
    };
    if not_bool(IsFeatureImplemented(FEAT_SPEv1p4) | __IMPDEF_boolean("filtering on event 4 is optionally supported")) then {
        tmp = Mk_PMSEVFR_EL1_Type(tmp.bits & not_vec(ZeroExtend(0x10, 64)))
    };
    if not_bool(IsFeatureImplemented(FEAT_SPEv1p2)) then {
        tmp = Mk_PMSEVFR_EL1_Type(tmp.bits & not_vec(ZeroExtend(0x40, 64)))
    };
    if not_bool((IsFeatureImplemented(FEAT_SPEv1p4) | __IMPDEF_boolean("filtering on event 8 is optionally supported")) & __IMPDEF_boolean("event 8 is implemented")) then {
        tmp = Mk_PMSEVFR_EL1_Type(tmp.bits & not_vec(ZeroExtend(0x100, 64)))
    };
    if not_bool((IsFeatureImplemented(FEAT_SPEv1p4) | __IMPDEF_boolean("filtering on event 9 is optionally supported")) & __IMPDEF_boolean("event 9 is implemented")) then {
        tmp = Mk_PMSEVFR_EL1_Type(tmp.bits & not_vec(ZeroExtend(0x200, 64)))
    };
    if not_bool((IsFeatureImplemented(FEAT_SPEv1p4) | __IMPDEF_boolean("filtering on event 10 is optionally supported")) & __IMPDEF_boolean("event 10 is implemented")) then {
        tmp = Mk_PMSEVFR_EL1_Type(tmp.bits & not_vec(ZeroExtend(0x400, 64)))
    };
    if not_bool(IsFeatureImplemented(FEAT_SPEv1p1)) then {
        tmp = Mk_PMSEVFR_EL1_Type(tmp.bits & not_vec(ZeroExtend(0x800, 64)))
    };
    if not_bool(IsFeatureImplemented(FEAT_TME)) then {
        tmp = Mk_PMSEVFR_EL1_Type(tmp.bits & not_vec(ZeroExtend(0x10000, 64)))
    };
    if not_bool(IsFeatureImplemented(FEAT_SPEv1p1) & IsFeatureImplemented(FEAT_SVE)) then {
        tmp = Mk_PMSEVFR_EL1_Type(tmp.bits & not_vec(ZeroExtend(0x60000, 64)))
    };
    if not_bool(IsFeatureImplemented(FEAT_SPEv1p4) & __IMPDEF_boolean("event 19 is implemented")) then {
        tmp = Mk_PMSEVFR_EL1_Type(tmp.bits & not_vec(ZeroExtend(0x80000, 64)))
    };
    if not_bool(IsFeatureImplemented(FEAT_SPEv1p4) & __IMPDEF_boolean("event 20 is implemented")) then {
        tmp = Mk_PMSEVFR_EL1_Type(tmp.bits & not_vec(ZeroExtend(0x100000, 64)))
    };
    if not_bool(IsFeatureImplemented(FEAT_SPEv1p4) & __IMPDEF_boolean("event 21 is implemented")) then {
        tmp = Mk_PMSEVFR_EL1_Type(tmp.bits & not_vec(ZeroExtend(0x200000, 64)))
    };
    if not_bool(IsFeatureImplemented(FEAT_SPEv1p4) & __IMPDEF_boolean("event 22 is implemented")) then {
        tmp = Mk_PMSEVFR_EL1_Type(tmp.bits & not_vec(ZeroExtend(0x400000, 64)))
    };
    if not_bool(IsFeatureImplemented(FEAT_SPEv1p4) & __IMPDEF_boolean("event 23 is implemented")) then {
        tmp = Mk_PMSEVFR_EL1_Type(tmp.bits & not_vec(ZeroExtend(0x800000, 64)))
    };
    return(tmp)
}

val __get_PMBLIMITR_EL1 : PMBLIMITR_EL1_Type -> PMBLIMITR_EL1_Type

function __get_PMBLIMITR_EL1 value_name = {
    tmp : PMBLIMITR_EL1_Type = value_name;
    let tmp : PMBLIMITR_EL1_Type = Mk_PMBLIMITR_EL1_Type(tmp.bits & not_vec(ZeroExtend(0xfd8, 64)));
    return(tmp)
}

val __get_PMBSR_EL1 : PMBSR_EL1_Type -> PMBSR_EL1_Type

function __get_PMBSR_EL1 value_name = {
    tmp : PMBSR_EL1_Type = value_name;
    let tmp : PMBSR_EL1_Type = Mk_PMBSR_EL1_Type(tmp.bits & not_vec(0xffffff1f03f00000));
    return(tmp)
}

val __get_PMSCR_EL2 : PMSCR_EL2_Type -> PMSCR_EL2_Type

function __get_PMSCR_EL2 value_name = {
    tmp : PMSCR_EL2_Type = value_name;
    let tmp : PMSCR_EL2_Type = Mk_PMSCR_EL2_Type(tmp.bits & not_vec(0xffffffffffffff04));
    return(tmp)
}

val __get_PMSCR_EL1 : PMSCR_EL1_Type -> PMSCR_EL1_Type

function __get_PMSCR_EL1 value_name = {
    tmp : PMSCR_EL1_Type = value_name;
    let tmp : PMSCR_EL1_Type = Mk_PMSCR_EL1_Type(tmp.bits & not_vec(0xffffffffffffff04));
    return(tmp)
}

val __get_PMSIDR_EL1 : PMSIDR_EL1_Type -> PMSIDR_EL1_Type

function __get_PMSIDR_EL1 value_name = {
    tmp : PMSIDR_EL1_Type = value_name;
    let tmp : PMSIDR_EL1_Type = Mk_PMSIDR_EL1_Type(tmp.bits & not_vec(0xfffffffffc000000));
    return(tmp)
}

val __get_PMSNEVFR_EL1 : PMSNEVFR_EL1_Type -> PMSNEVFR_EL1_Type

function __get_PMSNEVFR_EL1 value_name = {
    tmp : PMSNEVFR_EL1_Type = value_name;
    tmp : PMSNEVFR_EL1_Type = Mk_PMSNEVFR_EL1_Type(tmp.bits & not_vec(ZeroExtend(0xffff00000001, 64)));
    if not_bool(__IMPDEF_boolean("the PE supports sampling of speculative instructions")) then {
        tmp = Mk_PMSNEVFR_EL1_Type(tmp.bits & not_vec(ZeroExtend(0x2, 64)))
    };
    if not_bool(IsFeatureImplemented(FEAT_SPEv1p4) | __IMPDEF_boolean("filtering on event 2 is optionally supported")) then {
        tmp = Mk_PMSNEVFR_EL1_Type(tmp.bits & not_vec(ZeroExtend(0x4, 64)))
    };
    if not_bool(IsFeatureImplemented(FEAT_SPEv1p4) | __IMPDEF_boolean("filtering on event 4 is optionally supported")) then {
        tmp = Mk_PMSNEVFR_EL1_Type(tmp.bits & not_vec(ZeroExtend(0x10, 64)))
    };
    if not_bool((IsFeatureImplemented(FEAT_SPEv1p4) | __IMPDEF_boolean("filtering on event 8 is optionally supported")) & __IMPDEF_boolean("event 8 is implemented")) then {
        tmp = Mk_PMSNEVFR_EL1_Type(tmp.bits & not_vec(ZeroExtend(0x100, 64)))
    };
    if not_bool((IsFeatureImplemented(FEAT_SPEv1p4) | __IMPDEF_boolean("filtering on event 9 is optionally supported")) & __IMPDEF_boolean("event 9 is implemented")) then {
        tmp = Mk_PMSNEVFR_EL1_Type(tmp.bits & not_vec(ZeroExtend(0x200, 64)))
    };
    if not_bool((IsFeatureImplemented(FEAT_SPEv1p4) | __IMPDEF_boolean("filtering on event 10 is optionally supported")) & __IMPDEF_boolean("event 10 is implemented")) then {
        tmp = Mk_PMSNEVFR_EL1_Type(tmp.bits & not_vec(ZeroExtend(0x400, 64)))
    };
    if not_bool(IsFeatureImplemented(FEAT_SPEv1p1)) then {
        tmp = Mk_PMSNEVFR_EL1_Type(tmp.bits & not_vec(ZeroExtend(0x800, 64)))
    };
    if __IMPDEF_boolean("event 12 is not implemented, or filtering on event 12 is not supported") then {
        tmp = Mk_PMSNEVFR_EL1_Type(tmp.bits & not_vec(ZeroExtend(0x1000, 64)))
    };
    if __IMPDEF_boolean("event 13 is not implemented, or filtering on event 13 is not supported") then {
        tmp = Mk_PMSNEVFR_EL1_Type(tmp.bits & not_vec(ZeroExtend(0x2000, 64)))
    };
    if __IMPDEF_boolean("event 14 is not implemented, or filtering on event 14 is not supported") then {
        tmp = Mk_PMSNEVFR_EL1_Type(tmp.bits & not_vec(ZeroExtend(0x4000, 64)))
    };
    if __IMPDEF_boolean("event 15 is not implemented, or filtering on event 15 is not supported") then {
        tmp = Mk_PMSNEVFR_EL1_Type(tmp.bits & not_vec(ZeroExtend(0x8000, 64)))
    };
    if not_bool(IsFeatureImplemented(FEAT_TME)) then {
        tmp = Mk_PMSNEVFR_EL1_Type(tmp.bits & not_vec(ZeroExtend(0x10000, 64)))
    };
    if not_bool(IsFeatureImplemented(FEAT_SVE) & IsFeatureImplemented(FEAT_SPEv1p1)) then {
        tmp = Mk_PMSNEVFR_EL1_Type(tmp.bits & not_vec(ZeroExtend(0x60000, 64)))
    };
    if not_bool(IsFeatureImplemented(FEAT_SPEv1p4) & __IMPDEF_boolean("event 19 is implemented")) then {
        tmp = Mk_PMSNEVFR_EL1_Type(tmp.bits & not_vec(ZeroExtend(0x80000, 64)))
    };
    if not_bool(IsFeatureImplemented(FEAT_SPEv1p4) & __IMPDEF_boolean("event 20 is implemented")) then {
        tmp = Mk_PMSNEVFR_EL1_Type(tmp.bits & not_vec(ZeroExtend(0x100000, 64)))
    };
    if not_bool(IsFeatureImplemented(FEAT_SPEv1p4) & __IMPDEF_boolean("event 21 is implemented")) then {
        tmp = Mk_PMSNEVFR_EL1_Type(tmp.bits & not_vec(ZeroExtend(0x200000, 64)))
    };
    if not_bool(IsFeatureImplemented(FEAT_SPEv1p4) & __IMPDEF_boolean("event 22 is implemented")) then {
        tmp = Mk_PMSNEVFR_EL1_Type(tmp.bits & not_vec(ZeroExtend(0x400000, 64)))
    };
    if not_bool(IsFeatureImplemented(FEAT_SPEv1p4) & __IMPDEF_boolean("event 23 is implemented")) then {
        tmp = Mk_PMSNEVFR_EL1_Type(tmp.bits & not_vec(ZeroExtend(0x800000, 64)))
    };
    if __IMPDEF_boolean("event 24 is not implemented, or filtering on event 24 is not supported") then {
        tmp = Mk_PMSNEVFR_EL1_Type(tmp.bits & not_vec(ZeroExtend(0x1000000, 64)))
    };
    if __IMPDEF_boolean("event 25 is not implemented, or filtering on event 25 is not supported") then {
        tmp = Mk_PMSNEVFR_EL1_Type(tmp.bits & not_vec(ZeroExtend(0x2000000, 64)))
    };
    if __IMPDEF_boolean("event 26 is not implemented, or filtering on event 26 is not supported") then {
        tmp = Mk_PMSNEVFR_EL1_Type(tmp.bits & not_vec(ZeroExtend(0x4000000, 64)))
    };
    if __IMPDEF_boolean("event 27 is not implemented, or filtering on event 27 is not supported") then {
        tmp = Mk_PMSNEVFR_EL1_Type(tmp.bits & not_vec(ZeroExtend(0x8000000, 64)))
    };
    if __IMPDEF_boolean("event 28 is not implemented, or filtering on event 28 is not supported") then {
        tmp = Mk_PMSNEVFR_EL1_Type(tmp.bits & not_vec(ZeroExtend(0x10000000, 64)))
    };
    if __IMPDEF_boolean("event 29 is not implemented, or filtering on event 29 is not supported") then {
        tmp = Mk_PMSNEVFR_EL1_Type(tmp.bits & not_vec(ZeroExtend(0x20000000, 64)))
    };
    if __IMPDEF_boolean("event 30 is not implemented, or filtering on event 30 is not supported") then {
        tmp = Mk_PMSNEVFR_EL1_Type(tmp.bits & not_vec(ZeroExtend(0x40000000, 64)))
    };
    if __IMPDEF_boolean("event 31 is not implemented, or filtering on event 31 is not supported") then {
        tmp = Mk_PMSNEVFR_EL1_Type(tmp.bits & not_vec(ZeroExtend(0x80000000, 64)))
    };
    if __IMPDEF_boolean("event 48 is not implemented, or filtering on event 48 is not supported") then {
        tmp = Mk_PMSNEVFR_EL1_Type(tmp.bits & not_vec(ZeroExtend(0x1000000000000, 64)))
    };
    if __IMPDEF_boolean("event 49 is not implemented, or filtering on event 49 is not supported") then {
        tmp = Mk_PMSNEVFR_EL1_Type(tmp.bits & not_vec(ZeroExtend(0x2000000000000, 64)))
    };
    if __IMPDEF_boolean("event 50 is not implemented, or filtering on event 50 is not supported") then {
        tmp = Mk_PMSNEVFR_EL1_Type(tmp.bits & not_vec(ZeroExtend(0x4000000000000, 64)))
    };
    if __IMPDEF_boolean("event 51 is not implemented, or filtering on event 51 is not supported") then {
        tmp = Mk_PMSNEVFR_EL1_Type(tmp.bits & not_vec(ZeroExtend(0x8000000000000, 64)))
    };
    if __IMPDEF_boolean("event 52 is not implemented, or filtering on event 52 is not supported") then {
        tmp = Mk_PMSNEVFR_EL1_Type(tmp.bits & not_vec(ZeroExtend(0x10000000000000, 64)))
    };
    if __IMPDEF_boolean("event 53 is not implemented, or filtering on event 53 is not supported") then {
        tmp = Mk_PMSNEVFR_EL1_Type(tmp.bits & not_vec(ZeroExtend(0x20000000000000, 64)))
    };
    if __IMPDEF_boolean("event 54 is not implemented, or filtering on event 54 is not supported") then {
        tmp = Mk_PMSNEVFR_EL1_Type(tmp.bits & not_vec(ZeroExtend(0x40000000000000, 64)))
    };
    if __IMPDEF_boolean("event 55 is not implemented, or filtering on event 55 is not supported") then {
        tmp = Mk_PMSNEVFR_EL1_Type(tmp.bits & not_vec(ZeroExtend(0x80000000000000, 64)))
    };
    if __IMPDEF_boolean("event 56 is not implemented, or filtering on event 56 is not supported") then {
        tmp = Mk_PMSNEVFR_EL1_Type(tmp.bits & not_vec(ZeroExtend(0x100000000000000, 64)))
    };
    if __IMPDEF_boolean("event 57 is not implemented, or filtering on event 57 is not supported") then {
        tmp = Mk_PMSNEVFR_EL1_Type(tmp.bits & not_vec(ZeroExtend(0x200000000000000, 64)))
    };
    if __IMPDEF_boolean("event 58 is not implemented, or filtering on event 58 is not supported") then {
        tmp = Mk_PMSNEVFR_EL1_Type(tmp.bits & not_vec(ZeroExtend(0x400000000000000, 64)))
    };
    if __IMPDEF_boolean("event 59 is not implemented, or filtering on event 59 is not supported") then {
        tmp = Mk_PMSNEVFR_EL1_Type(tmp.bits & not_vec(ZeroExtend(0x800000000000000, 64)))
    };
    if __IMPDEF_boolean("event 60 is not implemented, or filtering on event 60 is not supported") then {
        tmp = Mk_PMSNEVFR_EL1_Type(tmp.bits & not_vec(0x1000000000000000))
    };
    if __IMPDEF_boolean("event 61 is not implemented, or filtering on event 61 is not supported") then {
        tmp = Mk_PMSNEVFR_EL1_Type(tmp.bits & not_vec(0x2000000000000000))
    };
    if __IMPDEF_boolean("event 62 is not implemented, or filtering on event 62 is not supported") then {
        tmp = Mk_PMSNEVFR_EL1_Type(tmp.bits & not_vec(0x4000000000000000))
    };
    if __IMPDEF_boolean("event 63 is not implemented, or filtering on event 63 is not supported") then {
        tmp = Mk_PMSNEVFR_EL1_Type(tmp.bits & not_vec(0x8000000000000000))
    };
    return(tmp)
}

val __get_PMBIDR_EL1 : PMBIDR_EL1_Type -> PMBIDR_EL1_Type

function __get_PMBIDR_EL1 value_name = {
    tmp : PMBIDR_EL1_Type = value_name;
    let tmp : PMBIDR_EL1_Type = Mk_PMBIDR_EL1_Type(tmp.bits & not_vec(0xfffffffffffff0c0));
    return(tmp)
}

val __get_PMSLATFR_EL1 : PMSLATFR_EL1_Type -> PMSLATFR_EL1_Type

function __get_PMSLATFR_EL1 value_name = {
    tmp : PMSLATFR_EL1_Type = value_name;
    let tmp : PMSLATFR_EL1_Type = Mk_PMSLATFR_EL1_Type(tmp.bits & not_vec(0xffffffffffff0000));
    return(tmp)
}

val __get_VDISR_EL2 : VDISR_EL2_Type -> VDISR_EL2_Type

function __get_VDISR_EL2 value_name = {
    tmp : VDISR_EL2_Type = value_name;
    let tmp : VDISR_EL2_Type = Mk_VDISR_EL2_Type(tmp.bits & not_vec(0xffffffff7e000000));
    return(tmp)
}

val __get_ERRIDR_EL1 : ERRIDR_EL1_Type -> ERRIDR_EL1_Type

function __get_ERRIDR_EL1 value_name = {
    tmp : ERRIDR_EL1_Type = value_name;
    let tmp : ERRIDR_EL1_Type = Mk_ERRIDR_EL1_Type(tmp.bits & not_vec(0xffffffffffff0000));
    return(tmp)
}

val __get_DISR_EL1 : DISR_EL1_Type -> DISR_EL1_Type

function __get_DISR_EL1 value_name = {
    tmp : DISR_EL1_Type = value_name;
    let tmp : DISR_EL1_Type = Mk_DISR_EL1_Type(tmp.bits & not_vec(0xffffffff7e000000));
    return(tmp)
}

val __get_ERRSELR_EL1 : ERRSELR_EL1_Type -> ERRSELR_EL1_Type

function __get_ERRSELR_EL1 value_name = {
    tmp : ERRSELR_EL1_Type = value_name;
    let tmp : ERRSELR_EL1_Type = Mk_ERRSELR_EL1_Type(tmp.bits & not_vec(0xffffffffffff0000));
    return(tmp)
}

val __get_VSESR_EL2 : VSESR_EL2_Type -> VSESR_EL2_Type

function __get_VSESR_EL2 value_name = {
    tmp : VSESR_EL2_Type = value_name;
    let tmp : VSESR_EL2_Type = Mk_VSESR_EL2_Type(tmp.bits & not_vec(0xfffffffffe000000));
    return(tmp)
}

val __get_BRBINF_EL1 : BRBINF_EL1_Type -> BRBINF_EL1_Type

function __get_BRBINF_EL1 value_name = {
    tmp : BRBINF_EL1_Type = value_name;
    let tmp : BRBINF_EL1_Type = Mk_BRBINF_EL1_Type(tmp.bits & not_vec(0xffff8000fffcc01c));
    return(tmp)
}

val __get_BRBCR_EL2 : BRBCR_EL2_Type -> BRBCR_EL2_Type

function __get_BRBCR_EL2 value_name = {
    tmp : BRBCR_EL2_Type = value_name;
    let tmp : BRBCR_EL2_Type = Mk_BRBCR_EL2_Type(tmp.bits & not_vec(0xffffffffff3ffc84));
    return(tmp)
}

val __get_BRBFCR_EL1 : BRBFCR_EL1_Type -> BRBFCR_EL1_Type

function __get_BRBFCR_EL1 value_name = {
    tmp : BRBFCR_EL1_Type = value_name;
    let tmp : BRBFCR_EL1_Type = Mk_BRBFCR_EL1_Type(tmp.bits & not_vec(0xffffffffcf80ff3f));
    return(tmp)
}

val __get_BRBINFINJ_EL1 : BRBINFINJ_EL1_Type -> BRBINFINJ_EL1_Type

function __get_BRBINFINJ_EL1 value_name = {
    tmp : BRBINFINJ_EL1_Type = value_name;
    let tmp : BRBINFINJ_EL1_Type = Mk_BRBINFINJ_EL1_Type(tmp.bits & not_vec(0xffff8000fffcc01c));
    return(tmp)
}

val __get_BRBCR_EL1 : BRBCR_EL1_Type -> BRBCR_EL1_Type

function __get_BRBCR_EL1 value_name = {
    tmp : BRBCR_EL1_Type = value_name;
    let tmp : BRBCR_EL1_Type = Mk_BRBCR_EL1_Type(tmp.bits & not_vec(0xffffffffff3ffc84));
    return(tmp)
}

val __get_BRBIDR0_EL1 : BRBIDR0_EL1_Type -> BRBIDR0_EL1_Type

function __get_BRBIDR0_EL1 value_name = {
    tmp : BRBIDR0_EL1_Type = value_name;
    let tmp : BRBIDR0_EL1_Type = Mk_BRBIDR0_EL1_Type(tmp.bits & not_vec(0xffffffffffff0000));
    return(tmp)
}

val __get_GCSPR_EL3 : GCSPR_EL3_Type -> GCSPR_EL3_Type

function __get_GCSPR_EL3 value_name = {
    tmp : GCSPR_EL3_Type = value_name;
    let tmp : GCSPR_EL3_Type = Mk_GCSPR_EL3_Type(tmp.bits & not_vec(ZeroExtend(0x7, 64)));
    return(tmp)
}

val __get_GCSPR_EL1 : GCSPR_EL1_Type -> GCSPR_EL1_Type

function __get_GCSPR_EL1 value_name = {
    tmp : GCSPR_EL1_Type = value_name;
    let tmp : GCSPR_EL1_Type = Mk_GCSPR_EL1_Type(tmp.bits & not_vec(ZeroExtend(0x7, 64)));
    return(tmp)
}

val __get_GCSCR_EL3 : GCSCR_EL3_Type -> GCSCR_EL3_Type

function __get_GCSCR_EL3 value_name = {
    tmp : GCSCR_EL3_Type = value_name;
    let tmp : GCSCR_EL3_Type = Mk_GCSCR_EL3_Type(tmp.bits & not_vec(0xfffffffffffffc9e));
    return(tmp)
}

val __get_GCSCR_EL1 : GCSCR_EL1_Type -> GCSCR_EL1_Type

function __get_GCSCR_EL1 value_name = {
    tmp : GCSCR_EL1_Type = value_name;
    let tmp : GCSCR_EL1_Type = Mk_GCSCR_EL1_Type(tmp.bits & not_vec(0xfffffffffffffc9e));
    return(tmp)
}

val __get_GCSPR_EL2 : GCSPR_EL2_Type -> GCSPR_EL2_Type

function __get_GCSPR_EL2 value_name = {
    tmp : GCSPR_EL2_Type = value_name;
    let tmp : GCSPR_EL2_Type = Mk_GCSPR_EL2_Type(tmp.bits & not_vec(ZeroExtend(0x7, 64)));
    return(tmp)
}

val __get_GCSCR_EL2 : GCSCR_EL2_Type -> GCSCR_EL2_Type

function __get_GCSCR_EL2 value_name = {
    tmp : GCSCR_EL2_Type = value_name;
    let tmp : GCSCR_EL2_Type = Mk_GCSCR_EL2_Type(tmp.bits & not_vec(0xfffffffffffffc9e));
    return(tmp)
}

val __get_GCSCRE0_EL1 : GCSCRE0_EL1_Type -> GCSCRE0_EL1_Type

function __get_GCSCRE0_EL1 value_name = {
    tmp : GCSCRE0_EL1_Type = value_name;
    let tmp : GCSCRE0_EL1_Type = Mk_GCSCRE0_EL1_Type(tmp.bits & not_vec(0xfffffffffffff8de));
    return(tmp)
}

val __get_GCSPR_EL0 : GCSPR_EL0_Type -> GCSPR_EL0_Type

function __get_GCSPR_EL0 value_name = {
    tmp : GCSPR_EL0_Type = value_name;
    let tmp : GCSPR_EL0_Type = Mk_GCSPR_EL0_Type(tmp.bits & not_vec(ZeroExtend(0x7, 64)));
    return(tmp)
}

val __get_DBGOSDLR : DBGOSDLR_Type -> DBGOSDLR_Type

function __get_DBGOSDLR value_name = {
    tmp : DBGOSDLR_Type = value_name;
    if not_bool(IsFeatureImplemented(FEAT_DoubleLock)) then {
        tmp = Mk_DBGOSDLR_Type(tmp.bits & not_vec(ZeroExtend(0x1, 32)))
    };
    let tmp : DBGOSDLR_Type = Mk_DBGOSDLR_Type(tmp.bits & not_vec(0xfffffffe));
    return(tmp)
}

val __get_ICH_ELRSR : ICH_ELRSR_Type -> ICH_ELRSR_Type

function __get_ICH_ELRSR value_name = {
    tmp : ICH_ELRSR_Type = value_name;
    let tmp : ICH_ELRSR_Type = Mk_ICH_ELRSR_Type(tmp.bits & not_vec(0xffff0000));
    return(tmp)
}

val __get_ICC_IAR1 : ICC_IAR1_Type -> ICC_IAR1_Type

function __get_ICC_IAR1 value_name = {
    tmp : ICC_IAR1_Type = value_name;
    let tmp : ICC_IAR1_Type = Mk_ICC_IAR1_Type(tmp.bits & not_vec(0xff000000));
    return(tmp)
}

val __get_JOSCR : JOSCR_Type -> JOSCR_Type

function __get_JOSCR value_name = {
    tmp : JOSCR_Type = value_name;
    let tmp : JOSCR_Type = tmp & not_vec(0xffffffff);
    return(tmp)
}

val __get_HCPTR : HCPTR_Type -> HCPTR_Type

function __get_HCPTR value_name = {
    tmp : HCPTR_Type = value_name;
    tmp : HCPTR_Type = Mk_HCPTR_Type(tmp.bits & not_vec(ZeroExtend(0xccc4000, 32)));
    if ((HaveEL(EL3) & ELUsingAArch32(EL3)) & not_bool(IsCurrentSecurityState(SS_Secure))) & NSACR[cp10] == 0b0 then {
        tmp = Mk_HCPTR_Type(tmp.bits & not_vec(ZeroExtend(0x0, 32)) | ZeroExtend(0xc00, 32))
    };
    return(tmp)
}

val __get_ICV_IGRPEN1 : ICV_IGRPEN1_Type -> ICV_IGRPEN1_Type

function __get_ICV_IGRPEN1 value_name = {
    tmp : ICV_IGRPEN1_Type = value_name;
    let tmp : ICV_IGRPEN1_Type = Mk_ICV_IGRPEN1_Type(tmp.bits & not_vec(0xfffffffe));
    return(tmp)
}

val __get_CTR : CTR_Type -> CTR_Type

function __get_CTR value_name = {
    tmp : CTR_Type = value_name;
    let tmp : CTR_Type = Mk_CTR_Type(tmp.bits & not_vec(0x40003ff0) | 0x80000000);
    return(tmp)
}

val __get_PMUSERENR : PMUSERENR_Type -> PMUSERENR_Type

function __get_PMUSERENR value_name = {
    tmp : PMUSERENR_Type = value_name;
    let tmp : PMUSERENR_Type = Mk_PMUSERENR_Type(tmp.bits & not_vec(0xffffff80));
    return(tmp)
}

val __get_DBGAUTHSTATUS : DBGAUTHSTATUS_Type -> DBGAUTHSTATUS_Type

function __get_DBGAUTHSTATUS value_name = {
    tmp : DBGAUTHSTATUS_Type = value_name;
    let tmp : DBGAUTHSTATUS_Type = Mk_DBGAUTHSTATUS_Type(tmp.bits & not_vec(0xf0ff0f00));
    return(tmp)
}

val __get_ICC_IAR0 : ICC_IAR0_Type -> ICC_IAR0_Type

function __get_ICC_IAR0 value_name = {
    tmp : ICC_IAR0_Type = value_name;
    let tmp : ICC_IAR0_Type = Mk_ICC_IAR0_Type(tmp.bits & not_vec(0xff000000));
    return(tmp)
}

val __get_ICV_IGRPEN0 : ICV_IGRPEN0_Type -> ICV_IGRPEN0_Type

function __get_ICV_IGRPEN0 value_name = {
    tmp : ICV_IGRPEN0_Type = value_name;
    let tmp : ICV_IGRPEN0_Type = Mk_ICV_IGRPEN0_Type(tmp.bits & not_vec(0xfffffffe));
    return(tmp)
}

val __get_ICV_CTLR : ICV_CTLR_Type -> ICV_CTLR_Type

function __get_ICV_CTLR value_name = {
    tmp : ICV_CTLR_Type = value_name;
    let tmp : ICV_CTLR_Type = Mk_ICV_CTLR_Type(tmp.bits & not_vec(0xfff300fc));
    return(tmp)
}

val __get_HPFAR : HPFAR_Type -> HPFAR_Type

function __get_HPFAR value_name = {
    tmp : HPFAR_Type = value_name;
    let tmp : HPFAR_Type = Mk_HPFAR_Type(tmp.bits & not_vec(ZeroExtend(0xf, 32)));
    return(tmp)
}

val __get_DBGCLAIMCLR : DBGCLAIMCLR_Type -> DBGCLAIMCLR_Type

function __get_DBGCLAIMCLR value_name = {
    tmp : DBGCLAIMCLR_Type = value_name;
    let tmp : DBGCLAIMCLR_Type = Mk_DBGCLAIMCLR_Type(tmp.bits & not_vec(0xffffff00));
    return(tmp)
}

val __get_DBGWVR : DBGWVR_Type -> DBGWVR_Type

function __get_DBGWVR value_name = {
    tmp : DBGWVR_Type = value_name;
    let tmp : DBGWVR_Type = Mk_DBGWVR_Type(tmp.bits & not_vec(ZeroExtend(0x3, 32)));
    return(tmp)
}

val __get_ICV_HPPIR1 : ICV_HPPIR1_Type -> ICV_HPPIR1_Type

function __get_ICV_HPPIR1 value_name = {
    tmp : ICV_HPPIR1_Type = value_name;
    let tmp : ICV_HPPIR1_Type = Mk_ICV_HPPIR1_Type(tmp.bits & not_vec(0xff000000));
    return(tmp)
}

val __get_HRMR : HRMR_Type -> HRMR_Type

function __get_HRMR value_name = {
    tmp : HRMR_Type = value_name;
    let tmp : HRMR_Type = Mk_HRMR_Type(tmp.bits & not_vec(0xfffffffc));
    return(tmp)
}

val __get_ICH_VTR : ICH_VTR_Type -> ICH_VTR_Type

function __get_ICH_VTR value_name = {
    tmp : ICH_VTR_Type = value_name;
    let tmp : ICH_VTR_Type = Mk_ICH_VTR_Type(tmp.bits & not_vec(ZeroExtend(0x3ffe0, 32)));
    return(tmp)
}

val __get_CSSELR : CSSELR_Type -> CSSELR_Type

function __get_CSSELR value_name = {
    tmp : CSSELR_Type = value_name;
    let tmp : CSSELR_Type = Mk_CSSELR_Type(tmp.bits & not_vec(0xffffffe0));
    return(tmp)
}

val __get_CSSELR_NS : CSSELR_Type -> CSSELR_Type

function __get_CSSELR_NS value_name = {
    tmp : CSSELR_Type = value_name;
    let tmp : CSSELR_Type = Mk_CSSELR_Type(tmp.bits & not_vec(0xffffffe0));
    return(tmp)
}

val __get_CSSELR_S : CSSELR_Type -> CSSELR_Type

function __get_CSSELR_S value_name = {
    tmp : CSSELR_Type = value_name;
    let tmp : CSSELR_Type = Mk_CSSELR_Type(tmp.bits & not_vec(0xffffffe0));
    return(tmp)
}

val __get_JIDR : JIDR_Type -> JIDR_Type

function __get_JIDR value_name = {
    tmp : JIDR_Type = value_name;
    let tmp : JIDR_Type = tmp & not_vec(0xffffffff);
    return(tmp)
}

val __get_PMCR : PMCR_Type -> PMCR_Type

function __get_PMCR value_name = {
    tmp : PMCR_Type = value_name;
    tmp : PMCR_Type = Mk_PMCR_Type(tmp.bits & not_vec(ZeroExtend(0x506, 32)));
    if not_bool(__IMPDEF_boolean("the implementation includes a PMU event export bus")) then {
        tmp = Mk_PMCR_Type(tmp.bits & not_vec(ZeroExtend(0x10, 32)))
    };
    if not_bool(not_bool(IsFeatureImplemented(FEAT_PMUv3p7))) then {
        tmp = Mk_PMCR_Type(tmp.bits & not_vec(0xff000000))
    };
    return(tmp)
}

val __get_DBGWCR : DBGWCR_Type -> DBGWCR_Type

function __get_DBGWCR value_name = {
    tmp : DBGWCR_Type = value_name;
    let tmp : DBGWCR_Type = Mk_DBGWCR_Type(tmp.bits & not_vec(ZeroExtend(0xe00000, 32)));
    return(tmp)
}

val __get_ICH_VMCR : ICH_VMCR_Type -> ICH_VMCR_Type

function __get_ICH_VMCR value_name = {
    tmp : ICH_VMCR_Type = value_name;
    let tmp : ICH_VMCR_Type = Mk_ICH_VMCR_Type(tmp.bits & not_vec(ZeroExtend(0x3fde0, 32)));
    return(tmp)
}

val __get_DBGDEVID1 : DBGDEVID1_Type -> DBGDEVID1_Type

function __get_DBGDEVID1 value_name = {
    tmp : DBGDEVID1_Type = value_name;
    let tmp : DBGDEVID1_Type = Mk_DBGDEVID1_Type(tmp.bits & not_vec(0xfffffff0));
    return(tmp)
}

val __get_ICC_BPR1 : ICC_BPR1_Type -> ICC_BPR1_Type

function __get_ICC_BPR1 value_name = {
    tmp : ICC_BPR1_Type = value_name;
    let tmp : ICC_BPR1_Type = Mk_ICC_BPR1_Type(tmp.bits & not_vec(0xfffffff8));
    return(tmp)
}

val __get_ICC_BPR1_NS : ICC_BPR1_Type -> ICC_BPR1_Type

function __get_ICC_BPR1_NS value_name = {
    tmp : ICC_BPR1_Type = value_name;
    let tmp : ICC_BPR1_Type = Mk_ICC_BPR1_Type(tmp.bits & not_vec(0xfffffff8));
    return(tmp)
}

val __get_ICC_BPR1_S : ICC_BPR1_Type -> ICC_BPR1_Type

function __get_ICC_BPR1_S value_name = {
    tmp : ICC_BPR1_Type = value_name;
    let tmp : ICC_BPR1_Type = Mk_ICC_BPR1_Type(tmp.bits & not_vec(0xfffffff8));
    return(tmp)
}

val __get_ICV_RPR : ICV_RPR_Type -> ICV_RPR_Type

function __get_ICV_RPR value_name = {
    tmp : ICV_RPR_Type = value_name;
    let tmp : ICV_RPR_Type = Mk_ICV_RPR_Type(tmp.bits & not_vec(0xffffff00));
    return(tmp)
}

val __get_VBAR : VBAR_Type -> VBAR_Type

function __get_VBAR value_name = {
    tmp : VBAR_Type = value_name;
    let tmp : VBAR_Type = tmp & not_vec(ZeroExtend(0x1f, 32));
    return(tmp)
}

val __get_VBAR_NS : VBAR_Type -> VBAR_Type

function __get_VBAR_NS value_name = {
    tmp : VBAR_Type = value_name;
    let tmp : VBAR_Type = tmp & not_vec(ZeroExtend(0x1f, 32));
    return(tmp)
}

val __get_VBAR_S : VBAR_Type -> VBAR_Type

function __get_VBAR_S value_name = {
    tmp : VBAR_Type = value_name;
    let tmp : VBAR_Type = tmp & not_vec(ZeroExtend(0x1f, 32));
    return(tmp)
}

val __get_ICV_IAR1 : ICV_IAR1_Type -> ICV_IAR1_Type

function __get_ICV_IAR1 value_name = {
    tmp : ICV_IAR1_Type = value_name;
    let tmp : ICV_IAR1_Type = Mk_ICV_IAR1_Type(tmp.bits & not_vec(0xff000000));
    return(tmp)
}

val __get_DBGPRCR : DBGPRCR_Type -> DBGPRCR_Type

function __get_DBGPRCR value_name = {
    tmp : DBGPRCR_Type = value_name;
    let tmp : DBGPRCR_Type = Mk_DBGPRCR_Type(tmp.bits & not_vec(0xfffffffe));
    return(tmp)
}

val __get_SDER : SDER_Type -> SDER_Type

function __get_SDER value_name = {
    tmp : SDER_Type = value_name;
    let tmp : SDER_Type = Mk_SDER_Type(tmp.bits & not_vec(0xfffffffc));
    return(tmp)
}

val __get_ICC_BPR0 : ICC_BPR0_Type -> ICC_BPR0_Type

function __get_ICC_BPR0 value_name = {
    tmp : ICC_BPR0_Type = value_name;
    let tmp : ICC_BPR0_Type = Mk_ICC_BPR0_Type(tmp.bits & not_vec(0xfffffff8));
    return(tmp)
}

val __get_CNTHCTL : CNTHCTL_Type -> CNTHCTL_Type

function __get_CNTHCTL value_name = {
    tmp : CNTHCTL_Type = value_name;
    let tmp : CNTHCTL_Type = Mk_CNTHCTL_Type(tmp.bits & not_vec(0xfff00000));
    return(tmp)
}

val __get_DBGVCR : DBGVCR_Type -> DBGVCR_Type

function __get_DBGVCR value_name = {
    tmp : DBGVCR_Type = value_name;
    let tmp : DBGVCR_Type = Mk_DBGVCR_Type(tmp.bits & not_vec(0x21ff2321));
    return(tmp)
}

val __get_ICV_BPR1 : ICV_BPR1_Type -> ICV_BPR1_Type

function __get_ICV_BPR1 value_name = {
    tmp : ICV_BPR1_Type = value_name;
    let tmp : ICV_BPR1_Type = Mk_ICV_BPR1_Type(tmp.bits & not_vec(0xfffffff8));
    return(tmp)
}

val __get_ICC_RPR : ICC_RPR_Type -> ICC_RPR_Type

function __get_ICC_RPR value_name = {
    tmp : ICC_RPR_Type = value_name;
    let tmp : ICC_RPR_Type = Mk_ICC_RPR_Type(tmp.bits & not_vec(0xffffff00));
    return(tmp)
}

val __get_ICC_MSRE : ICC_MSRE_Type -> ICC_MSRE_Type

function __get_ICC_MSRE value_name = {
    tmp : ICC_MSRE_Type = value_name;
    let tmp : ICC_MSRE_Type = Mk_ICC_MSRE_Type(tmp.bits & not_vec(0xfffffff0));
    return(tmp)
}

val __get_PMMIR : PMMIR_Type -> PMMIR_Type

function __get_PMMIR value_name = {
    tmp : PMMIR_Type = value_name;
    let tmp : PMMIR_Type = Mk_PMMIR_Type(tmp.bits & not_vec(0xf0000000));
    return(tmp)
}

val __get_VMPIDR : VMPIDR_Type -> VMPIDR_Type

function __get_VMPIDR value_name = {
    tmp : VMPIDR_Type = value_name;
    let tmp : VMPIDR_Type = Mk_VMPIDR_Type(tmp.bits & not_vec(0x3e000000) | 0x80000000);
    return(tmp)
}

val __get_ICC_IGRPEN1 : ICC_IGRPEN1_Type -> ICC_IGRPEN1_Type

function __get_ICC_IGRPEN1 value_name = {
    tmp : ICC_IGRPEN1_Type = value_name;
    let tmp : ICC_IGRPEN1_Type = Mk_ICC_IGRPEN1_Type(tmp.bits & not_vec(0xfffffffe));
    return(tmp)
}

val __get_ICC_IGRPEN1_NS : ICC_IGRPEN1_Type -> ICC_IGRPEN1_Type

function __get_ICC_IGRPEN1_NS value_name = {
    tmp : ICC_IGRPEN1_Type = value_name;
    let tmp : ICC_IGRPEN1_Type = Mk_ICC_IGRPEN1_Type(tmp.bits & not_vec(0xfffffffe));
    return(tmp)
}

val __get_ICC_IGRPEN1_S : ICC_IGRPEN1_Type -> ICC_IGRPEN1_Type

function __get_ICC_IGRPEN1_S value_name = {
    tmp : ICC_IGRPEN1_Type = value_name;
    let tmp : ICC_IGRPEN1_Type = Mk_ICC_IGRPEN1_Type(tmp.bits & not_vec(0xfffffffe));
    return(tmp)
}

val __get_HVBAR : HVBAR_Type -> HVBAR_Type

function __get_HVBAR value_name = {
    tmp : HVBAR_Type = value_name;
    let tmp : HVBAR_Type = tmp & not_vec(ZeroExtend(0x1f, 32));
    return(tmp)
}

val __get_HSTR : HSTR_Type -> HSTR_Type

function __get_HSTR value_name = {
    tmp : HSTR_Type = value_name;
    let tmp : HSTR_Type = Mk_HSTR_Type(tmp.bits & not_vec(0xffff4010));
    return(tmp)
}

val __get_ICC_MCTLR : ICC_MCTLR_Type -> ICC_MCTLR_Type

function __get_ICC_MCTLR value_name = {
    tmp : ICC_MCTLR_Type = value_name;
    let tmp : ICC_MCTLR_Type = Mk_ICC_MCTLR_Type(tmp.bits & not_vec(0xfff10080));
    return(tmp)
}

val __get_PMSELR : PMSELR_Type -> PMSELR_Type

function __get_PMSELR value_name = {
    tmp : PMSELR_Type = value_name;
    let tmp : PMSELR_Type = Mk_PMSELR_Type(tmp.bits & not_vec(0xffffffe0));
    return(tmp)
}

val __get_DBGCLAIMSET : DBGCLAIMSET_Type -> DBGCLAIMSET_Type

function __get_DBGCLAIMSET value_name = {
    tmp : DBGCLAIMSET_Type = value_name;
    let tmp : DBGCLAIMSET_Type = Mk_DBGCLAIMSET_Type(tmp.bits & not_vec(0xffffff00));
    return(tmp)
}

val __get_ICC_IGRPEN0 : ICC_IGRPEN0_Type -> ICC_IGRPEN0_Type

function __get_ICC_IGRPEN0 value_name = {
    tmp : ICC_IGRPEN0_Type = value_name;
    let tmp : ICC_IGRPEN0_Type = Mk_ICC_IGRPEN0_Type(tmp.bits & not_vec(0xfffffffe));
    return(tmp)
}

val __get_ICC_CTLR : ICC_CTLR_Type -> ICC_CTLR_Type

function __get_ICC_CTLR value_name = {
    tmp : ICC_CTLR_Type = value_name;
    let tmp : ICC_CTLR_Type = Mk_ICC_CTLR_Type(tmp.bits & not_vec(0xfff300bc));
    return(tmp)
}

val __get_ICC_CTLR_NS : ICC_CTLR_Type -> ICC_CTLR_Type

function __get_ICC_CTLR_NS value_name = {
    tmp : ICC_CTLR_Type = value_name;
    let tmp : ICC_CTLR_Type = Mk_ICC_CTLR_Type(tmp.bits & not_vec(0xfff300bc));
    return(tmp)
}

val __get_ICC_CTLR_S : ICC_CTLR_Type -> ICC_CTLR_Type

function __get_ICC_CTLR_S value_name = {
    tmp : ICC_CTLR_Type = value_name;
    let tmp : ICC_CTLR_Type = Mk_ICC_CTLR_Type(tmp.bits & not_vec(0xfff300bc));
    return(tmp)
}

val __get_SCR : SCR_Type -> SCR_Type

function __get_SCR value_name = {
    tmp : SCR_Type = value_name;
    let tmp : SCR_Type = Mk_SCR_Type(tmp.bits & not_vec(0xffff4c00));
    return(tmp)
}

val __get_NSACR : NSACR_Type -> NSACR_Type

function __get_NSACR value_name = {
    tmp : NSACR_Type = value_name;
    let tmp : NSACR_Type = Mk_NSACR_Type(tmp.bits & not_vec(0xffe873ff));
    return(tmp)
}

val __get_ICV_BPR0 : ICV_BPR0_Type -> ICV_BPR0_Type

function __get_ICV_BPR0 value_name = {
    tmp : ICV_BPR0_Type = value_name;
    let tmp : ICV_BPR0_Type = Mk_ICV_BPR0_Type(tmp.bits & not_vec(0xfffffff8));
    return(tmp)
}

val __get_ICH_EISR : ICH_EISR_Type -> ICH_EISR_Type

function __get_ICH_EISR value_name = {
    tmp : ICH_EISR_Type = value_name;
    let tmp : ICH_EISR_Type = Mk_ICH_EISR_Type(tmp.bits & not_vec(0xffff0000));
    return(tmp)
}

val __get_HDCR : HDCR_Type -> HDCR_Type

function __get_HDCR value_name = {
    tmp : HDCR_Type = value_name;
    let tmp : HDCR_Type = Mk_HDCR_Type(tmp.bits & not_vec(ZeroExtend(0x3750000, 32)));
    return(tmp)
}

val __get_ICC_HSRE : ICC_HSRE_Type -> ICC_HSRE_Type

function __get_ICC_HSRE value_name = {
    tmp : ICC_HSRE_Type = value_name;
    let tmp : ICC_HSRE_Type = Mk_ICC_HSRE_Type(tmp.bits & not_vec(0xfffffff0));
    return(tmp)
}

val __get_PMCCFILTR : PMCCFILTR_Type -> PMCCFILTR_Type

function __get_PMCCFILTR value_name = {
    tmp : PMCCFILTR_Type = value_name;
    let tmp : PMCCFILTR_Type = Mk_PMCCFILTR_Type(tmp.bits & not_vec(ZeroExtend(0x20fffff, 32)));
    return(tmp)
}

val __get_HTCR : HTCR_Type -> HTCR_Type

function __get_HTCR value_name = {
    tmp : HTCR_Type = value_name;
    let tmp : HTCR_Type = Mk_HTCR_Type(tmp.bits & not_vec(ZeroExtend(0x40, 32)));
    return(tmp)
}

val __get_ICC_PMR : ICC_PMR_Type -> ICC_PMR_Type

function __get_ICC_PMR value_name = {
    tmp : ICC_PMR_Type = value_name;
    let tmp : ICC_PMR_Type = Mk_ICC_PMR_Type(tmp.bits & not_vec(0xffffff00));
    return(tmp)
}

val __get_ICH_HCR : ICH_HCR_Type -> ICH_HCR_Type

function __get_ICH_HCR value_name = {
    tmp : ICH_HCR_Type = value_name;
    let tmp : ICH_HCR_Type = Mk_ICH_HCR_Type(tmp.bits & not_vec(ZeroExtend(0x7ff0200, 32)));
    return(tmp)
}

val __get_RMR : RMR_Type -> RMR_Type

function __get_RMR value_name = {
    tmp : RMR_Type = value_name;
    let tmp : RMR_Type = Mk_RMR_Type(tmp.bits & not_vec(0xfffffffc));
    return(tmp)
}

val __get_ICC_HPPIR0 : ICC_HPPIR0_Type -> ICC_HPPIR0_Type

function __get_ICC_HPPIR0 value_name = {
    tmp : ICC_HPPIR0_Type = value_name;
    let tmp : ICC_HPPIR0_Type = Mk_ICC_HPPIR0_Type(tmp.bits & not_vec(0xff000000));
    return(tmp)
}

val __get_TTBCR2 : TTBCR2_Type -> TTBCR2_Type

function __get_TTBCR2 value_name = {
    tmp : TTBCR2_Type = value_name;
    let tmp : TTBCR2_Type = Mk_TTBCR2_Type(tmp.bits & not_vec(0xc0000008));
    return(tmp)
}

val __get_TTBCR2_NS : TTBCR2_Type -> TTBCR2_Type

function __get_TTBCR2_NS value_name = {
    tmp : TTBCR2_Type = value_name;
    let tmp : TTBCR2_Type = Mk_TTBCR2_Type(tmp.bits & not_vec(0xc0000008));
    return(tmp)
}

val __get_TTBCR2_S : TTBCR2_Type -> TTBCR2_Type

function __get_TTBCR2_S value_name = {
    tmp : TTBCR2_Type = value_name;
    let tmp : TTBCR2_Type = Mk_TTBCR2_Type(tmp.bits & not_vec(0xc0000008));
    return(tmp)
}

val __get_FCSEIDR : FCSEIDR_Type -> FCSEIDR_Type

function __get_FCSEIDR value_name = {
    tmp : FCSEIDR_Type = value_name;
    let tmp : FCSEIDR_Type = tmp & not_vec(0xffffffff);
    return(tmp)
}

val __get_JMCR : JMCR_Type -> JMCR_Type

function __get_JMCR value_name = {
    tmp : JMCR_Type = value_name;
    let tmp : JMCR_Type = tmp & not_vec(0xffffffff);
    return(tmp)
}

val __get_CNTKCTL : CNTKCTL_Type -> CNTKCTL_Type

function __get_CNTKCTL value_name = {
    tmp : CNTKCTL_Type = value_name;
    let tmp : CNTKCTL_Type = Mk_CNTKCTL_Type(tmp.bits & not_vec(0xfffdfc00));
    return(tmp)
}

val __get_ICV_PMR : ICV_PMR_Type -> ICV_PMR_Type

function __get_ICV_PMR value_name = {
    tmp : ICV_PMR_Type = value_name;
    let tmp : ICV_PMR_Type = Mk_ICV_PMR_Type(tmp.bits & not_vec(0xffffff00));
    return(tmp)
}

val __get_ICV_HPPIR0 : ICV_HPPIR0_Type -> ICV_HPPIR0_Type

function __get_ICV_HPPIR0 value_name = {
    tmp : ICV_HPPIR0_Type = value_name;
    let tmp : ICV_HPPIR0_Type = Mk_ICV_HPPIR0_Type(tmp.bits & not_vec(0xff000000));
    return(tmp)
}

val __get_DBGBCR : DBGBCR_Type -> DBGBCR_Type

function __get_DBGBCR value_name = {
    tmp : DBGBCR_Type = value_name;
    let tmp : DBGBCR_Type = Mk_DBGBCR_Type(tmp.bits & not_vec(ZeroExtend(0x1e10, 32)));
    return(tmp)
}

val __get_DBGWFAR : DBGWFAR_Type -> DBGWFAR_Type

function __get_DBGWFAR value_name = {
    tmp : DBGWFAR_Type = value_name;
    let tmp : DBGWFAR_Type = tmp & not_vec(0xffffffff);
    return(tmp)
}

val __get_HSCTLR : HSCTLR_Type -> HSCTLR_Type

function __get_HSCTLR value_name = {
    tmp : HSCTLR_Type = value_name;
    tmp : HSCTLR_Type = Mk_HSCTLR_Type(tmp.bits & not_vec(ZeroExtend(0x20200, 32)));
    if not_bool(__IMPDEF_boolean("IMPLEMENTED_CP15BEN")) then {
        tmp = Mk_HSCTLR_Type(tmp.bits & not_vec(ZeroExtend(0x0, 32)) | ZeroExtend(0x20, 32))
    };
    if not_bool(__IMPDEF_boolean("IMPLEMENTED_ITD")) then {
        tmp = Mk_HSCTLR_Type(tmp.bits & not_vec(ZeroExtend(0x80, 32)))
    };
    return(tmp)
}

val __get_VTCR : VTCR_Type -> VTCR_Type

function __get_VTCR value_name = {
    tmp : VTCR_Type = value_name;
    let tmp : VTCR_Type = Mk_VTCR_Type(tmp.bits & not_vec(ZeroExtend(0x1900000, 32)) | 0x80000000);
    return(tmp)
}

val __get_ICC_MGRPEN1 : ICC_MGRPEN1_Type -> ICC_MGRPEN1_Type

function __get_ICC_MGRPEN1 value_name = {
    tmp : ICC_MGRPEN1_Type = value_name;
    let tmp : ICC_MGRPEN1_Type = Mk_ICC_MGRPEN1_Type(tmp.bits & not_vec(0xfffffffc));
    return(tmp)
}

val __get_CCSIDR2 : CCSIDR2_Type -> CCSIDR2_Type

function __get_CCSIDR2 value_name = {
    tmp : CCSIDR2_Type = value_name;
    let tmp : CCSIDR2_Type = Mk_CCSIDR2_Type(tmp.bits & not_vec(0xff000000));
    return(tmp)
}

val __get_ICH_MISR : ICH_MISR_Type -> ICH_MISR_Type

function __get_ICH_MISR value_name = {
    tmp : ICH_MISR_Type = value_name;
    let tmp : ICH_MISR_Type = Mk_ICH_MISR_Type(tmp.bits & not_vec(0xffffff00));
    return(tmp)
}

val __get_CPACR : CPACR_Type -> CPACR_Type

function __get_CPACR value_name = {
    tmp : CPACR_Type = value_name;
    tmp : CPACR_Type = Mk_CPACR_Type(tmp.bits & not_vec(0x4c0cffff));
    if ((HaveEL(EL3) & ELUsingAArch32(EL3)) & not_bool(IsCurrentSecurityState(SS_Secure))) & NSACR[cp10] == 0b0 then {
        tmp = Mk_CPACR_Type(tmp.bits & not_vec(ZeroExtend(0xf00000, 32)))
    };
    return(tmp)
}

val __get_ICV_IAR0 : ICV_IAR0_Type -> ICV_IAR0_Type

function __get_ICV_IAR0 value_name = {
    tmp : ICV_IAR0_Type = value_name;
    let tmp : ICV_IAR0_Type = Mk_ICV_IAR0_Type(tmp.bits & not_vec(0xff000000));
    return(tmp)
}

val __get_ISR : ISR_Type -> ISR_Type

function __get_ISR value_name = {
    tmp : ISR_Type = value_name;
    let tmp : ISR_Type = Mk_ISR_Type(tmp.bits & not_vec(0xfffff83f));
    return(tmp)
}

val __get_SCTLR : SCTLR_Type -> SCTLR_Type

function __get_SCTLR value_name = {
    tmp : SCTLR_Type = value_name;
    tmp : SCTLR_Type = Mk_SCTLR_Type(tmp.bits & not_vec(ZeroExtend(0x20000, 32)));
    if not_bool(__IMPDEF_boolean("IMPLEMENTED_CP15BEN")) then {
        tmp = Mk_SCTLR_Type(tmp.bits & not_vec(ZeroExtend(0x0, 32)) | ZeroExtend(0x20, 32))
    };
    if not_bool(__IMPDEF_boolean("IMPLEMENTED_ITD")) then {
        tmp = Mk_SCTLR_Type(tmp.bits & not_vec(ZeroExtend(0x80, 32)))
    };
    return(tmp)
}

val __get_SCTLR_NS : SCTLR_Type -> SCTLR_Type

function __get_SCTLR_NS value_name = {
    tmp : SCTLR_Type = value_name;
    tmp : SCTLR_Type = Mk_SCTLR_Type(tmp.bits & not_vec(ZeroExtend(0x20000, 32)));
    if not_bool(__IMPDEF_boolean("IMPLEMENTED_CP15BEN")) then {
        tmp = Mk_SCTLR_Type(tmp.bits & not_vec(ZeroExtend(0x0, 32)) | ZeroExtend(0x20, 32))
    };
    if not_bool(__IMPDEF_boolean("IMPLEMENTED_ITD")) then {
        tmp = Mk_SCTLR_Type(tmp.bits & not_vec(ZeroExtend(0x80, 32)))
    };
    return(tmp)
}

val __get_SCTLR_S : SCTLR_Type -> SCTLR_Type

function __get_SCTLR_S value_name = {
    tmp : SCTLR_Type = value_name;
    tmp : SCTLR_Type = Mk_SCTLR_Type(tmp.bits & not_vec(ZeroExtend(0x20000, 32)));
    if not_bool(__IMPDEF_boolean("IMPLEMENTED_CP15BEN")) then {
        tmp = Mk_SCTLR_Type(tmp.bits & not_vec(ZeroExtend(0x0, 32)) | ZeroExtend(0x20, 32))
    };
    if not_bool(__IMPDEF_boolean("IMPLEMENTED_ITD")) then {
        tmp = Mk_SCTLR_Type(tmp.bits & not_vec(ZeroExtend(0x80, 32)))
    };
    return(tmp)
}

val __get_DBGDSCRint : DBGDSCRint_Type -> DBGDSCRint_Type

function __get_DBGDSCRint value_name = {
    tmp : DBGDSCRint_Type = value_name;
    let tmp : DBGDSCRint_Type = Mk_DBGDSCRint_Type(tmp.bits & not_vec(0x9ff86fc3));
    return(tmp)
}

val __get_DBGDCCINT : DBGDCCINT_Type -> DBGDCCINT_Type

function __get_DBGDCCINT value_name = {
    tmp : DBGDCCINT_Type = value_name;
    let tmp : DBGDCCINT_Type = Mk_DBGDCCINT_Type(tmp.bits & not_vec(0x9fffffff));
    return(tmp)
}

val __get_DBGDSCRext : DBGDSCRext_Type -> DBGDSCRext_Type

function __get_DBGDSCRext value_name = {
    tmp : DBGDSCRext_Type = value_name;
    let tmp : DBGDSCRext_Type = Mk_DBGDSCRext_Type(tmp.bits & not_vec(0x13100f82));
    return(tmp)
}

val __get_IFSR : IFSR_Type -> IFSR_Type

function __get_IFSR value_name = {
    tmp : IFSR_Type = value_name;
    let tmp : IFSR_Type = Mk_IFSR_Type(tmp.bits & not_vec(0xfffee9c0));
    return(tmp)
}

val __get_IFSR_NS : IFSR_Type -> IFSR_Type

function __get_IFSR_NS value_name = {
    tmp : IFSR_Type = value_name;
    let tmp : IFSR_Type = Mk_IFSR_Type(tmp.bits & not_vec(0xfffee9c0));
    return(tmp)
}

val __get_IFSR_S : IFSR_Type -> IFSR_Type

function __get_IFSR_S value_name = {
    tmp : IFSR_Type = value_name;
    let tmp : IFSR_Type = Mk_IFSR_Type(tmp.bits & not_vec(0xfffee9c0));
    return(tmp)
}

val __get_DBGDIDR : DBGDIDR_Type -> DBGDIDR_Type

function __get_DBGDIDR value_name = {
    tmp : DBGDIDR_Type = value_name;
    let tmp : DBGDIDR_Type = Mk_DBGDIDR_Type(tmp.bits & not_vec(ZeroExtend(0x2fff, 32)) | ZeroExtend(0x8000, 32));
    return(tmp)
}

val __get_CNTP_CTL : CNTP_CTL_Type -> CNTP_CTL_Type

function __get_CNTP_CTL value_name = {
    tmp : CNTP_CTL_Type = value_name;
    let tmp : CNTP_CTL_Type = Mk_CNTP_CTL_Type(tmp.bits & not_vec(0xfffffff8));
    return(tmp)
}

val __get_CNTP_CTL_NS : CNTP_CTL_Type -> CNTP_CTL_Type

function __get_CNTP_CTL_NS value_name = {
    tmp : CNTP_CTL_Type = value_name;
    let tmp : CNTP_CTL_Type = Mk_CNTP_CTL_Type(tmp.bits & not_vec(0xfffffff8));
    return(tmp)
}

val __get_CNTP_CTL_S : CNTP_CTL_Type -> CNTP_CTL_Type

function __get_CNTP_CTL_S value_name = {
    tmp : CNTP_CTL_Type = value_name;
    let tmp : CNTP_CTL_Type = Mk_CNTP_CTL_Type(tmp.bits & not_vec(0xfffffff8));
    return(tmp)
}

val __get_HTRFCR : HTRFCR_Type -> HTRFCR_Type

function __get_HTRFCR value_name = {
    tmp : HTRFCR_Type = value_name;
    let tmp : HTRFCR_Type = Mk_HTRFCR_Type(tmp.bits & not_vec(0xffffff94));
    return(tmp)
}

val __get_PMEVTYPER : PMEVTYPER_Type -> PMEVTYPER_Type

function __get_PMEVTYPER value_name = {
    tmp : PMEVTYPER_Type = value_name;
    let tmp : PMEVTYPER_Type = Mk_PMEVTYPER_Type(tmp.bits & not_vec(ZeroExtend(0xf0000, 32)));
    return(tmp)
}

val __get_CNTV_CTL : CNTV_CTL_Type -> CNTV_CTL_Type

function __get_CNTV_CTL value_name = {
    tmp : CNTV_CTL_Type = value_name;
    let tmp : CNTV_CTL_Type = Mk_CNTV_CTL_Type(tmp.bits & not_vec(0xfffffff8));
    return(tmp)
}

val __get_DBGOSLSR : DBGOSLSR_Type -> DBGOSLSR_Type

function __get_DBGOSLSR value_name = {
    tmp : DBGOSLSR_Type = value_name;
    let tmp : DBGOSLSR_Type = Mk_DBGOSLSR_Type(tmp.bits & not_vec(0xfffffff0));
    return(tmp)
}

val __get_TRFCR : TRFCR_Type -> TRFCR_Type

function __get_TRFCR value_name = {
    tmp : TRFCR_Type = value_name;
    let tmp : TRFCR_Type = Mk_TRFCR_Type(tmp.bits & not_vec(0xffffff9c));
    return(tmp)
}

val __get_CNTHP_CTL : CNTHP_CTL_Type -> CNTHP_CTL_Type

function __get_CNTHP_CTL value_name = {
    tmp : CNTHP_CTL_Type = value_name;
    let tmp : CNTHP_CTL_Type = Mk_CNTHP_CTL_Type(tmp.bits & not_vec(0xfffffff8));
    return(tmp)
}

val __get_DBGDEVID2 : DBGDEVID2_Type -> DBGDEVID2_Type

function __get_DBGDEVID2 value_name = {
    tmp : DBGDEVID2_Type = value_name;
    let tmp : DBGDEVID2_Type = tmp & not_vec(0xffffffff);
    return(tmp)
}

val __get_MPIDR : MPIDR_Type -> MPIDR_Type

function __get_MPIDR value_name = {
    tmp : MPIDR_Type = value_name;
    let tmp : MPIDR_Type = Mk_MPIDR_Type(tmp.bits & not_vec(0x3e000000) | 0x80000000);
    return(tmp)
}

val __get_ICH_LRC : ICH_LRC_Type -> ICH_LRC_Type

function __get_ICH_LRC value_name = {
    tmp : ICH_LRC_Type = value_name;
    let tmp : ICH_LRC_Type = Mk_ICH_LRC_Type(tmp.bits & not_vec(ZeroExtend(0x700e000, 32)));
    return(tmp)
}

val __get_DSPSR2 : DSPSR2_Type -> DSPSR2_Type

function __get_DSPSR2 value_name = {
    tmp : DSPSR2_Type = value_name;
    let tmp : DSPSR2_Type = Mk_DSPSR2_Type(tmp.bits & not_vec(0xfffffff8));
    return(tmp)
}

val __get_ICC_HPPIR1 : ICC_HPPIR1_Type -> ICC_HPPIR1_Type

function __get_ICC_HPPIR1 value_name = {
    tmp : ICC_HPPIR1_Type = value_name;
    let tmp : ICC_HPPIR1_Type = Mk_ICC_HPPIR1_Type(tmp.bits & not_vec(0xff000000));
    return(tmp)
}

val __get_ICC_SRE : ICC_SRE_Type -> ICC_SRE_Type

function __get_ICC_SRE value_name = {
    tmp : ICC_SRE_Type = value_name;
    let tmp : ICC_SRE_Type = Mk_ICC_SRE_Type(tmp.bits & not_vec(0xfffffff8));
    return(tmp)
}

val __get_ICC_SRE_NS : ICC_SRE_Type -> ICC_SRE_Type

function __get_ICC_SRE_NS value_name = {
    tmp : ICC_SRE_Type = value_name;
    let tmp : ICC_SRE_Type = Mk_ICC_SRE_Type(tmp.bits & not_vec(0xfffffff8));
    return(tmp)
}

val __get_ICC_SRE_S : ICC_SRE_Type -> ICC_SRE_Type

function __get_ICC_SRE_S value_name = {
    tmp : ICC_SRE_Type = value_name;
    let tmp : ICC_SRE_Type = Mk_ICC_SRE_Type(tmp.bits & not_vec(0xfffffff8));
    return(tmp)
}

val __get_SDCR : SDCR_Type -> SDCR_Type

function __get_SDCR value_name = {
    tmp : SDCR_Type = value_name;
    let tmp : SDCR_Type = Mk_SDCR_Type(tmp.bits & not_vec(0xe7413fff));
    return(tmp)
}

val __get_AMEVTYPER0 : AMEVTYPER0_Type -> AMEVTYPER0_Type

function __get_AMEVTYPER0 value_name = {
    tmp : AMEVTYPER0_Type = value_name;
    let tmp : AMEVTYPER0_Type = Mk_AMEVTYPER0_Type(tmp.bits & not_vec(0xffff0000));
    return(tmp)
}

val __get_AMUSERENR : AMUSERENR_Type -> AMUSERENR_Type

function __get_AMUSERENR value_name = {
    tmp : AMUSERENR_Type = value_name;
    let tmp : AMUSERENR_Type = Mk_AMUSERENR_Type(tmp.bits & not_vec(0xfffffffe));
    return(tmp)
}

val __get_AMEVTYPER1 : AMEVTYPER1_Type -> AMEVTYPER1_Type

function __get_AMEVTYPER1 value_name = {
    tmp : AMEVTYPER1_Type = value_name;
    let tmp : AMEVTYPER1_Type = Mk_AMEVTYPER1_Type(tmp.bits & not_vec(0xffff0000));
    return(tmp)
}

val __get_AMCGCR : AMCGCR_Type -> AMCGCR_Type

function __get_AMCGCR value_name = {
    tmp : AMCGCR_Type = value_name;
    let tmp : AMCGCR_Type = Mk_AMCGCR_Type(tmp.bits & not_vec(0xffff0000));
    return(tmp)
}

val __get_AMCFGR : AMCFGR_Type -> AMCFGR_Type

function __get_AMCFGR value_name = {
    tmp : AMCFGR_Type = value_name;
    let tmp : AMCFGR_Type = Mk_AMCFGR_Type(tmp.bits & not_vec(ZeroExtend(0xeffc000, 32)));
    return(tmp)
}

val __get_AMCNTENCLR1 : AMCNTENCLR1_Type -> AMCNTENCLR1_Type

function __get_AMCNTENCLR1 value_name = {
    tmp : AMCNTENCLR1_Type = value_name;
    let tmp : AMCNTENCLR1_Type = Mk_AMCNTENCLR1_Type(tmp.bits & not_vec(0xffff0000));
    return(tmp)
}

val __get_AMCNTENSET0 : AMCNTENSET0_Type -> AMCNTENSET0_Type

function __get_AMCNTENSET0 value_name = {
    tmp : AMCNTENSET0_Type = value_name;
    let tmp : AMCNTENSET0_Type = Mk_AMCNTENSET0_Type(tmp.bits & not_vec(0xfffffff0));
    return(tmp)
}

val __get_AMCNTENCLR0 : AMCNTENCLR0_Type -> AMCNTENCLR0_Type

function __get_AMCNTENCLR0 value_name = {
    tmp : AMCNTENCLR0_Type = value_name;
    let tmp : AMCNTENCLR0_Type = Mk_AMCNTENCLR0_Type(tmp.bits & not_vec(0xfffffff0));
    return(tmp)
}

val __get_AMCNTENSET1 : AMCNTENSET1_Type -> AMCNTENSET1_Type

function __get_AMCNTENSET1 value_name = {
    tmp : AMCNTENSET1_Type = value_name;
    let tmp : AMCNTENSET1_Type = Mk_AMCNTENSET1_Type(tmp.bits & not_vec(0xffff0000));
    return(tmp)
}

val __get_AMCR : AMCR_Type -> AMCR_Type

function __get_AMCR value_name = {
    tmp : AMCR_Type = value_name;
    let tmp : AMCR_Type = Mk_AMCR_Type(tmp.bits & not_vec(0xfffdfbff));
    return(tmp)
}

val __get_ERRIDR : ERRIDR_Type -> ERRIDR_Type

function __get_ERRIDR value_name = {
    tmp : ERRIDR_Type = value_name;
    let tmp : ERRIDR_Type = Mk_ERRIDR_Type(tmp.bits & not_vec(0xffff0000));
    return(tmp)
}

val __get_ERRSELR : ERRSELR_Type -> ERRSELR_Type

function __get_ERRSELR value_name = {
    tmp : ERRSELR_Type = value_name;
    let tmp : ERRSELR_Type = Mk_ERRSELR_Type(tmp.bits & not_vec(0xffff0000));
    return(tmp)
}

val __get_DISR : DISR_Type -> DISR_Type

function __get_DISR value_name = {
    tmp : DISR_Type = value_name;
    let tmp : DISR_Type = Mk_DISR_Type(tmp.bits & not_vec(0x7e000000));
    return(tmp)
}

val __get_VDFSR : VDFSR_Type -> VDFSR_Type

function __get_VDFSR value_name = {
    tmp : VDFSR_Type = value_name;
    let tmp : VDFSR_Type = Mk_VDFSR_Type(tmp.bits & not_vec(0xfe000000));
    return(tmp)
}

val __get_VDISR : VDISR_Type -> VDISR_Type

function __get_VDISR value_name = {
    tmp : VDISR_Type = value_name;
    let tmp : VDISR_Type = Mk_VDISR_Type(tmp.bits & not_vec(0x7e000000));
    return(tmp)
}

val __get_PAR_EL1 : PAR_EL1_Type -> PAR_EL1_Type

function __get_PAR_EL1 value_name = {
    tmp : PAR_EL1_Type = value_name;
    let tmp : PAR_EL1_Type = Mk_PAR_EL1_Type(tmp.bits & not_vec(0xff00000000000ffe0000000000000000));
    return(tmp)
}

val __get_TTBR1_EL1 : TTBR1_EL1_Type -> TTBR1_EL1_Type

function __get_TTBR1_EL1 value_name = {
    tmp : TTBR1_EL1_Type = value_name;
    let tmp : TTBR1_EL1_Type = Mk_TTBR1_EL1_Type(tmp.bits & not_vec(0xffffffffff00ffff0000000000000000));
    return(tmp)
}

val __get_TTBR0_EL2 : TTBR0_EL2_Type -> TTBR0_EL2_Type

function __get_TTBR0_EL2 value_name = {
    tmp : TTBR0_EL2_Type = value_name;
    let tmp : TTBR0_EL2_Type = Mk_TTBR0_EL2_Type(tmp.bits & not_vec(0xffffffffff00ffff0000000000000000));
    return(tmp)
}

val __get_VTTBR_EL2 : VTTBR_EL2_Type -> VTTBR_EL2_Type

function __get_VTTBR_EL2 value_name = {
    tmp : VTTBR_EL2_Type = value_name;
    let tmp : VTTBR_EL2_Type = Mk_VTTBR_EL2_Type(tmp.bits & not_vec(0xffffffffff00ffff0000000000000000));
    return(tmp)
}

val __get_TTBR0_EL1 : TTBR0_EL1_Type -> TTBR0_EL1_Type

function __get_TTBR0_EL1 value_name = {
    tmp : TTBR0_EL1_Type = value_name;
    let tmp : TTBR0_EL1_Type = Mk_TTBR0_EL1_Type(tmp.bits & not_vec(0xffffffffff00ffff0000000000000000));
    return(tmp)
}

val __get_TTBR1_EL2 : TTBR1_EL2_Type -> TTBR1_EL2_Type

function __get_TTBR1_EL2 value_name = {
    tmp : TTBR1_EL2_Type = value_name;
    let tmp : TTBR1_EL2_Type = Mk_TTBR1_EL2_Type(tmp.bits & not_vec(0xffffffffff00ffff0000000000000000));
    return(tmp)
}

val ZeroUnsignedSatQ : forall 'M 'N 'i,
  (0 <= 'N - 1 & 'N - 1 < 'M).
  (int('i), int('N), int('M)) -> (bits('M), bool)

function ZeroUnsignedSatQ (i, N, M) = {
    result : int = undefined;
    saturated : bool = undefined;
    if i > pow2(N) - 1 then {
        result = pow2(N) - 1;
        saturated = true
    } else if i < 0 then {
        result = 0;
        saturated = true
    } else {
        result = i;
        saturated = false
    };
    let 'result = result;
    fullresult : bits('M) = Zeros();
    fullresult[N - 1 .. 0] = result[N - 1 .. 0];
    return((fullresult, saturated))
}

val LR_read : unit -> bits(32)

function LR_read () = {
    return(R_read(14))
}
