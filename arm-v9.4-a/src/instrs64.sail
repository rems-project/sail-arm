/******************************************************************************/
/*  BSD 3-clause Clear License                                                */
/*                                                                            */
/*  Copyright (c) 2023                                                        */
/*    Arm Limited (or its affiliates),                                        */
/*    Thomas Bauereiss,                                                       */
/*    Brian Campbell,                                                         */
/*    Alasdair Armstrong,                                                     */
/*    Alastair Reid,                                                          */
/*    Peter Sewell                                                            */
/*                                                                            */
/*  All rights reserved.                                                      */
/*                                                                            */
/*  Redistribution and use in source and binary forms, with or without        */
/*  modification, are permitted (subject to the limitations in the            */
/*  disclaimer below) provided that the following conditions are met:         */
/*                                                                            */
/*    * Redistributions of source code must retain the above copyright        */
/*      notice, this list of conditions and the following disclaimer.         */
/*    * Redistributions in binary form must reproduce the above copyright     */
/*      notice, this list of conditions and the following disclaimer in the   */
/*      documentation and/or other materials provided with the distribution.  */
/*    * Neither the name of ARM Limited nor the names of its contributors     */
/*      may be used to endorse or promote products derived from this          */
/*      software without specific prior written permission.                   */
/*                                                                            */
/*  NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED   */
/*  BY THIS LICENSE. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND   */
/*  CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,    */
/*  BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND         */
/*  FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE   */
/*  COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,      */
/*  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  */
/*  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF      */
/*  USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON    */
/*  ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT   */
/*  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  */
/*  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.         */
/******************************************************************************/

val execute_aarch64_instrs_integer_arithmetic_unary_abs : forall 'd 'datasize 'n,
  (0 <= 'n & 'n <= 31 & 'datasize in {32, 64} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('n)) -> unit

function execute_aarch64_instrs_integer_arithmetic_unary_abs (d, datasize, n) = {
    let operand1 : bits('datasize) = X_read(n, datasize);
    let 'result = Abs(SInt(operand1));
    X_set(d, datasize) = result[datasize - 1 .. 0]
}

val decode_abs_aarch64_instrs_integer_arithmetic_unary_abs : (bits(5), bits(5), bits(1)) -> unit

function decode_abs_aarch64_instrs_integer_arithmetic_unary_abs (Rd, Rn, sf) = {
    if not_bool(HaveCSSC()) then {
        throw(Error_Undefined())
    };
    let 'datasize = (32 << UInt(sf));
    let 'n = UInt(Rn);
    let 'd = UInt(Rd);
    execute_aarch64_instrs_integer_arithmetic_unary_abs(d, datasize, n)
}

function clause __DecodeA64_DataProcReg ((pc, ([_, bitone, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 1) = {
    SEE = 1;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let sf = Slice(__opcode, 31, 1);
    decode_abs_aarch64_instrs_integer_arithmetic_unary_abs(Rd, Rn, sf)
}

val execute_aarch64_instrs_vector_arithmetic_unary_diff_neg_int_sisd : forall 'd 'datasize 'elements 'esize 'n ('neg : Bool),
  (0 <= 'n & 'n <= 31 & 'esize in {8, 16, 32, 64} & 'datasize in {8, 16, 32, 64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('n), bool('neg)) -> unit

function execute_aarch64_instrs_vector_arithmetic_unary_diff_neg_int_sisd (d, datasize, elements, esize, n, neg) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('datasize) = V_read(n, datasize);
    result : bits('datasize) = undefined;
    element : int = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element = SInt(Elem_read(operand, e, esize));
        if neg then {
            element = negate(element)
        } else {
            element = Abs(element)
        };
        result = Elem_set(result, e, esize, element[esize - 1 .. 0])
    };
    V_set(d, datasize) = result
}

val decode_abs_advsimd_aarch64_instrs_vector_arithmetic_unary_diff_neg_int_sisd : (bits(5), bits(5), bits(2), bits(1)) -> unit

function decode_abs_advsimd_aarch64_instrs_vector_arithmetic_unary_diff_neg_int_sisd (Rd, Rn, size, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if size != 0b11 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    let 'datasize = esize;
    let 'elements = 1;
    let neg : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_diff_neg_int_sisd(d, datasize, elements, esize, n, neg)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 2) = {
    SEE = 2;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    decode_abs_advsimd_aarch64_instrs_vector_arithmetic_unary_diff_neg_int_sisd(Rd, Rn, size, U)
}

val decode_abs_advsimd_aarch64_instrs_vector_arithmetic_unary_diff_neg_int_simd : (bits(5), bits(5), bits(2), bits(1), bits(1)) -> unit

function decode_abs_advsimd_aarch64_instrs_vector_arithmetic_unary_diff_neg_int_simd (Rd, Rn, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (size @ Q) == 0b110 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let neg : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_diff_neg_int_sisd(d, datasize, elements, esize, n, neg)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 3) = {
    SEE = 3;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_abs_advsimd_aarch64_instrs_vector_arithmetic_unary_diff_neg_int_simd(Rd, Rn, size, U, Q)
}

val decode_neg_advsimd_aarch64_instrs_vector_arithmetic_unary_diff_neg_int_sisd : (bits(5), bits(5), bits(2), bits(1)) -> unit

function decode_neg_advsimd_aarch64_instrs_vector_arithmetic_unary_diff_neg_int_sisd (Rd, Rn, size, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if size != 0b11 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    let 'datasize = esize;
    let 'elements = 1;
    let neg : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_diff_neg_int_sisd(d, datasize, elements, esize, n, neg)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 4) = {
    SEE = 4;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    decode_neg_advsimd_aarch64_instrs_vector_arithmetic_unary_diff_neg_int_sisd(Rd, Rn, size, U)
}

val decode_neg_advsimd_aarch64_instrs_vector_arithmetic_unary_diff_neg_int_simd : (bits(5), bits(5), bits(2), bits(1), bits(1)) -> unit

function decode_neg_advsimd_aarch64_instrs_vector_arithmetic_unary_diff_neg_int_simd (Rd, Rn, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (size @ Q) == 0b110 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let neg : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_diff_neg_int_sisd(d, datasize, elements, esize, n, neg)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 5) = {
    SEE = 5;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_neg_advsimd_aarch64_instrs_vector_arithmetic_unary_diff_neg_int_simd(Rd, Rn, size, U, Q)
}

val execute_aarch64_instrs_integer_arithmetic_add_sub_carry : forall 'd 'datasize 'm 'n ('setflags : Bool) ('sub_op : Bool),
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'datasize in {32, 64} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('m), int('n), bool('setflags), bool('sub_op)) -> unit

function execute_aarch64_instrs_integer_arithmetic_add_sub_carry (d, datasize, m, n, setflags, sub_op) = {
    result : bits('datasize) = undefined;
    let operand1 : bits('datasize) = X_read(n, datasize);
    operand2 : bits('datasize) = X_read(m, datasize);
    nzcv : bits(4) = undefined;
    if sub_op then {
        operand2 = not_vec(operand2)
    };
    (result, nzcv) = AddWithCarry(operand1, operand2, PSTATE.C);
    if setflags then {
        (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V) = nzcv
    };
    X_set(d, datasize) = result
}

val decode_adc_aarch64_instrs_integer_arithmetic_add_sub_carry : (bits(5), bits(5), bits(5), bits(1), bits(1), bits(1)) -> unit

function decode_adc_aarch64_instrs_integer_arithmetic_add_sub_carry (Rd, Rn, Rm, S, op, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'datasize = if sf == 0b1 then 64 else 32;
    let sub_op : bool = op == 0b1;
    let setflags : bool = S == 0b1;
    execute_aarch64_instrs_integer_arithmetic_add_sub_carry(d, datasize, m, n, setflags, sub_op)
}

function clause __DecodeA64_DataProcReg ((pc, ([_, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 6) = {
    SEE = 6;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let S = Slice(__opcode, 29, 1);
    let op = Slice(__opcode, 30, 1);
    let sf = Slice(__opcode, 31, 1);
    decode_adc_aarch64_instrs_integer_arithmetic_add_sub_carry(Rd, Rn, Rm, S, op, sf)
}

val decode_adcs_aarch64_instrs_integer_arithmetic_add_sub_carry : (bits(5), bits(5), bits(5), bits(1), bits(1), bits(1)) -> unit

function decode_adcs_aarch64_instrs_integer_arithmetic_add_sub_carry (Rd, Rn, Rm, S, op, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'datasize = if sf == 0b1 then 64 else 32;
    let sub_op : bool = op == 0b1;
    let setflags : bool = S == 0b1;
    execute_aarch64_instrs_integer_arithmetic_add_sub_carry(d, datasize, m, n, setflags, sub_op)
}

function clause __DecodeA64_DataProcReg ((pc, ([_, bitzero, bitone, bitone, bitone, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 7) = {
    SEE = 7;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let S = Slice(__opcode, 29, 1);
    let op = Slice(__opcode, 30, 1);
    let sf = Slice(__opcode, 31, 1);
    decode_adcs_aarch64_instrs_integer_arithmetic_add_sub_carry(Rd, Rn, Rm, S, op, sf)
}

val decode_sbc_aarch64_instrs_integer_arithmetic_add_sub_carry : (bits(5), bits(5), bits(5), bits(1), bits(1), bits(1)) -> unit

function decode_sbc_aarch64_instrs_integer_arithmetic_add_sub_carry (Rd, Rn, Rm, S, op, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'datasize = if sf == 0b1 then 64 else 32;
    let sub_op : bool = op == 0b1;
    let setflags : bool = S == 0b1;
    execute_aarch64_instrs_integer_arithmetic_add_sub_carry(d, datasize, m, n, setflags, sub_op)
}

function clause __DecodeA64_DataProcReg ((pc, ([_, bitone, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 8) = {
    SEE = 8;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let S = Slice(__opcode, 29, 1);
    let op = Slice(__opcode, 30, 1);
    let sf = Slice(__opcode, 31, 1);
    decode_sbc_aarch64_instrs_integer_arithmetic_add_sub_carry(Rd, Rn, Rm, S, op, sf)
}

val decode_sbcs_aarch64_instrs_integer_arithmetic_add_sub_carry : (bits(5), bits(5), bits(5), bits(1), bits(1), bits(1)) -> unit

function decode_sbcs_aarch64_instrs_integer_arithmetic_add_sub_carry (Rd, Rn, Rm, S, op, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'datasize = if sf == 0b1 then 64 else 32;
    let sub_op : bool = op == 0b1;
    let setflags : bool = S == 0b1;
    execute_aarch64_instrs_integer_arithmetic_add_sub_carry(d, datasize, m, n, setflags, sub_op)
}

function clause __DecodeA64_DataProcReg ((pc, ([_, bitone, bitone, bitone, bitone, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 9) = {
    SEE = 9;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let S = Slice(__opcode, 29, 1);
    let op = Slice(__opcode, 30, 1);
    let sf = Slice(__opcode, 31, 1);
    decode_sbcs_aarch64_instrs_integer_arithmetic_add_sub_carry(Rd, Rn, Rm, S, op, sf)
}

val execute_aarch64_instrs_vector_arithmetic_binary_uniform_add_wrapping_single_sisd : forall 'd 'datasize 'elements 'esize 'm 'n ('sub_op : Bool),
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'esize in {8, 16, 32, 64} & 'datasize in {8, 16, 32, 64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('m), int('n), bool('sub_op)) -> unit

function execute_aarch64_instrs_vector_arithmetic_binary_uniform_add_wrapping_single_sisd (d, datasize, elements, esize, m, n, sub_op) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = V_read(n, datasize);
    let operand2 : bits('datasize) = V_read(m, datasize);
    result : bits('datasize) = undefined;
    element1 : bits('esize) = undefined;
    element2 : bits('esize) = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element1 = Elem_read(operand1, e, esize);
        element2 = Elem_read(operand2, e, esize);
        if sub_op then {
            result = Elem_set(result, e, esize, element1 - element2)
        } else {
            result = Elem_set(result, e, esize, element1 + element2)
        }
    };
    V_set(d, datasize) = result
}

val decode_add_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_add_wrapping_single_sisd : (bits(5), bits(5), bits(5), bits(2), bits(1)) -> unit

function decode_add_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_add_wrapping_single_sisd (Rd, Rn, Rm, size, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size != 0b11 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    let 'datasize = esize;
    let 'elements = 1;
    let sub_op : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_add_wrapping_single_sisd(d, datasize, elements, esize, m, n, sub_op)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 10) = {
    SEE = 10;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    decode_add_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_add_wrapping_single_sisd(Rd, Rn, Rm, size, U)
}

val decode_add_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_add_wrapping_single_simd : (bits(5), bits(5), bits(5), bits(2), bits(1), bits(1)) -> unit

function decode_add_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_add_wrapping_single_simd (Rd, Rn, Rm, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if (size @ Q) == 0b110 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let sub_op : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_add_wrapping_single_sisd(d, datasize, elements, esize, m, n, sub_op)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 11) = {
    SEE = 11;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_add_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_add_wrapping_single_simd(Rd, Rn, Rm, size, U, Q)
}

val decode_sub_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_add_wrapping_single_sisd : (bits(5), bits(5), bits(5), bits(2), bits(1)) -> unit

function decode_sub_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_add_wrapping_single_sisd (Rd, Rn, Rm, size, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size != 0b11 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    let 'datasize = esize;
    let 'elements = 1;
    let sub_op : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_add_wrapping_single_sisd(d, datasize, elements, esize, m, n, sub_op)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 12) = {
    SEE = 12;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    decode_sub_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_add_wrapping_single_sisd(Rd, Rn, Rm, size, U)
}

val decode_sub_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_add_wrapping_single_simd : (bits(5), bits(5), bits(5), bits(2), bits(1), bits(1)) -> unit

function decode_sub_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_add_wrapping_single_simd (Rd, Rn, Rm, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if (size @ Q) == 0b110 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let sub_op : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_add_wrapping_single_sisd(d, datasize, elements, esize, m, n, sub_op)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 13) = {
    SEE = 13;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_sub_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_add_wrapping_single_simd(Rd, Rn, Rm, size, U, Q)
}

val execute_aarch64_instrs_integer_arithmetic_add_sub_shiftedreg : forall 'd 'datasize 'm 'n ('setflags : Bool) 'shift_amount ('sub_op : Bool),
  (0 <= 'shift_amount & 'shift_amount <= 63 & 0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'datasize in {32, 64} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('m), int('n), bool('setflags), int('shift_amount), ShiftType, bool('sub_op)) -> unit

function execute_aarch64_instrs_integer_arithmetic_add_sub_shiftedreg (d, datasize, m, n, setflags, shift_amount, shift_type, sub_op) = {
    result : bits('datasize) = undefined;
    let operand1 : bits('datasize) = X_read(n, datasize);
    operand2 : bits('datasize) = ShiftReg(m, shift_type, shift_amount, datasize);
    nzcv : bits(4) = undefined;
    carry_in : bits(1) = undefined;
    if sub_op then {
        operand2 = not_vec(operand2);
        carry_in = 0b1
    } else {
        carry_in = 0b0
    };
    (result, nzcv) = AddWithCarry(operand1, operand2, carry_in);
    if setflags then {
        (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V) = nzcv
    };
    X_set(d, datasize) = result
}

val decode_add_addsub_shift_aarch64_instrs_integer_arithmetic_add_sub_shiftedreg : (bits(5), bits(5), bits(6), bits(5), bits(2), bits(1), bits(1), bits(1)) -> unit

function decode_add_addsub_shift_aarch64_instrs_integer_arithmetic_add_sub_shiftedreg (Rd, Rn, imm6, Rm, shift, S, op, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'datasize = if sf == 0b1 then 64 else 32;
    let sub_op : bool = op == 0b1;
    let setflags : bool = S == 0b1;
    if shift == 0b11 then {
        throw(Error_Undefined())
    };
    if sf == 0b0 & [imm6[5]] == 0b1 then {
        throw(Error_Undefined())
    };
    let shift_type : ShiftType = DecodeShift(shift);
    let 'shift_amount = UInt(imm6);
    execute_aarch64_instrs_integer_arithmetic_add_sub_shiftedreg(d, datasize, m, n, setflags, shift_amount, shift_type, sub_op)
}

function clause __DecodeA64_DataProcReg ((pc, ([_, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, _, _, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 14) = {
    SEE = 14;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm6 = Slice(__opcode, 10, 6);
    let Rm = Slice(__opcode, 16, 5);
    let shift = Slice(__opcode, 22, 2);
    let S = Slice(__opcode, 29, 1);
    let op = Slice(__opcode, 30, 1);
    let sf = Slice(__opcode, 31, 1);
    decode_add_addsub_shift_aarch64_instrs_integer_arithmetic_add_sub_shiftedreg(Rd, Rn, imm6, Rm, shift, S, op, sf)
}

val decode_adds_addsub_shift_aarch64_instrs_integer_arithmetic_add_sub_shiftedreg : (bits(5), bits(5), bits(6), bits(5), bits(2), bits(1), bits(1), bits(1)) -> unit

function decode_adds_addsub_shift_aarch64_instrs_integer_arithmetic_add_sub_shiftedreg (Rd, Rn, imm6, Rm, shift, S, op, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'datasize = if sf == 0b1 then 64 else 32;
    let sub_op : bool = op == 0b1;
    let setflags : bool = S == 0b1;
    if shift == 0b11 then {
        throw(Error_Undefined())
    };
    if sf == 0b0 & [imm6[5]] == 0b1 then {
        throw(Error_Undefined())
    };
    let shift_type : ShiftType = DecodeShift(shift);
    let 'shift_amount = UInt(imm6);
    execute_aarch64_instrs_integer_arithmetic_add_sub_shiftedreg(d, datasize, m, n, setflags, shift_amount, shift_type, sub_op)
}

function clause __DecodeA64_DataProcReg ((pc, ([_, bitzero, bitone, bitzero, bitone, bitzero, bitone, bitone, _, _, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 15) = {
    SEE = 15;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm6 = Slice(__opcode, 10, 6);
    let Rm = Slice(__opcode, 16, 5);
    let shift = Slice(__opcode, 22, 2);
    let S = Slice(__opcode, 29, 1);
    let op = Slice(__opcode, 30, 1);
    let sf = Slice(__opcode, 31, 1);
    decode_adds_addsub_shift_aarch64_instrs_integer_arithmetic_add_sub_shiftedreg(Rd, Rn, imm6, Rm, shift, S, op, sf)
}

val decode_sub_addsub_shift_aarch64_instrs_integer_arithmetic_add_sub_shiftedreg : (bits(5), bits(5), bits(6), bits(5), bits(2), bits(1), bits(1), bits(1)) -> unit

function decode_sub_addsub_shift_aarch64_instrs_integer_arithmetic_add_sub_shiftedreg (Rd, Rn, imm6, Rm, shift, S, op, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'datasize = if sf == 0b1 then 64 else 32;
    let sub_op : bool = op == 0b1;
    let setflags : bool = S == 0b1;
    if shift == 0b11 then {
        throw(Error_Undefined())
    };
    if sf == 0b0 & [imm6[5]] == 0b1 then {
        throw(Error_Undefined())
    };
    let shift_type : ShiftType = DecodeShift(shift);
    let 'shift_amount = UInt(imm6);
    execute_aarch64_instrs_integer_arithmetic_add_sub_shiftedreg(d, datasize, m, n, setflags, shift_amount, shift_type, sub_op)
}

function clause __DecodeA64_DataProcReg ((pc, ([_, bitone, bitzero, bitzero, bitone, bitzero, bitone, bitone, _, _, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 16) = {
    SEE = 16;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm6 = Slice(__opcode, 10, 6);
    let Rm = Slice(__opcode, 16, 5);
    let shift = Slice(__opcode, 22, 2);
    let S = Slice(__opcode, 29, 1);
    let op = Slice(__opcode, 30, 1);
    let sf = Slice(__opcode, 31, 1);
    decode_sub_addsub_shift_aarch64_instrs_integer_arithmetic_add_sub_shiftedreg(Rd, Rn, imm6, Rm, shift, S, op, sf)
}

val decode_subs_addsub_shift_aarch64_instrs_integer_arithmetic_add_sub_shiftedreg : (bits(5), bits(5), bits(6), bits(5), bits(2), bits(1), bits(1), bits(1)) -> unit

function decode_subs_addsub_shift_aarch64_instrs_integer_arithmetic_add_sub_shiftedreg (Rd, Rn, imm6, Rm, shift, S, op, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'datasize = if sf == 0b1 then 64 else 32;
    let sub_op : bool = op == 0b1;
    let setflags : bool = S == 0b1;
    if shift == 0b11 then {
        throw(Error_Undefined())
    };
    if sf == 0b0 & [imm6[5]] == 0b1 then {
        throw(Error_Undefined())
    };
    let shift_type : ShiftType = DecodeShift(shift);
    let 'shift_amount = UInt(imm6);
    execute_aarch64_instrs_integer_arithmetic_add_sub_shiftedreg(d, datasize, m, n, setflags, shift_amount, shift_type, sub_op)
}

function clause __DecodeA64_DataProcReg ((pc, ([_, bitone, bitone, bitzero, bitone, bitzero, bitone, bitone, _, _, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 17) = {
    SEE = 17;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm6 = Slice(__opcode, 10, 6);
    let Rm = Slice(__opcode, 16, 5);
    let shift = Slice(__opcode, 22, 2);
    let S = Slice(__opcode, 29, 1);
    let op = Slice(__opcode, 30, 1);
    let sf = Slice(__opcode, 31, 1);
    decode_subs_addsub_shift_aarch64_instrs_integer_arithmetic_add_sub_shiftedreg(Rd, Rn, imm6, Rm, shift, S, op, sf)
}

val execute_aarch64_instrs_integer_arithmetic_add_sub_immediate : forall 'd 'datasize 'n ('setflags : Bool) ('sub_op : Bool),
  (0 <= 'n & 'n <= 31 & 'datasize in {32, 64} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), bits('datasize), int('n), bool('setflags), bool('sub_op)) -> unit

function execute_aarch64_instrs_integer_arithmetic_add_sub_immediate (d, datasize, imm, n, setflags, sub_op) = {
    result : bits('datasize) = undefined;
    let operand1 : bits('datasize) = if n == 31 then
      SP_read()[datasize - 1 .. 0]
    else
      X_read(n, datasize);
    operand2 : bits('datasize) = imm;
    nzcv : bits(4) = undefined;
    carry_in : bits(1) = undefined;
    if sub_op then {
        operand2 = not_vec(operand2);
        carry_in = 0b1
    } else {
        carry_in = 0b0
    };
    (result, nzcv) = AddWithCarry(operand1, operand2, carry_in);
    if setflags then {
        (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V) = nzcv
    };
    if d == 31 & not_bool(setflags) then {
        SP_set() = ZeroExtend(result, 64)
    } else {
        X_set(d, datasize) = result
    }
}

val decode_add_addsub_imm_aarch64_instrs_integer_arithmetic_add_sub_immediate : (bits(5), bits(5), bits(12), bits(1), bits(1), bits(1), bits(1)) -> unit

function decode_add_addsub_imm_aarch64_instrs_integer_arithmetic_add_sub_immediate (Rd, Rn, imm12, sh, S, op, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'datasize = if sf == 0b1 then 64 else 32;
    let sub_op : bool = op == 0b1;
    let setflags : bool = S == 0b1;
    imm : bits('datasize) = undefined;
    match sh {
      0b0 => {
          imm = ZeroExtend(imm12, datasize)
      },
      0b1 => {
          imm = ZeroExtend(imm12 @ Zeros(12), datasize)
      }
    };
    let imm = imm;
    execute_aarch64_instrs_integer_arithmetic_add_sub_immediate(d, datasize, imm, n, setflags, sub_op)
}

function clause __DecodeA64_DataProcImm ((pc, ([_, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 18) = {
    SEE = 18;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm12 = Slice(__opcode, 10, 12);
    let sh = Slice(__opcode, 22, 1);
    let S = Slice(__opcode, 29, 1);
    let op = Slice(__opcode, 30, 1);
    let sf = Slice(__opcode, 31, 1);
    decode_add_addsub_imm_aarch64_instrs_integer_arithmetic_add_sub_immediate(Rd, Rn, imm12, sh, S, op, sf)
}

val decode_adds_addsub_imm_aarch64_instrs_integer_arithmetic_add_sub_immediate : (bits(5), bits(5), bits(12), bits(1), bits(1), bits(1), bits(1)) -> unit

function decode_adds_addsub_imm_aarch64_instrs_integer_arithmetic_add_sub_immediate (Rd, Rn, imm12, sh, S, op, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'datasize = if sf == 0b1 then 64 else 32;
    let sub_op : bool = op == 0b1;
    let setflags : bool = S == 0b1;
    imm : bits('datasize) = undefined;
    match sh {
      0b0 => {
          imm = ZeroExtend(imm12, datasize)
      },
      0b1 => {
          imm = ZeroExtend(imm12 @ Zeros(12), datasize)
      }
    };
    let imm = imm;
    execute_aarch64_instrs_integer_arithmetic_add_sub_immediate(d, datasize, imm, n, setflags, sub_op)
}

function clause __DecodeA64_DataProcImm ((pc, ([_, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 19) = {
    SEE = 19;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm12 = Slice(__opcode, 10, 12);
    let sh = Slice(__opcode, 22, 1);
    let S = Slice(__opcode, 29, 1);
    let op = Slice(__opcode, 30, 1);
    let sf = Slice(__opcode, 31, 1);
    decode_adds_addsub_imm_aarch64_instrs_integer_arithmetic_add_sub_immediate(Rd, Rn, imm12, sh, S, op, sf)
}

val decode_sub_addsub_imm_aarch64_instrs_integer_arithmetic_add_sub_immediate : (bits(5), bits(5), bits(12), bits(1), bits(1), bits(1), bits(1)) -> unit

function decode_sub_addsub_imm_aarch64_instrs_integer_arithmetic_add_sub_immediate (Rd, Rn, imm12, sh, S, op, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'datasize = if sf == 0b1 then 64 else 32;
    let sub_op : bool = op == 0b1;
    let setflags : bool = S == 0b1;
    imm : bits('datasize) = undefined;
    match sh {
      0b0 => {
          imm = ZeroExtend(imm12, datasize)
      },
      0b1 => {
          imm = ZeroExtend(imm12 @ Zeros(12), datasize)
      }
    };
    let imm = imm;
    execute_aarch64_instrs_integer_arithmetic_add_sub_immediate(d, datasize, imm, n, setflags, sub_op)
}

function clause __DecodeA64_DataProcImm ((pc, ([_, bitone, bitzero, bitone, bitzero, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 20) = {
    SEE = 20;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm12 = Slice(__opcode, 10, 12);
    let sh = Slice(__opcode, 22, 1);
    let S = Slice(__opcode, 29, 1);
    let op = Slice(__opcode, 30, 1);
    let sf = Slice(__opcode, 31, 1);
    decode_sub_addsub_imm_aarch64_instrs_integer_arithmetic_add_sub_immediate(Rd, Rn, imm12, sh, S, op, sf)
}

val decode_subs_addsub_imm_aarch64_instrs_integer_arithmetic_add_sub_immediate : (bits(5), bits(5), bits(12), bits(1), bits(1), bits(1), bits(1)) -> unit

function decode_subs_addsub_imm_aarch64_instrs_integer_arithmetic_add_sub_immediate (Rd, Rn, imm12, sh, S, op, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'datasize = if sf == 0b1 then 64 else 32;
    let sub_op : bool = op == 0b1;
    let setflags : bool = S == 0b1;
    imm : bits('datasize) = undefined;
    match sh {
      0b0 => {
          imm = ZeroExtend(imm12, datasize)
      },
      0b1 => {
          imm = ZeroExtend(imm12 @ Zeros(12), datasize)
      }
    };
    let imm = imm;
    execute_aarch64_instrs_integer_arithmetic_add_sub_immediate(d, datasize, imm, n, setflags, sub_op)
}

function clause __DecodeA64_DataProcImm ((pc, ([_, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 21) = {
    SEE = 21;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm12 = Slice(__opcode, 10, 12);
    let sh = Slice(__opcode, 22, 1);
    let S = Slice(__opcode, 29, 1);
    let op = Slice(__opcode, 30, 1);
    let sf = Slice(__opcode, 31, 1);
    decode_subs_addsub_imm_aarch64_instrs_integer_arithmetic_add_sub_immediate(Rd, Rn, imm12, sh, S, op, sf)
}

val execute_aarch64_instrs_integer_arithmetic_add_sub_extendedreg : forall 'd 'datasize 'm 'n ('setflags : Bool) 'shift ('sub_op : Bool),
  ('shift in {0, 1, 2, 3, 4, 5, 6, 7} & 0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'datasize in {32, 64} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), ExtendType, int('m), int('n), bool('setflags), int('shift), bool('sub_op)) -> unit

function execute_aarch64_instrs_integer_arithmetic_add_sub_extendedreg (d, datasize, extend_type, m, n, setflags, shift, sub_op) = {
    result : bits('datasize) = undefined;
    let operand1 : bits('datasize) = if n == 31 then
      SP_read()[datasize - 1 .. 0]
    else
      X_read(n, datasize);
    operand2 : bits('datasize) = ExtendReg(m, extend_type, shift, datasize);
    nzcv : bits(4) = undefined;
    carry_in : bits(1) = undefined;
    if sub_op then {
        operand2 = not_vec(operand2);
        carry_in = 0b1
    } else {
        carry_in = 0b0
    };
    (result, nzcv) = AddWithCarry(operand1, operand2, carry_in);
    if setflags then {
        (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V) = nzcv
    };
    if d == 31 & not_bool(setflags) then {
        SP_set() = ZeroExtend(result, 64)
    } else {
        X_set(d, datasize) = result
    }
}

val decode_add_addsub_ext_aarch64_instrs_integer_arithmetic_add_sub_extendedreg : (bits(5), bits(5), bits(3), bits(3), bits(5), bits(1), bits(1), bits(1)) -> unit

function decode_add_addsub_ext_aarch64_instrs_integer_arithmetic_add_sub_extendedreg (Rd, Rn, imm3, option_name, Rm, S, op, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'datasize = if sf == 0b1 then 64 else 32;
    let sub_op : bool = op == 0b1;
    let setflags : bool = S == 0b1;
    let extend_type : ExtendType = DecodeRegExtend(option_name);
    let 'shift = UInt(imm3);
    if shift > 4 then {
        throw(Error_Undefined())
    };
    execute_aarch64_instrs_integer_arithmetic_add_sub_extendedreg(d, datasize, extend_type, m, n, setflags, shift, sub_op)
}

function clause __DecodeA64_DataProcReg ((pc, ([_, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 22) = {
    SEE = 22;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm3 = Slice(__opcode, 10, 3);
    let option_name = Slice(__opcode, 13, 3);
    let Rm = Slice(__opcode, 16, 5);
    let S = Slice(__opcode, 29, 1);
    let op = Slice(__opcode, 30, 1);
    let sf = Slice(__opcode, 31, 1);
    decode_add_addsub_ext_aarch64_instrs_integer_arithmetic_add_sub_extendedreg(Rd, Rn, imm3, option_name, Rm, S, op, sf)
}

val decode_adds_addsub_ext_aarch64_instrs_integer_arithmetic_add_sub_extendedreg : (bits(5), bits(5), bits(3), bits(3), bits(5), bits(1), bits(1), bits(1)) -> unit

function decode_adds_addsub_ext_aarch64_instrs_integer_arithmetic_add_sub_extendedreg (Rd, Rn, imm3, option_name, Rm, S, op, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'datasize = if sf == 0b1 then 64 else 32;
    let sub_op : bool = op == 0b1;
    let setflags : bool = S == 0b1;
    let extend_type : ExtendType = DecodeRegExtend(option_name);
    let 'shift = UInt(imm3);
    if shift > 4 then {
        throw(Error_Undefined())
    };
    execute_aarch64_instrs_integer_arithmetic_add_sub_extendedreg(d, datasize, extend_type, m, n, setflags, shift, sub_op)
}

function clause __DecodeA64_DataProcReg ((pc, ([_, bitzero, bitone, bitzero, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 23) = {
    SEE = 23;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm3 = Slice(__opcode, 10, 3);
    let option_name = Slice(__opcode, 13, 3);
    let Rm = Slice(__opcode, 16, 5);
    let S = Slice(__opcode, 29, 1);
    let op = Slice(__opcode, 30, 1);
    let sf = Slice(__opcode, 31, 1);
    decode_adds_addsub_ext_aarch64_instrs_integer_arithmetic_add_sub_extendedreg(Rd, Rn, imm3, option_name, Rm, S, op, sf)
}

val decode_sub_addsub_ext_aarch64_instrs_integer_arithmetic_add_sub_extendedreg : (bits(5), bits(5), bits(3), bits(3), bits(5), bits(1), bits(1), bits(1)) -> unit

function decode_sub_addsub_ext_aarch64_instrs_integer_arithmetic_add_sub_extendedreg (Rd, Rn, imm3, option_name, Rm, S, op, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'datasize = if sf == 0b1 then 64 else 32;
    let sub_op : bool = op == 0b1;
    let setflags : bool = S == 0b1;
    let extend_type : ExtendType = DecodeRegExtend(option_name);
    let 'shift = UInt(imm3);
    if shift > 4 then {
        throw(Error_Undefined())
    };
    execute_aarch64_instrs_integer_arithmetic_add_sub_extendedreg(d, datasize, extend_type, m, n, setflags, shift, sub_op)
}

function clause __DecodeA64_DataProcReg ((pc, ([_, bitone, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 24) = {
    SEE = 24;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm3 = Slice(__opcode, 10, 3);
    let option_name = Slice(__opcode, 13, 3);
    let Rm = Slice(__opcode, 16, 5);
    let S = Slice(__opcode, 29, 1);
    let op = Slice(__opcode, 30, 1);
    let sf = Slice(__opcode, 31, 1);
    decode_sub_addsub_ext_aarch64_instrs_integer_arithmetic_add_sub_extendedreg(Rd, Rn, imm3, option_name, Rm, S, op, sf)
}

val decode_subs_addsub_ext_aarch64_instrs_integer_arithmetic_add_sub_extendedreg : (bits(5), bits(5), bits(3), bits(3), bits(5), bits(1), bits(1), bits(1)) -> unit

function decode_subs_addsub_ext_aarch64_instrs_integer_arithmetic_add_sub_extendedreg (Rd, Rn, imm3, option_name, Rm, S, op, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'datasize = if sf == 0b1 then 64 else 32;
    let sub_op : bool = op == 0b1;
    let setflags : bool = S == 0b1;
    let extend_type : ExtendType = DecodeRegExtend(option_name);
    let 'shift = UInt(imm3);
    if shift > 4 then {
        throw(Error_Undefined())
    };
    execute_aarch64_instrs_integer_arithmetic_add_sub_extendedreg(d, datasize, extend_type, m, n, setflags, shift, sub_op)
}

function clause __DecodeA64_DataProcReg ((pc, ([_, bitone, bitone, bitzero, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 25) = {
    SEE = 25;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm3 = Slice(__opcode, 10, 3);
    let option_name = Slice(__opcode, 13, 3);
    let Rm = Slice(__opcode, 16, 5);
    let S = Slice(__opcode, 29, 1);
    let op = Slice(__opcode, 30, 1);
    let sf = Slice(__opcode, 31, 1);
    decode_subs_addsub_ext_aarch64_instrs_integer_arithmetic_add_sub_extendedreg(Rd, Rn, imm3, option_name, Rm, S, op, sf)
}

val execute_aarch64_instrs_integer_tags_mcaddtag : forall ('ADD : Bool) 'd 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'd & 'd <= 31).
  (bool('ADD), int('d), int('n), bits(64), bits(4)) -> unit

function execute_aarch64_instrs_integer_tags_mcaddtag (ADD, d, n, offset, tag_offset) = {
    let operand1 : bits(64) = if n == 31 then SP_read() else X_read(n, 64);
    let start_tag : bits(4) = AArch64_AllocationTagFromAddress(operand1);
    let exclude : bits(16) = GCR_EL1[Exclude];
    result : bits(64) = undefined;
    rtag : bits(4) = undefined;
    if AArch64_AllocationTagAccessIsEnabled(PSTATE.EL) then {
        rtag = AArch64_ChooseNonExcludedTag(start_tag, tag_offset, exclude)
    } else {
        rtag = 0b0000
    };
    if ADD then {
        let (__tup_0 : bits(64), _) = AddWithCarry(operand1, offset, 0b0);
        result = __tup_0
    } else {
        let (__tup_0 : bits(64), _) = AddWithCarry(operand1, not_vec(offset), 0b1);
        result = __tup_0
    };
    let result : bits(64) = AArch64_AddressWithAllocationTag(result, rtag);
    if d == 31 then {
        SP_set() = result
    } else {
        X_set(d, 64) = result
    }
}

val decode_addg_aarch64_instrs_integer_tags_mcaddtag : (bits(5), bits(5), bits(4), bits(2), bits(6)) -> unit

function decode_addg_aarch64_instrs_integer_tags_mcaddtag (Xd, Xn, uimm4, op3, uimm6) = {
    if not_bool(HaveMTEExt()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Xd);
    let 'n = UInt(Xn);
    let tag_offset : bits(4) = uimm4;
    let offset : bits(64) = LSL(ZeroExtend(uimm6, 64), LOG2_TAG_GRANULE);
    let ADD : bool = true;
    execute_aarch64_instrs_integer_tags_mcaddtag(ADD, d, n, offset, tag_offset)
}

function clause __DecodeA64_DataProcImm ((pc, ([bitone, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitone, bitone, bitzero, _, _, _, _, _, _, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 26) = {
    SEE = 26;
    let Xd = Slice(__opcode, 0, 5);
    let Xn = Slice(__opcode, 5, 5);
    let uimm4 = Slice(__opcode, 10, 4);
    let op3 = Slice(__opcode, 14, 2);
    let uimm6 = Slice(__opcode, 16, 6);
    if [__opcode[14]] != 0b0 | [__opcode[15]] != 0b0 then {
        throw(Error_ConstrainedUnpredictable())
    } else {
        decode_addg_aarch64_instrs_integer_tags_mcaddtag(Xd, Xn, uimm4, op3, uimm6)
    }
}

val execute_aarch64_instrs_vector_arithmetic_binary_disparate_add_sub_narrow : forall 'd 'datasize 'elements 'esize 'm 'n 'part ('round : Bool) ('sub_op : Bool),
  ('part in {0, 1} & 0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'esize in {8, 16, 32, 64} & 'datasize == 64 & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('m), int('n), int('part), bool('round), bool('sub_op)) -> unit

function execute_aarch64_instrs_vector_arithmetic_binary_disparate_add_sub_narrow (d, datasize, elements, esize, m, n, part, round, sub_op) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits(2 * 'datasize) = V_read(n, 2 * datasize);
    let operand2 : bits(2 * 'datasize) = V_read(m, 2 * datasize);
    result : bits('datasize) = undefined;
    element1 : int = undefined;
    element2 : int = undefined;
    sum : int = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element1 = UInt(Elem_read(operand1, e, 2 * esize));
        element2 = UInt(Elem_read(operand2, e, 2 * esize));
        if sub_op then {
            sum = element1 - element2
        } else {
            sum = element1 + element2
        };
        sum = RShr(sum, esize, round);
        result = Elem_set(result, e, esize, sum[esize - 1 .. 0])
    };
    Vpart_set(d, part, datasize) = result
}

val decode_addhn_advsimd_aarch64_instrs_vector_arithmetic_binary_disparate_add_sub_narrow : (bits(5), bits(5), bits(1), bits(5), bits(2), bits(1), bits(1)) -> unit

function decode_addhn_advsimd_aarch64_instrs_vector_arithmetic_binary_disparate_add_sub_narrow (Rd, Rn, o1, Rm, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    let 'datasize = 64;
    let 'part = UInt(Q);
    let 'elements = DIV(datasize, esize);
    let sub_op : bool = o1 == 0b1;
    let round : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_disparate_add_sub_narrow(d, datasize, elements, esize, m, n, part, round, sub_op)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 27) = {
    SEE = 27;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 13, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_addhn_advsimd_aarch64_instrs_vector_arithmetic_binary_disparate_add_sub_narrow(Rd, Rn, o1, Rm, size, U, Q)
}

val decode_raddhn_advsimd_aarch64_instrs_vector_arithmetic_binary_disparate_add_sub_narrow : (bits(5), bits(5), bits(1), bits(5), bits(2), bits(1), bits(1)) -> unit

function decode_raddhn_advsimd_aarch64_instrs_vector_arithmetic_binary_disparate_add_sub_narrow (Rd, Rn, o1, Rm, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    let 'datasize = 64;
    let 'part = UInt(Q);
    let 'elements = DIV(datasize, esize);
    let sub_op : bool = o1 == 0b1;
    let round : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_disparate_add_sub_narrow(d, datasize, elements, esize, m, n, part, round, sub_op)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 28) = {
    SEE = 28;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 13, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_raddhn_advsimd_aarch64_instrs_vector_arithmetic_binary_disparate_add_sub_narrow(Rd, Rn, o1, Rm, size, U, Q)
}

val decode_rsubhn_advsimd_aarch64_instrs_vector_arithmetic_binary_disparate_add_sub_narrow : (bits(5), bits(5), bits(1), bits(5), bits(2), bits(1), bits(1)) -> unit

function decode_rsubhn_advsimd_aarch64_instrs_vector_arithmetic_binary_disparate_add_sub_narrow (Rd, Rn, o1, Rm, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    let 'datasize = 64;
    let 'part = UInt(Q);
    let 'elements = DIV(datasize, esize);
    let sub_op : bool = o1 == 0b1;
    let round : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_disparate_add_sub_narrow(d, datasize, elements, esize, m, n, part, round, sub_op)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitone, bitone, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 29) = {
    SEE = 29;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 13, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_rsubhn_advsimd_aarch64_instrs_vector_arithmetic_binary_disparate_add_sub_narrow(Rd, Rn, o1, Rm, size, U, Q)
}

val decode_subhn_advsimd_aarch64_instrs_vector_arithmetic_binary_disparate_add_sub_narrow : (bits(5), bits(5), bits(1), bits(5), bits(2), bits(1), bits(1)) -> unit

function decode_subhn_advsimd_aarch64_instrs_vector_arithmetic_binary_disparate_add_sub_narrow (Rd, Rn, o1, Rm, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    let 'datasize = 64;
    let 'part = UInt(Q);
    let 'elements = DIV(datasize, esize);
    let sub_op : bool = o1 == 0b1;
    let round : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_disparate_add_sub_narrow(d, datasize, elements, esize, m, n, part, round, sub_op)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitone, bitone, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 30) = {
    SEE = 30;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 13, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_subhn_advsimd_aarch64_instrs_vector_arithmetic_binary_disparate_add_sub_narrow(Rd, Rn, o1, Rm, size, U, Q)
}

val execute_aarch64_instrs_vector_arithmetic_binary_uniform_add_wrapping_pair : forall 'd 'datasize 'elements 'esize 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'esize in {8, 16, 32, 64} & 'datasize in {64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('m), int('n)) -> unit

function execute_aarch64_instrs_vector_arithmetic_binary_uniform_add_wrapping_pair (d, datasize, elements, esize, m, n) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = V_read(n, datasize);
    let operand2 : bits('datasize) = V_read(m, datasize);
    result : bits('datasize) = undefined;
    let concat : bits(2 * 'datasize) = operand2 @ operand1;
    element1 : bits('esize) = undefined;
    element2 : bits('esize) = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element1 = Elem_read(concat, 2 * e, esize);
        element2 = Elem_read(concat, 2 * e + 1, esize);
        result = Elem_set(result, e, esize, element1 + element2)
    };
    V_set(d, datasize) = result
}

val decode_addp_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_add_wrapping_pair : (bits(5), bits(5), bits(5), bits(2), bits(1)) -> unit

function decode_addp_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_add_wrapping_pair (Rd, Rn, Rm, size, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if (size @ Q) == 0b110 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_add_wrapping_pair(d, datasize, elements, esize, m, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitone, bitzero, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 31) = {
    SEE = 31;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let Q = Slice(__opcode, 30, 1);
    decode_addp_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_add_wrapping_pair(Rd, Rn, Rm, size, Q)
}

val execute_aarch64_instrs_vector_reduce_add_sisd : forall 'd 'datasize 'esize 'n,
  (0 <= 'n & 'n <= 31 & 'esize in {8, 16, 32, 64} & 'datasize in {16, 32, 64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('esize), int('n), ReduceOp) -> unit

function execute_aarch64_instrs_vector_reduce_add_sisd (d, datasize, esize, n, op) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('datasize) = V_read(n, datasize);
    assert(constraint('datasize >= 'esize));
    V_set(d, esize) = Reduce(op, operand, esize)
}

val decode_addp_advsimd_pair_aarch64_instrs_vector_reduce_add_sisd : (bits(5), bits(5), bits(2)) -> unit

function decode_addp_advsimd_pair_aarch64_instrs_vector_reduce_add_sisd (Rd, Rn, size) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if size != 0b11 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    let 'datasize = esize * 2;
    let 'elements = 2;
    let op : ReduceOp = ReduceOp_ADD;
    execute_aarch64_instrs_vector_reduce_add_sisd(d, datasize, esize, n, op)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 32) = {
    SEE = 32;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 22, 2);
    decode_addp_advsimd_pair_aarch64_instrs_vector_reduce_add_sisd(Rd, Rn, size)
}

val execute_aarch64_instrs_vector_reduce_add_simd : forall 'd 'datasize 'esize 'n,
  (0 <= 'n & 'n <= 31 & 'esize in {8, 16, 32, 64} & 'datasize in {64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('esize), int('n), ReduceOp) -> unit

function execute_aarch64_instrs_vector_reduce_add_simd (d, datasize, esize, n, op) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('datasize) = V_read(n, datasize);
    V_set(d, esize) = Reduce(op, operand, esize)
}

val decode_addv_advsimd_aarch64_instrs_vector_reduce_add_simd : (bits(5), bits(5), bits(2), bits(1)) -> unit

function decode_addv_advsimd_aarch64_instrs_vector_reduce_add_simd (Rd, Rn, size, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (size @ Q) == 0b100 then {
        throw(Error_Undefined())
    };
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let op : ReduceOp = ReduceOp_ADD;
    execute_aarch64_instrs_vector_reduce_add_simd(d, datasize, esize, n, op)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 33) = {
    SEE = 33;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 22, 2);
    let Q = Slice(__opcode, 30, 1);
    decode_addv_advsimd_aarch64_instrs_vector_reduce_add_simd(Rd, Rn, size, Q)
}

val execute_aarch64_instrs_integer_arithmetic_address_pc_rel : forall 'd ('page : Bool), (0 <= 'd & 'd <= 31).
  (int('d), bits(64), bool('page)) -> unit

function execute_aarch64_instrs_integer_arithmetic_address_pc_rel (d, imm, page) = {
    base : bits(64) = PC_read();
    if page then {
        base[11 .. 0] = Zeros(12)
    };
    X_set(d, 64) = base + imm
}

val decode_adr_aarch64_instrs_integer_arithmetic_address_pc_rel : (bits(5), bits(19), bits(2), bits(1)) -> unit

function decode_adr_aarch64_instrs_integer_arithmetic_address_pc_rel (Rd, immhi, immlo, op) = {
    let 'd = UInt(Rd);
    let page : bool = op == 0b1;
    imm : bits(64) = undefined;
    if page then {
        imm = SignExtend((immhi @ immlo) @ Zeros(12), 64)
    } else {
        imm = SignExtend(immhi @ immlo, 64)
    };
    execute_aarch64_instrs_integer_arithmetic_address_pc_rel(d, imm, page)
}

function clause __DecodeA64_DataProcImm ((pc, ([bitzero, _, _, bitone, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 34) = {
    SEE = 34;
    let Rd = Slice(__opcode, 0, 5);
    let immhi = Slice(__opcode, 5, 19);
    let immlo = Slice(__opcode, 29, 2);
    let op = Slice(__opcode, 31, 1);
    decode_adr_aarch64_instrs_integer_arithmetic_address_pc_rel(Rd, immhi, immlo, op)
}

val decode_adrp_aarch64_instrs_integer_arithmetic_address_pc_rel : (bits(5), bits(19), bits(2), bits(1)) -> unit

function decode_adrp_aarch64_instrs_integer_arithmetic_address_pc_rel (Rd, immhi, immlo, op) = {
    let 'd = UInt(Rd);
    let page : bool = op == 0b1;
    imm : bits(64) = undefined;
    if page then {
        imm = SignExtend((immhi @ immlo) @ Zeros(12), 64)
    } else {
        imm = SignExtend(immhi @ immlo, 64)
    };
    execute_aarch64_instrs_integer_arithmetic_address_pc_rel(d, imm, page)
}

function clause __DecodeA64_DataProcImm ((pc, ([bitone, _, _, bitone, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 35) = {
    SEE = 35;
    let Rd = Slice(__opcode, 0, 5);
    let immhi = Slice(__opcode, 5, 19);
    let immlo = Slice(__opcode, 29, 2);
    let op = Slice(__opcode, 31, 1);
    decode_adrp_aarch64_instrs_integer_arithmetic_address_pc_rel(Rd, immhi, immlo, op)
}

val execute_aarch64_instrs_vector_crypto_aes_round : forall 'd ('decrypt : Bool) 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'd & 'd <= 31).
  (int('d), bool('decrypt), int('n)) -> unit

function execute_aarch64_instrs_vector_crypto_aes_round (d, decrypt, n) = {
    AArch64_CheckFPAdvSIMDEnabled();
    let operand1 : bits(128) = V_read(d, 128);
    let operand2 : bits(128) = V_read(n, 128);
    result : bits(128) = EOR(operand1, operand2);
    if decrypt then {
        result = AESInvSubBytes(AESInvShiftRows(result))
    } else {
        result = AESSubBytes(AESShiftRows(result))
    };
    V_set(d, 128) = result
}

val decode_aesd_advsimd_aarch64_instrs_vector_crypto_aes_round : (bits(5), bits(5), bits(1)) -> unit

function decode_aesd_advsimd_aarch64_instrs_vector_crypto_aes_round (Rd, Rn, D) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if not_bool(HaveAESExt()) then {
        throw(Error_Undefined())
    };
    let decrypt : bool = D == 0b1;
    execute_aarch64_instrs_vector_crypto_aes_round(d, decrypt, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 36) = {
    SEE = 36;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let D = Slice(__opcode, 12, 1);
    decode_aesd_advsimd_aarch64_instrs_vector_crypto_aes_round(Rd, Rn, D)
}

val decode_aese_advsimd_aarch64_instrs_vector_crypto_aes_round : (bits(5), bits(5), bits(1)) -> unit

function decode_aese_advsimd_aarch64_instrs_vector_crypto_aes_round (Rd, Rn, D) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if not_bool(HaveAESExt()) then {
        throw(Error_Undefined())
    };
    let decrypt : bool = D == 0b1;
    execute_aarch64_instrs_vector_crypto_aes_round(d, decrypt, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 37) = {
    SEE = 37;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let D = Slice(__opcode, 12, 1);
    decode_aese_advsimd_aarch64_instrs_vector_crypto_aes_round(Rd, Rn, D)
}

val execute_aarch64_instrs_vector_crypto_aes_mix : forall 'd ('decrypt : Bool) 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'd & 'd <= 31).
  (int('d), bool('decrypt), int('n)) -> unit

function execute_aarch64_instrs_vector_crypto_aes_mix (d, decrypt, n) = {
    AArch64_CheckFPAdvSIMDEnabled();
    let operand : bits(128) = V_read(n, 128);
    result : bits(128) = undefined;
    if decrypt then {
        result = AESInvMixColumns(operand)
    } else {
        result = AESMixColumns(operand)
    };
    V_set(d, 128) = result
}

val decode_aesimc_advsimd_aarch64_instrs_vector_crypto_aes_mix : (bits(5), bits(5), bits(1)) -> unit

function decode_aesimc_advsimd_aarch64_instrs_vector_crypto_aes_mix (Rd, Rn, D) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if not_bool(HaveAESExt()) then {
        throw(Error_Undefined())
    };
    let decrypt : bool = D == 0b1;
    execute_aarch64_instrs_vector_crypto_aes_mix(d, decrypt, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 38) = {
    SEE = 38;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let D = Slice(__opcode, 12, 1);
    decode_aesimc_advsimd_aarch64_instrs_vector_crypto_aes_mix(Rd, Rn, D)
}

val decode_aesmc_advsimd_aarch64_instrs_vector_crypto_aes_mix : (bits(5), bits(5), bits(1)) -> unit

function decode_aesmc_advsimd_aarch64_instrs_vector_crypto_aes_mix (Rd, Rn, D) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if not_bool(HaveAESExt()) then {
        throw(Error_Undefined())
    };
    let decrypt : bool = D == 0b1;
    execute_aarch64_instrs_vector_crypto_aes_mix(d, decrypt, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 39) = {
    SEE = 39;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let D = Slice(__opcode, 12, 1);
    decode_aesmc_advsimd_aarch64_instrs_vector_crypto_aes_mix(Rd, Rn, D)
}

val execute_aarch64_instrs_integer_logical_immediate : forall 'd 'datasize 'n ('setflags : Bool),
  (0 <= 'n & 'n <= 31 & 'datasize in {32, 64} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), bits('datasize), int('n), LogicalOp, bool('setflags)) -> unit

function execute_aarch64_instrs_integer_logical_immediate (d, datasize, imm, n, op, setflags) = {
    result : bits('datasize) = undefined;
    let operand1 : bits('datasize) = X_read(n, datasize);
    let operand2 : bits('datasize) = imm;
    match op {
      LogicalOp_AND => {
          result = operand1 & operand2
      },
      LogicalOp_ORR => {
          result = operand1 | operand2
      },
      LogicalOp_EOR => {
          result = EOR(operand1, operand2)
      }
    };
    let result = result;
    if setflags then {
        (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V) = ([result[datasize - 1]] @ IsZeroBit(result)) @ 0b00
    };
    if d == 31 & not_bool(setflags) then {
        SP_set() = ZeroExtend(result, 64)
    } else {
        X_set(d, datasize) = result
    }
}

val decode_and_log_imm_aarch64_instrs_integer_logical_immediate : (bits(5), bits(5), bits(6), bits(6), bits(1), bits(2), bits(1)) -> unit

function decode_and_log_imm_aarch64_instrs_integer_logical_immediate (Rd, Rn, imms, immr, N, opc, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'datasize = if sf == 0b1 then 64 else 32;
    setflags : bool = undefined;
    op : LogicalOp = undefined;
    match opc {
      0b00 => {
          op = LogicalOp_AND;
          setflags = false
      },
      0b01 => {
          op = LogicalOp_ORR;
          setflags = false
      },
      0b10 => {
          op = LogicalOp_EOR;
          setflags = false
      },
      0b11 => {
          op = LogicalOp_AND;
          setflags = true
      }
    };
    let op = op;
    let setflags = setflags;
    imm : bits('datasize) = undefined;
    if sf == 0b0 & N != 0b0 then {
        throw(Error_Undefined())
    };
    let (__tup_0 : bits('datasize), _) =
      DecodeBitMasks(N, imms, immr, true, datasize)
    in
      {
          imm = __tup_0
      };
    execute_aarch64_instrs_integer_logical_immediate(d, datasize, imm, n, op, setflags)
}

function clause __DecodeA64_DataProcImm ((pc, ([_, bitzero, bitzero, bitone, bitzero, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 40) = {
    SEE = 40;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imms = Slice(__opcode, 10, 6);
    let immr = Slice(__opcode, 16, 6);
    let N = Slice(__opcode, 22, 1);
    let opc = Slice(__opcode, 29, 2);
    let sf = Slice(__opcode, 31, 1);
    decode_and_log_imm_aarch64_instrs_integer_logical_immediate(Rd, Rn, imms, immr, N, opc, sf)
}

val decode_ands_log_imm_aarch64_instrs_integer_logical_immediate : (bits(5), bits(5), bits(6), bits(6), bits(1), bits(2), bits(1)) -> unit

function decode_ands_log_imm_aarch64_instrs_integer_logical_immediate (Rd, Rn, imms, immr, N, opc, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'datasize = if sf == 0b1 then 64 else 32;
    setflags : bool = undefined;
    op : LogicalOp = undefined;
    match opc {
      0b00 => {
          op = LogicalOp_AND;
          setflags = false
      },
      0b01 => {
          op = LogicalOp_ORR;
          setflags = false
      },
      0b10 => {
          op = LogicalOp_EOR;
          setflags = false
      },
      0b11 => {
          op = LogicalOp_AND;
          setflags = true
      }
    };
    let op = op;
    let setflags = setflags;
    imm : bits('datasize) = undefined;
    if sf == 0b0 & N != 0b0 then {
        throw(Error_Undefined())
    };
    let (__tup_0 : bits('datasize), _) =
      DecodeBitMasks(N, imms, immr, true, datasize)
    in
      {
          imm = __tup_0
      };
    execute_aarch64_instrs_integer_logical_immediate(d, datasize, imm, n, op, setflags)
}

function clause __DecodeA64_DataProcImm ((pc, ([_, bitone, bitone, bitone, bitzero, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 41) = {
    SEE = 41;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imms = Slice(__opcode, 10, 6);
    let immr = Slice(__opcode, 16, 6);
    let N = Slice(__opcode, 22, 1);
    let opc = Slice(__opcode, 29, 2);
    let sf = Slice(__opcode, 31, 1);
    decode_ands_log_imm_aarch64_instrs_integer_logical_immediate(Rd, Rn, imms, immr, N, opc, sf)
}

val decode_eor_log_imm_aarch64_instrs_integer_logical_immediate : (bits(5), bits(5), bits(6), bits(6), bits(1), bits(2), bits(1)) -> unit

function decode_eor_log_imm_aarch64_instrs_integer_logical_immediate (Rd, Rn, imms, immr, N, opc, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'datasize = if sf == 0b1 then 64 else 32;
    setflags : bool = undefined;
    op : LogicalOp = undefined;
    match opc {
      0b00 => {
          op = LogicalOp_AND;
          setflags = false
      },
      0b01 => {
          op = LogicalOp_ORR;
          setflags = false
      },
      0b10 => {
          op = LogicalOp_EOR;
          setflags = false
      },
      0b11 => {
          op = LogicalOp_AND;
          setflags = true
      }
    };
    let op = op;
    let setflags = setflags;
    imm : bits('datasize) = undefined;
    if sf == 0b0 & N != 0b0 then {
        throw(Error_Undefined())
    };
    let (__tup_0 : bits('datasize), _) =
      DecodeBitMasks(N, imms, immr, true, datasize)
    in
      {
          imm = __tup_0
      };
    execute_aarch64_instrs_integer_logical_immediate(d, datasize, imm, n, op, setflags)
}

function clause __DecodeA64_DataProcImm ((pc, ([_, bitone, bitzero, bitone, bitzero, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 42) = {
    SEE = 42;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imms = Slice(__opcode, 10, 6);
    let immr = Slice(__opcode, 16, 6);
    let N = Slice(__opcode, 22, 1);
    let opc = Slice(__opcode, 29, 2);
    let sf = Slice(__opcode, 31, 1);
    decode_eor_log_imm_aarch64_instrs_integer_logical_immediate(Rd, Rn, imms, immr, N, opc, sf)
}

val decode_orr_log_imm_aarch64_instrs_integer_logical_immediate : (bits(5), bits(5), bits(6), bits(6), bits(1), bits(2), bits(1)) -> unit

function decode_orr_log_imm_aarch64_instrs_integer_logical_immediate (Rd, Rn, imms, immr, N, opc, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'datasize = if sf == 0b1 then 64 else 32;
    setflags : bool = undefined;
    op : LogicalOp = undefined;
    match opc {
      0b00 => {
          op = LogicalOp_AND;
          setflags = false
      },
      0b01 => {
          op = LogicalOp_ORR;
          setflags = false
      },
      0b10 => {
          op = LogicalOp_EOR;
          setflags = false
      },
      0b11 => {
          op = LogicalOp_AND;
          setflags = true
      }
    };
    let op = op;
    let setflags = setflags;
    imm : bits('datasize) = undefined;
    if sf == 0b0 & N != 0b0 then {
        throw(Error_Undefined())
    };
    let (__tup_0 : bits('datasize), _) =
      DecodeBitMasks(N, imms, immr, true, datasize)
    in
      {
          imm = __tup_0
      };
    execute_aarch64_instrs_integer_logical_immediate(d, datasize, imm, n, op, setflags)
}

function clause __DecodeA64_DataProcImm ((pc, ([_, bitzero, bitone, bitone, bitzero, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 43) = {
    SEE = 43;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imms = Slice(__opcode, 10, 6);
    let immr = Slice(__opcode, 16, 6);
    let N = Slice(__opcode, 22, 1);
    let opc = Slice(__opcode, 29, 2);
    let sf = Slice(__opcode, 31, 1);
    decode_orr_log_imm_aarch64_instrs_integer_logical_immediate(Rd, Rn, imms, immr, N, opc, sf)
}

val execute_aarch64_instrs_vector_arithmetic_binary_uniform_logical_and_orr : forall 'd 'datasize ('invert : Bool) 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'datasize in {64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), bool('invert), int('m), int('n), LogicalOp) -> unit

function execute_aarch64_instrs_vector_arithmetic_binary_uniform_logical_and_orr (d, datasize, invert, m, n, op) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = V_read(n, datasize);
    operand2 : bits('datasize) = V_read(m, datasize);
    result : bits('datasize) = undefined;
    if invert then {
        operand2 = not_vec(operand2)
    };
    match op {
      LogicalOp_AND => {
          result = operand1 & operand2
      },
      LogicalOp_ORR => {
          result = operand1 | operand2
      },
      _ => ()
    };
    V_set(d, datasize) = result
}

val decode_and_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_logical_and_orr : (bits(5), bits(5), bits(5), bits(2), bits(1)) -> unit

function decode_and_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_logical_and_orr (Rd, Rn, Rm, size, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = 8;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let invert : bool = [size[0]] == 0b1;
    let op : LogicalOp = if [size[1]] == 0b1 then LogicalOp_ORR else
      LogicalOp_AND;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_logical_and_orr(d, datasize, invert, m, n, op)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitone, _, _, _, _, _, bitzero, bitzero, bitzero, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 44) = {
    SEE = 44;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let Q = Slice(__opcode, 30, 1);
    decode_and_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_logical_and_orr(Rd, Rn, Rm, size, Q)
}

val decode_bic_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_logical_and_orr : (bits(5), bits(5), bits(5), bits(2), bits(1)) -> unit

function decode_bic_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_logical_and_orr (Rd, Rn, Rm, size, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = 8;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let invert : bool = [size[0]] == 0b1;
    let op : LogicalOp = if [size[1]] == 0b1 then LogicalOp_ORR else
      LogicalOp_AND;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_logical_and_orr(d, datasize, invert, m, n, op)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, _, _, _, _, _, bitzero, bitzero, bitzero, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 45) = {
    SEE = 45;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let Q = Slice(__opcode, 30, 1);
    decode_bic_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_logical_and_orr(Rd, Rn, Rm, size, Q)
}

val decode_orn_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_logical_and_orr : (bits(5), bits(5), bits(5), bits(2), bits(1)) -> unit

function decode_orn_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_logical_and_orr (Rd, Rn, Rm, size, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = 8;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let invert : bool = [size[0]] == 0b1;
    let op : LogicalOp = if [size[1]] == 0b1 then LogicalOp_ORR else
      LogicalOp_AND;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_logical_and_orr(d, datasize, invert, m, n, op)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitone, bitone, bitone, _, _, _, _, _, bitzero, bitzero, bitzero, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 46) = {
    SEE = 46;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let Q = Slice(__opcode, 30, 1);
    decode_orn_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_logical_and_orr(Rd, Rn, Rm, size, Q)
}

val decode_orr_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_logical_and_orr : (bits(5), bits(5), bits(5), bits(2), bits(1)) -> unit

function decode_orr_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_logical_and_orr (Rd, Rn, Rm, size, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = 8;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let invert : bool = [size[0]] == 0b1;
    let op : LogicalOp = if [size[1]] == 0b1 then LogicalOp_ORR else
      LogicalOp_AND;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_logical_and_orr(d, datasize, invert, m, n, op)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitone, bitzero, bitone, _, _, _, _, _, bitzero, bitzero, bitzero, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 47) = {
    SEE = 47;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let Q = Slice(__opcode, 30, 1);
    decode_orr_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_logical_and_orr(Rd, Rn, Rm, size, Q)
}

val execute_aarch64_instrs_integer_logical_shiftedreg : forall 'd 'datasize ('invert : Bool) 'm 'n ('setflags : Bool) 'shift_amount,
  (0 <= 'shift_amount & 'shift_amount <= 63 & 0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'datasize in {32, 64} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), bool('invert), int('m), int('n), LogicalOp, bool('setflags), int('shift_amount), ShiftType) -> unit

function execute_aarch64_instrs_integer_logical_shiftedreg (d, datasize, invert, m, n, op, setflags, shift_amount, shift_type) = {
    let operand1 : bits('datasize) = X_read(n, datasize);
    operand2 : bits('datasize) = ShiftReg(m, shift_type, shift_amount, datasize);
    result : bits('datasize) = undefined;
    if invert then {
        operand2 = not_vec(operand2)
    };
    match op {
      LogicalOp_AND => {
          result = operand1 & operand2
      },
      LogicalOp_ORR => {
          result = operand1 | operand2
      },
      LogicalOp_EOR => {
          result = EOR(operand1, operand2)
      }
    };
    let result = result;
    if setflags then {
        (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V) = ([result[datasize - 1]] @ IsZeroBit(result)) @ 0b00
    };
    X_set(d, datasize) = result
}

val decode_and_log_shift_aarch64_instrs_integer_logical_shiftedreg : (bits(5), bits(5), bits(6), bits(5), bits(1), bits(2), bits(2), bits(1)) -> unit

function decode_and_log_shift_aarch64_instrs_integer_logical_shiftedreg (Rd, Rn, imm6, Rm, N, shift, opc, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'datasize = if sf == 0b1 then 64 else 32;
    setflags : bool = undefined;
    op : LogicalOp = undefined;
    match opc {
      0b00 => {
          op = LogicalOp_AND;
          setflags = false
      },
      0b01 => {
          op = LogicalOp_ORR;
          setflags = false
      },
      0b10 => {
          op = LogicalOp_EOR;
          setflags = false
      },
      0b11 => {
          op = LogicalOp_AND;
          setflags = true
      }
    };
    let op = op;
    let setflags = setflags;
    if sf == 0b0 & [imm6[5]] == 0b1 then {
        throw(Error_Undefined())
    };
    let shift_type : ShiftType = DecodeShift(shift);
    let 'shift_amount = UInt(imm6);
    let invert : bool = N == 0b1;
    execute_aarch64_instrs_integer_logical_shiftedreg(d, datasize, invert, m, n, op, setflags, shift_amount, shift_type)
}

function clause __DecodeA64_DataProcReg ((pc, ([_, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitzero, _, _, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 48) = {
    SEE = 48;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm6 = Slice(__opcode, 10, 6);
    let Rm = Slice(__opcode, 16, 5);
    let N = Slice(__opcode, 21, 1);
    let shift = Slice(__opcode, 22, 2);
    let opc = Slice(__opcode, 29, 2);
    let sf = Slice(__opcode, 31, 1);
    decode_and_log_shift_aarch64_instrs_integer_logical_shiftedreg(Rd, Rn, imm6, Rm, N, shift, opc, sf)
}

val decode_ands_log_shift_aarch64_instrs_integer_logical_shiftedreg : (bits(5), bits(5), bits(6), bits(5), bits(1), bits(2), bits(2), bits(1)) -> unit

function decode_ands_log_shift_aarch64_instrs_integer_logical_shiftedreg (Rd, Rn, imm6, Rm, N, shift, opc, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'datasize = if sf == 0b1 then 64 else 32;
    setflags : bool = undefined;
    op : LogicalOp = undefined;
    match opc {
      0b00 => {
          op = LogicalOp_AND;
          setflags = false
      },
      0b01 => {
          op = LogicalOp_ORR;
          setflags = false
      },
      0b10 => {
          op = LogicalOp_EOR;
          setflags = false
      },
      0b11 => {
          op = LogicalOp_AND;
          setflags = true
      }
    };
    let op = op;
    let setflags = setflags;
    if sf == 0b0 & [imm6[5]] == 0b1 then {
        throw(Error_Undefined())
    };
    let shift_type : ShiftType = DecodeShift(shift);
    let 'shift_amount = UInt(imm6);
    let invert : bool = N == 0b1;
    execute_aarch64_instrs_integer_logical_shiftedreg(d, datasize, invert, m, n, op, setflags, shift_amount, shift_type)
}

function clause __DecodeA64_DataProcReg ((pc, ([_, bitone, bitone, bitzero, bitone, bitzero, bitone, bitzero, _, _, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 49) = {
    SEE = 49;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm6 = Slice(__opcode, 10, 6);
    let Rm = Slice(__opcode, 16, 5);
    let N = Slice(__opcode, 21, 1);
    let shift = Slice(__opcode, 22, 2);
    let opc = Slice(__opcode, 29, 2);
    let sf = Slice(__opcode, 31, 1);
    decode_ands_log_shift_aarch64_instrs_integer_logical_shiftedreg(Rd, Rn, imm6, Rm, N, shift, opc, sf)
}

val decode_bic_log_shift_aarch64_instrs_integer_logical_shiftedreg : (bits(5), bits(5), bits(6), bits(5), bits(1), bits(2), bits(2), bits(1)) -> unit

function decode_bic_log_shift_aarch64_instrs_integer_logical_shiftedreg (Rd, Rn, imm6, Rm, N, shift, opc, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'datasize = if sf == 0b1 then 64 else 32;
    setflags : bool = undefined;
    op : LogicalOp = undefined;
    match opc {
      0b00 => {
          op = LogicalOp_AND;
          setflags = false
      },
      0b01 => {
          op = LogicalOp_ORR;
          setflags = false
      },
      0b10 => {
          op = LogicalOp_EOR;
          setflags = false
      },
      0b11 => {
          op = LogicalOp_AND;
          setflags = true
      }
    };
    let op = op;
    let setflags = setflags;
    if sf == 0b0 & [imm6[5]] == 0b1 then {
        throw(Error_Undefined())
    };
    let shift_type : ShiftType = DecodeShift(shift);
    let 'shift_amount = UInt(imm6);
    let invert : bool = N == 0b1;
    execute_aarch64_instrs_integer_logical_shiftedreg(d, datasize, invert, m, n, op, setflags, shift_amount, shift_type)
}

function clause __DecodeA64_DataProcReg ((pc, ([_, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitzero, _, _, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 50) = {
    SEE = 50;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm6 = Slice(__opcode, 10, 6);
    let Rm = Slice(__opcode, 16, 5);
    let N = Slice(__opcode, 21, 1);
    let shift = Slice(__opcode, 22, 2);
    let opc = Slice(__opcode, 29, 2);
    let sf = Slice(__opcode, 31, 1);
    decode_bic_log_shift_aarch64_instrs_integer_logical_shiftedreg(Rd, Rn, imm6, Rm, N, shift, opc, sf)
}

val decode_bics_aarch64_instrs_integer_logical_shiftedreg : (bits(5), bits(5), bits(6), bits(5), bits(1), bits(2), bits(2), bits(1)) -> unit

function decode_bics_aarch64_instrs_integer_logical_shiftedreg (Rd, Rn, imm6, Rm, N, shift, opc, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'datasize = if sf == 0b1 then 64 else 32;
    setflags : bool = undefined;
    op : LogicalOp = undefined;
    match opc {
      0b00 => {
          op = LogicalOp_AND;
          setflags = false
      },
      0b01 => {
          op = LogicalOp_ORR;
          setflags = false
      },
      0b10 => {
          op = LogicalOp_EOR;
          setflags = false
      },
      0b11 => {
          op = LogicalOp_AND;
          setflags = true
      }
    };
    let op = op;
    let setflags = setflags;
    if sf == 0b0 & [imm6[5]] == 0b1 then {
        throw(Error_Undefined())
    };
    let shift_type : ShiftType = DecodeShift(shift);
    let 'shift_amount = UInt(imm6);
    let invert : bool = N == 0b1;
    execute_aarch64_instrs_integer_logical_shiftedreg(d, datasize, invert, m, n, op, setflags, shift_amount, shift_type)
}

function clause __DecodeA64_DataProcReg ((pc, ([_, bitone, bitone, bitzero, bitone, bitzero, bitone, bitzero, _, _, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 51) = {
    SEE = 51;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm6 = Slice(__opcode, 10, 6);
    let Rm = Slice(__opcode, 16, 5);
    let N = Slice(__opcode, 21, 1);
    let shift = Slice(__opcode, 22, 2);
    let opc = Slice(__opcode, 29, 2);
    let sf = Slice(__opcode, 31, 1);
    decode_bics_aarch64_instrs_integer_logical_shiftedreg(Rd, Rn, imm6, Rm, N, shift, opc, sf)
}

val decode_eon_aarch64_instrs_integer_logical_shiftedreg : (bits(5), bits(5), bits(6), bits(5), bits(1), bits(2), bits(2), bits(1)) -> unit

function decode_eon_aarch64_instrs_integer_logical_shiftedreg (Rd, Rn, imm6, Rm, N, shift, opc, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'datasize = if sf == 0b1 then 64 else 32;
    setflags : bool = undefined;
    op : LogicalOp = undefined;
    match opc {
      0b00 => {
          op = LogicalOp_AND;
          setflags = false
      },
      0b01 => {
          op = LogicalOp_ORR;
          setflags = false
      },
      0b10 => {
          op = LogicalOp_EOR;
          setflags = false
      },
      0b11 => {
          op = LogicalOp_AND;
          setflags = true
      }
    };
    let op = op;
    let setflags = setflags;
    if sf == 0b0 & [imm6[5]] == 0b1 then {
        throw(Error_Undefined())
    };
    let shift_type : ShiftType = DecodeShift(shift);
    let 'shift_amount = UInt(imm6);
    let invert : bool = N == 0b1;
    execute_aarch64_instrs_integer_logical_shiftedreg(d, datasize, invert, m, n, op, setflags, shift_amount, shift_type)
}

function clause __DecodeA64_DataProcReg ((pc, ([_, bitone, bitzero, bitzero, bitone, bitzero, bitone, bitzero, _, _, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 52) = {
    SEE = 52;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm6 = Slice(__opcode, 10, 6);
    let Rm = Slice(__opcode, 16, 5);
    let N = Slice(__opcode, 21, 1);
    let shift = Slice(__opcode, 22, 2);
    let opc = Slice(__opcode, 29, 2);
    let sf = Slice(__opcode, 31, 1);
    decode_eon_aarch64_instrs_integer_logical_shiftedreg(Rd, Rn, imm6, Rm, N, shift, opc, sf)
}

val decode_eor_log_shift_aarch64_instrs_integer_logical_shiftedreg : (bits(5), bits(5), bits(6), bits(5), bits(1), bits(2), bits(2), bits(1)) -> unit

function decode_eor_log_shift_aarch64_instrs_integer_logical_shiftedreg (Rd, Rn, imm6, Rm, N, shift, opc, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'datasize = if sf == 0b1 then 64 else 32;
    setflags : bool = undefined;
    op : LogicalOp = undefined;
    match opc {
      0b00 => {
          op = LogicalOp_AND;
          setflags = false
      },
      0b01 => {
          op = LogicalOp_ORR;
          setflags = false
      },
      0b10 => {
          op = LogicalOp_EOR;
          setflags = false
      },
      0b11 => {
          op = LogicalOp_AND;
          setflags = true
      }
    };
    let op = op;
    let setflags = setflags;
    if sf == 0b0 & [imm6[5]] == 0b1 then {
        throw(Error_Undefined())
    };
    let shift_type : ShiftType = DecodeShift(shift);
    let 'shift_amount = UInt(imm6);
    let invert : bool = N == 0b1;
    execute_aarch64_instrs_integer_logical_shiftedreg(d, datasize, invert, m, n, op, setflags, shift_amount, shift_type)
}

function clause __DecodeA64_DataProcReg ((pc, ([_, bitone, bitzero, bitzero, bitone, bitzero, bitone, bitzero, _, _, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 53) = {
    SEE = 53;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm6 = Slice(__opcode, 10, 6);
    let Rm = Slice(__opcode, 16, 5);
    let N = Slice(__opcode, 21, 1);
    let shift = Slice(__opcode, 22, 2);
    let opc = Slice(__opcode, 29, 2);
    let sf = Slice(__opcode, 31, 1);
    decode_eor_log_shift_aarch64_instrs_integer_logical_shiftedreg(Rd, Rn, imm6, Rm, N, shift, opc, sf)
}

val decode_orn_log_shift_aarch64_instrs_integer_logical_shiftedreg : (bits(5), bits(5), bits(6), bits(5), bits(1), bits(2), bits(2), bits(1)) -> unit

function decode_orn_log_shift_aarch64_instrs_integer_logical_shiftedreg (Rd, Rn, imm6, Rm, N, shift, opc, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'datasize = if sf == 0b1 then 64 else 32;
    setflags : bool = undefined;
    op : LogicalOp = undefined;
    match opc {
      0b00 => {
          op = LogicalOp_AND;
          setflags = false
      },
      0b01 => {
          op = LogicalOp_ORR;
          setflags = false
      },
      0b10 => {
          op = LogicalOp_EOR;
          setflags = false
      },
      0b11 => {
          op = LogicalOp_AND;
          setflags = true
      }
    };
    let op = op;
    let setflags = setflags;
    if sf == 0b0 & [imm6[5]] == 0b1 then {
        throw(Error_Undefined())
    };
    let shift_type : ShiftType = DecodeShift(shift);
    let 'shift_amount = UInt(imm6);
    let invert : bool = N == 0b1;
    execute_aarch64_instrs_integer_logical_shiftedreg(d, datasize, invert, m, n, op, setflags, shift_amount, shift_type)
}

function clause __DecodeA64_DataProcReg ((pc, ([_, bitzero, bitone, bitzero, bitone, bitzero, bitone, bitzero, _, _, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 54) = {
    SEE = 54;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm6 = Slice(__opcode, 10, 6);
    let Rm = Slice(__opcode, 16, 5);
    let N = Slice(__opcode, 21, 1);
    let shift = Slice(__opcode, 22, 2);
    let opc = Slice(__opcode, 29, 2);
    let sf = Slice(__opcode, 31, 1);
    decode_orn_log_shift_aarch64_instrs_integer_logical_shiftedreg(Rd, Rn, imm6, Rm, N, shift, opc, sf)
}

val decode_orr_log_shift_aarch64_instrs_integer_logical_shiftedreg : (bits(5), bits(5), bits(6), bits(5), bits(1), bits(2), bits(2), bits(1)) -> unit

function decode_orr_log_shift_aarch64_instrs_integer_logical_shiftedreg (Rd, Rn, imm6, Rm, N, shift, opc, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'datasize = if sf == 0b1 then 64 else 32;
    setflags : bool = undefined;
    op : LogicalOp = undefined;
    match opc {
      0b00 => {
          op = LogicalOp_AND;
          setflags = false
      },
      0b01 => {
          op = LogicalOp_ORR;
          setflags = false
      },
      0b10 => {
          op = LogicalOp_EOR;
          setflags = false
      },
      0b11 => {
          op = LogicalOp_AND;
          setflags = true
      }
    };
    let op = op;
    let setflags = setflags;
    if sf == 0b0 & [imm6[5]] == 0b1 then {
        throw(Error_Undefined())
    };
    let shift_type : ShiftType = DecodeShift(shift);
    let 'shift_amount = UInt(imm6);
    let invert : bool = N == 0b1;
    execute_aarch64_instrs_integer_logical_shiftedreg(d, datasize, invert, m, n, op, setflags, shift_amount, shift_type)
}

function clause __DecodeA64_DataProcReg ((pc, ([_, bitzero, bitone, bitzero, bitone, bitzero, bitone, bitzero, _, _, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 55) = {
    SEE = 55;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm6 = Slice(__opcode, 10, 6);
    let Rm = Slice(__opcode, 16, 5);
    let N = Slice(__opcode, 21, 1);
    let shift = Slice(__opcode, 22, 2);
    let opc = Slice(__opcode, 29, 2);
    let sf = Slice(__opcode, 31, 1);
    decode_orr_log_shift_aarch64_instrs_integer_logical_shiftedreg(Rd, Rn, imm6, Rm, N, shift, opc, sf)
}

val execute_aarch64_instrs_integer_shift_variable : forall 'd 'datasize 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'datasize in {32, 64} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('m), int('n), ShiftType) -> unit

function execute_aarch64_instrs_integer_shift_variable (d, datasize, m, n, shift_type) = {
    let operand2 : bits('datasize) = X_read(m, datasize);
    let result : bits('datasize) = ShiftReg(n, shift_type, MOD(UInt(operand2), datasize), datasize);
    X_set(d, datasize) = result
}

val decode_asrv_aarch64_instrs_integer_shift_variable : (bits(5), bits(5), bits(2), bits(5), bits(1)) -> unit

function decode_asrv_aarch64_instrs_integer_shift_variable (Rd, Rn, op2, Rm, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'datasize = if sf == 0b1 then 64 else 32;
    let shift_type : ShiftType = DecodeShift(op2);
    execute_aarch64_instrs_integer_shift_variable(d, datasize, m, n, shift_type)
}

function clause __DecodeA64_DataProcReg ((pc, ([_, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, bitzero, bitzero, bitone, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 56) = {
    SEE = 56;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op2 = Slice(__opcode, 10, 2);
    let Rm = Slice(__opcode, 16, 5);
    let sf = Slice(__opcode, 31, 1);
    decode_asrv_aarch64_instrs_integer_shift_variable(Rd, Rn, op2, Rm, sf)
}

val decode_lslv_aarch64_instrs_integer_shift_variable : (bits(5), bits(5), bits(2), bits(5), bits(1)) -> unit

function decode_lslv_aarch64_instrs_integer_shift_variable (Rd, Rn, op2, Rm, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'datasize = if sf == 0b1 then 64 else 32;
    let shift_type : ShiftType = DecodeShift(op2);
    execute_aarch64_instrs_integer_shift_variable(d, datasize, m, n, shift_type)
}

function clause __DecodeA64_DataProcReg ((pc, ([_, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 57) = {
    SEE = 57;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op2 = Slice(__opcode, 10, 2);
    let Rm = Slice(__opcode, 16, 5);
    let sf = Slice(__opcode, 31, 1);
    decode_lslv_aarch64_instrs_integer_shift_variable(Rd, Rn, op2, Rm, sf)
}

val decode_lsrv_aarch64_instrs_integer_shift_variable : (bits(5), bits(5), bits(2), bits(5), bits(1)) -> unit

function decode_lsrv_aarch64_instrs_integer_shift_variable (Rd, Rn, op2, Rm, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'datasize = if sf == 0b1 then 64 else 32;
    let shift_type : ShiftType = DecodeShift(op2);
    execute_aarch64_instrs_integer_shift_variable(d, datasize, m, n, shift_type)
}

function clause __DecodeA64_DataProcReg ((pc, ([_, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, bitzero, bitzero, bitone, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 58) = {
    SEE = 58;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op2 = Slice(__opcode, 10, 2);
    let Rm = Slice(__opcode, 16, 5);
    let sf = Slice(__opcode, 31, 1);
    decode_lsrv_aarch64_instrs_integer_shift_variable(Rd, Rn, op2, Rm, sf)
}

val decode_rorv_aarch64_instrs_integer_shift_variable : (bits(5), bits(5), bits(2), bits(5), bits(1)) -> unit

function decode_rorv_aarch64_instrs_integer_shift_variable (Rd, Rn, op2, Rm, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'datasize = if sf == 0b1 then 64 else 32;
    let shift_type : ShiftType = DecodeShift(op2);
    execute_aarch64_instrs_integer_shift_variable(d, datasize, m, n, shift_type)
}

function clause __DecodeA64_DataProcReg ((pc, ([_, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, bitzero, bitzero, bitone, bitzero, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 59) = {
    SEE = 59;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op2 = Slice(__opcode, 10, 2);
    let Rm = Slice(__opcode, 16, 5);
    let sf = Slice(__opcode, 31, 1);
    decode_rorv_aarch64_instrs_integer_shift_variable(Rd, Rn, op2, Rm, sf)
}

val execute_aarch64_instrs_integer_pac_autda_dp_1src : forall 'd 'n ('source_is_sp : Bool),
  (0 <= 'n & 'n <= 31 & 0 <= 'd & 'd <= 31).
  (int('d), int('n), bool('source_is_sp)) -> unit

function execute_aarch64_instrs_integer_pac_autda_dp_1src (d, n, source_is_sp) = {
    let auth_then_branch : bool = false;
    if HavePACExt() then {
        if source_is_sp then {
            X_set(d, 64) = AuthDA(X_read(d, 64), SP_read(), auth_then_branch)
        } else {
            X_set(d, 64) = AuthDA(X_read(d, 64), X_read(n, 64), auth_then_branch)
        }
    };
    ()
}

val decode_autda_aarch64_instrs_integer_pac_autda_dp_1src : (bits(5), bits(5), bits(1)) -> unit

function decode_autda_aarch64_instrs_integer_pac_autda_dp_1src (Rd, Rn, Z) = {
    source_is_sp : bool = false;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if not_bool(HavePACExt()) then {
        throw(Error_Undefined())
    };
    if Z == 0b0 then {
        if n == 31 then {
            source_is_sp = true
        };
        ()
    } else {
        if n != 31 then {
            throw(Error_Undefined())
        };
        ()
    };
    execute_aarch64_instrs_integer_pac_autda_dp_1src(d, n, source_is_sp)
}

function clause __DecodeA64_DataProcReg ((pc, ([bitone, bitone, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, _, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 60) = {
    SEE = 60;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Z = Slice(__opcode, 13, 1);
    decode_autda_aarch64_instrs_integer_pac_autda_dp_1src(Rd, Rn, Z)
}

val execute_aarch64_instrs_integer_pac_autdb_dp_1src : forall 'd 'n ('source_is_sp : Bool),
  (0 <= 'n & 'n <= 31 & 0 <= 'd & 'd <= 31).
  (int('d), int('n), bool('source_is_sp)) -> unit

function execute_aarch64_instrs_integer_pac_autdb_dp_1src (d, n, source_is_sp) = {
    let auth_then_branch : bool = false;
    if HavePACExt() then {
        if source_is_sp then {
            X_set(d, 64) = AuthDB(X_read(d, 64), SP_read(), auth_then_branch)
        } else {
            X_set(d, 64) = AuthDB(X_read(d, 64), X_read(n, 64), auth_then_branch)
        }
    };
    ()
}

val decode_autdb_aarch64_instrs_integer_pac_autdb_dp_1src : (bits(5), bits(5), bits(1)) -> unit

function decode_autdb_aarch64_instrs_integer_pac_autdb_dp_1src (Rd, Rn, Z) = {
    source_is_sp : bool = false;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if not_bool(HavePACExt()) then {
        throw(Error_Undefined())
    };
    if Z == 0b0 then {
        if n == 31 then {
            source_is_sp = true
        };
        ()
    } else {
        if n != 31 then {
            throw(Error_Undefined())
        };
        ()
    };
    execute_aarch64_instrs_integer_pac_autdb_dp_1src(d, n, source_is_sp)
}

function clause __DecodeA64_DataProcReg ((pc, ([bitone, bitone, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, _, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 61) = {
    SEE = 61;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Z = Slice(__opcode, 13, 1);
    decode_autdb_aarch64_instrs_integer_pac_autdb_dp_1src(Rd, Rn, Z)
}

val execute_aarch64_instrs_integer_pac_autia_dp_1src : forall 'd 'n ('source_is_sp : Bool),
  (0 <= 'n & 'n <= 31 & 0 <= 'd & 'd <= 31).
  (int('d), int('n), bool('source_is_sp)) -> unit

function execute_aarch64_instrs_integer_pac_autia_dp_1src (d, n, source_is_sp) = {
    let auth_then_branch : bool = false;
    if HavePACExt() then {
        if source_is_sp then {
            X_set(d, 64) = AuthIA(X_read(d, 64), SP_read(), auth_then_branch)
        } else {
            X_set(d, 64) = AuthIA(X_read(d, 64), X_read(n, 64), auth_then_branch)
        }
    };
    ()
}

val decode_autia_aarch64_instrs_integer_pac_autia_dp_1src : (bits(5), bits(5), bits(1)) -> unit

function decode_autia_aarch64_instrs_integer_pac_autia_dp_1src (Rd, Rn, Z) = {
    source_is_sp : bool = false;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if not_bool(HavePACExt()) then {
        throw(Error_Undefined())
    };
    if Z == 0b0 then {
        if n == 31 then {
            source_is_sp = true
        };
        ()
    } else {
        if n != 31 then {
            throw(Error_Undefined())
        };
        ()
    };
    execute_aarch64_instrs_integer_pac_autia_dp_1src(d, n, source_is_sp)
}

function clause __DecodeA64_DataProcReg ((pc, ([bitone, bitone, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, _, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 62) = {
    SEE = 62;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Z = Slice(__opcode, 13, 1);
    decode_autia_aarch64_instrs_integer_pac_autia_dp_1src(Rd, Rn, Z)
}

val decode_autia_aarch64_instrs_integer_pac_autia_hint : (bits(3), bits(4)) -> unit

function decode_autia_aarch64_instrs_integer_pac_autia_hint (op2, CRm) = {
    d : {17, 30} = 17;
    n : int = undefined;
    source_is_sp : bool = false;
    match CRm @ op2 {
      0b0011100 => {
          d = 30;
          n = 31
      },
      0b0011101 => {
          d = 30;
          source_is_sp = true
      },
      0b0001100 => {
          d = 17;
          n = 16
      },
      0b0001000 => {
          throw(Error_See("PACIA"))
      },
      0b0001010 => {
          throw(Error_See("PACIB"))
      },
      0b0001110 => {
          throw(Error_See("AUTIB"))
      },
      [bitzero, bitzero, bitone, bitone, bitzero, bitzero, _] => {
          throw(Error_See("PACIA"))
      },
      [bitzero, bitzero, bitone, bitone, bitzero, bitone, _] => {
          throw(Error_See("PACIB"))
      },
      [bitzero, bitzero, bitone, bitone, bitone, bitone, _] => {
          throw(Error_See("AUTIB"))
      },
      0b0000111 => {
          throw(Error_See("XPACLRI"))
      },
      _ => {
          throw(Error_See("HINT"))
      }
    };
    let 'n = n;
    let 'd = d;
    assert(constraint((0 <= 'n & 'n <= 31)));
    execute_aarch64_instrs_integer_pac_autia_dp_1src(d, n, source_is_sp)
}

function clause __DecodeA64_BranchExcSys ((pc, ([bitone, bitone, bitzero, bitone, bitzero, bitone, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, _, bitone, bitone, bitzero, _, bitone, bitone, bitone, bitone, bitone] as __opcode)) if SEE < 63) = {
    SEE = 63;
    let op2 = Slice(__opcode, 5, 3);
    let CRm = Slice(__opcode, 8, 4);
    decode_autia_aarch64_instrs_integer_pac_autia_hint(op2, CRm)
}

val execute_aarch64_instrs_integer_pac_autib_dp_1src : forall 'd 'n ('source_is_sp : Bool),
  (0 <= 'n & 'n <= 31 & 0 <= 'd & 'd <= 31).
  (int('d), int('n), bool('source_is_sp)) -> unit

function execute_aarch64_instrs_integer_pac_autib_dp_1src (d, n, source_is_sp) = {
    let auth_then_branch : bool = false;
    if HavePACExt() then {
        if source_is_sp then {
            X_set(d, 64) = AuthIB(X_read(d, 64), SP_read(), auth_then_branch)
        } else {
            X_set(d, 64) = AuthIB(X_read(d, 64), X_read(n, 64), auth_then_branch)
        }
    };
    ()
}

val decode_autib_aarch64_instrs_integer_pac_autib_dp_1src : (bits(5), bits(5), bits(1)) -> unit

function decode_autib_aarch64_instrs_integer_pac_autib_dp_1src (Rd, Rn, Z) = {
    source_is_sp : bool = false;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if not_bool(HavePACExt()) then {
        throw(Error_Undefined())
    };
    if Z == 0b0 then {
        if n == 31 then {
            source_is_sp = true
        };
        ()
    } else {
        if n != 31 then {
            throw(Error_Undefined())
        };
        ()
    };
    execute_aarch64_instrs_integer_pac_autib_dp_1src(d, n, source_is_sp)
}

function clause __DecodeA64_DataProcReg ((pc, ([bitone, bitone, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, _, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 64) = {
    SEE = 64;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Z = Slice(__opcode, 13, 1);
    decode_autib_aarch64_instrs_integer_pac_autib_dp_1src(Rd, Rn, Z)
}

val decode_autib_aarch64_instrs_integer_pac_autib_hint : (bits(3), bits(4)) -> unit

function decode_autib_aarch64_instrs_integer_pac_autib_hint (op2, CRm) = {
    d : {17, 30} = 17;
    n : int = undefined;
    source_is_sp : bool = false;
    match CRm @ op2 {
      0b0011110 => {
          d = 30;
          n = 31
      },
      0b0011111 => {
          d = 30;
          source_is_sp = true
      },
      0b0001110 => {
          d = 17;
          n = 16
      },
      0b0001000 => {
          throw(Error_See("PACIA"))
      },
      0b0001010 => {
          throw(Error_See("PACIB"))
      },
      0b0001100 => {
          throw(Error_See("AUTIA"))
      },
      [bitzero, bitzero, bitone, bitone, bitzero, bitzero, _] => {
          throw(Error_See("PACIA"))
      },
      [bitzero, bitzero, bitone, bitone, bitzero, bitone, _] => {
          throw(Error_See("PACIB"))
      },
      [bitzero, bitzero, bitone, bitone, bitone, bitzero, _] => {
          throw(Error_See("AUTIA"))
      },
      0b0000111 => {
          throw(Error_See("XPACLRI"))
      },
      _ => {
          throw(Error_See("HINT"))
      }
    };
    let 'n = n;
    let 'd = d;
    assert(constraint((0 <= 'n & 'n <= 31)));
    execute_aarch64_instrs_integer_pac_autib_dp_1src(d, n, source_is_sp)
}

function clause __DecodeA64_BranchExcSys ((pc, ([bitone, bitone, bitzero, bitone, bitzero, bitone, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, _, bitone, bitone, bitone, _, bitone, bitone, bitone, bitone, bitone] as __opcode)) if SEE < 65) = {
    SEE = 65;
    let op2 = Slice(__opcode, 5, 3);
    let CRm = Slice(__opcode, 8, 4);
    decode_autib_aarch64_instrs_integer_pac_autib_hint(op2, CRm)
}

val execute_aarch64_instrs_integer_flags_axflag : unit -> unit

function execute_aarch64_instrs_integer_flags_axflag () = {
    let n : bits(1) = 0b0;
    let z : bits(1) = PSTATE.Z | PSTATE.V;
    let c : bits(1) = PSTATE.C & not_vec(PSTATE.V);
    let v : bits(1) = 0b0;
    PSTATE.N = n;
    PSTATE.Z = z;
    PSTATE.C = c;
    PSTATE.V = v
}

val decode_axflag_aarch64_instrs_integer_flags_axflag : bits(4) -> unit

function decode_axflag_aarch64_instrs_integer_flags_axflag CRm = {
    if not_bool(HaveFlagFormatExt()) then {
        throw(Error_Undefined())
    };
    execute_aarch64_instrs_integer_flags_axflag()
}

function clause __DecodeA64_BranchExcSys ((pc, (0b11010101000000000100000001011111 as __opcode)) if SEE < 66) = {
    SEE = 66;
    let CRm = Slice(__opcode, 8, 4);
    if (([__opcode[8]] != 0b0 | [__opcode[9]] != 0b0) | [__opcode[10]] != 0b0) | [__opcode[11]] != 0b0 then {
        throw(Error_ConstrainedUnpredictable())
    } else {
        decode_axflag_aarch64_instrs_integer_flags_axflag(CRm)
    }
}

val execute_aarch64_instrs_branch_unconditional_immediate : (BranchType, bits(64)) -> unit

function execute_aarch64_instrs_branch_unconditional_immediate (branch_type, offset) = {
    if branch_type == BranchType_DIRCALL then {
        if HaveGCS() & GCSPCREnabled(PSTATE.EL) then {
            AddGCSRecord(PC_read() + 4)
        };
        X_set(30, 64) = PC_read() + 4
    };
    let branch_conditional : bool = false;
    BranchTo(PC_read() + offset, branch_type, branch_conditional)
}

val decode_b_uncond_aarch64_instrs_branch_unconditional_immediate : (bits(26), bits(1)) -> unit

function decode_b_uncond_aarch64_instrs_branch_unconditional_immediate (imm26, op) = {
    let branch_type : BranchType = if op == 0b1 then BranchType_DIRCALL else
      BranchType_DIR;
    let offset : bits(64) = SignExtend(imm26 @ 0b00, 64);
    execute_aarch64_instrs_branch_unconditional_immediate(branch_type, offset)
}

function clause __DecodeA64_BranchExcSys ((pc, ([bitzero, bitzero, bitzero, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 67) = {
    SEE = 67;
    let imm26 = Slice(__opcode, 0, 26);
    let op = Slice(__opcode, 31, 1);
    decode_b_uncond_aarch64_instrs_branch_unconditional_immediate(imm26, op)
}

val decode_bl_aarch64_instrs_branch_unconditional_immediate : (bits(26), bits(1)) -> unit

function decode_bl_aarch64_instrs_branch_unconditional_immediate (imm26, op) = {
    let branch_type : BranchType = if op == 0b1 then BranchType_DIRCALL else
      BranchType_DIR;
    let offset : bits(64) = SignExtend(imm26 @ 0b00, 64);
    execute_aarch64_instrs_branch_unconditional_immediate(branch_type, offset)
}

function clause __DecodeA64_BranchExcSys ((pc, ([bitone, bitzero, bitzero, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 68) = {
    SEE = 68;
    let imm26 = Slice(__opcode, 0, 26);
    let op = Slice(__opcode, 31, 1);
    decode_bl_aarch64_instrs_branch_unconditional_immediate(imm26, op)
}

val execute_aarch64_instrs_branch_conditional_cond : (bits(4), bits(64)) -> unit

function execute_aarch64_instrs_branch_conditional_cond (condition, offset) = {
    let branch_conditional : bool = true;
    if ConditionHolds(condition) then {
        BranchTo(PC_read() + offset, BranchType_DIR, branch_conditional)
    } else {
        BranchNotTaken(BranchType_DIR, branch_conditional)
    }
}

val decode_b_cond_aarch64_instrs_branch_conditional_cond : (bits(4), bits(19)) -> unit

function decode_b_cond_aarch64_instrs_branch_conditional_cond (cond, imm19) = {
    let offset : bits(64) = SignExtend(imm19 @ 0b00, 64);
    let condition : bits(4) = cond;
    execute_aarch64_instrs_branch_conditional_cond(condition, offset)
}

function clause __DecodeA64_BranchExcSys ((pc, ([bitzero, bitone, bitzero, bitone, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, bitzero, _, _, _, _] as __opcode)) if SEE < 69) = {
    SEE = 69;
    let cond = Slice(__opcode, 0, 4);
    let imm19 = Slice(__opcode, 5, 19);
    decode_b_cond_aarch64_instrs_branch_conditional_cond(cond, imm19)
}

val execute_aarch64_instrs_branch_conditional_hinted : (bits(4), bits(64)) -> unit

function execute_aarch64_instrs_branch_conditional_hinted (condition, offset) = {
    let branch_conditional : bool = true;
    if ConditionHolds(condition) then {
        BranchTo(PC_read() + offset, BranchType_DIR, branch_conditional)
    } else {
        BranchNotTaken(BranchType_DIR, branch_conditional)
    }
}

val decode_bc_cond_aarch64_instrs_branch_conditional_hinted : (bits(4), bits(19)) -> unit

function decode_bc_cond_aarch64_instrs_branch_conditional_hinted (cond, imm19) = {
    if not_bool(HaveFeatHBC()) then {
        throw(Error_Undefined())
    };
    let offset : bits(64) = SignExtend(imm19 @ 0b00, 64);
    let condition : bits(4) = cond;
    execute_aarch64_instrs_branch_conditional_hinted(condition, offset)
}

function clause __DecodeA64_BranchExcSys ((pc, ([bitzero, bitone, bitzero, bitone, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, bitone, _, _, _, _] as __opcode)) if SEE < 70) = {
    SEE = 70;
    let cond = Slice(__opcode, 0, 4);
    let imm19 = Slice(__opcode, 5, 19);
    decode_bc_cond_aarch64_instrs_branch_conditional_hinted(cond, imm19)
}

val execute_aarch64_instrs_vector_crypto_sha3_bcax : forall 'a 'd 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 0 <= 'd & 'd <= 31 & 0 <= 'a & 'a <= 31).
  (int('a), int('d), int('m), int('n)) -> unit

function execute_aarch64_instrs_vector_crypto_sha3_bcax (a, d, m, n) = {
    AArch64_CheckFPAdvSIMDEnabled();
    let Vm : bits(128) = V_read(m, 128);
    let Vn : bits(128) = V_read(n, 128);
    let Va : bits(128) = V_read(a, 128);
    V_set(d, 128) = EOR(Vn, Vm & not_vec(Va))
}

val decode_bcax_advsimd_aarch64_instrs_vector_crypto_sha3_bcax : (bits(5), bits(5), bits(5), bits(5)) -> unit

function decode_bcax_advsimd_aarch64_instrs_vector_crypto_sha3_bcax (Rd, Rn, Ra, Rm) = {
    if not_bool(HaveSHA3Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'a = UInt(Ra);
    execute_aarch64_instrs_vector_crypto_sha3_bcax(a, d, m, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitone, bitone, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitone, _, _, _, _, _, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 71) = {
    SEE = 71;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Ra = Slice(__opcode, 10, 5);
    let Rm = Slice(__opcode, 16, 5);
    decode_bcax_advsimd_aarch64_instrs_vector_crypto_sha3_bcax(Rd, Rn, Ra, Rm)
}

val execute_aarch64_instrs_vector_cvt_bf16_scalar : forall 'd 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'd & 'd <= 31).
  (int('d), int('n)) -> unit

function execute_aarch64_instrs_vector_cvt_bf16_scalar (d, n) = {
    CheckFPEnabled64();
    let operand : bits(32) = V_read(n, 32);
    let fpcr : FPCRType = FPCR_read();
    let merge : bool = IsMerging(fpcr);
    result : bits(128) = if merge then V_read(d, 128) else Zeros(128);
    result = Elem_set(result, 0, 16, FPConvertBF__1(operand, fpcr));
    V_set(d, 128) = result
}

val decode_bfcvt_float_aarch64_instrs_vector_cvt_bf16_scalar : (bits(5), bits(5)) -> unit

function decode_bfcvt_float_aarch64_instrs_vector_cvt_bf16_scalar (Rd, Rn) = {
    if not_bool(HaveBF16Ext()) then {
        throw(Error_Undefined())
    };
    let 'n = UInt(Rn);
    let 'd = UInt(Rd);
    execute_aarch64_instrs_vector_cvt_bf16_scalar(d, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 72) = {
    SEE = 72;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    decode_bfcvt_float_aarch64_instrs_vector_cvt_bf16_scalar(Rd, Rn)
}

val execute_aarch64_instrs_vector_cvt_bf16_vector : forall 'd 'elements 'n 'part,
  ('part in {0, 1} & 0 <= 'n & 'n <= 31 & 'elements == 4 & 0 <= 'd & 'd <= 31).
  (int('d), int('elements), int('n), int('part)) -> unit

function execute_aarch64_instrs_vector_cvt_bf16_vector (d, elements, n, part) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits(128) = V_read(n, 128);
    result : bits(64) = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        result = Elem_set(result, e, 16, FPConvertBF__1(Elem_read(operand, e, 32), FPCR_read()))
    };
    Vpart_set(d, part, 64) = result
}

val decode_bfcvtn_advsimd_aarch64_instrs_vector_cvt_bf16_vector : (bits(5), bits(5), bits(1)) -> unit

function decode_bfcvtn_advsimd_aarch64_instrs_vector_cvt_bf16_vector (Rd, Rn, Q) = {
    if not_bool(HaveBF16Ext()) then {
        throw(Error_Undefined())
    };
    let 'n = UInt(Rn);
    let 'd = UInt(Rd);
    let 'part = UInt(Q);
    let 'elements = DIV(64, 16);
    execute_aarch64_instrs_vector_cvt_bf16_vector(d, elements, n, part)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitone, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 73) = {
    SEE = 73;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Q = Slice(__opcode, 30, 1);
    decode_bfcvtn_advsimd_aarch64_instrs_vector_cvt_bf16_vector(Rd, Rn, Q)
}

val execute_aarch64_instrs_vector_arithmetic_binary_element_bfdot : forall 'd 'datasize 'elements 'i 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'i in {0, 1, 2, 3} & 'elements in {2, 4} & 'datasize in {64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('i), int('m), int('n)) -> unit

function execute_aarch64_instrs_vector_arithmetic_binary_element_bfdot (d, datasize, elements, i, m, n) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = V_read(n, datasize);
    let operand2 : bits(128) = V_read(m, 128);
    let operand3 : bits('datasize) = V_read(d, datasize);
    result : bits('datasize) = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        let elt1_a : bits(16) = Elem_read(operand1, 2 * e + 0, 16);
        let elt1_b : bits(16) = Elem_read(operand1, 2 * e + 1, 16);
        let elt2_a : bits(16) = Elem_read(operand2, 2 * i + 0, 16);
        let elt2_b : bits(16) = Elem_read(operand2, 2 * i + 1, 16);
        sum : bits(32) = Elem_read(operand3, e, 32);
        let sum : bits(32) = BFDotAdd(sum, elt1_a, elt1_b, elt2_a, elt2_b, FPCR_read());
        result = Elem_set(result, e, 32, sum)
    };
    V_set(d, datasize) = result
}

val decode_bfdot_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_bfdot : (bits(5), bits(5), bits(1), bits(4), bits(1), bits(1), bits(1)) -> unit

function decode_bfdot_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_bfdot (Rd, Rn, H, Rm, M, L, Q) = {
    if not_bool(HaveBF16Ext()) then {
        throw(Error_Undefined())
    };
    let 'n = UInt(Rn);
    let 'm = UInt(M @ Rm);
    let 'd = UInt(Rd);
    let 'i = UInt(H @ L);
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, 32);
    execute_aarch64_instrs_vector_arithmetic_binary_element_bfdot(d, datasize, elements, i, m, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, bitone, _, _, _, _, _, _, bitone, bitone, bitone, bitone, _, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 74) = {
    SEE = 74;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let H = Slice(__opcode, 11, 1);
    let Rm = Slice(__opcode, 16, 4);
    let M = Slice(__opcode, 20, 1);
    let L = Slice(__opcode, 21, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_bfdot_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_bfdot(Rd, Rn, H, Rm, M, L, Q)
}

val execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_bfdot : forall 'd 'datasize 'elements 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'elements in {2, 4} & 'datasize in {64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('m), int('n)) -> unit

function execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_bfdot (d, datasize, elements, m, n) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = V_read(n, datasize);
    let operand2 : bits('datasize) = V_read(m, datasize);
    let operand3 : bits('datasize) = V_read(d, datasize);
    result : bits('datasize) = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        let elt1_a : bits(16) = Elem_read(operand1, 2 * e + 0, 16);
        let elt1_b : bits(16) = Elem_read(operand1, 2 * e + 1, 16);
        let elt2_a : bits(16) = Elem_read(operand2, 2 * e + 0, 16);
        let elt2_b : bits(16) = Elem_read(operand2, 2 * e + 1, 16);
        sum : bits(32) = Elem_read(operand3, e, 32);
        let sum : bits(32) = BFDotAdd(sum, elt1_a, elt1_b, elt2_a, elt2_b, FPCR_read());
        result = Elem_set(result, e, 32, sum)
    };
    V_set(d, datasize) = result
}

val decode_bfdot_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_bfdot : (bits(5), bits(5), bits(5), bits(1)) -> unit

function decode_bfdot_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_bfdot (Rd, Rn, Rm, Q) = {
    if not_bool(HaveBF16Ext()) then {
        throw(Error_Undefined())
    };
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'd = UInt(Rd);
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, 32);
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_bfdot(d, datasize, elements, m, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, bitone, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 75) = {
    SEE = 75;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let Q = Slice(__opcode, 30, 1);
    decode_bfdot_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_bfdot(Rd, Rn, Rm, Q)
}

val execute_aarch64_instrs_integer_bitfield : forall 'd 'datasize ('extend : Bool) ('inzero : Bool) 'n 'r 's,
  (0 <= 's & 's <= 63 & 0 <= 'r & 'r <= 63 & 0 <= 'n & 'n <= 31 & 'datasize in {32, 64} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), bool('extend), bool('inzero), int('n), int('r), int('s), bits('datasize), bits('datasize)) -> unit

function execute_aarch64_instrs_integer_bitfield (d, datasize, extend, inzero, n, r, s, tmask, wmask) = {
    let dst : bits('datasize) = if inzero then Zeros(datasize) else
      X_read(d, datasize);
    let src : bits('datasize) = X_read(n, datasize);
    let bot : bits('datasize) = dst & not_vec(wmask) | ROR(src, r) & wmask;
    let top : bits('datasize) = if extend then {
        assert(constraint((0 <= 's & 's < 'datasize)));
        Replicate([src[s]], datasize)
    } else dst;
    X_set(d, datasize) = top & not_vec(tmask) | bot & tmask
}

val decode_bfm_aarch64_instrs_integer_bitfield : (bits(5), bits(5), bits(6), bits(6), bits(1), bits(2), bits(1)) -> unit

function decode_bfm_aarch64_instrs_integer_bitfield (Rd, Rn, imms, immr, N, opc, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'datasize = if sf == 0b1 then 64 else 32;
    inzero : bool = undefined;
    extend : bool = undefined;
    wmask : bits('datasize) = undefined;
    tmask : bits('datasize) = undefined;
    match opc {
      0b00 => {
          inzero = true;
          extend = true
      },
      0b01 => {
          inzero = false;
          extend = false
      },
      0b10 => {
          inzero = true;
          extend = false
      },
      0b11 => {
          throw(Error_Undefined())
      }
    };
    let extend = extend;
    let inzero = inzero;
    if sf == 0b1 & N != 0b1 then {
        throw(Error_Undefined())
    };
    if sf == 0b0 & ((N != 0b0 | [immr[5]] != 0b0) | [imms[5]] != 0b0) then {
        throw(Error_Undefined())
    };
    let 'r = UInt(immr);
    let 's = UInt(imms);
    (wmask, tmask) = DecodeBitMasks(N, imms, immr, false, datasize);
    execute_aarch64_instrs_integer_bitfield(d, datasize, extend, inzero, n, r, s, tmask, wmask)
}

function clause __DecodeA64_DataProcImm ((pc, ([_, bitzero, bitone, bitone, bitzero, bitzero, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 76) = {
    SEE = 76;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imms = Slice(__opcode, 10, 6);
    let immr = Slice(__opcode, 16, 6);
    let N = Slice(__opcode, 22, 1);
    let opc = Slice(__opcode, 29, 2);
    let sf = Slice(__opcode, 31, 1);
    decode_bfm_aarch64_instrs_integer_bitfield(Rd, Rn, imms, immr, N, opc, sf)
}

val decode_sbfm_aarch64_instrs_integer_bitfield : (bits(5), bits(5), bits(6), bits(6), bits(1), bits(2), bits(1)) -> unit

function decode_sbfm_aarch64_instrs_integer_bitfield (Rd, Rn, imms, immr, N, opc, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'datasize = if sf == 0b1 then 64 else 32;
    inzero : bool = undefined;
    extend : bool = undefined;
    wmask : bits('datasize) = undefined;
    tmask : bits('datasize) = undefined;
    match opc {
      0b00 => {
          inzero = true;
          extend = true
      },
      0b01 => {
          inzero = false;
          extend = false
      },
      0b10 => {
          inzero = true;
          extend = false
      },
      0b11 => {
          throw(Error_Undefined())
      }
    };
    let extend = extend;
    let inzero = inzero;
    if sf == 0b1 & N != 0b1 then {
        throw(Error_Undefined())
    };
    if sf == 0b0 & ((N != 0b0 | [immr[5]] != 0b0) | [imms[5]] != 0b0) then {
        throw(Error_Undefined())
    };
    let 'r = UInt(immr);
    let 's = UInt(imms);
    (wmask, tmask) = DecodeBitMasks(N, imms, immr, false, datasize);
    execute_aarch64_instrs_integer_bitfield(d, datasize, extend, inzero, n, r, s, tmask, wmask)
}

function clause __DecodeA64_DataProcImm ((pc, ([_, bitzero, bitzero, bitone, bitzero, bitzero, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 77) = {
    SEE = 77;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imms = Slice(__opcode, 10, 6);
    let immr = Slice(__opcode, 16, 6);
    let N = Slice(__opcode, 22, 1);
    let opc = Slice(__opcode, 29, 2);
    let sf = Slice(__opcode, 31, 1);
    decode_sbfm_aarch64_instrs_integer_bitfield(Rd, Rn, imms, immr, N, opc, sf)
}

val decode_ubfm_aarch64_instrs_integer_bitfield : (bits(5), bits(5), bits(6), bits(6), bits(1), bits(2), bits(1)) -> unit

function decode_ubfm_aarch64_instrs_integer_bitfield (Rd, Rn, imms, immr, N, opc, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'datasize = if sf == 0b1 then 64 else 32;
    inzero : bool = undefined;
    extend : bool = undefined;
    wmask : bits('datasize) = undefined;
    tmask : bits('datasize) = undefined;
    match opc {
      0b00 => {
          inzero = true;
          extend = true
      },
      0b01 => {
          inzero = false;
          extend = false
      },
      0b10 => {
          inzero = true;
          extend = false
      },
      0b11 => {
          throw(Error_Undefined())
      }
    };
    let extend = extend;
    let inzero = inzero;
    if sf == 0b1 & N != 0b1 then {
        throw(Error_Undefined())
    };
    if sf == 0b0 & ((N != 0b0 | [immr[5]] != 0b0) | [imms[5]] != 0b0) then {
        throw(Error_Undefined())
    };
    let 'r = UInt(immr);
    let 's = UInt(imms);
    (wmask, tmask) = DecodeBitMasks(N, imms, immr, false, datasize);
    execute_aarch64_instrs_integer_bitfield(d, datasize, extend, inzero, n, r, s, tmask, wmask)
}

function clause __DecodeA64_DataProcImm ((pc, ([_, bitone, bitzero, bitone, bitzero, bitzero, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 78) = {
    SEE = 78;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imms = Slice(__opcode, 10, 6);
    let immr = Slice(__opcode, 16, 6);
    let N = Slice(__opcode, 22, 1);
    let opc = Slice(__opcode, 29, 2);
    let sf = Slice(__opcode, 31, 1);
    decode_ubfm_aarch64_instrs_integer_bitfield(Rd, Rn, imms, immr, N, opc, sf)
}

val execute_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_bf16_long : forall 'd 'elements 'index 'm 'n 'sel,
  ('sel in {0, 1} & 0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'index in {0, 1, 2, 3, 4, 5, 6, 7} & 'elements == 4 & 0 <= 'd & 'd <= 31).
  (int('d), int('elements), int('index), int('m), int('n), int('sel)) -> unit

function execute_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_bf16_long (d, elements, index, m, n, sel) = {
    CheckFPAdvSIMDEnabled64();
    result : bits(128) = undefined;
    let operand1 : bits(128) = V_read(n, 128);
    let operand2 : bits(128) = V_read(m, 128);
    let operand3 : bits(128) = V_read(d, 128);
    let element2 : bits(16) = Elem_read(operand2, index, 16);
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        let element1 : bits(16) = Elem_read(operand1, 2 * e + sel, 16);
        let addend : bits(32) = Elem_read(operand3, e, 32);
        result = Elem_set(result, e, 32, BFMulAddH(addend, element1, element2, FPCR_read()))
    };
    V_set(d, 128) = result
}

val decode_bfmlal_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_bf16_long : (bits(5), bits(5), bits(1), bits(4), bits(1), bits(1), bits(1)) -> unit

function decode_bfmlal_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_bf16_long (Rd, Rn, H, Rm, M, L, Q) = {
    if not_bool(HaveBF16Ext()) then {
        throw(Error_Undefined())
    };
    let 'n = UInt(Rn);
    let 'm = UInt(0b0 @ Rm);
    let 'd = UInt(Rd);
    let 'index = UInt((H @ L) @ M);
    let 'elements = DIV(128, 32);
    let 'sel = UInt(Q);
    execute_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_bf16_long(d, elements, index, m, n, sel)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, bitone, bitone, bitone, bitone, _, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 79) = {
    SEE = 79;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let H = Slice(__opcode, 11, 1);
    let Rm = Slice(__opcode, 16, 4);
    let M = Slice(__opcode, 20, 1);
    let L = Slice(__opcode, 21, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_bfmlal_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_bf16_long(Rd, Rn, H, Rm, M, L, Q)
}

val execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_acc_bf16_long : forall 'd 'elements 'm 'n 'sel,
  ('sel in {0, 1} & 0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'elements == 4 & 0 <= 'd & 'd <= 31).
  (int('d), int('elements), int('m), int('n), int('sel)) -> unit

function execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_acc_bf16_long (d, elements, m, n, sel) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits(128) = V_read(n, 128);
    let operand2 : bits(128) = V_read(m, 128);
    let operand3 : bits(128) = V_read(d, 128);
    result : bits(128) = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        let element1 : bits(16) = Elem_read(operand1, 2 * e + sel, 16);
        let element2 : bits(16) = Elem_read(operand2, 2 * e + sel, 16);
        let addend : bits(32) = Elem_read(operand3, e, 32);
        result = Elem_set(result, e, 32, BFMulAddH(addend, element1, element2, FPCR_read()))
    };
    V_set(d, 128) = result
}

val decode_bfmlal_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_acc_bf16_long : (bits(5), bits(5), bits(5), bits(1)) -> unit

function decode_bfmlal_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_acc_bf16_long (Rd, Rn, Rm, Q) = {
    if not_bool(HaveBF16Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'elements = DIV(128, 32);
    let 'sel = UInt(Q);
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_acc_bf16_long(d, elements, m, n, sel)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, bitone, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 80) = {
    SEE = 80;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let Q = Slice(__opcode, 30, 1);
    decode_bfmlal_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_acc_bf16_long(Rd, Rn, Rm, Q)
}

val execute_aarch64_instrs_vector_bfmmla : forall 'd 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 0 <= 'd & 'd <= 31).
  (int('d), int('m), int('n)) -> unit

function execute_aarch64_instrs_vector_bfmmla (d, m, n) = {
    CheckFPAdvSIMDEnabled64();
    let op1 : bits(128) = V_read(n, 128);
    let op2 : bits(128) = V_read(m, 128);
    let acc : bits(128) = V_read(d, 128);
    V_set(d, 128) = BFMatMulAdd(acc, op1, op2)
}

val decode_bfmmla_advsimd_aarch64_instrs_vector_bfmmla : (bits(5), bits(5), bits(5)) -> unit

function decode_bfmmla_advsimd_aarch64_instrs_vector_bfmmla (Rd, Rn, Rm) = {
    if not_bool(HaveBF16Ext()) then {
        throw(Error_Undefined())
    };
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'd = UInt(Rd);
    execute_aarch64_instrs_vector_bfmmla(d, m, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitone, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, bitone, bitone, bitone, bitzero, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 81) = {
    SEE = 81;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    decode_bfmmla_advsimd_aarch64_instrs_vector_bfmmla(Rd, Rn, Rm)
}

val execute_aarch64_instrs_vector_logical : forall 'datasize 'rd,
  (0 <= 'rd & 'rd <= 31 & 'datasize in {64, 128}).
  (int('datasize), bits('datasize), ImmediateOp, int('rd)) -> unit

function execute_aarch64_instrs_vector_logical (datasize, imm, operation, rd) = {
    CheckFPAdvSIMDEnabled64();
    operand : bits('datasize) = undefined;
    result : bits('datasize) = undefined;
    match operation {
      ImmediateOp_MOVI => {
          result = imm
      },
      ImmediateOp_MVNI => {
          result = not_vec(imm)
      },
      ImmediateOp_ORR => {
          let operand : bits('datasize) = V_read(rd, datasize);
          result = operand | imm
      },
      ImmediateOp_BIC => {
          let operand : bits('datasize) = V_read(rd, datasize);
          result = operand & not_vec(imm)
      }
    };
    V_set(rd, datasize) = result
}

val decode_bic_advsimd_imm_aarch64_instrs_vector_logical : (bits(5), bits(1), bits(1), bits(1), bits(1), bits(1), bits(4), bits(1), bits(1), bits(1), bits(1), bits(1)) -> unit

function decode_bic_advsimd_imm_aarch64_instrs_vector_logical (Rd, h, g, f, e, d, cmode, c, b, a, op, Q) = {
    let 'rd = UInt(Rd);
    let 'datasize = if Q == 0b1 then 128 else 64;
    operation : ImmediateOp = undefined;
    match cmode @ op {
      [bitzero, _, _, bitzero, bitzero] => {
          operation = ImmediateOp_MOVI
      },
      [bitzero, _, _, bitzero, bitone] => {
          operation = ImmediateOp_MVNI
      },
      [bitzero, _, _, bitone, bitzero] => {
          operation = ImmediateOp_ORR
      },
      [bitzero, _, _, bitone, bitone] => {
          operation = ImmediateOp_BIC
      },
      [bitone, bitzero, _, bitzero, bitzero] => {
          operation = ImmediateOp_MOVI
      },
      [bitone, bitzero, _, bitzero, bitone] => {
          operation = ImmediateOp_MVNI
      },
      [bitone, bitzero, _, bitone, bitzero] => {
          operation = ImmediateOp_ORR
      },
      [bitone, bitzero, _, bitone, bitone] => {
          operation = ImmediateOp_BIC
      },
      [bitone, bitone, bitzero, _, bitzero] => {
          operation = ImmediateOp_MOVI
      },
      [bitone, bitone, bitzero, _, bitone] => {
          operation = ImmediateOp_MVNI
      },
      [bitone, bitone, bitone, bitzero, _] => {
          operation = ImmediateOp_MOVI
      },
      0b11110 => {
          operation = ImmediateOp_MOVI
      },
      0b11111 => {
          if Q == 0b0 then {
              throw(Error_Undefined())
          };
          operation = ImmediateOp_MOVI
      }
    };
    let operation = operation;
    let imm64 : bits(64) = AdvSIMDExpandImm(op, cmode, ((((((a @ b) @ c) @ d) @ e) @ f) @ g) @ h);
    let imm : bits('datasize) = Replicate(imm64, DIV(datasize, 64));
    execute_aarch64_instrs_vector_logical(datasize, imm, operation, rd)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 82) = {
    SEE = 82;
    let Rd = Slice(__opcode, 0, 5);
    let h = Slice(__opcode, 5, 1);
    let g = Slice(__opcode, 6, 1);
    let f = Slice(__opcode, 7, 1);
    let e = Slice(__opcode, 8, 1);
    let d = Slice(__opcode, 9, 1);
    let cmode = Slice(__opcode, 12, 4);
    let c = Slice(__opcode, 16, 1);
    let b = Slice(__opcode, 17, 1);
    let a = Slice(__opcode, 18, 1);
    let op = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_bic_advsimd_imm_aarch64_instrs_vector_logical(Rd, h, g, f, e, d, cmode, c, b, a, op, Q)
}

val decode_movi_advsimd_aarch64_instrs_vector_logical : (bits(5), bits(1), bits(1), bits(1), bits(1), bits(1), bits(4), bits(1), bits(1), bits(1), bits(1), bits(1)) -> unit

function decode_movi_advsimd_aarch64_instrs_vector_logical (Rd, h, g, f, e, d, cmode, c, b, a, op, Q) = {
    let 'rd = UInt(Rd);
    let 'datasize = if Q == 0b1 then 128 else 64;
    operation : ImmediateOp = undefined;
    match cmode @ op {
      [bitzero, _, _, bitzero, bitzero] => {
          operation = ImmediateOp_MOVI
      },
      [bitzero, _, _, bitzero, bitone] => {
          operation = ImmediateOp_MVNI
      },
      [bitzero, _, _, bitone, bitzero] => {
          operation = ImmediateOp_ORR
      },
      [bitzero, _, _, bitone, bitone] => {
          operation = ImmediateOp_BIC
      },
      [bitone, bitzero, _, bitzero, bitzero] => {
          operation = ImmediateOp_MOVI
      },
      [bitone, bitzero, _, bitzero, bitone] => {
          operation = ImmediateOp_MVNI
      },
      [bitone, bitzero, _, bitone, bitzero] => {
          operation = ImmediateOp_ORR
      },
      [bitone, bitzero, _, bitone, bitone] => {
          operation = ImmediateOp_BIC
      },
      [bitone, bitone, bitzero, _, bitzero] => {
          operation = ImmediateOp_MOVI
      },
      [bitone, bitone, bitzero, _, bitone] => {
          operation = ImmediateOp_MVNI
      },
      [bitone, bitone, bitone, bitzero, _] => {
          operation = ImmediateOp_MOVI
      },
      0b11110 => {
          operation = ImmediateOp_MOVI
      },
      0b11111 => {
          if Q == 0b0 then {
              throw(Error_Undefined())
          };
          operation = ImmediateOp_MOVI
      }
    };
    let operation = operation;
    let imm64 : bits(64) = AdvSIMDExpandImm(op, cmode, ((((((a @ b) @ c) @ d) @ e) @ f) @ g) @ h);
    let imm : bits('datasize) = Replicate(imm64, DIV(datasize, 64));
    execute_aarch64_instrs_vector_logical(datasize, imm, operation, rd)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, _, bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 83) = {
    SEE = 83;
    let Rd = Slice(__opcode, 0, 5);
    let h = Slice(__opcode, 5, 1);
    let g = Slice(__opcode, 6, 1);
    let f = Slice(__opcode, 7, 1);
    let e = Slice(__opcode, 8, 1);
    let d = Slice(__opcode, 9, 1);
    let cmode = Slice(__opcode, 12, 4);
    let c = Slice(__opcode, 16, 1);
    let b = Slice(__opcode, 17, 1);
    let a = Slice(__opcode, 18, 1);
    let op = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_movi_advsimd_aarch64_instrs_vector_logical(Rd, h, g, f, e, d, cmode, c, b, a, op, Q)
}

val decode_mvni_advsimd_aarch64_instrs_vector_logical : (bits(5), bits(1), bits(1), bits(1), bits(1), bits(1), bits(4), bits(1), bits(1), bits(1), bits(1), bits(1)) -> unit

function decode_mvni_advsimd_aarch64_instrs_vector_logical (Rd, h, g, f, e, d, cmode, c, b, a, op, Q) = {
    let 'rd = UInt(Rd);
    let 'datasize = if Q == 0b1 then 128 else 64;
    operation : ImmediateOp = undefined;
    match cmode @ op {
      [bitzero, _, _, bitzero, bitzero] => {
          operation = ImmediateOp_MOVI
      },
      [bitzero, _, _, bitzero, bitone] => {
          operation = ImmediateOp_MVNI
      },
      [bitzero, _, _, bitone, bitzero] => {
          operation = ImmediateOp_ORR
      },
      [bitzero, _, _, bitone, bitone] => {
          operation = ImmediateOp_BIC
      },
      [bitone, bitzero, _, bitzero, bitzero] => {
          operation = ImmediateOp_MOVI
      },
      [bitone, bitzero, _, bitzero, bitone] => {
          operation = ImmediateOp_MVNI
      },
      [bitone, bitzero, _, bitone, bitzero] => {
          operation = ImmediateOp_ORR
      },
      [bitone, bitzero, _, bitone, bitone] => {
          operation = ImmediateOp_BIC
      },
      [bitone, bitone, bitzero, _, bitzero] => {
          operation = ImmediateOp_MOVI
      },
      [bitone, bitone, bitzero, _, bitone] => {
          operation = ImmediateOp_MVNI
      },
      [bitone, bitone, bitone, bitzero, _] => {
          operation = ImmediateOp_MOVI
      },
      0b11110 => {
          operation = ImmediateOp_MOVI
      },
      0b11111 => {
          if Q == 0b0 then {
              throw(Error_Undefined())
          };
          operation = ImmediateOp_MOVI
      }
    };
    let operation = operation;
    let imm64 : bits(64) = AdvSIMDExpandImm(op, cmode, ((((((a @ b) @ c) @ d) @ e) @ f) @ g) @ h);
    let imm : bits('datasize) = Replicate(imm64, DIV(datasize, 64));
    execute_aarch64_instrs_vector_logical(datasize, imm, operation, rd)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 84) = {
    SEE = 84;
    let Rd = Slice(__opcode, 0, 5);
    let h = Slice(__opcode, 5, 1);
    let g = Slice(__opcode, 6, 1);
    let f = Slice(__opcode, 7, 1);
    let e = Slice(__opcode, 8, 1);
    let d = Slice(__opcode, 9, 1);
    let cmode = Slice(__opcode, 12, 4);
    let c = Slice(__opcode, 16, 1);
    let b = Slice(__opcode, 17, 1);
    let a = Slice(__opcode, 18, 1);
    let op = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_mvni_advsimd_aarch64_instrs_vector_logical(Rd, h, g, f, e, d, cmode, c, b, a, op, Q)
}

val decode_orr_advsimd_imm_aarch64_instrs_vector_logical : (bits(5), bits(1), bits(1), bits(1), bits(1), bits(1), bits(4), bits(1), bits(1), bits(1), bits(1), bits(1)) -> unit

function decode_orr_advsimd_imm_aarch64_instrs_vector_logical (Rd, h, g, f, e, d, cmode, c, b, a, op, Q) = {
    let 'rd = UInt(Rd);
    let 'datasize = if Q == 0b1 then 128 else 64;
    operation : ImmediateOp = undefined;
    match cmode @ op {
      [bitzero, _, _, bitzero, bitzero] => {
          operation = ImmediateOp_MOVI
      },
      [bitzero, _, _, bitzero, bitone] => {
          operation = ImmediateOp_MVNI
      },
      [bitzero, _, _, bitone, bitzero] => {
          operation = ImmediateOp_ORR
      },
      [bitzero, _, _, bitone, bitone] => {
          operation = ImmediateOp_BIC
      },
      [bitone, bitzero, _, bitzero, bitzero] => {
          operation = ImmediateOp_MOVI
      },
      [bitone, bitzero, _, bitzero, bitone] => {
          operation = ImmediateOp_MVNI
      },
      [bitone, bitzero, _, bitone, bitzero] => {
          operation = ImmediateOp_ORR
      },
      [bitone, bitzero, _, bitone, bitone] => {
          operation = ImmediateOp_BIC
      },
      [bitone, bitone, bitzero, _, bitzero] => {
          operation = ImmediateOp_MOVI
      },
      [bitone, bitone, bitzero, _, bitone] => {
          operation = ImmediateOp_MVNI
      },
      [bitone, bitone, bitone, bitzero, _] => {
          operation = ImmediateOp_MOVI
      },
      0b11110 => {
          operation = ImmediateOp_MOVI
      },
      0b11111 => {
          if Q == 0b0 then {
              throw(Error_Undefined())
          };
          operation = ImmediateOp_MOVI
      }
    };
    let operation = operation;
    let imm64 : bits(64) = AdvSIMDExpandImm(op, cmode, ((((((a @ b) @ c) @ d) @ e) @ f) @ g) @ h);
    let imm : bits('datasize) = Replicate(imm64, DIV(datasize, 64));
    execute_aarch64_instrs_vector_logical(datasize, imm, operation, rd)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 85) = {
    SEE = 85;
    let Rd = Slice(__opcode, 0, 5);
    let h = Slice(__opcode, 5, 1);
    let g = Slice(__opcode, 6, 1);
    let f = Slice(__opcode, 7, 1);
    let e = Slice(__opcode, 8, 1);
    let d = Slice(__opcode, 9, 1);
    let cmode = Slice(__opcode, 12, 4);
    let c = Slice(__opcode, 16, 1);
    let b = Slice(__opcode, 17, 1);
    let a = Slice(__opcode, 18, 1);
    let op = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_orr_advsimd_imm_aarch64_instrs_vector_logical(Rd, h, g, f, e, d, cmode, c, b, a, op, Q)
}

val execute_aarch64_instrs_vector_arithmetic_binary_uniform_logical_bsl_eor : forall 'd 'datasize 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'datasize in {64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('m), int('n), VBitOp) -> unit

function execute_aarch64_instrs_vector_arithmetic_binary_uniform_logical_bsl_eor (d, datasize, m, n, op) = {
    CheckFPAdvSIMDEnabled64();
    operand1 : bits('datasize) = undefined;
    operand2 : bits('datasize) = undefined;
    operand3 : bits('datasize) = undefined;
    let operand4 : bits('datasize) = V_read(n, datasize);
    match op {
      VBitOp_VEOR => {
          operand1 = V_read(m, datasize);
          operand2 = Zeros(datasize);
          operand3 = Ones(datasize)
      },
      VBitOp_VBSL => {
          operand1 = V_read(m, datasize);
          operand2 = operand1;
          operand3 = V_read(d, datasize)
      },
      VBitOp_VBIT => {
          operand1 = V_read(d, datasize);
          operand2 = operand1;
          operand3 = V_read(m, datasize)
      },
      VBitOp_VBIF => {
          operand1 = V_read(d, datasize);
          operand2 = operand1;
          operand3 = not_vec(V_read(m, datasize))
      }
    };
    let operand3 = operand3;
    let operand2 = operand2;
    let operand1 = operand1;
    V_set(d, datasize) = EOR(operand1, EOR(operand2, operand4) & operand3)
}

val decode_bif_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_logical_bsl_eor : (bits(5), bits(5), bits(5), bits(2), bits(1)) -> unit

function decode_bif_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_logical_bsl_eor (Rd, Rn, Rm, opc2, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = 8;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    op : VBitOp = undefined;
    match opc2 {
      0b00 => {
          op = VBitOp_VEOR
      },
      0b01 => {
          op = VBitOp_VBSL
      },
      0b10 => {
          op = VBitOp_VBIT
      },
      0b11 => {
          op = VBitOp_VBIF
      }
    };
    let op = op;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_logical_bsl_eor(d, datasize, m, n, op)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, bitone, bitone, bitone, _, _, _, _, _, bitzero, bitzero, bitzero, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 86) = {
    SEE = 86;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let opc2 = Slice(__opcode, 22, 2);
    let Q = Slice(__opcode, 30, 1);
    decode_bif_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_logical_bsl_eor(Rd, Rn, Rm, opc2, Q)
}

val decode_bit_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_logical_bsl_eor : (bits(5), bits(5), bits(5), bits(2), bits(1)) -> unit

function decode_bit_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_logical_bsl_eor (Rd, Rn, Rm, opc2, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = 8;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    op : VBitOp = undefined;
    match opc2 {
      0b00 => {
          op = VBitOp_VEOR
      },
      0b01 => {
          op = VBitOp_VBSL
      },
      0b10 => {
          op = VBitOp_VBIT
      },
      0b11 => {
          op = VBitOp_VBIF
      }
    };
    let op = op;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_logical_bsl_eor(d, datasize, m, n, op)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, bitone, bitzero, bitone, _, _, _, _, _, bitzero, bitzero, bitzero, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 87) = {
    SEE = 87;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let opc2 = Slice(__opcode, 22, 2);
    let Q = Slice(__opcode, 30, 1);
    decode_bit_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_logical_bsl_eor(Rd, Rn, Rm, opc2, Q)
}

val decode_bsl_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_logical_bsl_eor : (bits(5), bits(5), bits(5), bits(2), bits(1)) -> unit

function decode_bsl_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_logical_bsl_eor (Rd, Rn, Rm, opc2, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = 8;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    op : VBitOp = undefined;
    match opc2 {
      0b00 => {
          op = VBitOp_VEOR
      },
      0b01 => {
          op = VBitOp_VBSL
      },
      0b10 => {
          op = VBitOp_VBIT
      },
      0b11 => {
          op = VBitOp_VBIF
      }
    };
    let op = op;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_logical_bsl_eor(d, datasize, m, n, op)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, _, _, _, _, _, bitzero, bitzero, bitzero, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 88) = {
    SEE = 88;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let opc2 = Slice(__opcode, 22, 2);
    let Q = Slice(__opcode, 30, 1);
    decode_bsl_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_logical_bsl_eor(Rd, Rn, Rm, opc2, Q)
}

val decode_eor_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_logical_bsl_eor : (bits(5), bits(5), bits(5), bits(2), bits(1)) -> unit

function decode_eor_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_logical_bsl_eor (Rd, Rn, Rm, opc2, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = 8;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    op : VBitOp = undefined;
    match opc2 {
      0b00 => {
          op = VBitOp_VEOR
      },
      0b01 => {
          op = VBitOp_VBSL
      },
      0b10 => {
          op = VBitOp_VBIT
      },
      0b11 => {
          op = VBitOp_VBIF
      }
    };
    let op = op;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_logical_bsl_eor(d, datasize, m, n, op)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitone, _, _, _, _, _, bitzero, bitzero, bitzero, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 89) = {
    SEE = 89;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let opc2 = Slice(__opcode, 22, 2);
    let Q = Slice(__opcode, 30, 1);
    decode_eor_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_logical_bsl_eor(Rd, Rn, Rm, opc2, Q)
}

val execute_aarch64_instrs_branch_unconditional_register : forall 'm 'n ('pac : Bool) ('source_is_sp : Bool) ('use_key_a : Bool),
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31).
  (BranchType, int('m), int('n), bool('pac), bool('source_is_sp), bool('use_key_a)) -> unit

function execute_aarch64_instrs_branch_unconditional_register (branch_type, m, n, pac, source_is_sp, use_key_a) = {
    inst_type : GCSInstruction = undefined;
    target : bits(64) = X_read(n, 64);
    let auth_then_branch : bool = true;
    if pac then {
        let modifier : bits(64) = if source_is_sp then SP_read() else
          X_read(m, 64);
        if use_key_a then {
            target = AuthIA(target, modifier, auth_then_branch)
        } else {
            target = AuthIB(target, modifier, auth_then_branch)
        }
    };
    if (branch_type == BranchType_RET & HaveGCS()) & GCSPCREnabled(PSTATE.EL) then {
        if not_bool(pac) then {
            inst_type = GCSInstType_PRET
        } else {
            if use_key_a then {
                inst_type = GCSInstType_PRETAA
            } else {
                inst_type = GCSInstType_PRETAB
            }
        };
        target = LoadCheckGCSRecord(target, inst_type);
        SetCurrentGCSPointer(GetCurrentGCSPointer() + 8)
    };
    if branch_type == BranchType_INDCALL then {
        if HaveGCS() & GCSPCREnabled(PSTATE.EL) then {
            AddGCSRecord(PC_read() + 4)
        };
        X_set(30, 64) = PC_read() + 4
    };
    match branch_type {
      BranchType_INDIR => {
          if InGuardedPage then {
              if n == 16 | n == 17 then {
                  BTypeNext = 0b01
              } else {
                  BTypeNext = 0b11
              }
          } else {
              BTypeNext = 0b01
          }
      },
      BranchType_INDCALL => {
          BTypeNext = 0b10
      },
      BranchType_RET => {
          BTypeNext = 0b00
      },
      _ => ()
    };
    let branch_conditional : bool = false;
    BranchTo(target, branch_type, branch_conditional)
}

val decode_blr_aarch64_instrs_branch_unconditional_register : (bits(5), bits(5), bits(1), bits(1), bits(2), bits(1)) -> unit

function decode_blr_aarch64_instrs_branch_unconditional_register (Rm, Rn, M, A, op, Z) = {
    n : range(0, 31) = UInt(Rn);
    branch_type : BranchType = undefined;
    let 'm = UInt(Rm);
    let pac : bool = A == 0b1;
    let use_key_a : bool = M == 0b0;
    source_is_sp : bool = Z == 0b1 & m == 31;
    if not_bool(pac) & m != 0 then {
        throw(Error_Undefined())
    } else if pac & not_bool(HavePACExt()) then {
        throw(Error_Undefined())
    } else ();
    match op {
      0b00 => {
          branch_type = BranchType_INDIR
      },
      0b01 => {
          branch_type = BranchType_INDCALL
      },
      0b10 => {
          branch_type = BranchType_RET
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let branch_type = branch_type;
    if pac then {
        if Z == 0b0 & m != 31 then {
            throw(Error_Undefined())
        };
        if branch_type == BranchType_RET then {
            if n != 31 then {
                throw(Error_Undefined())
            };
            n = 30;
            source_is_sp = true
        };
        ()
    };
    let 'n = n;
    execute_aarch64_instrs_branch_unconditional_register(branch_type, m, n, pac, source_is_sp, use_key_a)
}

function clause __DecodeA64_BranchExcSys ((pc, ([bitone, bitone, bitzero, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, bitzero, bitzero, bitzero, bitzero, bitzero] as __opcode)) if SEE < 90) = {
    SEE = 90;
    let Rm = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let M = Slice(__opcode, 10, 1);
    let A = Slice(__opcode, 11, 1);
    let op = Slice(__opcode, 21, 2);
    let Z = Slice(__opcode, 24, 1);
    decode_blr_aarch64_instrs_branch_unconditional_register(Rm, Rn, M, A, op, Z)
}

val decode_blra_aarch64_instrs_branch_unconditional_register : (bits(5), bits(5), bits(1), bits(1), bits(2), bits(1)) -> unit

function decode_blra_aarch64_instrs_branch_unconditional_register (Rm, Rn, M, A, op, Z) = {
    n : range(0, 31) = UInt(Rn);
    branch_type : BranchType = undefined;
    let 'm = UInt(Rm);
    let pac : bool = A == 0b1;
    let use_key_a : bool = M == 0b0;
    source_is_sp : bool = Z == 0b1 & m == 31;
    if not_bool(pac) & m != 0 then {
        throw(Error_Undefined())
    } else if pac & not_bool(HavePACExt()) then {
        throw(Error_Undefined())
    } else ();
    match op {
      0b00 => {
          branch_type = BranchType_INDIR
      },
      0b01 => {
          branch_type = BranchType_INDCALL
      },
      0b10 => {
          branch_type = BranchType_RET
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let branch_type = branch_type;
    if pac then {
        if Z == 0b0 & m != 31 then {
            throw(Error_Undefined())
        };
        if branch_type == BranchType_RET then {
            if n != 31 then {
                throw(Error_Undefined())
            };
            n = 30;
            source_is_sp = true
        };
        ()
    };
    let 'n = n;
    execute_aarch64_instrs_branch_unconditional_register(branch_type, m, n, pac, source_is_sp, use_key_a)
}

function clause __DecodeA64_BranchExcSys ((pc, ([bitone, bitone, bitzero, bitone, bitzero, bitone, bitone, _, bitzero, bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 91) = {
    SEE = 91;
    let Rm = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let M = Slice(__opcode, 10, 1);
    let A = Slice(__opcode, 11, 1);
    let op = Slice(__opcode, 21, 2);
    let Z = Slice(__opcode, 24, 1);
    decode_blra_aarch64_instrs_branch_unconditional_register(Rm, Rn, M, A, op, Z)
}

val decode_br_aarch64_instrs_branch_unconditional_register : (bits(5), bits(5), bits(1), bits(1), bits(2), bits(1)) -> unit

function decode_br_aarch64_instrs_branch_unconditional_register (Rm, Rn, M, A, op, Z) = {
    n : range(0, 31) = UInt(Rn);
    branch_type : BranchType = undefined;
    let 'm = UInt(Rm);
    let pac : bool = A == 0b1;
    let use_key_a : bool = M == 0b0;
    source_is_sp : bool = Z == 0b1 & m == 31;
    if not_bool(pac) & m != 0 then {
        throw(Error_Undefined())
    } else if pac & not_bool(HavePACExt()) then {
        throw(Error_Undefined())
    } else ();
    match op {
      0b00 => {
          branch_type = BranchType_INDIR
      },
      0b01 => {
          branch_type = BranchType_INDCALL
      },
      0b10 => {
          branch_type = BranchType_RET
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let branch_type = branch_type;
    if pac then {
        if Z == 0b0 & m != 31 then {
            throw(Error_Undefined())
        };
        if branch_type == BranchType_RET then {
            if n != 31 then {
                throw(Error_Undefined())
            };
            n = 30;
            source_is_sp = true
        };
        ()
    };
    let 'n = n;
    execute_aarch64_instrs_branch_unconditional_register(branch_type, m, n, pac, source_is_sp, use_key_a)
}

function clause __DecodeA64_BranchExcSys ((pc, ([bitone, bitone, bitzero, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, bitzero, bitzero, bitzero, bitzero, bitzero] as __opcode)) if SEE < 92) = {
    SEE = 92;
    let Rm = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let M = Slice(__opcode, 10, 1);
    let A = Slice(__opcode, 11, 1);
    let op = Slice(__opcode, 21, 2);
    let Z = Slice(__opcode, 24, 1);
    decode_br_aarch64_instrs_branch_unconditional_register(Rm, Rn, M, A, op, Z)
}

val decode_bra_aarch64_instrs_branch_unconditional_register : (bits(5), bits(5), bits(1), bits(1), bits(2), bits(1)) -> unit

function decode_bra_aarch64_instrs_branch_unconditional_register (Rm, Rn, M, A, op, Z) = {
    n : range(0, 31) = UInt(Rn);
    branch_type : BranchType = undefined;
    let 'm = UInt(Rm);
    let pac : bool = A == 0b1;
    let use_key_a : bool = M == 0b0;
    source_is_sp : bool = Z == 0b1 & m == 31;
    if not_bool(pac) & m != 0 then {
        throw(Error_Undefined())
    } else if pac & not_bool(HavePACExt()) then {
        throw(Error_Undefined())
    } else ();
    match op {
      0b00 => {
          branch_type = BranchType_INDIR
      },
      0b01 => {
          branch_type = BranchType_INDCALL
      },
      0b10 => {
          branch_type = BranchType_RET
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let branch_type = branch_type;
    if pac then {
        if Z == 0b0 & m != 31 then {
            throw(Error_Undefined())
        };
        if branch_type == BranchType_RET then {
            if n != 31 then {
                throw(Error_Undefined())
            };
            n = 30;
            source_is_sp = true
        };
        ()
    };
    let 'n = n;
    execute_aarch64_instrs_branch_unconditional_register(branch_type, m, n, pac, source_is_sp, use_key_a)
}

function clause __DecodeA64_BranchExcSys ((pc, ([bitone, bitone, bitzero, bitone, bitzero, bitone, bitone, _, bitzero, bitzero, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 93) = {
    SEE = 93;
    let Rm = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let M = Slice(__opcode, 10, 1);
    let A = Slice(__opcode, 11, 1);
    let op = Slice(__opcode, 21, 2);
    let Z = Slice(__opcode, 24, 1);
    decode_bra_aarch64_instrs_branch_unconditional_register(Rm, Rn, M, A, op, Z)
}

val decode_ret_aarch64_instrs_branch_unconditional_register : (bits(5), bits(5), bits(1), bits(1), bits(2), bits(1)) -> unit

function decode_ret_aarch64_instrs_branch_unconditional_register (Rm, Rn, M, A, op, Z) = {
    n : range(0, 31) = UInt(Rn);
    branch_type : BranchType = undefined;
    let 'm = UInt(Rm);
    let pac : bool = A == 0b1;
    let use_key_a : bool = M == 0b0;
    source_is_sp : bool = Z == 0b1 & m == 31;
    if not_bool(pac) & m != 0 then {
        throw(Error_Undefined())
    } else if pac & not_bool(HavePACExt()) then {
        throw(Error_Undefined())
    } else ();
    match op {
      0b00 => {
          branch_type = BranchType_INDIR
      },
      0b01 => {
          branch_type = BranchType_INDCALL
      },
      0b10 => {
          branch_type = BranchType_RET
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let branch_type = branch_type;
    if pac then {
        if Z == 0b0 & m != 31 then {
            throw(Error_Undefined())
        };
        if branch_type == BranchType_RET then {
            if n != 31 then {
                throw(Error_Undefined())
            };
            n = 30;
            source_is_sp = true
        };
        ()
    };
    let 'n = n;
    execute_aarch64_instrs_branch_unconditional_register(branch_type, m, n, pac, source_is_sp, use_key_a)
}

function clause __DecodeA64_BranchExcSys ((pc, ([bitone, bitone, bitzero, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, bitzero, bitzero, bitzero, bitzero, bitzero] as __opcode)) if SEE < 94) = {
    SEE = 94;
    let Rm = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let M = Slice(__opcode, 10, 1);
    let A = Slice(__opcode, 11, 1);
    let op = Slice(__opcode, 21, 2);
    let Z = Slice(__opcode, 24, 1);
    decode_ret_aarch64_instrs_branch_unconditional_register(Rm, Rn, M, A, op, Z)
}

val decode_reta_aarch64_instrs_branch_unconditional_register : (bits(5), bits(5), bits(1), bits(1), bits(2), bits(1)) -> unit

function decode_reta_aarch64_instrs_branch_unconditional_register (Rm, Rn, M, A, op, Z) = {
    n : range(0, 31) = UInt(Rn);
    branch_type : BranchType = undefined;
    let 'm = UInt(Rm);
    let pac : bool = A == 0b1;
    let use_key_a : bool = M == 0b0;
    source_is_sp : bool = Z == 0b1 & m == 31;
    if not_bool(pac) & m != 0 then {
        throw(Error_Undefined())
    } else if pac & not_bool(HavePACExt()) then {
        throw(Error_Undefined())
    } else ();
    match op {
      0b00 => {
          branch_type = BranchType_INDIR
      },
      0b01 => {
          branch_type = BranchType_INDCALL
      },
      0b10 => {
          branch_type = BranchType_RET
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let branch_type = branch_type;
    if pac then {
        if Z == 0b0 & m != 31 then {
            throw(Error_Undefined())
        };
        if branch_type == BranchType_RET then {
            if n != 31 then {
                throw(Error_Undefined())
            };
            n = 30;
            source_is_sp = true
        };
        ()
    };
    let 'n = n;
    execute_aarch64_instrs_branch_unconditional_register(branch_type, m, n, pac, source_is_sp, use_key_a)
}

function clause __DecodeA64_BranchExcSys ((pc, ([bitone, bitone, bitzero, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, _, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitone] as __opcode)) if SEE < 95) = {
    SEE = 95;
    let Rm = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let M = Slice(__opcode, 10, 1);
    let A = Slice(__opcode, 11, 1);
    let op = Slice(__opcode, 21, 2);
    let Z = Slice(__opcode, 24, 1);
    decode_reta_aarch64_instrs_branch_unconditional_register(Rm, Rn, M, A, op, Z)
}

val execute_aarch64_instrs_system_exceptions_debug_breakpoint : bits(16) -> unit

function execute_aarch64_instrs_system_exceptions_debug_breakpoint comment = {
    AArch64_SoftwareBreakpoint(comment)
}

val decode_brk_aarch64_instrs_system_exceptions_debug_breakpoint : bits(16) -> unit

function decode_brk_aarch64_instrs_system_exceptions_debug_breakpoint imm16 = {
    let comment : bits(16) = imm16;
    if HaveBTIExt() then {
        SetBTypeCompatible(true)
    };
    execute_aarch64_instrs_system_exceptions_debug_breakpoint(comment)
}

function clause __DecodeA64_BranchExcSys ((pc, ([bitone, bitone, bitzero, bitone, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, bitzero, bitzero, bitzero, bitzero, bitzero] as __opcode)) if SEE < 96) = {
    SEE = 96;
    let imm16 = Slice(__opcode, 5, 16);
    decode_brk_aarch64_instrs_system_exceptions_debug_breakpoint(imm16)
}

val execute_aarch64_instrs_system_hints : SystemHintOp -> unit

function execute_aarch64_instrs_system_hints op = {
    match op {
      SystemHintOp_YIELD => {
          Hint_Yield()
      },
      SystemHintOp_DGH => {
          Hint_DGH()
      },
      SystemHintOp_WFE => {
          let 'localtimeout = (1 << 64);
          Hint_WFE(localtimeout, WFxType_WFE)
      },
      SystemHintOp_WFI => {
          let 'localtimeout = (1 << 64);
          Hint_WFI(localtimeout, WFxType_WFI)
      },
      SystemHintOp_SEV => {
          SendEvent()
      },
      SystemHintOp_SEVL => {
          SendEventLocal()
      },
      SystemHintOp_ESB => {
          if HaveTME() & TSTATE.depth > 0 then {
              FailTransaction(TMFailure_ERR, false)
          };
          SynchronizeErrors();
          AArch64_ESBOperation();
          if (PSTATE.EL == EL0 | PSTATE.EL == EL1) & EL2Enabled() then {
              AArch64_vESBOperation()
          };
          TakeUnmaskedSErrorInterrupts()
      },
      SystemHintOp_PSB => {
          ProfilingSynchronizationBarrier()
      },
      SystemHintOp_TSB => {
          TraceSynchronizationBarrier()
      },
      SystemHintOp_GCSB => {
          GCSSynchronizationBarrier()
      },
      SystemHintOp_CHKFEAT => {
          X_set(16, 64) = AArch64_ChkFeat(X_read(16, 64))
      },
      SystemHintOp_CSDB => {
          ConsumptionOfSpeculativeDataBarrier()
      },
      SystemHintOp_CLRBHB => {
          Hint_CLRBHB()
      },
      SystemHintOp_BTI => {
          SetBTypeNext(0b00)
      },
      SystemHintOp_NOP => {
          return()
      },
      _ => {
          Unreachable()
      }
    }
}

val decode_bti_aarch64_instrs_system_hints : (bits(3), bits(4)) -> unit

function decode_bti_aarch64_instrs_system_hints (op2, CRm) = {
    op : SystemHintOp = undefined;
    match CRm @ op2 {
      0b0000000 => {
          op = SystemHintOp_NOP
      },
      0b0000001 => {
          op = SystemHintOp_YIELD
      },
      0b0000010 => {
          op = SystemHintOp_WFE
      },
      0b0000011 => {
          op = SystemHintOp_WFI
      },
      0b0000100 => {
          op = SystemHintOp_SEV
      },
      0b0000101 => {
          op = SystemHintOp_SEVL
      },
      0b0000110 => {
          if not_bool(HaveDGHExt()) then {
              EndOfInstruction()
          };
          op = SystemHintOp_DGH
      },
      0b0000111 => {
          throw(Error_See("XPACLRI"))
      },
      [bitzero, bitzero, bitzero, bitone, _, _, _] => {
          match op2 {
            0b000 => {
                throw(Error_See("PACIA1716"))
            },
            0b010 => {
                throw(Error_See("PACIB1716"))
            },
            0b100 => {
                throw(Error_See("AUTIA1716"))
            },
            0b110 => {
                throw(Error_See("AUTIB1716"))
            },
            _ => {
                EndOfInstruction()
            }
          }
      },
      0b0010000 => {
          if not_bool(HaveRASExt()) then {
              EndOfInstruction()
          };
          op = SystemHintOp_ESB
      },
      0b0010001 => {
          if not_bool(HaveStatisticalProfiling()) then {
              EndOfInstruction()
          };
          op = SystemHintOp_PSB
      },
      0b0010010 => {
          if not_bool(HaveSelfHostedTrace()) then {
              EndOfInstruction()
          };
          op = SystemHintOp_TSB
      },
      0b0010011 => {
          if not_bool(IsFeatureImplemented(FEAT_GCS)) then {
              EndOfInstruction()
          };
          op = SystemHintOp_GCSB
      },
      0b0010100 => {
          op = SystemHintOp_CSDB
      },
      0b0010110 => {
          if not_bool(HaveFeatCLRBHB()) then {
              EndOfInstruction()
          };
          op = SystemHintOp_CLRBHB
      },
      [bitzero, bitzero, bitone, bitone, _, _, _] => {
          match op2 {
            0b000 => {
                throw(Error_See("PACIAZ"))
            },
            0b001 => {
                throw(Error_See("PACIASP"))
            },
            0b010 => {
                throw(Error_See("PACIBZ"))
            },
            0b011 => {
                throw(Error_See("PACIBSP"))
            },
            0b100 => {
                throw(Error_See("AUTIAZ"))
            },
            0b101 => {
                throw(Error_See("AUTIASP"))
            },
            0b110 => {
                throw(Error_See("AUTIBZ"))
            },
            0b111 => {
                throw(Error_See("AUTIBSP"))
            }
          }
      },
      [bitzero, bitone, bitzero, bitzero, _, _, bitzero] => {
          op = SystemHintOp_BTI;
          SetBTypeCompatible(BTypeCompatible_BTI(op2[2 .. 1]))
      },
      0b0101000 => {
          if not_bool(IsFeatureImplemented(FEAT_CHK)) then {
              EndOfInstruction()
          };
          op = SystemHintOp_CHKFEAT
      },
      _ => {
          EndOfInstruction()
      }
    };
    execute_aarch64_instrs_system_hints(op)
}

function clause __DecodeA64_BranchExcSys ((pc, ([bitone, bitone, bitzero, bitone, bitzero, bitone, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitone, bitzero, bitzero, bitone, bitzero, bitzero, _, _, bitzero, bitone, bitone, bitone, bitone, bitone] as __opcode)) if SEE < 97) = {
    SEE = 97;
    let op2 = Slice(__opcode, 5, 3);
    let CRm = Slice(__opcode, 8, 4);
    decode_bti_aarch64_instrs_system_hints(op2, CRm)
}

val decode_chkfeat_aarch64_instrs_system_hints : (bits(3), bits(4)) -> unit

function decode_chkfeat_aarch64_instrs_system_hints (op2, CRm) = {
    op : SystemHintOp = undefined;
    match CRm @ op2 {
      0b0000000 => {
          op = SystemHintOp_NOP
      },
      0b0000001 => {
          op = SystemHintOp_YIELD
      },
      0b0000010 => {
          op = SystemHintOp_WFE
      },
      0b0000011 => {
          op = SystemHintOp_WFI
      },
      0b0000100 => {
          op = SystemHintOp_SEV
      },
      0b0000101 => {
          op = SystemHintOp_SEVL
      },
      0b0000110 => {
          if not_bool(HaveDGHExt()) then {
              EndOfInstruction()
          };
          op = SystemHintOp_DGH
      },
      0b0000111 => {
          throw(Error_See("XPACLRI"))
      },
      [bitzero, bitzero, bitzero, bitone, _, _, _] => {
          match op2 {
            0b000 => {
                throw(Error_See("PACIA1716"))
            },
            0b010 => {
                throw(Error_See("PACIB1716"))
            },
            0b100 => {
                throw(Error_See("AUTIA1716"))
            },
            0b110 => {
                throw(Error_See("AUTIB1716"))
            },
            _ => {
                EndOfInstruction()
            }
          }
      },
      0b0010000 => {
          if not_bool(HaveRASExt()) then {
              EndOfInstruction()
          };
          op = SystemHintOp_ESB
      },
      0b0010001 => {
          if not_bool(HaveStatisticalProfiling()) then {
              EndOfInstruction()
          };
          op = SystemHintOp_PSB
      },
      0b0010010 => {
          if not_bool(HaveSelfHostedTrace()) then {
              EndOfInstruction()
          };
          op = SystemHintOp_TSB
      },
      0b0010011 => {
          if not_bool(IsFeatureImplemented(FEAT_GCS)) then {
              EndOfInstruction()
          };
          op = SystemHintOp_GCSB
      },
      0b0010100 => {
          op = SystemHintOp_CSDB
      },
      0b0010110 => {
          if not_bool(HaveFeatCLRBHB()) then {
              EndOfInstruction()
          };
          op = SystemHintOp_CLRBHB
      },
      [bitzero, bitzero, bitone, bitone, _, _, _] => {
          match op2 {
            0b000 => {
                throw(Error_See("PACIAZ"))
            },
            0b001 => {
                throw(Error_See("PACIASP"))
            },
            0b010 => {
                throw(Error_See("PACIBZ"))
            },
            0b011 => {
                throw(Error_See("PACIBSP"))
            },
            0b100 => {
                throw(Error_See("AUTIAZ"))
            },
            0b101 => {
                throw(Error_See("AUTIASP"))
            },
            0b110 => {
                throw(Error_See("AUTIBZ"))
            },
            0b111 => {
                throw(Error_See("AUTIBSP"))
            }
          }
      },
      [bitzero, bitone, bitzero, bitzero, _, _, bitzero] => {
          op = SystemHintOp_BTI;
          SetBTypeCompatible(BTypeCompatible_BTI(op2[2 .. 1]))
      },
      0b0101000 => {
          if not_bool(IsFeatureImplemented(FEAT_CHK)) then {
              EndOfInstruction()
          };
          op = SystemHintOp_CHKFEAT
      },
      _ => {
          EndOfInstruction()
      }
    };
    execute_aarch64_instrs_system_hints(op)
}

function clause __DecodeA64_BranchExcSys ((pc, (0b11010101000000110010010100011111 as __opcode)) if SEE < 98) = {
    SEE = 98;
    let op2 = Slice(__opcode, 5, 3);
    let CRm = Slice(__opcode, 8, 4);
    decode_chkfeat_aarch64_instrs_system_hints(op2, CRm)
}

val decode_clrbhb_aarch64_instrs_system_hints : (bits(3), bits(4)) -> unit

function decode_clrbhb_aarch64_instrs_system_hints (op2, CRm) = {
    op : SystemHintOp = undefined;
    match CRm @ op2 {
      0b0000000 => {
          op = SystemHintOp_NOP
      },
      0b0000001 => {
          op = SystemHintOp_YIELD
      },
      0b0000010 => {
          op = SystemHintOp_WFE
      },
      0b0000011 => {
          op = SystemHintOp_WFI
      },
      0b0000100 => {
          op = SystemHintOp_SEV
      },
      0b0000101 => {
          op = SystemHintOp_SEVL
      },
      0b0000110 => {
          if not_bool(HaveDGHExt()) then {
              EndOfInstruction()
          };
          op = SystemHintOp_DGH
      },
      0b0000111 => {
          throw(Error_See("XPACLRI"))
      },
      [bitzero, bitzero, bitzero, bitone, _, _, _] => {
          match op2 {
            0b000 => {
                throw(Error_See("PACIA1716"))
            },
            0b010 => {
                throw(Error_See("PACIB1716"))
            },
            0b100 => {
                throw(Error_See("AUTIA1716"))
            },
            0b110 => {
                throw(Error_See("AUTIB1716"))
            },
            _ => {
                EndOfInstruction()
            }
          }
      },
      0b0010000 => {
          if not_bool(HaveRASExt()) then {
              EndOfInstruction()
          };
          op = SystemHintOp_ESB
      },
      0b0010001 => {
          if not_bool(HaveStatisticalProfiling()) then {
              EndOfInstruction()
          };
          op = SystemHintOp_PSB
      },
      0b0010010 => {
          if not_bool(HaveSelfHostedTrace()) then {
              EndOfInstruction()
          };
          op = SystemHintOp_TSB
      },
      0b0010011 => {
          if not_bool(IsFeatureImplemented(FEAT_GCS)) then {
              EndOfInstruction()
          };
          op = SystemHintOp_GCSB
      },
      0b0010100 => {
          op = SystemHintOp_CSDB
      },
      0b0010110 => {
          if not_bool(HaveFeatCLRBHB()) then {
              EndOfInstruction()
          };
          op = SystemHintOp_CLRBHB
      },
      [bitzero, bitzero, bitone, bitone, _, _, _] => {
          match op2 {
            0b000 => {
                throw(Error_See("PACIAZ"))
            },
            0b001 => {
                throw(Error_See("PACIASP"))
            },
            0b010 => {
                throw(Error_See("PACIBZ"))
            },
            0b011 => {
                throw(Error_See("PACIBSP"))
            },
            0b100 => {
                throw(Error_See("AUTIAZ"))
            },
            0b101 => {
                throw(Error_See("AUTIASP"))
            },
            0b110 => {
                throw(Error_See("AUTIBZ"))
            },
            0b111 => {
                throw(Error_See("AUTIBSP"))
            }
          }
      },
      [bitzero, bitone, bitzero, bitzero, _, _, bitzero] => {
          op = SystemHintOp_BTI;
          SetBTypeCompatible(BTypeCompatible_BTI(op2[2 .. 1]))
      },
      0b0101000 => {
          if not_bool(IsFeatureImplemented(FEAT_CHK)) then {
              EndOfInstruction()
          };
          op = SystemHintOp_CHKFEAT
      },
      _ => {
          EndOfInstruction()
      }
    };
    execute_aarch64_instrs_system_hints(op)
}

function clause __DecodeA64_BranchExcSys ((pc, (0b11010101000000110010001011011111 as __opcode)) if SEE < 99) = {
    SEE = 99;
    let op2 = Slice(__opcode, 5, 3);
    let CRm = Slice(__opcode, 8, 4);
    decode_clrbhb_aarch64_instrs_system_hints(op2, CRm)
}

val decode_csdb_aarch64_instrs_system_hints : (bits(3), bits(4)) -> unit

function decode_csdb_aarch64_instrs_system_hints (op2, CRm) = {
    op : SystemHintOp = undefined;
    match CRm @ op2 {
      0b0000000 => {
          op = SystemHintOp_NOP
      },
      0b0000001 => {
          op = SystemHintOp_YIELD
      },
      0b0000010 => {
          op = SystemHintOp_WFE
      },
      0b0000011 => {
          op = SystemHintOp_WFI
      },
      0b0000100 => {
          op = SystemHintOp_SEV
      },
      0b0000101 => {
          op = SystemHintOp_SEVL
      },
      0b0000110 => {
          if not_bool(HaveDGHExt()) then {
              EndOfInstruction()
          };
          op = SystemHintOp_DGH
      },
      0b0000111 => {
          throw(Error_See("XPACLRI"))
      },
      [bitzero, bitzero, bitzero, bitone, _, _, _] => {
          match op2 {
            0b000 => {
                throw(Error_See("PACIA1716"))
            },
            0b010 => {
                throw(Error_See("PACIB1716"))
            },
            0b100 => {
                throw(Error_See("AUTIA1716"))
            },
            0b110 => {
                throw(Error_See("AUTIB1716"))
            },
            _ => {
                EndOfInstruction()
            }
          }
      },
      0b0010000 => {
          if not_bool(HaveRASExt()) then {
              EndOfInstruction()
          };
          op = SystemHintOp_ESB
      },
      0b0010001 => {
          if not_bool(HaveStatisticalProfiling()) then {
              EndOfInstruction()
          };
          op = SystemHintOp_PSB
      },
      0b0010010 => {
          if not_bool(HaveSelfHostedTrace()) then {
              EndOfInstruction()
          };
          op = SystemHintOp_TSB
      },
      0b0010011 => {
          if not_bool(IsFeatureImplemented(FEAT_GCS)) then {
              EndOfInstruction()
          };
          op = SystemHintOp_GCSB
      },
      0b0010100 => {
          op = SystemHintOp_CSDB
      },
      0b0010110 => {
          if not_bool(HaveFeatCLRBHB()) then {
              EndOfInstruction()
          };
          op = SystemHintOp_CLRBHB
      },
      [bitzero, bitzero, bitone, bitone, _, _, _] => {
          match op2 {
            0b000 => {
                throw(Error_See("PACIAZ"))
            },
            0b001 => {
                throw(Error_See("PACIASP"))
            },
            0b010 => {
                throw(Error_See("PACIBZ"))
            },
            0b011 => {
                throw(Error_See("PACIBSP"))
            },
            0b100 => {
                throw(Error_See("AUTIAZ"))
            },
            0b101 => {
                throw(Error_See("AUTIASP"))
            },
            0b110 => {
                throw(Error_See("AUTIBZ"))
            },
            0b111 => {
                throw(Error_See("AUTIBSP"))
            }
          }
      },
      [bitzero, bitone, bitzero, bitzero, _, _, bitzero] => {
          op = SystemHintOp_BTI;
          SetBTypeCompatible(BTypeCompatible_BTI(op2[2 .. 1]))
      },
      0b0101000 => {
          if not_bool(IsFeatureImplemented(FEAT_CHK)) then {
              EndOfInstruction()
          };
          op = SystemHintOp_CHKFEAT
      },
      _ => {
          EndOfInstruction()
      }
    };
    execute_aarch64_instrs_system_hints(op)
}

function clause __DecodeA64_BranchExcSys ((pc, (0b11010101000000110010001010011111 as __opcode)) if SEE < 100) = {
    SEE = 100;
    let op2 = Slice(__opcode, 5, 3);
    let CRm = Slice(__opcode, 8, 4);
    decode_csdb_aarch64_instrs_system_hints(op2, CRm)
}

val decode_dgh_aarch64_instrs_system_hints : (bits(3), bits(4)) -> unit

function decode_dgh_aarch64_instrs_system_hints (op2, CRm) = {
    op : SystemHintOp = undefined;
    match CRm @ op2 {
      0b0000000 => {
          op = SystemHintOp_NOP
      },
      0b0000001 => {
          op = SystemHintOp_YIELD
      },
      0b0000010 => {
          op = SystemHintOp_WFE
      },
      0b0000011 => {
          op = SystemHintOp_WFI
      },
      0b0000100 => {
          op = SystemHintOp_SEV
      },
      0b0000101 => {
          op = SystemHintOp_SEVL
      },
      0b0000110 => {
          if not_bool(HaveDGHExt()) then {
              EndOfInstruction()
          };
          op = SystemHintOp_DGH
      },
      0b0000111 => {
          throw(Error_See("XPACLRI"))
      },
      [bitzero, bitzero, bitzero, bitone, _, _, _] => {
          match op2 {
            0b000 => {
                throw(Error_See("PACIA1716"))
            },
            0b010 => {
                throw(Error_See("PACIB1716"))
            },
            0b100 => {
                throw(Error_See("AUTIA1716"))
            },
            0b110 => {
                throw(Error_See("AUTIB1716"))
            },
            _ => {
                EndOfInstruction()
            }
          }
      },
      0b0010000 => {
          if not_bool(HaveRASExt()) then {
              EndOfInstruction()
          };
          op = SystemHintOp_ESB
      },
      0b0010001 => {
          if not_bool(HaveStatisticalProfiling()) then {
              EndOfInstruction()
          };
          op = SystemHintOp_PSB
      },
      0b0010010 => {
          if not_bool(HaveSelfHostedTrace()) then {
              EndOfInstruction()
          };
          op = SystemHintOp_TSB
      },
      0b0010011 => {
          if not_bool(IsFeatureImplemented(FEAT_GCS)) then {
              EndOfInstruction()
          };
          op = SystemHintOp_GCSB
      },
      0b0010100 => {
          op = SystemHintOp_CSDB
      },
      0b0010110 => {
          if not_bool(HaveFeatCLRBHB()) then {
              EndOfInstruction()
          };
          op = SystemHintOp_CLRBHB
      },
      [bitzero, bitzero, bitone, bitone, _, _, _] => {
          match op2 {
            0b000 => {
                throw(Error_See("PACIAZ"))
            },
            0b001 => {
                throw(Error_See("PACIASP"))
            },
            0b010 => {
                throw(Error_See("PACIBZ"))
            },
            0b011 => {
                throw(Error_See("PACIBSP"))
            },
            0b100 => {
                throw(Error_See("AUTIAZ"))
            },
            0b101 => {
                throw(Error_See("AUTIASP"))
            },
            0b110 => {
                throw(Error_See("AUTIBZ"))
            },
            0b111 => {
                throw(Error_See("AUTIBSP"))
            }
          }
      },
      [bitzero, bitone, bitzero, bitzero, _, _, bitzero] => {
          op = SystemHintOp_BTI;
          SetBTypeCompatible(BTypeCompatible_BTI(op2[2 .. 1]))
      },
      0b0101000 => {
          if not_bool(IsFeatureImplemented(FEAT_CHK)) then {
              EndOfInstruction()
          };
          op = SystemHintOp_CHKFEAT
      },
      _ => {
          EndOfInstruction()
      }
    };
    execute_aarch64_instrs_system_hints(op)
}

function clause __DecodeA64_BranchExcSys ((pc, (0b11010101000000110010000011011111 as __opcode)) if SEE < 101) = {
    SEE = 101;
    let op2 = Slice(__opcode, 5, 3);
    let CRm = Slice(__opcode, 8, 4);
    decode_dgh_aarch64_instrs_system_hints(op2, CRm)
}

val decode_esb_aarch64_instrs_system_hints : (bits(3), bits(4)) -> unit

function decode_esb_aarch64_instrs_system_hints (op2, CRm) = {
    op : SystemHintOp = undefined;
    match CRm @ op2 {
      0b0000000 => {
          op = SystemHintOp_NOP
      },
      0b0000001 => {
          op = SystemHintOp_YIELD
      },
      0b0000010 => {
          op = SystemHintOp_WFE
      },
      0b0000011 => {
          op = SystemHintOp_WFI
      },
      0b0000100 => {
          op = SystemHintOp_SEV
      },
      0b0000101 => {
          op = SystemHintOp_SEVL
      },
      0b0000110 => {
          if not_bool(HaveDGHExt()) then {
              EndOfInstruction()
          };
          op = SystemHintOp_DGH
      },
      0b0000111 => {
          throw(Error_See("XPACLRI"))
      },
      [bitzero, bitzero, bitzero, bitone, _, _, _] => {
          match op2 {
            0b000 => {
                throw(Error_See("PACIA1716"))
            },
            0b010 => {
                throw(Error_See("PACIB1716"))
            },
            0b100 => {
                throw(Error_See("AUTIA1716"))
            },
            0b110 => {
                throw(Error_See("AUTIB1716"))
            },
            _ => {
                EndOfInstruction()
            }
          }
      },
      0b0010000 => {
          if not_bool(HaveRASExt()) then {
              EndOfInstruction()
          };
          op = SystemHintOp_ESB
      },
      0b0010001 => {
          if not_bool(HaveStatisticalProfiling()) then {
              EndOfInstruction()
          };
          op = SystemHintOp_PSB
      },
      0b0010010 => {
          if not_bool(HaveSelfHostedTrace()) then {
              EndOfInstruction()
          };
          op = SystemHintOp_TSB
      },
      0b0010011 => {
          if not_bool(IsFeatureImplemented(FEAT_GCS)) then {
              EndOfInstruction()
          };
          op = SystemHintOp_GCSB
      },
      0b0010100 => {
          op = SystemHintOp_CSDB
      },
      0b0010110 => {
          if not_bool(HaveFeatCLRBHB()) then {
              EndOfInstruction()
          };
          op = SystemHintOp_CLRBHB
      },
      [bitzero, bitzero, bitone, bitone, _, _, _] => {
          match op2 {
            0b000 => {
                throw(Error_See("PACIAZ"))
            },
            0b001 => {
                throw(Error_See("PACIASP"))
            },
            0b010 => {
                throw(Error_See("PACIBZ"))
            },
            0b011 => {
                throw(Error_See("PACIBSP"))
            },
            0b100 => {
                throw(Error_See("AUTIAZ"))
            },
            0b101 => {
                throw(Error_See("AUTIASP"))
            },
            0b110 => {
                throw(Error_See("AUTIBZ"))
            },
            0b111 => {
                throw(Error_See("AUTIBSP"))
            }
          }
      },
      [bitzero, bitone, bitzero, bitzero, _, _, bitzero] => {
          op = SystemHintOp_BTI;
          SetBTypeCompatible(BTypeCompatible_BTI(op2[2 .. 1]))
      },
      0b0101000 => {
          if not_bool(IsFeatureImplemented(FEAT_CHK)) then {
              EndOfInstruction()
          };
          op = SystemHintOp_CHKFEAT
      },
      _ => {
          EndOfInstruction()
      }
    };
    execute_aarch64_instrs_system_hints(op)
}

function clause __DecodeA64_BranchExcSys ((pc, (0b11010101000000110010001000011111 as __opcode)) if SEE < 102) = {
    SEE = 102;
    let op2 = Slice(__opcode, 5, 3);
    let CRm = Slice(__opcode, 8, 4);
    decode_esb_aarch64_instrs_system_hints(op2, CRm)
}

val decode_gcsb_aarch64_instrs_system_hints : (bits(3), bits(4)) -> unit

function decode_gcsb_aarch64_instrs_system_hints (op2, CRm) = {
    op : SystemHintOp = undefined;
    match CRm @ op2 {
      0b0000000 => {
          op = SystemHintOp_NOP
      },
      0b0000001 => {
          op = SystemHintOp_YIELD
      },
      0b0000010 => {
          op = SystemHintOp_WFE
      },
      0b0000011 => {
          op = SystemHintOp_WFI
      },
      0b0000100 => {
          op = SystemHintOp_SEV
      },
      0b0000101 => {
          op = SystemHintOp_SEVL
      },
      0b0000110 => {
          if not_bool(HaveDGHExt()) then {
              EndOfInstruction()
          };
          op = SystemHintOp_DGH
      },
      0b0000111 => {
          throw(Error_See("XPACLRI"))
      },
      [bitzero, bitzero, bitzero, bitone, _, _, _] => {
          match op2 {
            0b000 => {
                throw(Error_See("PACIA1716"))
            },
            0b010 => {
                throw(Error_See("PACIB1716"))
            },
            0b100 => {
                throw(Error_See("AUTIA1716"))
            },
            0b110 => {
                throw(Error_See("AUTIB1716"))
            },
            _ => {
                EndOfInstruction()
            }
          }
      },
      0b0010000 => {
          if not_bool(HaveRASExt()) then {
              EndOfInstruction()
          };
          op = SystemHintOp_ESB
      },
      0b0010001 => {
          if not_bool(HaveStatisticalProfiling()) then {
              EndOfInstruction()
          };
          op = SystemHintOp_PSB
      },
      0b0010010 => {
          if not_bool(HaveSelfHostedTrace()) then {
              EndOfInstruction()
          };
          op = SystemHintOp_TSB
      },
      0b0010011 => {
          if not_bool(IsFeatureImplemented(FEAT_GCS)) then {
              EndOfInstruction()
          };
          op = SystemHintOp_GCSB
      },
      0b0010100 => {
          op = SystemHintOp_CSDB
      },
      0b0010110 => {
          if not_bool(HaveFeatCLRBHB()) then {
              EndOfInstruction()
          };
          op = SystemHintOp_CLRBHB
      },
      [bitzero, bitzero, bitone, bitone, _, _, _] => {
          match op2 {
            0b000 => {
                throw(Error_See("PACIAZ"))
            },
            0b001 => {
                throw(Error_See("PACIASP"))
            },
            0b010 => {
                throw(Error_See("PACIBZ"))
            },
            0b011 => {
                throw(Error_See("PACIBSP"))
            },
            0b100 => {
                throw(Error_See("AUTIAZ"))
            },
            0b101 => {
                throw(Error_See("AUTIASP"))
            },
            0b110 => {
                throw(Error_See("AUTIBZ"))
            },
            0b111 => {
                throw(Error_See("AUTIBSP"))
            }
          }
      },
      [bitzero, bitone, bitzero, bitzero, _, _, bitzero] => {
          op = SystemHintOp_BTI;
          SetBTypeCompatible(BTypeCompatible_BTI(op2[2 .. 1]))
      },
      0b0101000 => {
          if not_bool(IsFeatureImplemented(FEAT_CHK)) then {
              EndOfInstruction()
          };
          op = SystemHintOp_CHKFEAT
      },
      _ => {
          EndOfInstruction()
      }
    };
    execute_aarch64_instrs_system_hints(op)
}

function clause __DecodeA64_BranchExcSys ((pc, (0b11010101000000110010001001111111 as __opcode)) if SEE < 103) = {
    SEE = 103;
    let op2 = Slice(__opcode, 5, 3);
    let CRm = Slice(__opcode, 8, 4);
    decode_gcsb_aarch64_instrs_system_hints(op2, CRm)
}

val decode_hint_aarch64_instrs_system_hints : (bits(3), bits(4)) -> unit

function decode_hint_aarch64_instrs_system_hints (op2, CRm) = {
    op : SystemHintOp = undefined;
    match CRm @ op2 {
      0b0000000 => {
          op = SystemHintOp_NOP
      },
      0b0000001 => {
          op = SystemHintOp_YIELD
      },
      0b0000010 => {
          op = SystemHintOp_WFE
      },
      0b0000011 => {
          op = SystemHintOp_WFI
      },
      0b0000100 => {
          op = SystemHintOp_SEV
      },
      0b0000101 => {
          op = SystemHintOp_SEVL
      },
      0b0000110 => {
          if not_bool(HaveDGHExt()) then {
              EndOfInstruction()
          };
          op = SystemHintOp_DGH
      },
      0b0000111 => {
          throw(Error_See("XPACLRI"))
      },
      [bitzero, bitzero, bitzero, bitone, _, _, _] => {
          match op2 {
            0b000 => {
                throw(Error_See("PACIA1716"))
            },
            0b010 => {
                throw(Error_See("PACIB1716"))
            },
            0b100 => {
                throw(Error_See("AUTIA1716"))
            },
            0b110 => {
                throw(Error_See("AUTIB1716"))
            },
            _ => {
                EndOfInstruction()
            }
          }
      },
      0b0010000 => {
          if not_bool(HaveRASExt()) then {
              EndOfInstruction()
          };
          op = SystemHintOp_ESB
      },
      0b0010001 => {
          if not_bool(HaveStatisticalProfiling()) then {
              EndOfInstruction()
          };
          op = SystemHintOp_PSB
      },
      0b0010010 => {
          if not_bool(HaveSelfHostedTrace()) then {
              EndOfInstruction()
          };
          op = SystemHintOp_TSB
      },
      0b0010011 => {
          if not_bool(IsFeatureImplemented(FEAT_GCS)) then {
              EndOfInstruction()
          };
          op = SystemHintOp_GCSB
      },
      0b0010100 => {
          op = SystemHintOp_CSDB
      },
      0b0010110 => {
          if not_bool(HaveFeatCLRBHB()) then {
              EndOfInstruction()
          };
          op = SystemHintOp_CLRBHB
      },
      [bitzero, bitzero, bitone, bitone, _, _, _] => {
          match op2 {
            0b000 => {
                throw(Error_See("PACIAZ"))
            },
            0b001 => {
                throw(Error_See("PACIASP"))
            },
            0b010 => {
                throw(Error_See("PACIBZ"))
            },
            0b011 => {
                throw(Error_See("PACIBSP"))
            },
            0b100 => {
                throw(Error_See("AUTIAZ"))
            },
            0b101 => {
                throw(Error_See("AUTIASP"))
            },
            0b110 => {
                throw(Error_See("AUTIBZ"))
            },
            0b111 => {
                throw(Error_See("AUTIBSP"))
            }
          }
      },
      [bitzero, bitone, bitzero, bitzero, _, _, bitzero] => {
          op = SystemHintOp_BTI;
          SetBTypeCompatible(BTypeCompatible_BTI(op2[2 .. 1]))
      },
      0b0101000 => {
          if not_bool(IsFeatureImplemented(FEAT_CHK)) then {
              EndOfInstruction()
          };
          op = SystemHintOp_CHKFEAT
      },
      _ => {
          EndOfInstruction()
      }
    };
    execute_aarch64_instrs_system_hints(op)
}

function clause __DecodeA64_BranchExcSys ((pc, ([bitone, bitone, bitzero, bitone, bitzero, bitone, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, bitone, bitone, bitone, bitone, bitone] as __opcode)) if SEE < 104) = {
    SEE = 104;
    let op2 = Slice(__opcode, 5, 3);
    let CRm = Slice(__opcode, 8, 4);
    decode_hint_aarch64_instrs_system_hints(op2, CRm)
}

val decode_nop_aarch64_instrs_system_hints : (bits(3), bits(4)) -> unit

function decode_nop_aarch64_instrs_system_hints (op2, CRm) = {
    op : SystemHintOp = undefined;
    match CRm @ op2 {
      0b0000000 => {
          op = SystemHintOp_NOP
      },
      0b0000001 => {
          op = SystemHintOp_YIELD
      },
      0b0000010 => {
          op = SystemHintOp_WFE
      },
      0b0000011 => {
          op = SystemHintOp_WFI
      },
      0b0000100 => {
          op = SystemHintOp_SEV
      },
      0b0000101 => {
          op = SystemHintOp_SEVL
      },
      0b0000110 => {
          if not_bool(HaveDGHExt()) then {
              EndOfInstruction()
          };
          op = SystemHintOp_DGH
      },
      0b0000111 => {
          throw(Error_See("XPACLRI"))
      },
      [bitzero, bitzero, bitzero, bitone, _, _, _] => {
          match op2 {
            0b000 => {
                throw(Error_See("PACIA1716"))
            },
            0b010 => {
                throw(Error_See("PACIB1716"))
            },
            0b100 => {
                throw(Error_See("AUTIA1716"))
            },
            0b110 => {
                throw(Error_See("AUTIB1716"))
            },
            _ => {
                EndOfInstruction()
            }
          }
      },
      0b0010000 => {
          if not_bool(HaveRASExt()) then {
              EndOfInstruction()
          };
          op = SystemHintOp_ESB
      },
      0b0010001 => {
          if not_bool(HaveStatisticalProfiling()) then {
              EndOfInstruction()
          };
          op = SystemHintOp_PSB
      },
      0b0010010 => {
          if not_bool(HaveSelfHostedTrace()) then {
              EndOfInstruction()
          };
          op = SystemHintOp_TSB
      },
      0b0010011 => {
          if not_bool(IsFeatureImplemented(FEAT_GCS)) then {
              EndOfInstruction()
          };
          op = SystemHintOp_GCSB
      },
      0b0010100 => {
          op = SystemHintOp_CSDB
      },
      0b0010110 => {
          if not_bool(HaveFeatCLRBHB()) then {
              EndOfInstruction()
          };
          op = SystemHintOp_CLRBHB
      },
      [bitzero, bitzero, bitone, bitone, _, _, _] => {
          match op2 {
            0b000 => {
                throw(Error_See("PACIAZ"))
            },
            0b001 => {
                throw(Error_See("PACIASP"))
            },
            0b010 => {
                throw(Error_See("PACIBZ"))
            },
            0b011 => {
                throw(Error_See("PACIBSP"))
            },
            0b100 => {
                throw(Error_See("AUTIAZ"))
            },
            0b101 => {
                throw(Error_See("AUTIASP"))
            },
            0b110 => {
                throw(Error_See("AUTIBZ"))
            },
            0b111 => {
                throw(Error_See("AUTIBSP"))
            }
          }
      },
      [bitzero, bitone, bitzero, bitzero, _, _, bitzero] => {
          op = SystemHintOp_BTI;
          SetBTypeCompatible(BTypeCompatible_BTI(op2[2 .. 1]))
      },
      0b0101000 => {
          if not_bool(IsFeatureImplemented(FEAT_CHK)) then {
              EndOfInstruction()
          };
          op = SystemHintOp_CHKFEAT
      },
      _ => {
          EndOfInstruction()
      }
    };
    execute_aarch64_instrs_system_hints(op)
}

function clause __DecodeA64_BranchExcSys ((pc, (0b11010101000000110010000000011111 as __opcode)) if SEE < 105) = {
    SEE = 105;
    let op2 = Slice(__opcode, 5, 3);
    let CRm = Slice(__opcode, 8, 4);
    decode_nop_aarch64_instrs_system_hints(op2, CRm)
}

val decode_psb_aarch64_instrs_system_hints : (bits(3), bits(4)) -> unit

function decode_psb_aarch64_instrs_system_hints (op2, CRm) = {
    op : SystemHintOp = undefined;
    match CRm @ op2 {
      0b0000000 => {
          op = SystemHintOp_NOP
      },
      0b0000001 => {
          op = SystemHintOp_YIELD
      },
      0b0000010 => {
          op = SystemHintOp_WFE
      },
      0b0000011 => {
          op = SystemHintOp_WFI
      },
      0b0000100 => {
          op = SystemHintOp_SEV
      },
      0b0000101 => {
          op = SystemHintOp_SEVL
      },
      0b0000110 => {
          if not_bool(HaveDGHExt()) then {
              EndOfInstruction()
          };
          op = SystemHintOp_DGH
      },
      0b0000111 => {
          throw(Error_See("XPACLRI"))
      },
      [bitzero, bitzero, bitzero, bitone, _, _, _] => {
          match op2 {
            0b000 => {
                throw(Error_See("PACIA1716"))
            },
            0b010 => {
                throw(Error_See("PACIB1716"))
            },
            0b100 => {
                throw(Error_See("AUTIA1716"))
            },
            0b110 => {
                throw(Error_See("AUTIB1716"))
            },
            _ => {
                EndOfInstruction()
            }
          }
      },
      0b0010000 => {
          if not_bool(HaveRASExt()) then {
              EndOfInstruction()
          };
          op = SystemHintOp_ESB
      },
      0b0010001 => {
          if not_bool(HaveStatisticalProfiling()) then {
              EndOfInstruction()
          };
          op = SystemHintOp_PSB
      },
      0b0010010 => {
          if not_bool(HaveSelfHostedTrace()) then {
              EndOfInstruction()
          };
          op = SystemHintOp_TSB
      },
      0b0010011 => {
          if not_bool(IsFeatureImplemented(FEAT_GCS)) then {
              EndOfInstruction()
          };
          op = SystemHintOp_GCSB
      },
      0b0010100 => {
          op = SystemHintOp_CSDB
      },
      0b0010110 => {
          if not_bool(HaveFeatCLRBHB()) then {
              EndOfInstruction()
          };
          op = SystemHintOp_CLRBHB
      },
      [bitzero, bitzero, bitone, bitone, _, _, _] => {
          match op2 {
            0b000 => {
                throw(Error_See("PACIAZ"))
            },
            0b001 => {
                throw(Error_See("PACIASP"))
            },
            0b010 => {
                throw(Error_See("PACIBZ"))
            },
            0b011 => {
                throw(Error_See("PACIBSP"))
            },
            0b100 => {
                throw(Error_See("AUTIAZ"))
            },
            0b101 => {
                throw(Error_See("AUTIASP"))
            },
            0b110 => {
                throw(Error_See("AUTIBZ"))
            },
            0b111 => {
                throw(Error_See("AUTIBSP"))
            }
          }
      },
      [bitzero, bitone, bitzero, bitzero, _, _, bitzero] => {
          op = SystemHintOp_BTI;
          SetBTypeCompatible(BTypeCompatible_BTI(op2[2 .. 1]))
      },
      0b0101000 => {
          if not_bool(IsFeatureImplemented(FEAT_CHK)) then {
              EndOfInstruction()
          };
          op = SystemHintOp_CHKFEAT
      },
      _ => {
          EndOfInstruction()
      }
    };
    execute_aarch64_instrs_system_hints(op)
}

function clause __DecodeA64_BranchExcSys ((pc, (0b11010101000000110010001000111111 as __opcode)) if SEE < 106) = {
    SEE = 106;
    let op2 = Slice(__opcode, 5, 3);
    let CRm = Slice(__opcode, 8, 4);
    decode_psb_aarch64_instrs_system_hints(op2, CRm)
}

val decode_sev_aarch64_instrs_system_hints : (bits(3), bits(4)) -> unit

function decode_sev_aarch64_instrs_system_hints (op2, CRm) = {
    op : SystemHintOp = undefined;
    match CRm @ op2 {
      0b0000000 => {
          op = SystemHintOp_NOP
      },
      0b0000001 => {
          op = SystemHintOp_YIELD
      },
      0b0000010 => {
          op = SystemHintOp_WFE
      },
      0b0000011 => {
          op = SystemHintOp_WFI
      },
      0b0000100 => {
          op = SystemHintOp_SEV
      },
      0b0000101 => {
          op = SystemHintOp_SEVL
      },
      0b0000110 => {
          if not_bool(HaveDGHExt()) then {
              EndOfInstruction()
          };
          op = SystemHintOp_DGH
      },
      0b0000111 => {
          throw(Error_See("XPACLRI"))
      },
      [bitzero, bitzero, bitzero, bitone, _, _, _] => {
          match op2 {
            0b000 => {
                throw(Error_See("PACIA1716"))
            },
            0b010 => {
                throw(Error_See("PACIB1716"))
            },
            0b100 => {
                throw(Error_See("AUTIA1716"))
            },
            0b110 => {
                throw(Error_See("AUTIB1716"))
            },
            _ => {
                EndOfInstruction()
            }
          }
      },
      0b0010000 => {
          if not_bool(HaveRASExt()) then {
              EndOfInstruction()
          };
          op = SystemHintOp_ESB
      },
      0b0010001 => {
          if not_bool(HaveStatisticalProfiling()) then {
              EndOfInstruction()
          };
          op = SystemHintOp_PSB
      },
      0b0010010 => {
          if not_bool(HaveSelfHostedTrace()) then {
              EndOfInstruction()
          };
          op = SystemHintOp_TSB
      },
      0b0010011 => {
          if not_bool(IsFeatureImplemented(FEAT_GCS)) then {
              EndOfInstruction()
          };
          op = SystemHintOp_GCSB
      },
      0b0010100 => {
          op = SystemHintOp_CSDB
      },
      0b0010110 => {
          if not_bool(HaveFeatCLRBHB()) then {
              EndOfInstruction()
          };
          op = SystemHintOp_CLRBHB
      },
      [bitzero, bitzero, bitone, bitone, _, _, _] => {
          match op2 {
            0b000 => {
                throw(Error_See("PACIAZ"))
            },
            0b001 => {
                throw(Error_See("PACIASP"))
            },
            0b010 => {
                throw(Error_See("PACIBZ"))
            },
            0b011 => {
                throw(Error_See("PACIBSP"))
            },
            0b100 => {
                throw(Error_See("AUTIAZ"))
            },
            0b101 => {
                throw(Error_See("AUTIASP"))
            },
            0b110 => {
                throw(Error_See("AUTIBZ"))
            },
            0b111 => {
                throw(Error_See("AUTIBSP"))
            }
          }
      },
      [bitzero, bitone, bitzero, bitzero, _, _, bitzero] => {
          op = SystemHintOp_BTI;
          SetBTypeCompatible(BTypeCompatible_BTI(op2[2 .. 1]))
      },
      0b0101000 => {
          if not_bool(IsFeatureImplemented(FEAT_CHK)) then {
              EndOfInstruction()
          };
          op = SystemHintOp_CHKFEAT
      },
      _ => {
          EndOfInstruction()
      }
    };
    execute_aarch64_instrs_system_hints(op)
}

function clause __DecodeA64_BranchExcSys ((pc, (0b11010101000000110010000010011111 as __opcode)) if SEE < 107) = {
    SEE = 107;
    let op2 = Slice(__opcode, 5, 3);
    let CRm = Slice(__opcode, 8, 4);
    decode_sev_aarch64_instrs_system_hints(op2, CRm)
}

val decode_sevl_aarch64_instrs_system_hints : (bits(3), bits(4)) -> unit

function decode_sevl_aarch64_instrs_system_hints (op2, CRm) = {
    op : SystemHintOp = undefined;
    match CRm @ op2 {
      0b0000000 => {
          op = SystemHintOp_NOP
      },
      0b0000001 => {
          op = SystemHintOp_YIELD
      },
      0b0000010 => {
          op = SystemHintOp_WFE
      },
      0b0000011 => {
          op = SystemHintOp_WFI
      },
      0b0000100 => {
          op = SystemHintOp_SEV
      },
      0b0000101 => {
          op = SystemHintOp_SEVL
      },
      0b0000110 => {
          if not_bool(HaveDGHExt()) then {
              EndOfInstruction()
          };
          op = SystemHintOp_DGH
      },
      0b0000111 => {
          throw(Error_See("XPACLRI"))
      },
      [bitzero, bitzero, bitzero, bitone, _, _, _] => {
          match op2 {
            0b000 => {
                throw(Error_See("PACIA1716"))
            },
            0b010 => {
                throw(Error_See("PACIB1716"))
            },
            0b100 => {
                throw(Error_See("AUTIA1716"))
            },
            0b110 => {
                throw(Error_See("AUTIB1716"))
            },
            _ => {
                EndOfInstruction()
            }
          }
      },
      0b0010000 => {
          if not_bool(HaveRASExt()) then {
              EndOfInstruction()
          };
          op = SystemHintOp_ESB
      },
      0b0010001 => {
          if not_bool(HaveStatisticalProfiling()) then {
              EndOfInstruction()
          };
          op = SystemHintOp_PSB
      },
      0b0010010 => {
          if not_bool(HaveSelfHostedTrace()) then {
              EndOfInstruction()
          };
          op = SystemHintOp_TSB
      },
      0b0010011 => {
          if not_bool(IsFeatureImplemented(FEAT_GCS)) then {
              EndOfInstruction()
          };
          op = SystemHintOp_GCSB
      },
      0b0010100 => {
          op = SystemHintOp_CSDB
      },
      0b0010110 => {
          if not_bool(HaveFeatCLRBHB()) then {
              EndOfInstruction()
          };
          op = SystemHintOp_CLRBHB
      },
      [bitzero, bitzero, bitone, bitone, _, _, _] => {
          match op2 {
            0b000 => {
                throw(Error_See("PACIAZ"))
            },
            0b001 => {
                throw(Error_See("PACIASP"))
            },
            0b010 => {
                throw(Error_See("PACIBZ"))
            },
            0b011 => {
                throw(Error_See("PACIBSP"))
            },
            0b100 => {
                throw(Error_See("AUTIAZ"))
            },
            0b101 => {
                throw(Error_See("AUTIASP"))
            },
            0b110 => {
                throw(Error_See("AUTIBZ"))
            },
            0b111 => {
                throw(Error_See("AUTIBSP"))
            }
          }
      },
      [bitzero, bitone, bitzero, bitzero, _, _, bitzero] => {
          op = SystemHintOp_BTI;
          SetBTypeCompatible(BTypeCompatible_BTI(op2[2 .. 1]))
      },
      0b0101000 => {
          if not_bool(IsFeatureImplemented(FEAT_CHK)) then {
              EndOfInstruction()
          };
          op = SystemHintOp_CHKFEAT
      },
      _ => {
          EndOfInstruction()
      }
    };
    execute_aarch64_instrs_system_hints(op)
}

function clause __DecodeA64_BranchExcSys ((pc, (0b11010101000000110010000010111111 as __opcode)) if SEE < 108) = {
    SEE = 108;
    let op2 = Slice(__opcode, 5, 3);
    let CRm = Slice(__opcode, 8, 4);
    decode_sevl_aarch64_instrs_system_hints(op2, CRm)
}

val decode_tsb_aarch64_instrs_system_hints : (bits(3), bits(4)) -> unit

function decode_tsb_aarch64_instrs_system_hints (op2, CRm) = {
    op : SystemHintOp = undefined;
    match CRm @ op2 {
      0b0000000 => {
          op = SystemHintOp_NOP
      },
      0b0000001 => {
          op = SystemHintOp_YIELD
      },
      0b0000010 => {
          op = SystemHintOp_WFE
      },
      0b0000011 => {
          op = SystemHintOp_WFI
      },
      0b0000100 => {
          op = SystemHintOp_SEV
      },
      0b0000101 => {
          op = SystemHintOp_SEVL
      },
      0b0000110 => {
          if not_bool(HaveDGHExt()) then {
              EndOfInstruction()
          };
          op = SystemHintOp_DGH
      },
      0b0000111 => {
          throw(Error_See("XPACLRI"))
      },
      [bitzero, bitzero, bitzero, bitone, _, _, _] => {
          match op2 {
            0b000 => {
                throw(Error_See("PACIA1716"))
            },
            0b010 => {
                throw(Error_See("PACIB1716"))
            },
            0b100 => {
                throw(Error_See("AUTIA1716"))
            },
            0b110 => {
                throw(Error_See("AUTIB1716"))
            },
            _ => {
                EndOfInstruction()
            }
          }
      },
      0b0010000 => {
          if not_bool(HaveRASExt()) then {
              EndOfInstruction()
          };
          op = SystemHintOp_ESB
      },
      0b0010001 => {
          if not_bool(HaveStatisticalProfiling()) then {
              EndOfInstruction()
          };
          op = SystemHintOp_PSB
      },
      0b0010010 => {
          if not_bool(HaveSelfHostedTrace()) then {
              EndOfInstruction()
          };
          op = SystemHintOp_TSB
      },
      0b0010011 => {
          if not_bool(IsFeatureImplemented(FEAT_GCS)) then {
              EndOfInstruction()
          };
          op = SystemHintOp_GCSB
      },
      0b0010100 => {
          op = SystemHintOp_CSDB
      },
      0b0010110 => {
          if not_bool(HaveFeatCLRBHB()) then {
              EndOfInstruction()
          };
          op = SystemHintOp_CLRBHB
      },
      [bitzero, bitzero, bitone, bitone, _, _, _] => {
          match op2 {
            0b000 => {
                throw(Error_See("PACIAZ"))
            },
            0b001 => {
                throw(Error_See("PACIASP"))
            },
            0b010 => {
                throw(Error_See("PACIBZ"))
            },
            0b011 => {
                throw(Error_See("PACIBSP"))
            },
            0b100 => {
                throw(Error_See("AUTIAZ"))
            },
            0b101 => {
                throw(Error_See("AUTIASP"))
            },
            0b110 => {
                throw(Error_See("AUTIBZ"))
            },
            0b111 => {
                throw(Error_See("AUTIBSP"))
            }
          }
      },
      [bitzero, bitone, bitzero, bitzero, _, _, bitzero] => {
          op = SystemHintOp_BTI;
          SetBTypeCompatible(BTypeCompatible_BTI(op2[2 .. 1]))
      },
      0b0101000 => {
          if not_bool(IsFeatureImplemented(FEAT_CHK)) then {
              EndOfInstruction()
          };
          op = SystemHintOp_CHKFEAT
      },
      _ => {
          EndOfInstruction()
      }
    };
    execute_aarch64_instrs_system_hints(op)
}

function clause __DecodeA64_BranchExcSys ((pc, (0b11010101000000110010001001011111 as __opcode)) if SEE < 109) = {
    SEE = 109;
    let op2 = Slice(__opcode, 5, 3);
    let CRm = Slice(__opcode, 8, 4);
    decode_tsb_aarch64_instrs_system_hints(op2, CRm)
}

val decode_wfe_aarch64_instrs_system_hints : (bits(3), bits(4)) -> unit

function decode_wfe_aarch64_instrs_system_hints (op2, CRm) = {
    op : SystemHintOp = undefined;
    match CRm @ op2 {
      0b0000000 => {
          op = SystemHintOp_NOP
      },
      0b0000001 => {
          op = SystemHintOp_YIELD
      },
      0b0000010 => {
          op = SystemHintOp_WFE
      },
      0b0000011 => {
          op = SystemHintOp_WFI
      },
      0b0000100 => {
          op = SystemHintOp_SEV
      },
      0b0000101 => {
          op = SystemHintOp_SEVL
      },
      0b0000110 => {
          if not_bool(HaveDGHExt()) then {
              EndOfInstruction()
          };
          op = SystemHintOp_DGH
      },
      0b0000111 => {
          throw(Error_See("XPACLRI"))
      },
      [bitzero, bitzero, bitzero, bitone, _, _, _] => {
          match op2 {
            0b000 => {
                throw(Error_See("PACIA1716"))
            },
            0b010 => {
                throw(Error_See("PACIB1716"))
            },
            0b100 => {
                throw(Error_See("AUTIA1716"))
            },
            0b110 => {
                throw(Error_See("AUTIB1716"))
            },
            _ => {
                EndOfInstruction()
            }
          }
      },
      0b0010000 => {
          if not_bool(HaveRASExt()) then {
              EndOfInstruction()
          };
          op = SystemHintOp_ESB
      },
      0b0010001 => {
          if not_bool(HaveStatisticalProfiling()) then {
              EndOfInstruction()
          };
          op = SystemHintOp_PSB
      },
      0b0010010 => {
          if not_bool(HaveSelfHostedTrace()) then {
              EndOfInstruction()
          };
          op = SystemHintOp_TSB
      },
      0b0010011 => {
          if not_bool(IsFeatureImplemented(FEAT_GCS)) then {
              EndOfInstruction()
          };
          op = SystemHintOp_GCSB
      },
      0b0010100 => {
          op = SystemHintOp_CSDB
      },
      0b0010110 => {
          if not_bool(HaveFeatCLRBHB()) then {
              EndOfInstruction()
          };
          op = SystemHintOp_CLRBHB
      },
      [bitzero, bitzero, bitone, bitone, _, _, _] => {
          match op2 {
            0b000 => {
                throw(Error_See("PACIAZ"))
            },
            0b001 => {
                throw(Error_See("PACIASP"))
            },
            0b010 => {
                throw(Error_See("PACIBZ"))
            },
            0b011 => {
                throw(Error_See("PACIBSP"))
            },
            0b100 => {
                throw(Error_See("AUTIAZ"))
            },
            0b101 => {
                throw(Error_See("AUTIASP"))
            },
            0b110 => {
                throw(Error_See("AUTIBZ"))
            },
            0b111 => {
                throw(Error_See("AUTIBSP"))
            }
          }
      },
      [bitzero, bitone, bitzero, bitzero, _, _, bitzero] => {
          op = SystemHintOp_BTI;
          SetBTypeCompatible(BTypeCompatible_BTI(op2[2 .. 1]))
      },
      0b0101000 => {
          if not_bool(IsFeatureImplemented(FEAT_CHK)) then {
              EndOfInstruction()
          };
          op = SystemHintOp_CHKFEAT
      },
      _ => {
          EndOfInstruction()
      }
    };
    execute_aarch64_instrs_system_hints(op)
}

function clause __DecodeA64_BranchExcSys ((pc, (0b11010101000000110010000001011111 as __opcode)) if SEE < 110) = {
    SEE = 110;
    let op2 = Slice(__opcode, 5, 3);
    let CRm = Slice(__opcode, 8, 4);
    decode_wfe_aarch64_instrs_system_hints(op2, CRm)
}

val decode_wfi_aarch64_instrs_system_hints : (bits(3), bits(4)) -> unit

function decode_wfi_aarch64_instrs_system_hints (op2, CRm) = {
    op : SystemHintOp = undefined;
    match CRm @ op2 {
      0b0000000 => {
          op = SystemHintOp_NOP
      },
      0b0000001 => {
          op = SystemHintOp_YIELD
      },
      0b0000010 => {
          op = SystemHintOp_WFE
      },
      0b0000011 => {
          op = SystemHintOp_WFI
      },
      0b0000100 => {
          op = SystemHintOp_SEV
      },
      0b0000101 => {
          op = SystemHintOp_SEVL
      },
      0b0000110 => {
          if not_bool(HaveDGHExt()) then {
              EndOfInstruction()
          };
          op = SystemHintOp_DGH
      },
      0b0000111 => {
          throw(Error_See("XPACLRI"))
      },
      [bitzero, bitzero, bitzero, bitone, _, _, _] => {
          match op2 {
            0b000 => {
                throw(Error_See("PACIA1716"))
            },
            0b010 => {
                throw(Error_See("PACIB1716"))
            },
            0b100 => {
                throw(Error_See("AUTIA1716"))
            },
            0b110 => {
                throw(Error_See("AUTIB1716"))
            },
            _ => {
                EndOfInstruction()
            }
          }
      },
      0b0010000 => {
          if not_bool(HaveRASExt()) then {
              EndOfInstruction()
          };
          op = SystemHintOp_ESB
      },
      0b0010001 => {
          if not_bool(HaveStatisticalProfiling()) then {
              EndOfInstruction()
          };
          op = SystemHintOp_PSB
      },
      0b0010010 => {
          if not_bool(HaveSelfHostedTrace()) then {
              EndOfInstruction()
          };
          op = SystemHintOp_TSB
      },
      0b0010011 => {
          if not_bool(IsFeatureImplemented(FEAT_GCS)) then {
              EndOfInstruction()
          };
          op = SystemHintOp_GCSB
      },
      0b0010100 => {
          op = SystemHintOp_CSDB
      },
      0b0010110 => {
          if not_bool(HaveFeatCLRBHB()) then {
              EndOfInstruction()
          };
          op = SystemHintOp_CLRBHB
      },
      [bitzero, bitzero, bitone, bitone, _, _, _] => {
          match op2 {
            0b000 => {
                throw(Error_See("PACIAZ"))
            },
            0b001 => {
                throw(Error_See("PACIASP"))
            },
            0b010 => {
                throw(Error_See("PACIBZ"))
            },
            0b011 => {
                throw(Error_See("PACIBSP"))
            },
            0b100 => {
                throw(Error_See("AUTIAZ"))
            },
            0b101 => {
                throw(Error_See("AUTIASP"))
            },
            0b110 => {
                throw(Error_See("AUTIBZ"))
            },
            0b111 => {
                throw(Error_See("AUTIBSP"))
            }
          }
      },
      [bitzero, bitone, bitzero, bitzero, _, _, bitzero] => {
          op = SystemHintOp_BTI;
          SetBTypeCompatible(BTypeCompatible_BTI(op2[2 .. 1]))
      },
      0b0101000 => {
          if not_bool(IsFeatureImplemented(FEAT_CHK)) then {
              EndOfInstruction()
          };
          op = SystemHintOp_CHKFEAT
      },
      _ => {
          EndOfInstruction()
      }
    };
    execute_aarch64_instrs_system_hints(op)
}

function clause __DecodeA64_BranchExcSys ((pc, (0b11010101000000110010000001111111 as __opcode)) if SEE < 111) = {
    SEE = 111;
    let op2 = Slice(__opcode, 5, 3);
    let CRm = Slice(__opcode, 8, 4);
    decode_wfi_aarch64_instrs_system_hints(op2, CRm)
}

val decode_yield_aarch64_instrs_system_hints : (bits(3), bits(4)) -> unit

function decode_yield_aarch64_instrs_system_hints (op2, CRm) = {
    op : SystemHintOp = undefined;
    match CRm @ op2 {
      0b0000000 => {
          op = SystemHintOp_NOP
      },
      0b0000001 => {
          op = SystemHintOp_YIELD
      },
      0b0000010 => {
          op = SystemHintOp_WFE
      },
      0b0000011 => {
          op = SystemHintOp_WFI
      },
      0b0000100 => {
          op = SystemHintOp_SEV
      },
      0b0000101 => {
          op = SystemHintOp_SEVL
      },
      0b0000110 => {
          if not_bool(HaveDGHExt()) then {
              EndOfInstruction()
          };
          op = SystemHintOp_DGH
      },
      0b0000111 => {
          throw(Error_See("XPACLRI"))
      },
      [bitzero, bitzero, bitzero, bitone, _, _, _] => {
          match op2 {
            0b000 => {
                throw(Error_See("PACIA1716"))
            },
            0b010 => {
                throw(Error_See("PACIB1716"))
            },
            0b100 => {
                throw(Error_See("AUTIA1716"))
            },
            0b110 => {
                throw(Error_See("AUTIB1716"))
            },
            _ => {
                EndOfInstruction()
            }
          }
      },
      0b0010000 => {
          if not_bool(HaveRASExt()) then {
              EndOfInstruction()
          };
          op = SystemHintOp_ESB
      },
      0b0010001 => {
          if not_bool(HaveStatisticalProfiling()) then {
              EndOfInstruction()
          };
          op = SystemHintOp_PSB
      },
      0b0010010 => {
          if not_bool(HaveSelfHostedTrace()) then {
              EndOfInstruction()
          };
          op = SystemHintOp_TSB
      },
      0b0010011 => {
          if not_bool(IsFeatureImplemented(FEAT_GCS)) then {
              EndOfInstruction()
          };
          op = SystemHintOp_GCSB
      },
      0b0010100 => {
          op = SystemHintOp_CSDB
      },
      0b0010110 => {
          if not_bool(HaveFeatCLRBHB()) then {
              EndOfInstruction()
          };
          op = SystemHintOp_CLRBHB
      },
      [bitzero, bitzero, bitone, bitone, _, _, _] => {
          match op2 {
            0b000 => {
                throw(Error_See("PACIAZ"))
            },
            0b001 => {
                throw(Error_See("PACIASP"))
            },
            0b010 => {
                throw(Error_See("PACIBZ"))
            },
            0b011 => {
                throw(Error_See("PACIBSP"))
            },
            0b100 => {
                throw(Error_See("AUTIAZ"))
            },
            0b101 => {
                throw(Error_See("AUTIASP"))
            },
            0b110 => {
                throw(Error_See("AUTIBZ"))
            },
            0b111 => {
                throw(Error_See("AUTIBSP"))
            }
          }
      },
      [bitzero, bitone, bitzero, bitzero, _, _, bitzero] => {
          op = SystemHintOp_BTI;
          SetBTypeCompatible(BTypeCompatible_BTI(op2[2 .. 1]))
      },
      0b0101000 => {
          if not_bool(IsFeatureImplemented(FEAT_CHK)) then {
              EndOfInstruction()
          };
          op = SystemHintOp_CHKFEAT
      },
      _ => {
          EndOfInstruction()
      }
    };
    execute_aarch64_instrs_system_hints(op)
}

function clause __DecodeA64_BranchExcSys ((pc, (0b11010101000000110010000000111111 as __opcode)) if SEE < 112) = {
    SEE = 112;
    let op2 = Slice(__opcode, 5, 3);
    let CRm = Slice(__opcode, 8, 4);
    decode_yield_aarch64_instrs_system_hints(op2, CRm)
}

val execute_aarch64_instrs_memory_atomicops_cas_single : forall ('acquire : Bool) 'datasize 'n 'regsize ('release : Bool) 's 't ('tagchecked : Bool),
  (0 <= 't & 't <= 31 & 0 <= 's & 's <= 31 & 'regsize in {32, 64} & 0 <= 'n & 'n <= 31 & 'datasize in {8, 16, 32, 64}).
  (bool('acquire), int('datasize), int('n), int('regsize), bool('release), int('s), int('t), bool('tagchecked)) -> unit

function execute_aarch64_instrs_memory_atomicops_cas_single (acquire, datasize, n, regsize, release, s, t, tagchecked) = {
    address : bits(64) = undefined;
    let accdesc : AccessDescriptor = CreateAccDescAtomicOp(MemAtomicOp_CAS, acquire, release, tagchecked);
    let comparevalue : bits('datasize) = X_read(s, datasize);
    let newvalue : bits('datasize) = X_read(t, datasize);
    if n == 31 then {
        CheckSPAlignment();
        address = SP_read()
    } else {
        address = X_read(n, 64)
    };
    let data : bits('datasize) = MemAtomic(address, comparevalue, newvalue, accdesc);
    assert(constraint('regsize >= 'datasize));
    X_set(s, regsize) = ZeroExtend(data, regsize);
    if SPESampleInFlight then {
        let ar : bits(1) = if acquire | release then 0b1 else 0b0;
        let excl : bits(1) = 0b0;
        let at : bits(1) = 0b1;
        let is_load : bool = true;
        SPESampleExtendedLoadStore(ar, excl, at, is_load)
    };
    ()
}

val decode_cas_aarch64_instrs_memory_atomicops_cas_single : (bits(5), bits(5), bits(1), bits(5), bits(1), bits(2)) -> unit

function decode_cas_aarch64_instrs_memory_atomicops_cas_single (Rt, Rn, o0, Rs, L, size) = {
    if not_bool(HaveAtomicExt()) then {
        throw(Error_Undefined())
    };
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 's = UInt(Rs);
    let 'datasize = (8 << UInt(size));
    let 'regsize = if datasize == 64 then 64 else 32;
    let acquire : bool = L == 0b1;
    let release : bool = o0 == 0b1;
    let tagchecked : bool = n != 31;
    execute_aarch64_instrs_memory_atomicops_cas_single(acquire, datasize, n, regsize, release, s, t, tagchecked)
}

function clause __DecodeA64_LoadStore ((pc, ([bitone, _, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitone, _, bitone, _, _, _, _, _, _, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 113) = {
    SEE = 113;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o0 = Slice(__opcode, 15, 1);
    let Rs = Slice(__opcode, 16, 5);
    let L = Slice(__opcode, 22, 1);
    let size = Slice(__opcode, 30, 2);
    decode_cas_aarch64_instrs_memory_atomicops_cas_single(Rt, Rn, o0, Rs, L, size)
}

val decode_casb_aarch64_instrs_memory_atomicops_cas_single : (bits(5), bits(5), bits(1), bits(5), bits(1), bits(2)) -> unit

function decode_casb_aarch64_instrs_memory_atomicops_cas_single (Rt, Rn, o0, Rs, L, size) = {
    if not_bool(HaveAtomicExt()) then {
        throw(Error_Undefined())
    };
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 's = UInt(Rs);
    let 'datasize = (8 << UInt(size));
    let 'regsize = if datasize == 64 then 64 else 32;
    let acquire : bool = L == 0b1;
    let release : bool = o0 == 0b1;
    let tagchecked : bool = n != 31;
    execute_aarch64_instrs_memory_atomicops_cas_single(acquire, datasize, n, regsize, release, s, t, tagchecked)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitone, _, bitone, _, _, _, _, _, _, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 114) = {
    SEE = 114;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o0 = Slice(__opcode, 15, 1);
    let Rs = Slice(__opcode, 16, 5);
    let L = Slice(__opcode, 22, 1);
    let size = Slice(__opcode, 30, 2);
    decode_casb_aarch64_instrs_memory_atomicops_cas_single(Rt, Rn, o0, Rs, L, size)
}

val decode_cash_aarch64_instrs_memory_atomicops_cas_single : (bits(5), bits(5), bits(1), bits(5), bits(1), bits(2)) -> unit

function decode_cash_aarch64_instrs_memory_atomicops_cas_single (Rt, Rn, o0, Rs, L, size) = {
    if not_bool(HaveAtomicExt()) then {
        throw(Error_Undefined())
    };
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 's = UInt(Rs);
    let 'datasize = (8 << UInt(size));
    let 'regsize = if datasize == 64 then 64 else 32;
    let acquire : bool = L == 0b1;
    let release : bool = o0 == 0b1;
    let tagchecked : bool = n != 31;
    execute_aarch64_instrs_memory_atomicops_cas_single(acquire, datasize, n, regsize, release, s, t, tagchecked)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, bitone, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitone, _, bitone, _, _, _, _, _, _, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 115) = {
    SEE = 115;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o0 = Slice(__opcode, 15, 1);
    let Rs = Slice(__opcode, 16, 5);
    let L = Slice(__opcode, 22, 1);
    let size = Slice(__opcode, 30, 2);
    decode_cash_aarch64_instrs_memory_atomicops_cas_single(Rt, Rn, o0, Rs, L, size)
}

val execute_aarch64_instrs_memory_atomicops_cas_pair : forall ('acquire : Bool) 'datasize 'n ('release : Bool) 's 't ('tagchecked : Bool),
  (0 <= 't & 't <= 31 & 0 <= 's & 's <= 31 & 0 <= 'n & 'n <= 31 & 'datasize in {32, 64}).
  (bool('acquire), int('datasize), int('n), bool('release), int('s), int('t), bool('tagchecked)) -> unit

function execute_aarch64_instrs_memory_atomicops_cas_pair (acquire, datasize, n, release, s, t, tagchecked) = {
    address : bits(64) = undefined;
    let s1 : bits('datasize) = X_read(s, datasize);
    let s2 : bits('datasize) = X_read(s + 1, datasize);
    let t1 : bits('datasize) = X_read(t, datasize);
    let t2 : bits('datasize) = X_read(t + 1, datasize);
    let accdesc : AccessDescriptor = CreateAccDescAtomicOp(MemAtomicOp_CAS, acquire, release, tagchecked);
    let comparevalue : bits(2 * 'datasize) = if BigEndian(accdesc.acctype) then
      s1 @ s2
    else
      s2 @ s1;
    let newvalue : bits(2 * 'datasize) = if BigEndian(accdesc.acctype) then
      t1 @ t2
    else
      t2 @ t1;
    if n == 31 then {
        CheckSPAlignment();
        address = SP_read()
    } else {
        address = X_read(n, 64)
    };
    let data : bits(2 * 'datasize) = MemAtomic(address, comparevalue, newvalue, accdesc);
    if BigEndian(accdesc.acctype) then {
        X_set(s, datasize) = data[2 * datasize - 1 .. datasize];
        X_set(s + 1, datasize) = data[datasize - 1 .. 0]
    } else {
        X_set(s, datasize) = data[datasize - 1 .. 0];
        X_set(s + 1, datasize) = data[2 * datasize - 1 .. datasize]
    };
    if SPESampleInFlight then {
        let ar : bits(1) = if acquire | release then 0b1 else 0b0;
        let excl : bits(1) = 0b0;
        let at : bits(1) = 0b1;
        let is_load : bool = true;
        SPESampleExtendedLoadStore(ar, excl, at, is_load)
    };
    ()
}

val decode_casp_aarch64_instrs_memory_atomicops_cas_pair : (bits(5), bits(5), bits(5), bits(1), bits(5), bits(1), bits(1)) -> unit

function decode_casp_aarch64_instrs_memory_atomicops_cas_pair (Rt, Rn, Rt2, o0, Rs, L, sz) = {
    if not_bool(HaveAtomicExt()) then {
        throw(Error_Undefined())
    };
    if [Rs[0]] == 0b1 then {
        throw(Error_Undefined())
    };
    if [Rt[0]] == 0b1 then {
        throw(Error_Undefined())
    };
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 's = UInt(Rs);
    let 'datasize = (32 << UInt(sz));
    let 'regsize = datasize;
    let acquire : bool = L == 0b1;
    let release : bool = o0 == 0b1;
    let tagchecked : bool = n != 31;
    execute_aarch64_instrs_memory_atomicops_cas_pair(acquire, datasize, n, release, s, t, tagchecked)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, _, bitone, _, _, _, _, _, _, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 116) = {
    SEE = 116;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rt2 = Slice(__opcode, 10, 5);
    let o0 = Slice(__opcode, 15, 1);
    let Rs = Slice(__opcode, 16, 5);
    let L = Slice(__opcode, 22, 1);
    let sz = Slice(__opcode, 30, 1);
    decode_casp_aarch64_instrs_memory_atomicops_cas_pair(Rt, Rn, Rt2, o0, Rs, L, sz)
}

val execute_aarch64_instrs_branch_conditional_compare : forall 'datasize ('iszero : Bool) 't,
  (0 <= 't & 't <= 31 & 'datasize in {32, 64}).
  (int('datasize), bool('iszero), bits(64), int('t)) -> unit

function execute_aarch64_instrs_branch_conditional_compare (datasize, iszero, offset, t) = {
    let operand1 : bits('datasize) = X_read(t, datasize);
    let branch_conditional : bool = true;
    if IsZero(operand1) == iszero then {
        BranchTo(PC_read() + offset, BranchType_DIR, branch_conditional)
    } else {
        BranchNotTaken(BranchType_DIR, branch_conditional)
    }
}

val decode_cbnz_aarch64_instrs_branch_conditional_compare : (bits(5), bits(19), bits(1), bits(1)) -> unit

function decode_cbnz_aarch64_instrs_branch_conditional_compare (Rt, imm19, op, sf) = {
    let 't = UInt(Rt);
    let 'datasize = if sf == 0b1 then 64 else 32;
    let iszero : bool = op == 0b0;
    let offset : bits(64) = SignExtend(imm19 @ 0b00, 64);
    execute_aarch64_instrs_branch_conditional_compare(datasize, iszero, offset, t)
}

function clause __DecodeA64_BranchExcSys ((pc, ([_, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 117) = {
    SEE = 117;
    let Rt = Slice(__opcode, 0, 5);
    let imm19 = Slice(__opcode, 5, 19);
    let op = Slice(__opcode, 24, 1);
    let sf = Slice(__opcode, 31, 1);
    decode_cbnz_aarch64_instrs_branch_conditional_compare(Rt, imm19, op, sf)
}

val decode_cbz_aarch64_instrs_branch_conditional_compare : (bits(5), bits(19), bits(1), bits(1)) -> unit

function decode_cbz_aarch64_instrs_branch_conditional_compare (Rt, imm19, op, sf) = {
    let 't = UInt(Rt);
    let 'datasize = if sf == 0b1 then 64 else 32;
    let iszero : bool = op == 0b0;
    let offset : bits(64) = SignExtend(imm19 @ 0b00, 64);
    execute_aarch64_instrs_branch_conditional_compare(datasize, iszero, offset, t)
}

function clause __DecodeA64_BranchExcSys ((pc, ([_, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 118) = {
    SEE = 118;
    let Rt = Slice(__opcode, 0, 5);
    let imm19 = Slice(__opcode, 5, 19);
    let op = Slice(__opcode, 24, 1);
    let sf = Slice(__opcode, 31, 1);
    decode_cbz_aarch64_instrs_branch_conditional_compare(Rt, imm19, op, sf)
}

val execute_aarch64_instrs_integer_conditional_compare_register : forall 'datasize 'm 'n ('sub_op : Bool),
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'datasize in {32, 64}).
  (bits(4), int('datasize), bits(4), int('m), int('n), bool('sub_op)) -> unit

function execute_aarch64_instrs_integer_conditional_compare_register (condition, datasize, flags__arg, m, n, sub_op) = {
    flags : bits(4) = flags__arg;
    taken : bool = false;
    if ConditionHolds(condition) then {
        let operand1 : bits('datasize) = X_read(n, datasize);
        operand2 : bits('datasize) = X_read(m, datasize);
        carry_in : bits(1) = 0b0;
        if sub_op then {
            operand2 = not_vec(operand2);
            carry_in = 0b1
        };
        let (_, __tup_1 : bits(4)) = AddWithCarry(operand1, operand2, carry_in)
        in
          {
              flags = __tup_1
          };
        taken = true
    };
    (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V) = flags;
    if SPESampleInFlight then {
        let conditional : bool = true;
        SPESampleAddOpOther(conditional, taken)
    };
    ()
}

val decode_ccmn_reg_aarch64_instrs_integer_conditional_compare_register : (bits(4), bits(5), bits(4), bits(5), bits(1), bits(1)) -> unit

function decode_ccmn_reg_aarch64_instrs_integer_conditional_compare_register (nzcv, Rn, cond, Rm, op, sf) = {
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'datasize = if sf == 0b1 then 64 else 32;
    let sub_op : bool = op == 0b1;
    let condition : bits(4) = cond;
    let flags : bits(4) = nzcv;
    execute_aarch64_instrs_integer_conditional_compare_register(condition, datasize, flags, m, n, sub_op)
}

function clause __DecodeA64_DataProcReg ((pc, ([_, bitzero, bitone, bitone, bitone, bitzero, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, bitzero, bitzero, _, _, _, _, _, bitzero, _, _, _, _] as __opcode)) if SEE < 119) = {
    SEE = 119;
    let nzcv = Slice(__opcode, 0, 4);
    let Rn = Slice(__opcode, 5, 5);
    let cond = Slice(__opcode, 12, 4);
    let Rm = Slice(__opcode, 16, 5);
    let op = Slice(__opcode, 30, 1);
    let sf = Slice(__opcode, 31, 1);
    decode_ccmn_reg_aarch64_instrs_integer_conditional_compare_register(nzcv, Rn, cond, Rm, op, sf)
}

val decode_ccmp_reg_aarch64_instrs_integer_conditional_compare_register : (bits(4), bits(5), bits(4), bits(5), bits(1), bits(1)) -> unit

function decode_ccmp_reg_aarch64_instrs_integer_conditional_compare_register (nzcv, Rn, cond, Rm, op, sf) = {
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'datasize = if sf == 0b1 then 64 else 32;
    let sub_op : bool = op == 0b1;
    let condition : bits(4) = cond;
    let flags : bits(4) = nzcv;
    execute_aarch64_instrs_integer_conditional_compare_register(condition, datasize, flags, m, n, sub_op)
}

function clause __DecodeA64_DataProcReg ((pc, ([_, bitone, bitone, bitone, bitone, bitzero, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, bitzero, bitzero, _, _, _, _, _, bitzero, _, _, _, _] as __opcode)) if SEE < 120) = {
    SEE = 120;
    let nzcv = Slice(__opcode, 0, 4);
    let Rn = Slice(__opcode, 5, 5);
    let cond = Slice(__opcode, 12, 4);
    let Rm = Slice(__opcode, 16, 5);
    let op = Slice(__opcode, 30, 1);
    let sf = Slice(__opcode, 31, 1);
    decode_ccmp_reg_aarch64_instrs_integer_conditional_compare_register(nzcv, Rn, cond, Rm, op, sf)
}

val execute_aarch64_instrs_integer_conditional_compare_immediate : forall 'datasize 'n ('sub_op : Bool),
  (0 <= 'n & 'n <= 31 & 'datasize in {32, 64}).
  (bits(4), int('datasize), bits(4), bits('datasize), int('n), bool('sub_op)) -> unit

function execute_aarch64_instrs_integer_conditional_compare_immediate (condition, datasize, flags__arg, imm, n, sub_op) = {
    flags : bits(4) = flags__arg;
    taken : bool = false;
    if ConditionHolds(condition) then {
        let operand1 : bits('datasize) = X_read(n, datasize);
        operand2 : bits('datasize) = imm;
        carry_in : bits(1) = 0b0;
        if sub_op then {
            operand2 = not_vec(operand2);
            carry_in = 0b1
        };
        let (_, __tup_1 : bits(4)) = AddWithCarry(operand1, operand2, carry_in)
        in
          {
              flags = __tup_1
          };
        taken = true
    };
    (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V) = flags;
    if SPESampleInFlight then {
        let conditional : bool = true;
        SPESampleAddOpOther(conditional, taken)
    };
    ()
}

val decode_ccmn_imm_aarch64_instrs_integer_conditional_compare_immediate : (bits(4), bits(5), bits(4), bits(5), bits(1), bits(1)) -> unit

function decode_ccmn_imm_aarch64_instrs_integer_conditional_compare_immediate (nzcv, Rn, cond, imm5, op, sf) = {
    let 'n = UInt(Rn);
    let 'datasize = if sf == 0b1 then 64 else 32;
    let sub_op : bool = op == 0b1;
    let condition : bits(4) = cond;
    let flags : bits(4) = nzcv;
    let imm : bits('datasize) = ZeroExtend(imm5, datasize);
    execute_aarch64_instrs_integer_conditional_compare_immediate(condition, datasize, flags, imm, n, sub_op)
}

function clause __DecodeA64_DataProcReg ((pc, ([_, bitzero, bitone, bitone, bitone, bitzero, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, bitone, bitzero, _, _, _, _, _, bitzero, _, _, _, _] as __opcode)) if SEE < 121) = {
    SEE = 121;
    let nzcv = Slice(__opcode, 0, 4);
    let Rn = Slice(__opcode, 5, 5);
    let cond = Slice(__opcode, 12, 4);
    let imm5 = Slice(__opcode, 16, 5);
    let op = Slice(__opcode, 30, 1);
    let sf = Slice(__opcode, 31, 1);
    decode_ccmn_imm_aarch64_instrs_integer_conditional_compare_immediate(nzcv, Rn, cond, imm5, op, sf)
}

val decode_ccmp_imm_aarch64_instrs_integer_conditional_compare_immediate : (bits(4), bits(5), bits(4), bits(5), bits(1), bits(1)) -> unit

function decode_ccmp_imm_aarch64_instrs_integer_conditional_compare_immediate (nzcv, Rn, cond, imm5, op, sf) = {
    let 'n = UInt(Rn);
    let 'datasize = if sf == 0b1 then 64 else 32;
    let sub_op : bool = op == 0b1;
    let condition : bits(4) = cond;
    let flags : bits(4) = nzcv;
    let imm : bits('datasize) = ZeroExtend(imm5, datasize);
    execute_aarch64_instrs_integer_conditional_compare_immediate(condition, datasize, flags, imm, n, sub_op)
}

function clause __DecodeA64_DataProcReg ((pc, ([_, bitone, bitone, bitone, bitone, bitzero, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, bitone, bitzero, _, _, _, _, _, bitzero, _, _, _, _] as __opcode)) if SEE < 122) = {
    SEE = 122;
    let nzcv = Slice(__opcode, 0, 4);
    let Rn = Slice(__opcode, 5, 5);
    let cond = Slice(__opcode, 12, 4);
    let imm5 = Slice(__opcode, 16, 5);
    let op = Slice(__opcode, 30, 1);
    let sf = Slice(__opcode, 31, 1);
    decode_ccmp_imm_aarch64_instrs_integer_conditional_compare_immediate(nzcv, Rn, cond, imm5, op, sf)
}

val execute_aarch64_instrs_integer_flags_cfinv : unit -> unit

function execute_aarch64_instrs_integer_flags_cfinv () = {
    PSTATE.C = not_vec(PSTATE.C)
}

val decode_cfinv_aarch64_instrs_integer_flags_cfinv : bits(4) -> unit

function decode_cfinv_aarch64_instrs_integer_flags_cfinv CRm = {
    if not_bool(HaveFlagManipulateExt()) then {
        throw(Error_Undefined())
    };
    execute_aarch64_instrs_integer_flags_cfinv()
}

function clause __DecodeA64_BranchExcSys ((pc, (0b11010101000000000100000000011111 as __opcode)) if SEE < 123) = {
    SEE = 123;
    let CRm = Slice(__opcode, 8, 4);
    if (([__opcode[8]] != 0b0 | [__opcode[9]] != 0b0) | [__opcode[10]] != 0b0) | [__opcode[11]] != 0b0 then {
        throw(Error_ConstrainedUnpredictable())
    } else {
        decode_cfinv_aarch64_instrs_integer_flags_cfinv(CRm)
    }
}

val execute_aarch64_instrs_system_monitors : unit -> unit

function execute_aarch64_instrs_system_monitors () = {
    ClearExclusiveLocal(ProcessorID())
}

val decode_clrex_aarch64_instrs_system_monitors : bits(4) -> unit

function decode_clrex_aarch64_instrs_system_monitors CRm = {
    execute_aarch64_instrs_system_monitors()
}

function clause __DecodeA64_BranchExcSys ((pc, ([bitone, bitone, bitzero, bitone, bitzero, bitone, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitone, bitone, _, _, _, _, bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitone] as __opcode)) if SEE < 124) = {
    SEE = 124;
    let CRm = Slice(__opcode, 8, 4);
    decode_clrex_aarch64_instrs_system_monitors(CRm)
}

val execute_aarch64_instrs_vector_arithmetic_unary_clsz : forall 'd 'datasize 'elements 'esize 'n,
  (0 <= 'n & 'n <= 31 & 'esize in {8, 16, 32, 64} & 'datasize in {64, 128} & 0 <= 'd & 'd <= 31).
  (CountOp, int('d), int('datasize), int('elements), int('esize), int('n)) -> unit

function execute_aarch64_instrs_vector_arithmetic_unary_clsz (countop, d, datasize, elements, esize, n) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('datasize) = V_read(n, datasize);
    result : bits('datasize) = undefined;
    count : int = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        if countop == CountOp_CLS then {
            count = CountLeadingSignBits(Elem_read(operand, e, esize))
        } else {
            count = CountLeadingZeroBits(Elem_read(operand, e, esize))
        };
        result = Elem_set(result, e, esize, count[esize - 1 .. 0])
    };
    V_set(d, datasize) = result
}

val decode_cls_advsimd_aarch64_instrs_vector_arithmetic_unary_clsz : (bits(5), bits(5), bits(2), bits(1), bits(1)) -> unit

function decode_cls_advsimd_aarch64_instrs_vector_arithmetic_unary_clsz (Rd, Rn, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let countop : CountOp = if U == 0b1 then CountOp_CLZ else CountOp_CLS;
    execute_aarch64_instrs_vector_arithmetic_unary_clsz(countop, d, datasize, elements, esize, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 125) = {
    SEE = 125;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_cls_advsimd_aarch64_instrs_vector_arithmetic_unary_clsz(Rd, Rn, size, U, Q)
}

val decode_clz_advsimd_aarch64_instrs_vector_arithmetic_unary_clsz : (bits(5), bits(5), bits(2), bits(1), bits(1)) -> unit

function decode_clz_advsimd_aarch64_instrs_vector_arithmetic_unary_clsz (Rd, Rn, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let countop : CountOp = if U == 0b1 then CountOp_CLZ else CountOp_CLS;
    execute_aarch64_instrs_vector_arithmetic_unary_clsz(countop, d, datasize, elements, esize, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 126) = {
    SEE = 126;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_clz_advsimd_aarch64_instrs_vector_arithmetic_unary_clsz(Rd, Rn, size, U, Q)
}

val execute_aarch64_instrs_integer_arithmetic_cnt : forall 'd 'datasize 'n,
  (0 <= 'n & 'n <= 31 & 'datasize in {32, 64} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('n), CountOp) -> unit

function execute_aarch64_instrs_integer_arithmetic_cnt (d, datasize, n, opcode) = {
    result : int = undefined;
    let operand1 : bits('datasize) = X_read(n, datasize);
    if opcode == CountOp_CLZ then {
        result = CountLeadingZeroBits(operand1)
    } else {
        result = CountLeadingSignBits(operand1)
    };
    let 'result = result;
    X_set(d, datasize) = result[datasize - 1 .. 0]
}

val decode_cls_int_aarch64_instrs_integer_arithmetic_cnt : (bits(5), bits(5), bits(1), bits(1)) -> unit

function decode_cls_int_aarch64_instrs_integer_arithmetic_cnt (Rd, Rn, op, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'datasize = if sf == 0b1 then 64 else 32;
    let opcode : CountOp = if op == 0b0 then CountOp_CLZ else CountOp_CLS;
    execute_aarch64_instrs_integer_arithmetic_cnt(d, datasize, n, opcode)
}

function clause __DecodeA64_DataProcReg ((pc, ([_, bitone, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 127) = {
    SEE = 127;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 10, 1);
    let sf = Slice(__opcode, 31, 1);
    decode_cls_int_aarch64_instrs_integer_arithmetic_cnt(Rd, Rn, op, sf)
}

val decode_clz_int_aarch64_instrs_integer_arithmetic_cnt : (bits(5), bits(5), bits(1), bits(1)) -> unit

function decode_clz_int_aarch64_instrs_integer_arithmetic_cnt (Rd, Rn, op, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'datasize = if sf == 0b1 then 64 else 32;
    let opcode : CountOp = if op == 0b0 then CountOp_CLZ else CountOp_CLS;
    execute_aarch64_instrs_integer_arithmetic_cnt(d, datasize, n, opcode)
}

function clause __DecodeA64_DataProcReg ((pc, ([_, bitone, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 128) = {
    SEE = 128;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 10, 1);
    let sf = Slice(__opcode, 31, 1);
    decode_clz_int_aarch64_instrs_integer_arithmetic_cnt(Rd, Rn, op, sf)
}

val execute_aarch64_instrs_vector_arithmetic_unary_cmp_int_bulk_sisd : forall 'd 'datasize 'elements 'esize 'n,
  (0 <= 'n & 'n <= 31 & 'esize in {8, 16, 32, 64} & 'datasize in {8, 16, 32, 64, 128} & 0 <= 'd & 'd <= 31).
  (CompareOp, int('d), int('datasize), int('elements), int('esize), int('n)) -> unit

function execute_aarch64_instrs_vector_arithmetic_unary_cmp_int_bulk_sisd (comparison, d, datasize, elements, esize, n) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('datasize) = V_read(n, datasize);
    result : bits('datasize) = undefined;
    element : int = undefined;
    test_passed : bool = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element = SInt(Elem_read(operand, e, esize));
        match comparison {
          CompareOp_GT => {
              test_passed = element > 0
          },
          CompareOp_GE => {
              test_passed = element >= 0
          },
          CompareOp_EQ => {
              test_passed = element == 0
          },
          CompareOp_LE => {
              test_passed = element <= 0
          },
          CompareOp_LT => {
              test_passed = element < 0
          }
        };
        result = Elem_set(result, e, esize, if test_passed then Ones(esize) else
          Zeros(esize))
    };
    V_set(d, datasize) = result
}

val decode_cmeq_advsimd_zero_aarch64_instrs_vector_arithmetic_unary_cmp_int_bulk_sisd : (bits(5), bits(5), bits(1), bits(2), bits(1)) -> unit

function decode_cmeq_advsimd_zero_aarch64_instrs_vector_arithmetic_unary_cmp_int_bulk_sisd (Rd, Rn, op, size, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if size != 0b11 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    let 'datasize = esize;
    let 'elements = 1;
    comparison : CompareOp = undefined;
    match op @ U {
      0b00 => {
          comparison = CompareOp_GT
      },
      0b01 => {
          comparison = CompareOp_GE
      },
      0b10 => {
          comparison = CompareOp_EQ
      },
      0b11 => {
          comparison = CompareOp_LE
      }
    };
    let comparison = comparison;
    execute_aarch64_instrs_vector_arithmetic_unary_cmp_int_bulk_sisd(comparison, d, datasize, elements, esize, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 129) = {
    SEE = 129;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 12, 1);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    decode_cmeq_advsimd_zero_aarch64_instrs_vector_arithmetic_unary_cmp_int_bulk_sisd(Rd, Rn, op, size, U)
}

val decode_cmeq_advsimd_zero_aarch64_instrs_vector_arithmetic_unary_cmp_int_bulk_simd : (bits(5), bits(5), bits(1), bits(2), bits(1), bits(1)) -> unit

function decode_cmeq_advsimd_zero_aarch64_instrs_vector_arithmetic_unary_cmp_int_bulk_simd (Rd, Rn, op, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (size @ Q) == 0b110 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    comparison : CompareOp = undefined;
    match op @ U {
      0b00 => {
          comparison = CompareOp_GT
      },
      0b01 => {
          comparison = CompareOp_GE
      },
      0b10 => {
          comparison = CompareOp_EQ
      },
      0b11 => {
          comparison = CompareOp_LE
      }
    };
    let comparison = comparison;
    execute_aarch64_instrs_vector_arithmetic_unary_cmp_int_bulk_sisd(comparison, d, datasize, elements, esize, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 130) = {
    SEE = 130;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 12, 1);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_cmeq_advsimd_zero_aarch64_instrs_vector_arithmetic_unary_cmp_int_bulk_simd(Rd, Rn, op, size, U, Q)
}

val decode_cmge_advsimd_zero_aarch64_instrs_vector_arithmetic_unary_cmp_int_bulk_sisd : (bits(5), bits(5), bits(1), bits(2), bits(1)) -> unit

function decode_cmge_advsimd_zero_aarch64_instrs_vector_arithmetic_unary_cmp_int_bulk_sisd (Rd, Rn, op, size, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if size != 0b11 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    let 'datasize = esize;
    let 'elements = 1;
    comparison : CompareOp = undefined;
    match op @ U {
      0b00 => {
          comparison = CompareOp_GT
      },
      0b01 => {
          comparison = CompareOp_GE
      },
      0b10 => {
          comparison = CompareOp_EQ
      },
      0b11 => {
          comparison = CompareOp_LE
      }
    };
    let comparison = comparison;
    execute_aarch64_instrs_vector_arithmetic_unary_cmp_int_bulk_sisd(comparison, d, datasize, elements, esize, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 131) = {
    SEE = 131;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 12, 1);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    decode_cmge_advsimd_zero_aarch64_instrs_vector_arithmetic_unary_cmp_int_bulk_sisd(Rd, Rn, op, size, U)
}

val decode_cmge_advsimd_zero_aarch64_instrs_vector_arithmetic_unary_cmp_int_bulk_simd : (bits(5), bits(5), bits(1), bits(2), bits(1), bits(1)) -> unit

function decode_cmge_advsimd_zero_aarch64_instrs_vector_arithmetic_unary_cmp_int_bulk_simd (Rd, Rn, op, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (size @ Q) == 0b110 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    comparison : CompareOp = undefined;
    match op @ U {
      0b00 => {
          comparison = CompareOp_GT
      },
      0b01 => {
          comparison = CompareOp_GE
      },
      0b10 => {
          comparison = CompareOp_EQ
      },
      0b11 => {
          comparison = CompareOp_LE
      }
    };
    let comparison = comparison;
    execute_aarch64_instrs_vector_arithmetic_unary_cmp_int_bulk_sisd(comparison, d, datasize, elements, esize, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 132) = {
    SEE = 132;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 12, 1);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_cmge_advsimd_zero_aarch64_instrs_vector_arithmetic_unary_cmp_int_bulk_simd(Rd, Rn, op, size, U, Q)
}

val decode_cmgt_advsimd_zero_aarch64_instrs_vector_arithmetic_unary_cmp_int_bulk_sisd : (bits(5), bits(5), bits(1), bits(2), bits(1)) -> unit

function decode_cmgt_advsimd_zero_aarch64_instrs_vector_arithmetic_unary_cmp_int_bulk_sisd (Rd, Rn, op, size, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if size != 0b11 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    let 'datasize = esize;
    let 'elements = 1;
    comparison : CompareOp = undefined;
    match op @ U {
      0b00 => {
          comparison = CompareOp_GT
      },
      0b01 => {
          comparison = CompareOp_GE
      },
      0b10 => {
          comparison = CompareOp_EQ
      },
      0b11 => {
          comparison = CompareOp_LE
      }
    };
    let comparison = comparison;
    execute_aarch64_instrs_vector_arithmetic_unary_cmp_int_bulk_sisd(comparison, d, datasize, elements, esize, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 133) = {
    SEE = 133;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 12, 1);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    decode_cmgt_advsimd_zero_aarch64_instrs_vector_arithmetic_unary_cmp_int_bulk_sisd(Rd, Rn, op, size, U)
}

val decode_cmgt_advsimd_zero_aarch64_instrs_vector_arithmetic_unary_cmp_int_bulk_simd : (bits(5), bits(5), bits(1), bits(2), bits(1), bits(1)) -> unit

function decode_cmgt_advsimd_zero_aarch64_instrs_vector_arithmetic_unary_cmp_int_bulk_simd (Rd, Rn, op, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (size @ Q) == 0b110 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    comparison : CompareOp = undefined;
    match op @ U {
      0b00 => {
          comparison = CompareOp_GT
      },
      0b01 => {
          comparison = CompareOp_GE
      },
      0b10 => {
          comparison = CompareOp_EQ
      },
      0b11 => {
          comparison = CompareOp_LE
      }
    };
    let comparison = comparison;
    execute_aarch64_instrs_vector_arithmetic_unary_cmp_int_bulk_sisd(comparison, d, datasize, elements, esize, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 134) = {
    SEE = 134;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 12, 1);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_cmgt_advsimd_zero_aarch64_instrs_vector_arithmetic_unary_cmp_int_bulk_simd(Rd, Rn, op, size, U, Q)
}

val decode_cmle_advsimd_aarch64_instrs_vector_arithmetic_unary_cmp_int_bulk_sisd : (bits(5), bits(5), bits(1), bits(2), bits(1)) -> unit

function decode_cmle_advsimd_aarch64_instrs_vector_arithmetic_unary_cmp_int_bulk_sisd (Rd, Rn, op, size, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if size != 0b11 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    let 'datasize = esize;
    let 'elements = 1;
    comparison : CompareOp = undefined;
    match op @ U {
      0b00 => {
          comparison = CompareOp_GT
      },
      0b01 => {
          comparison = CompareOp_GE
      },
      0b10 => {
          comparison = CompareOp_EQ
      },
      0b11 => {
          comparison = CompareOp_LE
      }
    };
    let comparison = comparison;
    execute_aarch64_instrs_vector_arithmetic_unary_cmp_int_bulk_sisd(comparison, d, datasize, elements, esize, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 135) = {
    SEE = 135;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 12, 1);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    decode_cmle_advsimd_aarch64_instrs_vector_arithmetic_unary_cmp_int_bulk_sisd(Rd, Rn, op, size, U)
}

val decode_cmle_advsimd_aarch64_instrs_vector_arithmetic_unary_cmp_int_bulk_simd : (bits(5), bits(5), bits(1), bits(2), bits(1), bits(1)) -> unit

function decode_cmle_advsimd_aarch64_instrs_vector_arithmetic_unary_cmp_int_bulk_simd (Rd, Rn, op, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (size @ Q) == 0b110 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    comparison : CompareOp = undefined;
    match op @ U {
      0b00 => {
          comparison = CompareOp_GT
      },
      0b01 => {
          comparison = CompareOp_GE
      },
      0b10 => {
          comparison = CompareOp_EQ
      },
      0b11 => {
          comparison = CompareOp_LE
      }
    };
    let comparison = comparison;
    execute_aarch64_instrs_vector_arithmetic_unary_cmp_int_bulk_sisd(comparison, d, datasize, elements, esize, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 136) = {
    SEE = 136;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 12, 1);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_cmle_advsimd_aarch64_instrs_vector_arithmetic_unary_cmp_int_bulk_simd(Rd, Rn, op, size, U, Q)
}

val execute_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_bitwise_sisd : forall ('and_test : Bool) 'd 'datasize 'elements 'esize 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'esize in {8, 16, 32, 64} & 'datasize in {8, 16, 32, 64, 128} & 0 <= 'd & 'd <= 31).
  (bool('and_test), int('d), int('datasize), int('elements), int('esize), int('m), int('n)) -> unit

function execute_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_bitwise_sisd (and_test, d, datasize, elements, esize, m, n) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = V_read(n, datasize);
    let operand2 : bits('datasize) = V_read(m, datasize);
    result : bits('datasize) = undefined;
    element1 : bits('esize) = undefined;
    element2 : bits('esize) = undefined;
    test_passed : bool = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element1 = Elem_read(operand1, e, esize);
        element2 = Elem_read(operand2, e, esize);
        if and_test then {
            test_passed = not_bool(IsZero(element1 & element2))
        } else {
            test_passed = element1 == element2
        };
        result = Elem_set(result, e, esize, if test_passed then Ones(esize) else
          Zeros(esize))
    };
    V_set(d, datasize) = result
}

val decode_cmeq_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_bitwise_sisd : (bits(5), bits(5), bits(5), bits(2), bits(1)) -> unit

function decode_cmeq_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_bitwise_sisd (Rd, Rn, Rm, size, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size != 0b11 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    let 'datasize = esize;
    let 'elements = 1;
    let and_test : bool = U == 0b0;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_bitwise_sisd(and_test, d, datasize, elements, esize, m, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitone, bitzero, bitzero, bitzero, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 137) = {
    SEE = 137;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    decode_cmeq_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_bitwise_sisd(Rd, Rn, Rm, size, U)
}

val decode_cmeq_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_bitwise_simd : (bits(5), bits(5), bits(5), bits(2), bits(1), bits(1)) -> unit

function decode_cmeq_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_bitwise_simd (Rd, Rn, Rm, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if (size @ Q) == 0b110 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let and_test : bool = U == 0b0;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_bitwise_sisd(and_test, d, datasize, elements, esize, m, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitone, bitzero, bitzero, bitzero, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 138) = {
    SEE = 138;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_cmeq_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_bitwise_simd(Rd, Rn, Rm, size, U, Q)
}

val decode_cmtst_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_bitwise_sisd : (bits(5), bits(5), bits(5), bits(2), bits(1)) -> unit

function decode_cmtst_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_bitwise_sisd (Rd, Rn, Rm, size, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size != 0b11 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    let 'datasize = esize;
    let 'elements = 1;
    let and_test : bool = U == 0b0;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_bitwise_sisd(and_test, d, datasize, elements, esize, m, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitone, bitzero, bitzero, bitzero, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 139) = {
    SEE = 139;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    decode_cmtst_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_bitwise_sisd(Rd, Rn, Rm, size, U)
}

val decode_cmtst_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_bitwise_simd : (bits(5), bits(5), bits(5), bits(2), bits(1), bits(1)) -> unit

function decode_cmtst_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_bitwise_simd (Rd, Rn, Rm, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if (size @ Q) == 0b110 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let and_test : bool = U == 0b0;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_bitwise_sisd(and_test, d, datasize, elements, esize, m, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitone, bitzero, bitzero, bitzero, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 140) = {
    SEE = 140;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_cmtst_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_bitwise_simd(Rd, Rn, Rm, size, U, Q)
}

val execute_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_int_sisd : forall ('cmp_eq : Bool) 'd 'datasize 'elements 'esize ('is_unsigned : Bool) 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'esize in {8, 16, 32, 64} & 'datasize in {8, 16, 32, 64, 128} & 0 <= 'd & 'd <= 31).
  (bool('cmp_eq), int('d), int('datasize), int('elements), int('esize), int('m), int('n), bool('is_unsigned)) -> unit

function execute_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_int_sisd (cmp_eq, d, datasize, elements, esize, m, n, is_unsigned) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = V_read(n, datasize);
    let operand2 : bits('datasize) = V_read(m, datasize);
    result : bits('datasize) = undefined;
    element1 : int = undefined;
    element2 : int = undefined;
    test_passed : bool = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element1 = asl_Int(Elem_read(operand1, e, esize), is_unsigned);
        element2 = asl_Int(Elem_read(operand2, e, esize), is_unsigned);
        test_passed = if cmp_eq then element1 >= element2 else
          element1 > element2;
        result = Elem_set(result, e, esize, if test_passed then Ones(esize) else
          Zeros(esize))
    };
    V_set(d, datasize) = result
}

val decode_cmge_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_int_sisd : (bits(5), bits(5), bits(1), bits(5), bits(2), bits(1)) -> unit

function decode_cmge_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_int_sisd (Rd, Rn, eq, Rm, size, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size != 0b11 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    let 'datasize = esize;
    let 'elements = 1;
    let is_unsigned : bool = U == 0b1;
    let cmp_eq : bool = eq == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_int_sisd(cmp_eq, d, datasize, elements, esize, m, n, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitzero, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 141) = {
    SEE = 141;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let eq = Slice(__opcode, 11, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    decode_cmge_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_int_sisd(Rd, Rn, eq, Rm, size, U)
}

val decode_cmge_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_int_simd : (bits(5), bits(5), bits(1), bits(5), bits(2), bits(1), bits(1)) -> unit

function decode_cmge_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_int_simd (Rd, Rn, eq, Rm, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if (size @ Q) == 0b110 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let is_unsigned : bool = U == 0b1;
    let cmp_eq : bool = eq == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_int_sisd(cmp_eq, d, datasize, elements, esize, m, n, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitzero, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 142) = {
    SEE = 142;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let eq = Slice(__opcode, 11, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_cmge_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_int_simd(Rd, Rn, eq, Rm, size, U, Q)
}

val decode_cmgt_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_int_sisd : (bits(5), bits(5), bits(1), bits(5), bits(2), bits(1)) -> unit

function decode_cmgt_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_int_sisd (Rd, Rn, eq, Rm, size, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size != 0b11 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    let 'datasize = esize;
    let 'elements = 1;
    let is_unsigned : bool = U == 0b1;
    let cmp_eq : bool = eq == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_int_sisd(cmp_eq, d, datasize, elements, esize, m, n, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitzero, bitone, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 143) = {
    SEE = 143;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let eq = Slice(__opcode, 11, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    decode_cmgt_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_int_sisd(Rd, Rn, eq, Rm, size, U)
}

val decode_cmgt_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_int_simd : (bits(5), bits(5), bits(1), bits(5), bits(2), bits(1), bits(1)) -> unit

function decode_cmgt_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_int_simd (Rd, Rn, eq, Rm, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if (size @ Q) == 0b110 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let is_unsigned : bool = U == 0b1;
    let cmp_eq : bool = eq == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_int_sisd(cmp_eq, d, datasize, elements, esize, m, n, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitzero, bitone, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 144) = {
    SEE = 144;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let eq = Slice(__opcode, 11, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_cmgt_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_int_simd(Rd, Rn, eq, Rm, size, U, Q)
}

val decode_cmhi_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_int_sisd : (bits(5), bits(5), bits(1), bits(5), bits(2), bits(1)) -> unit

function decode_cmhi_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_int_sisd (Rd, Rn, eq, Rm, size, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size != 0b11 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    let 'datasize = esize;
    let 'elements = 1;
    let is_unsigned : bool = U == 0b1;
    let cmp_eq : bool = eq == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_int_sisd(cmp_eq, d, datasize, elements, esize, m, n, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitzero, bitone, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 145) = {
    SEE = 145;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let eq = Slice(__opcode, 11, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    decode_cmhi_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_int_sisd(Rd, Rn, eq, Rm, size, U)
}

val decode_cmhi_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_int_simd : (bits(5), bits(5), bits(1), bits(5), bits(2), bits(1), bits(1)) -> unit

function decode_cmhi_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_int_simd (Rd, Rn, eq, Rm, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if (size @ Q) == 0b110 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let is_unsigned : bool = U == 0b1;
    let cmp_eq : bool = eq == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_int_sisd(cmp_eq, d, datasize, elements, esize, m, n, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitzero, bitone, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 146) = {
    SEE = 146;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let eq = Slice(__opcode, 11, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_cmhi_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_int_simd(Rd, Rn, eq, Rm, size, U, Q)
}

val decode_cmhs_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_int_sisd : (bits(5), bits(5), bits(1), bits(5), bits(2), bits(1)) -> unit

function decode_cmhs_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_int_sisd (Rd, Rn, eq, Rm, size, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size != 0b11 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    let 'datasize = esize;
    let 'elements = 1;
    let is_unsigned : bool = U == 0b1;
    let cmp_eq : bool = eq == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_int_sisd(cmp_eq, d, datasize, elements, esize, m, n, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitzero, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 147) = {
    SEE = 147;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let eq = Slice(__opcode, 11, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    decode_cmhs_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_int_sisd(Rd, Rn, eq, Rm, size, U)
}

val decode_cmhs_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_int_simd : (bits(5), bits(5), bits(1), bits(5), bits(2), bits(1), bits(1)) -> unit

function decode_cmhs_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_int_simd (Rd, Rn, eq, Rm, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if (size @ Q) == 0b110 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let is_unsigned : bool = U == 0b1;
    let cmp_eq : bool = eq == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_int_sisd(cmp_eq, d, datasize, elements, esize, m, n, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitzero, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 148) = {
    SEE = 148;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let eq = Slice(__opcode, 11, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_cmhs_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_int_simd(Rd, Rn, eq, Rm, size, U, Q)
}

val execute_aarch64_instrs_vector_arithmetic_unary_cmp_int_lessthan_sisd : forall 'd 'datasize 'elements 'esize 'n,
  (0 <= 'n & 'n <= 31 & 'esize in {8, 16, 32, 64} & 'datasize in {8, 16, 32, 64, 128} & 0 <= 'd & 'd <= 31).
  (CompareOp, int('d), int('datasize), int('elements), int('esize), int('n)) -> unit

function execute_aarch64_instrs_vector_arithmetic_unary_cmp_int_lessthan_sisd (comparison, d, datasize, elements, esize, n) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('datasize) = V_read(n, datasize);
    result : bits('datasize) = undefined;
    element : int = undefined;
    test_passed : bool = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element = SInt(Elem_read(operand, e, esize));
        match comparison {
          CompareOp_GT => {
              test_passed = element > 0
          },
          CompareOp_GE => {
              test_passed = element >= 0
          },
          CompareOp_EQ => {
              test_passed = element == 0
          },
          CompareOp_LE => {
              test_passed = element <= 0
          },
          CompareOp_LT => {
              test_passed = element < 0
          }
        };
        result = Elem_set(result, e, esize, if test_passed then Ones(esize) else
          Zeros(esize))
    };
    V_set(d, datasize) = result
}

val decode_cmlt_advsimd_aarch64_instrs_vector_arithmetic_unary_cmp_int_lessthan_sisd : (bits(5), bits(5), bits(2)) -> unit

function decode_cmlt_advsimd_aarch64_instrs_vector_arithmetic_unary_cmp_int_lessthan_sisd (Rd, Rn, size) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if size != 0b11 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    let 'datasize = esize;
    let 'elements = 1;
    let comparison : CompareOp = CompareOp_LT;
    execute_aarch64_instrs_vector_arithmetic_unary_cmp_int_lessthan_sisd(comparison, d, datasize, elements, esize, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 149) = {
    SEE = 149;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 22, 2);
    decode_cmlt_advsimd_aarch64_instrs_vector_arithmetic_unary_cmp_int_lessthan_sisd(Rd, Rn, size)
}

val decode_cmlt_advsimd_aarch64_instrs_vector_arithmetic_unary_cmp_int_lessthan_simd : (bits(5), bits(5), bits(2), bits(1)) -> unit

function decode_cmlt_advsimd_aarch64_instrs_vector_arithmetic_unary_cmp_int_lessthan_simd (Rd, Rn, size, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (size @ Q) == 0b110 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let comparison : CompareOp = CompareOp_LT;
    execute_aarch64_instrs_vector_arithmetic_unary_cmp_int_lessthan_sisd(comparison, d, datasize, elements, esize, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 150) = {
    SEE = 150;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 22, 2);
    let Q = Slice(__opcode, 30, 1);
    decode_cmlt_advsimd_aarch64_instrs_vector_arithmetic_unary_cmp_int_lessthan_simd(Rd, Rn, size, Q)
}

val execute_aarch64_instrs_integer_arithmetic_unary_cnt : forall 'd 'datasize 'n,
  (0 <= 'n & 'n <= 31 & 'datasize in {32, 64} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('n)) -> unit

function execute_aarch64_instrs_integer_arithmetic_unary_cnt (d, datasize, n) = {
    let operand1 : bits('datasize) = X_read(n, datasize);
    let 'result = BitCount(operand1);
    X_set(d, datasize) = result[datasize - 1 .. 0]
}

val decode_cnt_aarch64_instrs_integer_arithmetic_unary_cnt : (bits(5), bits(5), bits(1)) -> unit

function decode_cnt_aarch64_instrs_integer_arithmetic_unary_cnt (Rd, Rn, sf) = {
    if not_bool(HaveCSSC()) then {
        throw(Error_Undefined())
    };
    let 'datasize = (32 << UInt(sf));
    let 'n = UInt(Rn);
    let 'd = UInt(Rd);
    execute_aarch64_instrs_integer_arithmetic_unary_cnt(d, datasize, n)
}

function clause __DecodeA64_DataProcReg ((pc, ([_, bitone, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 151) = {
    SEE = 151;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let sf = Slice(__opcode, 31, 1);
    decode_cnt_aarch64_instrs_integer_arithmetic_unary_cnt(Rd, Rn, sf)
}

val execute_aarch64_instrs_vector_arithmetic_unary_cnt : forall 'd 'datasize 'elements 'esize 'n,
  (0 <= 'n & 'n <= 31 & 'esize == 8 & 'elements in {8, 16} & 'datasize in {64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('n)) -> unit

function execute_aarch64_instrs_vector_arithmetic_unary_cnt (d, datasize, elements, esize, n) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('datasize) = V_read(n, datasize);
    result : bits('datasize) = undefined;
    count : int = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        count = BitCount(Elem_read(operand, e, esize));
        result = Elem_set(result, e, esize, count[esize - 1 .. 0])
    };
    V_set(d, datasize) = result
}

val decode_cnt_advsimd_aarch64_instrs_vector_arithmetic_unary_cnt : (bits(5), bits(5), bits(2), bits(1)) -> unit

function decode_cnt_advsimd_aarch64_instrs_vector_arithmetic_unary_cnt (Rd, Rn, size, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if size != 0b00 then {
        throw(Error_Undefined())
    };
    let 'esize = 8;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, 8);
    execute_aarch64_instrs_vector_arithmetic_unary_cnt(d, datasize, elements, esize, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 152) = {
    SEE = 152;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 22, 2);
    let Q = Slice(__opcode, 30, 1);
    decode_cnt_advsimd_aarch64_instrs_vector_arithmetic_unary_cnt(Rd, Rn, size, Q)
}

val execute_aarch64_instrs_memory_mcpymset_cpy : forall 'd 'n 's,
  (0 <= 's & 's <= 31 & 0 <= 'n & 'n <= 31 & 0 <= 'd & 'd <= 31).
  (int('d), int('n), bits(4), int('s), MOPSStage) -> unit

function execute_aarch64_instrs_memory_mcpymset_cpy (d, n, options_name, s, stage) = {
    let 'N = MaxBlockSizeCopiedBytes();
    toaddress : bits(64) = X_read(d, 64);
    fromaddress : bits(64) = X_read(s, 64);
    cpysize : bits(64) = X_read(n, 64);
    nzcv : bits(4) = PSTATE.N @ (PSTATE.Z @ (PSTATE.C @ PSTATE.V));
    stagecpysize : bits(64) = undefined;
    readdata : bits(8 * 'N) = undefined;
    B : int = undefined;
    let supports_option_a : bool = CPYOptionA();
    let rprivileged : bool = if [options_name[1]] == 0b1 then
      AArch64_IsUnprivAccessPriv()
    else
      PSTATE.EL != EL0;
    let wprivileged : bool = if [options_name[0]] == 0b1 then
      AArch64_IsUnprivAccessPriv()
    else
      PSTATE.EL != EL0;
    let rnontemporal : bool = [options_name[3]] == 0b1;
    let wnontemporal : bool = [options_name[2]] == 0b1;
    let raccdesc : AccessDescriptor = CreateAccDescMOPS(MemOp_LOAD, rprivileged, rnontemporal);
    let waccdesc : AccessDescriptor = CreateAccDescMOPS(MemOp_STORE, wprivileged, wnontemporal);
    if stage == MOPSStage_Prologue then {
        if cpysize[63 .. 55] != 0b000000000 then {
            cpysize = 0x007FFFFFFFFFFFFF
        };
        forward : bool = undefined;
        if UInt(fromaddress[55 .. 0]) > UInt(toaddress[55 .. 0]) & UInt(fromaddress[55 .. 0]) < UInt(toaddress[55 .. 0] + cpysize[55 .. 0]) then {
            forward = true
        } else if UInt(fromaddress[55 .. 0]) < UInt(toaddress[55 .. 0]) & UInt(fromaddress[55 .. 0] + cpysize[55 .. 0]) > UInt(toaddress[55 .. 0]) then {
            forward = false
        } else {
            forward = MemCpyDirectionChoice(fromaddress, toaddress, cpysize)
        };
        if supports_option_a then {
            nzcv = 0b0000;
            if forward then {
                toaddress = toaddress + cpysize;
                fromaddress = fromaddress + cpysize;
                cpysize = Zeros(64) - cpysize
            };
            ()
        } else {
            if not_bool(forward) then {
                toaddress = toaddress + cpysize;
                fromaddress = fromaddress + cpysize;
                nzcv = 0b1010
            } else {
                nzcv = 0b0010
            }
        };
        stagecpysize = CPYPreSizeChoice(toaddress, fromaddress, cpysize);
        assert([stagecpysize[63]] == [cpysize[63]] | stagecpysize == Zeros(64));
        if SInt(cpysize) > 0 then {
            assert(SInt(stagecpysize) <= SInt(cpysize))
        } else {
            assert(SInt(stagecpysize) >= SInt(cpysize))
        }
    } else {
        let zero_size_exceptions : bool = MemCpyZeroSizeCheck();
        if zero_size_exceptions | SInt(cpysize) != 0 then {
            if supports_option_a then {
                if [nzcv[1]] == 0b1 then {
                    let wrong_option : bool = true;
                    let from_epilogue : bool = stage == MOPSStage_Epilogue;
                    MismatchedMemCpyException(supports_option_a, d, s, n, wrong_option, from_epilogue, options_name)
                };
                ()
            } else {
                if [nzcv[1]] == 0b0 then {
                    let wrong_option : bool = true;
                    let from_epilogue : bool = stage == MOPSStage_Epilogue;
                    MismatchedMemCpyException(supports_option_a, d, s, n, wrong_option, from_epilogue, options_name)
                };
                ()
            }
        };
        let postsize : bits(64) = CPYPostSizeChoice(toaddress, fromaddress, cpysize);
        assert([postsize[63]] == [cpysize[63]] | SInt(postsize) == 0);
        if stage == MOPSStage_Main then {
            stagecpysize = cpysize - postsize;
            if MemCpyParametersIllformedM(toaddress, fromaddress, cpysize) then {
                let wrong_option : bool = false;
                let from_epilogue : bool = false;
                MismatchedMemCpyException(supports_option_a, d, s, n, wrong_option, from_epilogue, options_name)
            };
            ()
        } else {
            stagecpysize = postsize;
            if cpysize != postsize | MemCpyParametersIllformedE(toaddress, fromaddress, cpysize) then {
                let wrong_option : bool = false;
                let from_epilogue : bool = true;
                MismatchedMemCpyException(supports_option_a, d, s, n, wrong_option, from_epilogue, options_name)
            };
            ()
        }
    };
    if SPESampleInFlight then {
        SPESampleMemCopy()
    };
    if supports_option_a then {
        while SInt(stagecpysize) != 0 do {
            B = CPYSizeChoice(toaddress, fromaddress, cpysize);
            let 'B = B in
              {
                  if SInt(cpysize) < 0 then {
                      assert(B <= negate(1) * SInt(stagecpysize));
                      assert(constraint((0 <= 'B * 8 - 1 & 'B * 8 - 1 < 8 * 'N)));
                      readdata[B * 8 - 1 .. 0] = Mem_read(fromaddress + cpysize, B, raccdesc);
                      Mem_set(toaddress + cpysize, B, waccdesc) = readdata[B * 8 - 1 .. 0];
                      cpysize = cpysize + B;
                      stagecpysize = stagecpysize + B
                  } else {
                      assert(B <= SInt(stagecpysize));
                      cpysize = cpysize - B;
                      stagecpysize = stagecpysize - B;
                      assert(constraint((0 <= 'B * 8 - 1 & 'B * 8 - 1 < 8 * 'N)));
                      readdata[B * 8 - 1 .. 0] = Mem_read(fromaddress + cpysize, B, raccdesc);
                      Mem_set(toaddress + cpysize, B, waccdesc) = readdata[B * 8 - 1 .. 0]
                  }
              };
            if stage != MOPSStage_Prologue then {
                X_set(n, 64) = cpysize
            };
            ()
        }
    } else {
        while UInt(stagecpysize) > 0 do {
            B = CPYSizeChoice(toaddress, fromaddress, cpysize);
            assert(B <= UInt(stagecpysize));
            let 'B = B in
              {
                  if [nzcv[3]] == 0b0 then {
                      assert(constraint((0 <= 'B * 8 - 1 & 'B * 8 - 1 < 8 * 'N)));
                      readdata[B * 8 - 1 .. 0] = Mem_read(fromaddress, B, raccdesc);
                      Mem_set(toaddress, B, waccdesc) = readdata[B * 8 - 1 .. 0];
                      fromaddress = fromaddress + B;
                      toaddress = toaddress + B
                  } else {
                      assert(constraint((0 <= 'B * 8 - 1 & 'B * 8 - 1 < 8 * 'N)));
                      readdata[B * 8 - 1 .. 0] = Mem_read(fromaddress - B, B, raccdesc);
                      Mem_set(toaddress - B, B, waccdesc) = readdata[B * 8 - 1 .. 0];
                      fromaddress = fromaddress - B;
                      toaddress = toaddress - B
                  }
              };
            cpysize = cpysize - B;
            stagecpysize = stagecpysize - B;
            if stage != MOPSStage_Prologue then {
                X_set(n, 64) = cpysize;
                X_set(d, 64) = toaddress;
                X_set(s, 64) = fromaddress
            };
            ()
        }
    };
    if stage == MOPSStage_Prologue then {
        X_set(n, 64) = cpysize;
        X_set(d, 64) = toaddress;
        X_set(s, 64) = fromaddress;
        (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V) = nzcv
    };
    ()
}

val decode_cpyp_aarch64_instrs_memory_mcpymset_cpy : (bits(5), bits(5), bits(4), bits(5), bits(2), bits(2)) -> unit

function decode_cpyp_aarch64_instrs_memory_mcpymset_cpy (Rd, Rn, op2, Rs, op1, sz) = {
    if not_bool(HaveFeatMOPS()) then {
        throw(Error_Undefined())
    };
    if sz != 0b00 then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 's = UInt(Rs);
    let 'n = UInt(Rn);
    let options_name : bits(4) = op2;
    stage : MOPSStage = undefined;
    match op1 {
      0b00 => {
          stage = MOPSStage_Prologue
      },
      0b01 => {
          stage = MOPSStage_Main
      },
      0b10 => {
          stage = MOPSStage_Epilogue
      },
      _ => {
          throw(Error_See("Memory Copy and Memory Set"))
      }
    };
    let stage = stage;
    CheckMOPSEnabled();
    if ((((s == n | s == d) | n == d) | d == 31) | s == 31) | n == 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_MOPSOVERLAP31);
        assert(c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    execute_aarch64_instrs_memory_mcpymset_cpy(d, n, options_name, s, stage)
}

function clause __DecodeA64_LoadStore ((pc, ([_, _, bitzero, bitone, bitone, bitone, bitzero, bitone, _, _, bitzero, _, _, _, _, _, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 153) = {
    SEE = 153;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op2 = Slice(__opcode, 12, 4);
    let Rs = Slice(__opcode, 16, 5);
    let op1 = Slice(__opcode, 22, 2);
    let sz = Slice(__opcode, 30, 2);
    decode_cpyp_aarch64_instrs_memory_mcpymset_cpy(Rd, Rn, op2, Rs, op1, sz)
}

val decode_cpypn_aarch64_instrs_memory_mcpymset_cpy : (bits(5), bits(5), bits(4), bits(5), bits(2), bits(2)) -> unit

function decode_cpypn_aarch64_instrs_memory_mcpymset_cpy (Rd, Rn, op2, Rs, op1, sz) = {
    if not_bool(HaveFeatMOPS()) then {
        throw(Error_Undefined())
    };
    if sz != 0b00 then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 's = UInt(Rs);
    let 'n = UInt(Rn);
    let options_name : bits(4) = op2;
    stage : MOPSStage = undefined;
    match op1 {
      0b00 => {
          stage = MOPSStage_Prologue
      },
      0b01 => {
          stage = MOPSStage_Main
      },
      0b10 => {
          stage = MOPSStage_Epilogue
      },
      _ => {
          throw(Error_See("Memory Copy and Memory Set"))
      }
    };
    let stage = stage;
    CheckMOPSEnabled();
    if ((((s == n | s == d) | n == d) | d == 31) | s == 31) | n == 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_MOPSOVERLAP31);
        assert(c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    execute_aarch64_instrs_memory_mcpymset_cpy(d, n, options_name, s, stage)
}

function clause __DecodeA64_LoadStore ((pc, ([_, _, bitzero, bitone, bitone, bitone, bitzero, bitone, _, _, bitzero, _, _, _, _, _, bitone, bitone, bitzero, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 154) = {
    SEE = 154;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op2 = Slice(__opcode, 12, 4);
    let Rs = Slice(__opcode, 16, 5);
    let op1 = Slice(__opcode, 22, 2);
    let sz = Slice(__opcode, 30, 2);
    decode_cpypn_aarch64_instrs_memory_mcpymset_cpy(Rd, Rn, op2, Rs, op1, sz)
}

val decode_cpyprn_aarch64_instrs_memory_mcpymset_cpy : (bits(5), bits(5), bits(4), bits(5), bits(2), bits(2)) -> unit

function decode_cpyprn_aarch64_instrs_memory_mcpymset_cpy (Rd, Rn, op2, Rs, op1, sz) = {
    if not_bool(HaveFeatMOPS()) then {
        throw(Error_Undefined())
    };
    if sz != 0b00 then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 's = UInt(Rs);
    let 'n = UInt(Rn);
    let options_name : bits(4) = op2;
    stage : MOPSStage = undefined;
    match op1 {
      0b00 => {
          stage = MOPSStage_Prologue
      },
      0b01 => {
          stage = MOPSStage_Main
      },
      0b10 => {
          stage = MOPSStage_Epilogue
      },
      _ => {
          throw(Error_See("Memory Copy and Memory Set"))
      }
    };
    let stage = stage;
    CheckMOPSEnabled();
    if ((((s == n | s == d) | n == d) | d == 31) | s == 31) | n == 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_MOPSOVERLAP31);
        assert(c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    execute_aarch64_instrs_memory_mcpymset_cpy(d, n, options_name, s, stage)
}

function clause __DecodeA64_LoadStore ((pc, ([_, _, bitzero, bitone, bitone, bitone, bitzero, bitone, _, _, bitzero, _, _, _, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 155) = {
    SEE = 155;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op2 = Slice(__opcode, 12, 4);
    let Rs = Slice(__opcode, 16, 5);
    let op1 = Slice(__opcode, 22, 2);
    let sz = Slice(__opcode, 30, 2);
    decode_cpyprn_aarch64_instrs_memory_mcpymset_cpy(Rd, Rn, op2, Rs, op1, sz)
}

val decode_cpyprt_aarch64_instrs_memory_mcpymset_cpy : (bits(5), bits(5), bits(4), bits(5), bits(2), bits(2)) -> unit

function decode_cpyprt_aarch64_instrs_memory_mcpymset_cpy (Rd, Rn, op2, Rs, op1, sz) = {
    if not_bool(HaveFeatMOPS()) then {
        throw(Error_Undefined())
    };
    if sz != 0b00 then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 's = UInt(Rs);
    let 'n = UInt(Rn);
    let options_name : bits(4) = op2;
    stage : MOPSStage = undefined;
    match op1 {
      0b00 => {
          stage = MOPSStage_Prologue
      },
      0b01 => {
          stage = MOPSStage_Main
      },
      0b10 => {
          stage = MOPSStage_Epilogue
      },
      _ => {
          throw(Error_See("Memory Copy and Memory Set"))
      }
    };
    let stage = stage;
    CheckMOPSEnabled();
    if ((((s == n | s == d) | n == d) | d == 31) | s == 31) | n == 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_MOPSOVERLAP31);
        assert(c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    execute_aarch64_instrs_memory_mcpymset_cpy(d, n, options_name, s, stage)
}

function clause __DecodeA64_LoadStore ((pc, ([_, _, bitzero, bitone, bitone, bitone, bitzero, bitone, _, _, bitzero, _, _, _, _, _, bitzero, bitzero, bitone, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 156) = {
    SEE = 156;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op2 = Slice(__opcode, 12, 4);
    let Rs = Slice(__opcode, 16, 5);
    let op1 = Slice(__opcode, 22, 2);
    let sz = Slice(__opcode, 30, 2);
    decode_cpyprt_aarch64_instrs_memory_mcpymset_cpy(Rd, Rn, op2, Rs, op1, sz)
}

val decode_cpyprtn_aarch64_instrs_memory_mcpymset_cpy : (bits(5), bits(5), bits(4), bits(5), bits(2), bits(2)) -> unit

function decode_cpyprtn_aarch64_instrs_memory_mcpymset_cpy (Rd, Rn, op2, Rs, op1, sz) = {
    if not_bool(HaveFeatMOPS()) then {
        throw(Error_Undefined())
    };
    if sz != 0b00 then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 's = UInt(Rs);
    let 'n = UInt(Rn);
    let options_name : bits(4) = op2;
    stage : MOPSStage = undefined;
    match op1 {
      0b00 => {
          stage = MOPSStage_Prologue
      },
      0b01 => {
          stage = MOPSStage_Main
      },
      0b10 => {
          stage = MOPSStage_Epilogue
      },
      _ => {
          throw(Error_See("Memory Copy and Memory Set"))
      }
    };
    let stage = stage;
    CheckMOPSEnabled();
    if ((((s == n | s == d) | n == d) | d == 31) | s == 31) | n == 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_MOPSOVERLAP31);
        assert(c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    execute_aarch64_instrs_memory_mcpymset_cpy(d, n, options_name, s, stage)
}

function clause __DecodeA64_LoadStore ((pc, ([_, _, bitzero, bitone, bitone, bitone, bitzero, bitone, _, _, bitzero, _, _, _, _, _, bitone, bitone, bitone, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 157) = {
    SEE = 157;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op2 = Slice(__opcode, 12, 4);
    let Rs = Slice(__opcode, 16, 5);
    let op1 = Slice(__opcode, 22, 2);
    let sz = Slice(__opcode, 30, 2);
    decode_cpyprtn_aarch64_instrs_memory_mcpymset_cpy(Rd, Rn, op2, Rs, op1, sz)
}

val decode_cpyprtrn_aarch64_instrs_memory_mcpymset_cpy : (bits(5), bits(5), bits(4), bits(5), bits(2), bits(2)) -> unit

function decode_cpyprtrn_aarch64_instrs_memory_mcpymset_cpy (Rd, Rn, op2, Rs, op1, sz) = {
    if not_bool(HaveFeatMOPS()) then {
        throw(Error_Undefined())
    };
    if sz != 0b00 then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 's = UInt(Rs);
    let 'n = UInt(Rn);
    let options_name : bits(4) = op2;
    stage : MOPSStage = undefined;
    match op1 {
      0b00 => {
          stage = MOPSStage_Prologue
      },
      0b01 => {
          stage = MOPSStage_Main
      },
      0b10 => {
          stage = MOPSStage_Epilogue
      },
      _ => {
          throw(Error_See("Memory Copy and Memory Set"))
      }
    };
    let stage = stage;
    CheckMOPSEnabled();
    if ((((s == n | s == d) | n == d) | d == 31) | s == 31) | n == 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_MOPSOVERLAP31);
        assert(c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    execute_aarch64_instrs_memory_mcpymset_cpy(d, n, options_name, s, stage)
}

function clause __DecodeA64_LoadStore ((pc, ([_, _, bitzero, bitone, bitone, bitone, bitzero, bitone, _, _, bitzero, _, _, _, _, _, bitone, bitzero, bitone, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 158) = {
    SEE = 158;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op2 = Slice(__opcode, 12, 4);
    let Rs = Slice(__opcode, 16, 5);
    let op1 = Slice(__opcode, 22, 2);
    let sz = Slice(__opcode, 30, 2);
    decode_cpyprtrn_aarch64_instrs_memory_mcpymset_cpy(Rd, Rn, op2, Rs, op1, sz)
}

val decode_cpyprtwn_aarch64_instrs_memory_mcpymset_cpy : (bits(5), bits(5), bits(4), bits(5), bits(2), bits(2)) -> unit

function decode_cpyprtwn_aarch64_instrs_memory_mcpymset_cpy (Rd, Rn, op2, Rs, op1, sz) = {
    if not_bool(HaveFeatMOPS()) then {
        throw(Error_Undefined())
    };
    if sz != 0b00 then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 's = UInt(Rs);
    let 'n = UInt(Rn);
    let options_name : bits(4) = op2;
    stage : MOPSStage = undefined;
    match op1 {
      0b00 => {
          stage = MOPSStage_Prologue
      },
      0b01 => {
          stage = MOPSStage_Main
      },
      0b10 => {
          stage = MOPSStage_Epilogue
      },
      _ => {
          throw(Error_See("Memory Copy and Memory Set"))
      }
    };
    let stage = stage;
    CheckMOPSEnabled();
    if ((((s == n | s == d) | n == d) | d == 31) | s == 31) | n == 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_MOPSOVERLAP31);
        assert(c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    execute_aarch64_instrs_memory_mcpymset_cpy(d, n, options_name, s, stage)
}

function clause __DecodeA64_LoadStore ((pc, ([_, _, bitzero, bitone, bitone, bitone, bitzero, bitone, _, _, bitzero, _, _, _, _, _, bitzero, bitone, bitone, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 159) = {
    SEE = 159;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op2 = Slice(__opcode, 12, 4);
    let Rs = Slice(__opcode, 16, 5);
    let op1 = Slice(__opcode, 22, 2);
    let sz = Slice(__opcode, 30, 2);
    decode_cpyprtwn_aarch64_instrs_memory_mcpymset_cpy(Rd, Rn, op2, Rs, op1, sz)
}

val decode_cpypt_aarch64_instrs_memory_mcpymset_cpy : (bits(5), bits(5), bits(4), bits(5), bits(2), bits(2)) -> unit

function decode_cpypt_aarch64_instrs_memory_mcpymset_cpy (Rd, Rn, op2, Rs, op1, sz) = {
    if not_bool(HaveFeatMOPS()) then {
        throw(Error_Undefined())
    };
    if sz != 0b00 then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 's = UInt(Rs);
    let 'n = UInt(Rn);
    let options_name : bits(4) = op2;
    stage : MOPSStage = undefined;
    match op1 {
      0b00 => {
          stage = MOPSStage_Prologue
      },
      0b01 => {
          stage = MOPSStage_Main
      },
      0b10 => {
          stage = MOPSStage_Epilogue
      },
      _ => {
          throw(Error_See("Memory Copy and Memory Set"))
      }
    };
    let stage = stage;
    CheckMOPSEnabled();
    if ((((s == n | s == d) | n == d) | d == 31) | s == 31) | n == 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_MOPSOVERLAP31);
        assert(c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    execute_aarch64_instrs_memory_mcpymset_cpy(d, n, options_name, s, stage)
}

function clause __DecodeA64_LoadStore ((pc, ([_, _, bitzero, bitone, bitone, bitone, bitzero, bitone, _, _, bitzero, _, _, _, _, _, bitzero, bitzero, bitone, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 160) = {
    SEE = 160;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op2 = Slice(__opcode, 12, 4);
    let Rs = Slice(__opcode, 16, 5);
    let op1 = Slice(__opcode, 22, 2);
    let sz = Slice(__opcode, 30, 2);
    decode_cpypt_aarch64_instrs_memory_mcpymset_cpy(Rd, Rn, op2, Rs, op1, sz)
}

val decode_cpyptn_aarch64_instrs_memory_mcpymset_cpy : (bits(5), bits(5), bits(4), bits(5), bits(2), bits(2)) -> unit

function decode_cpyptn_aarch64_instrs_memory_mcpymset_cpy (Rd, Rn, op2, Rs, op1, sz) = {
    if not_bool(HaveFeatMOPS()) then {
        throw(Error_Undefined())
    };
    if sz != 0b00 then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 's = UInt(Rs);
    let 'n = UInt(Rn);
    let options_name : bits(4) = op2;
    stage : MOPSStage = undefined;
    match op1 {
      0b00 => {
          stage = MOPSStage_Prologue
      },
      0b01 => {
          stage = MOPSStage_Main
      },
      0b10 => {
          stage = MOPSStage_Epilogue
      },
      _ => {
          throw(Error_See("Memory Copy and Memory Set"))
      }
    };
    let stage = stage;
    CheckMOPSEnabled();
    if ((((s == n | s == d) | n == d) | d == 31) | s == 31) | n == 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_MOPSOVERLAP31);
        assert(c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    execute_aarch64_instrs_memory_mcpymset_cpy(d, n, options_name, s, stage)
}

function clause __DecodeA64_LoadStore ((pc, ([_, _, bitzero, bitone, bitone, bitone, bitzero, bitone, _, _, bitzero, _, _, _, _, _, bitone, bitone, bitone, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 161) = {
    SEE = 161;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op2 = Slice(__opcode, 12, 4);
    let Rs = Slice(__opcode, 16, 5);
    let op1 = Slice(__opcode, 22, 2);
    let sz = Slice(__opcode, 30, 2);
    decode_cpyptn_aarch64_instrs_memory_mcpymset_cpy(Rd, Rn, op2, Rs, op1, sz)
}

val decode_cpyptrn_aarch64_instrs_memory_mcpymset_cpy : (bits(5), bits(5), bits(4), bits(5), bits(2), bits(2)) -> unit

function decode_cpyptrn_aarch64_instrs_memory_mcpymset_cpy (Rd, Rn, op2, Rs, op1, sz) = {
    if not_bool(HaveFeatMOPS()) then {
        throw(Error_Undefined())
    };
    if sz != 0b00 then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 's = UInt(Rs);
    let 'n = UInt(Rn);
    let options_name : bits(4) = op2;
    stage : MOPSStage = undefined;
    match op1 {
      0b00 => {
          stage = MOPSStage_Prologue
      },
      0b01 => {
          stage = MOPSStage_Main
      },
      0b10 => {
          stage = MOPSStage_Epilogue
      },
      _ => {
          throw(Error_See("Memory Copy and Memory Set"))
      }
    };
    let stage = stage;
    CheckMOPSEnabled();
    if ((((s == n | s == d) | n == d) | d == 31) | s == 31) | n == 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_MOPSOVERLAP31);
        assert(c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    execute_aarch64_instrs_memory_mcpymset_cpy(d, n, options_name, s, stage)
}

function clause __DecodeA64_LoadStore ((pc, ([_, _, bitzero, bitone, bitone, bitone, bitzero, bitone, _, _, bitzero, _, _, _, _, _, bitone, bitzero, bitone, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 162) = {
    SEE = 162;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op2 = Slice(__opcode, 12, 4);
    let Rs = Slice(__opcode, 16, 5);
    let op1 = Slice(__opcode, 22, 2);
    let sz = Slice(__opcode, 30, 2);
    decode_cpyptrn_aarch64_instrs_memory_mcpymset_cpy(Rd, Rn, op2, Rs, op1, sz)
}

val decode_cpyptwn_aarch64_instrs_memory_mcpymset_cpy : (bits(5), bits(5), bits(4), bits(5), bits(2), bits(2)) -> unit

function decode_cpyptwn_aarch64_instrs_memory_mcpymset_cpy (Rd, Rn, op2, Rs, op1, sz) = {
    if not_bool(HaveFeatMOPS()) then {
        throw(Error_Undefined())
    };
    if sz != 0b00 then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 's = UInt(Rs);
    let 'n = UInt(Rn);
    let options_name : bits(4) = op2;
    stage : MOPSStage = undefined;
    match op1 {
      0b00 => {
          stage = MOPSStage_Prologue
      },
      0b01 => {
          stage = MOPSStage_Main
      },
      0b10 => {
          stage = MOPSStage_Epilogue
      },
      _ => {
          throw(Error_See("Memory Copy and Memory Set"))
      }
    };
    let stage = stage;
    CheckMOPSEnabled();
    if ((((s == n | s == d) | n == d) | d == 31) | s == 31) | n == 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_MOPSOVERLAP31);
        assert(c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    execute_aarch64_instrs_memory_mcpymset_cpy(d, n, options_name, s, stage)
}

function clause __DecodeA64_LoadStore ((pc, ([_, _, bitzero, bitone, bitone, bitone, bitzero, bitone, _, _, bitzero, _, _, _, _, _, bitzero, bitone, bitone, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 163) = {
    SEE = 163;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op2 = Slice(__opcode, 12, 4);
    let Rs = Slice(__opcode, 16, 5);
    let op1 = Slice(__opcode, 22, 2);
    let sz = Slice(__opcode, 30, 2);
    decode_cpyptwn_aarch64_instrs_memory_mcpymset_cpy(Rd, Rn, op2, Rs, op1, sz)
}

val decode_cpypwn_aarch64_instrs_memory_mcpymset_cpy : (bits(5), bits(5), bits(4), bits(5), bits(2), bits(2)) -> unit

function decode_cpypwn_aarch64_instrs_memory_mcpymset_cpy (Rd, Rn, op2, Rs, op1, sz) = {
    if not_bool(HaveFeatMOPS()) then {
        throw(Error_Undefined())
    };
    if sz != 0b00 then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 's = UInt(Rs);
    let 'n = UInt(Rn);
    let options_name : bits(4) = op2;
    stage : MOPSStage = undefined;
    match op1 {
      0b00 => {
          stage = MOPSStage_Prologue
      },
      0b01 => {
          stage = MOPSStage_Main
      },
      0b10 => {
          stage = MOPSStage_Epilogue
      },
      _ => {
          throw(Error_See("Memory Copy and Memory Set"))
      }
    };
    let stage = stage;
    CheckMOPSEnabled();
    if ((((s == n | s == d) | n == d) | d == 31) | s == 31) | n == 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_MOPSOVERLAP31);
        assert(c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    execute_aarch64_instrs_memory_mcpymset_cpy(d, n, options_name, s, stage)
}

function clause __DecodeA64_LoadStore ((pc, ([_, _, bitzero, bitone, bitone, bitone, bitzero, bitone, _, _, bitzero, _, _, _, _, _, bitzero, bitone, bitzero, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 164) = {
    SEE = 164;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op2 = Slice(__opcode, 12, 4);
    let Rs = Slice(__opcode, 16, 5);
    let op1 = Slice(__opcode, 22, 2);
    let sz = Slice(__opcode, 30, 2);
    decode_cpypwn_aarch64_instrs_memory_mcpymset_cpy(Rd, Rn, op2, Rs, op1, sz)
}

val decode_cpypwt_aarch64_instrs_memory_mcpymset_cpy : (bits(5), bits(5), bits(4), bits(5), bits(2), bits(2)) -> unit

function decode_cpypwt_aarch64_instrs_memory_mcpymset_cpy (Rd, Rn, op2, Rs, op1, sz) = {
    if not_bool(HaveFeatMOPS()) then {
        throw(Error_Undefined())
    };
    if sz != 0b00 then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 's = UInt(Rs);
    let 'n = UInt(Rn);
    let options_name : bits(4) = op2;
    stage : MOPSStage = undefined;
    match op1 {
      0b00 => {
          stage = MOPSStage_Prologue
      },
      0b01 => {
          stage = MOPSStage_Main
      },
      0b10 => {
          stage = MOPSStage_Epilogue
      },
      _ => {
          throw(Error_See("Memory Copy and Memory Set"))
      }
    };
    let stage = stage;
    CheckMOPSEnabled();
    if ((((s == n | s == d) | n == d) | d == 31) | s == 31) | n == 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_MOPSOVERLAP31);
        assert(c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    execute_aarch64_instrs_memory_mcpymset_cpy(d, n, options_name, s, stage)
}

function clause __DecodeA64_LoadStore ((pc, ([_, _, bitzero, bitone, bitone, bitone, bitzero, bitone, _, _, bitzero, _, _, _, _, _, bitzero, bitzero, bitzero, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 165) = {
    SEE = 165;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op2 = Slice(__opcode, 12, 4);
    let Rs = Slice(__opcode, 16, 5);
    let op1 = Slice(__opcode, 22, 2);
    let sz = Slice(__opcode, 30, 2);
    decode_cpypwt_aarch64_instrs_memory_mcpymset_cpy(Rd, Rn, op2, Rs, op1, sz)
}

val decode_cpypwtn_aarch64_instrs_memory_mcpymset_cpy : (bits(5), bits(5), bits(4), bits(5), bits(2), bits(2)) -> unit

function decode_cpypwtn_aarch64_instrs_memory_mcpymset_cpy (Rd, Rn, op2, Rs, op1, sz) = {
    if not_bool(HaveFeatMOPS()) then {
        throw(Error_Undefined())
    };
    if sz != 0b00 then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 's = UInt(Rs);
    let 'n = UInt(Rn);
    let options_name : bits(4) = op2;
    stage : MOPSStage = undefined;
    match op1 {
      0b00 => {
          stage = MOPSStage_Prologue
      },
      0b01 => {
          stage = MOPSStage_Main
      },
      0b10 => {
          stage = MOPSStage_Epilogue
      },
      _ => {
          throw(Error_See("Memory Copy and Memory Set"))
      }
    };
    let stage = stage;
    CheckMOPSEnabled();
    if ((((s == n | s == d) | n == d) | d == 31) | s == 31) | n == 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_MOPSOVERLAP31);
        assert(c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    execute_aarch64_instrs_memory_mcpymset_cpy(d, n, options_name, s, stage)
}

function clause __DecodeA64_LoadStore ((pc, ([_, _, bitzero, bitone, bitone, bitone, bitzero, bitone, _, _, bitzero, _, _, _, _, _, bitone, bitone, bitzero, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 166) = {
    SEE = 166;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op2 = Slice(__opcode, 12, 4);
    let Rs = Slice(__opcode, 16, 5);
    let op1 = Slice(__opcode, 22, 2);
    let sz = Slice(__opcode, 30, 2);
    decode_cpypwtn_aarch64_instrs_memory_mcpymset_cpy(Rd, Rn, op2, Rs, op1, sz)
}

val decode_cpypwtrn_aarch64_instrs_memory_mcpymset_cpy : (bits(5), bits(5), bits(4), bits(5), bits(2), bits(2)) -> unit

function decode_cpypwtrn_aarch64_instrs_memory_mcpymset_cpy (Rd, Rn, op2, Rs, op1, sz) = {
    if not_bool(HaveFeatMOPS()) then {
        throw(Error_Undefined())
    };
    if sz != 0b00 then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 's = UInt(Rs);
    let 'n = UInt(Rn);
    let options_name : bits(4) = op2;
    stage : MOPSStage = undefined;
    match op1 {
      0b00 => {
          stage = MOPSStage_Prologue
      },
      0b01 => {
          stage = MOPSStage_Main
      },
      0b10 => {
          stage = MOPSStage_Epilogue
      },
      _ => {
          throw(Error_See("Memory Copy and Memory Set"))
      }
    };
    let stage = stage;
    CheckMOPSEnabled();
    if ((((s == n | s == d) | n == d) | d == 31) | s == 31) | n == 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_MOPSOVERLAP31);
        assert(c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    execute_aarch64_instrs_memory_mcpymset_cpy(d, n, options_name, s, stage)
}

function clause __DecodeA64_LoadStore ((pc, ([_, _, bitzero, bitone, bitone, bitone, bitzero, bitone, _, _, bitzero, _, _, _, _, _, bitone, bitzero, bitzero, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 167) = {
    SEE = 167;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op2 = Slice(__opcode, 12, 4);
    let Rs = Slice(__opcode, 16, 5);
    let op1 = Slice(__opcode, 22, 2);
    let sz = Slice(__opcode, 30, 2);
    decode_cpypwtrn_aarch64_instrs_memory_mcpymset_cpy(Rd, Rn, op2, Rs, op1, sz)
}

val decode_cpypwtwn_aarch64_instrs_memory_mcpymset_cpy : (bits(5), bits(5), bits(4), bits(5), bits(2), bits(2)) -> unit

function decode_cpypwtwn_aarch64_instrs_memory_mcpymset_cpy (Rd, Rn, op2, Rs, op1, sz) = {
    if not_bool(HaveFeatMOPS()) then {
        throw(Error_Undefined())
    };
    if sz != 0b00 then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 's = UInt(Rs);
    let 'n = UInt(Rn);
    let options_name : bits(4) = op2;
    stage : MOPSStage = undefined;
    match op1 {
      0b00 => {
          stage = MOPSStage_Prologue
      },
      0b01 => {
          stage = MOPSStage_Main
      },
      0b10 => {
          stage = MOPSStage_Epilogue
      },
      _ => {
          throw(Error_See("Memory Copy and Memory Set"))
      }
    };
    let stage = stage;
    CheckMOPSEnabled();
    if ((((s == n | s == d) | n == d) | d == 31) | s == 31) | n == 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_MOPSOVERLAP31);
        assert(c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    execute_aarch64_instrs_memory_mcpymset_cpy(d, n, options_name, s, stage)
}

function clause __DecodeA64_LoadStore ((pc, ([_, _, bitzero, bitone, bitone, bitone, bitzero, bitone, _, _, bitzero, _, _, _, _, _, bitzero, bitone, bitzero, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 168) = {
    SEE = 168;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op2 = Slice(__opcode, 12, 4);
    let Rs = Slice(__opcode, 16, 5);
    let op1 = Slice(__opcode, 22, 2);
    let sz = Slice(__opcode, 30, 2);
    decode_cpypwtwn_aarch64_instrs_memory_mcpymset_cpy(Rd, Rn, op2, Rs, op1, sz)
}

val execute_aarch64_instrs_memory_mcpymset_cpyf : forall 'd 'n 's,
  (0 <= 's & 's <= 31 & 0 <= 'n & 'n <= 31 & 0 <= 'd & 'd <= 31).
  (int('d), int('n), bits(4), int('s), MOPSStage) -> unit

function execute_aarch64_instrs_memory_mcpymset_cpyf (d, n, options_name, s, stage) = {
    let 'N = MaxBlockSizeCopiedBytes();
    toaddress : bits(64) = X_read(d, 64);
    fromaddress : bits(64) = X_read(s, 64);
    cpysize : bits(64) = X_read(n, 64);
    nzcv : bits(4) = PSTATE.N @ (PSTATE.Z @ (PSTATE.C @ PSTATE.V));
    stagecpysize : bits(64) = undefined;
    readdata : bits(8 * 'N) = undefined;
    B : int = undefined;
    let supports_option_a : bool = CPYFOptionA();
    let rprivileged : bool = if [options_name[1]] == 0b1 then
      AArch64_IsUnprivAccessPriv()
    else
      PSTATE.EL != EL0;
    let wprivileged : bool = if [options_name[0]] == 0b1 then
      AArch64_IsUnprivAccessPriv()
    else
      PSTATE.EL != EL0;
    let rnontemporal : bool = [options_name[3]] == 0b1;
    let wnontemporal : bool = [options_name[2]] == 0b1;
    let raccdesc : AccessDescriptor = CreateAccDescMOPS(MemOp_LOAD, rprivileged, rnontemporal);
    let waccdesc : AccessDescriptor = CreateAccDescMOPS(MemOp_STORE, wprivileged, wnontemporal);
    if stage == MOPSStage_Prologue then {
        if [cpysize[63]] == 0b1 then {
            cpysize = 0x7FFFFFFFFFFFFFFF
        };
        if supports_option_a then {
            nzcv = 0b0000;
            toaddress = toaddress + cpysize;
            fromaddress = fromaddress + cpysize;
            cpysize = Zeros(64) - cpysize
        } else {
            nzcv = 0b0010
        };
        stagecpysize = CPYPreSizeChoice(toaddress, fromaddress, cpysize);
        assert([stagecpysize[63]] == [cpysize[63]] | stagecpysize == Zeros(64));
        if SInt(cpysize) > 0 then {
            assert(SInt(stagecpysize) <= SInt(cpysize))
        } else {
            assert(SInt(stagecpysize) >= SInt(cpysize))
        }
    } else {
        let zero_size_exceptions : bool = MemCpyZeroSizeCheck();
        if zero_size_exceptions | SInt(cpysize) != 0 then {
            if supports_option_a then {
                if [nzcv[1]] == 0b1 then {
                    let wrong_option : bool = true;
                    let from_epilogue : bool = stage == MOPSStage_Epilogue;
                    MismatchedMemCpyException(supports_option_a, d, s, n, wrong_option, from_epilogue, options_name)
                };
                ()
            } else {
                if [nzcv[1]] == 0b0 then {
                    let wrong_option : bool = true;
                    let from_epilogue : bool = stage == MOPSStage_Epilogue;
                    MismatchedMemCpyException(supports_option_a, d, s, n, wrong_option, from_epilogue, options_name)
                };
                ()
            }
        };
        let postsize : bits(64) = CPYPostSizeChoice(toaddress, fromaddress, cpysize);
        assert([postsize[63]] == [cpysize[63]] | SInt(postsize) == 0);
        if stage == MOPSStage_Main then {
            stagecpysize = cpysize - postsize;
            if MemCpyParametersIllformedM(toaddress, fromaddress, cpysize) then {
                let wrong_option : bool = false;
                let from_epilogue : bool = false;
                MismatchedMemCpyException(supports_option_a, d, s, n, wrong_option, from_epilogue, options_name)
            };
            ()
        } else {
            stagecpysize = postsize;
            if cpysize != postsize | MemCpyParametersIllformedE(toaddress, fromaddress, cpysize) then {
                let wrong_option : bool = false;
                let from_epilogue : bool = true;
                MismatchedMemCpyException(supports_option_a, d, s, n, wrong_option, from_epilogue, options_name)
            };
            ()
        }
    };
    if SPESampleInFlight then {
        SPESampleMemCopy()
    };
    if supports_option_a then {
        while SInt(stagecpysize) != 0 do {
            B = CPYSizeChoice(toaddress, fromaddress, cpysize);
            assert(B <= negate(1) * SInt(stagecpysize));
            let 'B = B in
              {
                  assert(constraint((0 <= 'B * 8 - 1 & 'B * 8 - 1 < 8 * 'N)));
                  readdata[B * 8 - 1 .. 0] = Mem_read(fromaddress + cpysize, B, raccdesc)
              };
            let 'B = B in
              {
                  assert(constraint((0 <= 'B * 8 - 1 & 'B * 8 - 1 < 8 * 'N)));
                  Mem_set(toaddress + cpysize, B, waccdesc) = readdata[B * 8 - 1 .. 0]
              };
            cpysize = cpysize + B;
            stagecpysize = stagecpysize + B;
            if stage != MOPSStage_Prologue then {
                X_set(n, 64) = cpysize
            };
            ()
        }
    } else {
        while UInt(stagecpysize) > 0 do {
            B = CPYSizeChoice(toaddress, fromaddress, cpysize);
            assert(B <= UInt(stagecpysize));
            let 'B = B in
              {
                  assert(constraint((0 <= 'B * 8 - 1 & 'B * 8 - 1 < 8 * 'N)));
                  readdata[B * 8 - 1 .. 0] = Mem_read(fromaddress, B, raccdesc)
              };
            let 'B = B in
              {
                  assert(constraint((0 <= 'B * 8 - 1 & 'B * 8 - 1 < 8 * 'N)));
                  Mem_set(toaddress, B, waccdesc) = readdata[B * 8 - 1 .. 0]
              };
            fromaddress = fromaddress + B;
            toaddress = toaddress + B;
            cpysize = cpysize - B;
            stagecpysize = stagecpysize - B;
            if stage != MOPSStage_Prologue then {
                X_set(n, 64) = cpysize;
                X_set(d, 64) = toaddress;
                X_set(s, 64) = fromaddress
            };
            ()
        }
    };
    if stage == MOPSStage_Prologue then {
        X_set(n, 64) = cpysize;
        X_set(d, 64) = toaddress;
        X_set(s, 64) = fromaddress;
        (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V) = nzcv
    };
    ()
}

val decode_cpyfp_aarch64_instrs_memory_mcpymset_cpyf : (bits(5), bits(5), bits(4), bits(5), bits(2), bits(2)) -> unit

function decode_cpyfp_aarch64_instrs_memory_mcpymset_cpyf (Rd, Rn, op2, Rs, op1, sz) = {
    if not_bool(HaveFeatMOPS()) then {
        throw(Error_Undefined())
    };
    if sz != 0b00 then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 's = UInt(Rs);
    let 'n = UInt(Rn);
    let options_name : bits(4) = op2;
    stage : MOPSStage = undefined;
    match op1 {
      0b00 => {
          stage = MOPSStage_Prologue
      },
      0b01 => {
          stage = MOPSStage_Main
      },
      0b10 => {
          stage = MOPSStage_Epilogue
      },
      _ => {
          throw(Error_See("Memory Copy and Memory Set"))
      }
    };
    let stage = stage;
    CheckMOPSEnabled();
    if ((((s == n | s == d) | n == d) | d == 31) | s == 31) | n == 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_MOPSOVERLAP31);
        assert(c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    execute_aarch64_instrs_memory_mcpymset_cpyf(d, n, options_name, s, stage)
}

function clause __DecodeA64_LoadStore ((pc, ([_, _, bitzero, bitone, bitone, bitzero, bitzero, bitone, _, _, bitzero, _, _, _, _, _, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 169) = {
    SEE = 169;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op2 = Slice(__opcode, 12, 4);
    let Rs = Slice(__opcode, 16, 5);
    let op1 = Slice(__opcode, 22, 2);
    let sz = Slice(__opcode, 30, 2);
    decode_cpyfp_aarch64_instrs_memory_mcpymset_cpyf(Rd, Rn, op2, Rs, op1, sz)
}

val decode_cpyfpn_aarch64_instrs_memory_mcpymset_cpyf : (bits(5), bits(5), bits(4), bits(5), bits(2), bits(2)) -> unit

function decode_cpyfpn_aarch64_instrs_memory_mcpymset_cpyf (Rd, Rn, op2, Rs, op1, sz) = {
    if not_bool(HaveFeatMOPS()) then {
        throw(Error_Undefined())
    };
    if sz != 0b00 then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 's = UInt(Rs);
    let 'n = UInt(Rn);
    let options_name : bits(4) = op2;
    stage : MOPSStage = undefined;
    match op1 {
      0b00 => {
          stage = MOPSStage_Prologue
      },
      0b01 => {
          stage = MOPSStage_Main
      },
      0b10 => {
          stage = MOPSStage_Epilogue
      },
      _ => {
          throw(Error_See("Memory Copy and Memory Set"))
      }
    };
    let stage = stage;
    CheckMOPSEnabled();
    if ((((s == n | s == d) | n == d) | d == 31) | s == 31) | n == 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_MOPSOVERLAP31);
        assert(c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    execute_aarch64_instrs_memory_mcpymset_cpyf(d, n, options_name, s, stage)
}

function clause __DecodeA64_LoadStore ((pc, ([_, _, bitzero, bitone, bitone, bitzero, bitzero, bitone, _, _, bitzero, _, _, _, _, _, bitone, bitone, bitzero, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 170) = {
    SEE = 170;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op2 = Slice(__opcode, 12, 4);
    let Rs = Slice(__opcode, 16, 5);
    let op1 = Slice(__opcode, 22, 2);
    let sz = Slice(__opcode, 30, 2);
    decode_cpyfpn_aarch64_instrs_memory_mcpymset_cpyf(Rd, Rn, op2, Rs, op1, sz)
}

val decode_cpyfprn_aarch64_instrs_memory_mcpymset_cpyf : (bits(5), bits(5), bits(4), bits(5), bits(2), bits(2)) -> unit

function decode_cpyfprn_aarch64_instrs_memory_mcpymset_cpyf (Rd, Rn, op2, Rs, op1, sz) = {
    if not_bool(HaveFeatMOPS()) then {
        throw(Error_Undefined())
    };
    if sz != 0b00 then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 's = UInt(Rs);
    let 'n = UInt(Rn);
    let options_name : bits(4) = op2;
    stage : MOPSStage = undefined;
    match op1 {
      0b00 => {
          stage = MOPSStage_Prologue
      },
      0b01 => {
          stage = MOPSStage_Main
      },
      0b10 => {
          stage = MOPSStage_Epilogue
      },
      _ => {
          throw(Error_See("Memory Copy and Memory Set"))
      }
    };
    let stage = stage;
    CheckMOPSEnabled();
    if ((((s == n | s == d) | n == d) | d == 31) | s == 31) | n == 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_MOPSOVERLAP31);
        assert(c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    execute_aarch64_instrs_memory_mcpymset_cpyf(d, n, options_name, s, stage)
}

function clause __DecodeA64_LoadStore ((pc, ([_, _, bitzero, bitone, bitone, bitzero, bitzero, bitone, _, _, bitzero, _, _, _, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 171) = {
    SEE = 171;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op2 = Slice(__opcode, 12, 4);
    let Rs = Slice(__opcode, 16, 5);
    let op1 = Slice(__opcode, 22, 2);
    let sz = Slice(__opcode, 30, 2);
    decode_cpyfprn_aarch64_instrs_memory_mcpymset_cpyf(Rd, Rn, op2, Rs, op1, sz)
}

val decode_cpyfprt_aarch64_instrs_memory_mcpymset_cpyf : (bits(5), bits(5), bits(4), bits(5), bits(2), bits(2)) -> unit

function decode_cpyfprt_aarch64_instrs_memory_mcpymset_cpyf (Rd, Rn, op2, Rs, op1, sz) = {
    if not_bool(HaveFeatMOPS()) then {
        throw(Error_Undefined())
    };
    if sz != 0b00 then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 's = UInt(Rs);
    let 'n = UInt(Rn);
    let options_name : bits(4) = op2;
    stage : MOPSStage = undefined;
    match op1 {
      0b00 => {
          stage = MOPSStage_Prologue
      },
      0b01 => {
          stage = MOPSStage_Main
      },
      0b10 => {
          stage = MOPSStage_Epilogue
      },
      _ => {
          throw(Error_See("Memory Copy and Memory Set"))
      }
    };
    let stage = stage;
    CheckMOPSEnabled();
    if ((((s == n | s == d) | n == d) | d == 31) | s == 31) | n == 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_MOPSOVERLAP31);
        assert(c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    execute_aarch64_instrs_memory_mcpymset_cpyf(d, n, options_name, s, stage)
}

function clause __DecodeA64_LoadStore ((pc, ([_, _, bitzero, bitone, bitone, bitzero, bitzero, bitone, _, _, bitzero, _, _, _, _, _, bitzero, bitzero, bitone, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 172) = {
    SEE = 172;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op2 = Slice(__opcode, 12, 4);
    let Rs = Slice(__opcode, 16, 5);
    let op1 = Slice(__opcode, 22, 2);
    let sz = Slice(__opcode, 30, 2);
    decode_cpyfprt_aarch64_instrs_memory_mcpymset_cpyf(Rd, Rn, op2, Rs, op1, sz)
}

val decode_cpyfprtn_aarch64_instrs_memory_mcpymset_cpyf : (bits(5), bits(5), bits(4), bits(5), bits(2), bits(2)) -> unit

function decode_cpyfprtn_aarch64_instrs_memory_mcpymset_cpyf (Rd, Rn, op2, Rs, op1, sz) = {
    if not_bool(HaveFeatMOPS()) then {
        throw(Error_Undefined())
    };
    if sz != 0b00 then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 's = UInt(Rs);
    let 'n = UInt(Rn);
    let options_name : bits(4) = op2;
    stage : MOPSStage = undefined;
    match op1 {
      0b00 => {
          stage = MOPSStage_Prologue
      },
      0b01 => {
          stage = MOPSStage_Main
      },
      0b10 => {
          stage = MOPSStage_Epilogue
      },
      _ => {
          throw(Error_See("Memory Copy and Memory Set"))
      }
    };
    let stage = stage;
    CheckMOPSEnabled();
    if ((((s == n | s == d) | n == d) | d == 31) | s == 31) | n == 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_MOPSOVERLAP31);
        assert(c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    execute_aarch64_instrs_memory_mcpymset_cpyf(d, n, options_name, s, stage)
}

function clause __DecodeA64_LoadStore ((pc, ([_, _, bitzero, bitone, bitone, bitzero, bitzero, bitone, _, _, bitzero, _, _, _, _, _, bitone, bitone, bitone, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 173) = {
    SEE = 173;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op2 = Slice(__opcode, 12, 4);
    let Rs = Slice(__opcode, 16, 5);
    let op1 = Slice(__opcode, 22, 2);
    let sz = Slice(__opcode, 30, 2);
    decode_cpyfprtn_aarch64_instrs_memory_mcpymset_cpyf(Rd, Rn, op2, Rs, op1, sz)
}

val decode_cpyfprtrn_aarch64_instrs_memory_mcpymset_cpyf : (bits(5), bits(5), bits(4), bits(5), bits(2), bits(2)) -> unit

function decode_cpyfprtrn_aarch64_instrs_memory_mcpymset_cpyf (Rd, Rn, op2, Rs, op1, sz) = {
    if not_bool(HaveFeatMOPS()) then {
        throw(Error_Undefined())
    };
    if sz != 0b00 then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 's = UInt(Rs);
    let 'n = UInt(Rn);
    let options_name : bits(4) = op2;
    stage : MOPSStage = undefined;
    match op1 {
      0b00 => {
          stage = MOPSStage_Prologue
      },
      0b01 => {
          stage = MOPSStage_Main
      },
      0b10 => {
          stage = MOPSStage_Epilogue
      },
      _ => {
          throw(Error_See("Memory Copy and Memory Set"))
      }
    };
    let stage = stage;
    CheckMOPSEnabled();
    if ((((s == n | s == d) | n == d) | d == 31) | s == 31) | n == 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_MOPSOVERLAP31);
        assert(c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    execute_aarch64_instrs_memory_mcpymset_cpyf(d, n, options_name, s, stage)
}

function clause __DecodeA64_LoadStore ((pc, ([_, _, bitzero, bitone, bitone, bitzero, bitzero, bitone, _, _, bitzero, _, _, _, _, _, bitone, bitzero, bitone, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 174) = {
    SEE = 174;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op2 = Slice(__opcode, 12, 4);
    let Rs = Slice(__opcode, 16, 5);
    let op1 = Slice(__opcode, 22, 2);
    let sz = Slice(__opcode, 30, 2);
    decode_cpyfprtrn_aarch64_instrs_memory_mcpymset_cpyf(Rd, Rn, op2, Rs, op1, sz)
}

val decode_cpyfprtwn_aarch64_instrs_memory_mcpymset_cpyf : (bits(5), bits(5), bits(4), bits(5), bits(2), bits(2)) -> unit

function decode_cpyfprtwn_aarch64_instrs_memory_mcpymset_cpyf (Rd, Rn, op2, Rs, op1, sz) = {
    if not_bool(HaveFeatMOPS()) then {
        throw(Error_Undefined())
    };
    if sz != 0b00 then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 's = UInt(Rs);
    let 'n = UInt(Rn);
    let options_name : bits(4) = op2;
    stage : MOPSStage = undefined;
    match op1 {
      0b00 => {
          stage = MOPSStage_Prologue
      },
      0b01 => {
          stage = MOPSStage_Main
      },
      0b10 => {
          stage = MOPSStage_Epilogue
      },
      _ => {
          throw(Error_See("Memory Copy and Memory Set"))
      }
    };
    let stage = stage;
    CheckMOPSEnabled();
    if ((((s == n | s == d) | n == d) | d == 31) | s == 31) | n == 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_MOPSOVERLAP31);
        assert(c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    execute_aarch64_instrs_memory_mcpymset_cpyf(d, n, options_name, s, stage)
}

function clause __DecodeA64_LoadStore ((pc, ([_, _, bitzero, bitone, bitone, bitzero, bitzero, bitone, _, _, bitzero, _, _, _, _, _, bitzero, bitone, bitone, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 175) = {
    SEE = 175;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op2 = Slice(__opcode, 12, 4);
    let Rs = Slice(__opcode, 16, 5);
    let op1 = Slice(__opcode, 22, 2);
    let sz = Slice(__opcode, 30, 2);
    decode_cpyfprtwn_aarch64_instrs_memory_mcpymset_cpyf(Rd, Rn, op2, Rs, op1, sz)
}

val decode_cpyfpt_aarch64_instrs_memory_mcpymset_cpyf : (bits(5), bits(5), bits(4), bits(5), bits(2), bits(2)) -> unit

function decode_cpyfpt_aarch64_instrs_memory_mcpymset_cpyf (Rd, Rn, op2, Rs, op1, sz) = {
    if not_bool(HaveFeatMOPS()) then {
        throw(Error_Undefined())
    };
    if sz != 0b00 then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 's = UInt(Rs);
    let 'n = UInt(Rn);
    let options_name : bits(4) = op2;
    stage : MOPSStage = undefined;
    match op1 {
      0b00 => {
          stage = MOPSStage_Prologue
      },
      0b01 => {
          stage = MOPSStage_Main
      },
      0b10 => {
          stage = MOPSStage_Epilogue
      },
      _ => {
          throw(Error_See("Memory Copy and Memory Set"))
      }
    };
    let stage = stage;
    CheckMOPSEnabled();
    if ((((s == n | s == d) | n == d) | d == 31) | s == 31) | n == 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_MOPSOVERLAP31);
        assert(c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    execute_aarch64_instrs_memory_mcpymset_cpyf(d, n, options_name, s, stage)
}

function clause __DecodeA64_LoadStore ((pc, ([_, _, bitzero, bitone, bitone, bitzero, bitzero, bitone, _, _, bitzero, _, _, _, _, _, bitzero, bitzero, bitone, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 176) = {
    SEE = 176;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op2 = Slice(__opcode, 12, 4);
    let Rs = Slice(__opcode, 16, 5);
    let op1 = Slice(__opcode, 22, 2);
    let sz = Slice(__opcode, 30, 2);
    decode_cpyfpt_aarch64_instrs_memory_mcpymset_cpyf(Rd, Rn, op2, Rs, op1, sz)
}

val decode_cpyfptn_aarch64_instrs_memory_mcpymset_cpyf : (bits(5), bits(5), bits(4), bits(5), bits(2), bits(2)) -> unit

function decode_cpyfptn_aarch64_instrs_memory_mcpymset_cpyf (Rd, Rn, op2, Rs, op1, sz) = {
    if not_bool(HaveFeatMOPS()) then {
        throw(Error_Undefined())
    };
    if sz != 0b00 then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 's = UInt(Rs);
    let 'n = UInt(Rn);
    let options_name : bits(4) = op2;
    stage : MOPSStage = undefined;
    match op1 {
      0b00 => {
          stage = MOPSStage_Prologue
      },
      0b01 => {
          stage = MOPSStage_Main
      },
      0b10 => {
          stage = MOPSStage_Epilogue
      },
      _ => {
          throw(Error_See("Memory Copy and Memory Set"))
      }
    };
    let stage = stage;
    CheckMOPSEnabled();
    if ((((s == n | s == d) | n == d) | d == 31) | s == 31) | n == 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_MOPSOVERLAP31);
        assert(c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    execute_aarch64_instrs_memory_mcpymset_cpyf(d, n, options_name, s, stage)
}

function clause __DecodeA64_LoadStore ((pc, ([_, _, bitzero, bitone, bitone, bitzero, bitzero, bitone, _, _, bitzero, _, _, _, _, _, bitone, bitone, bitone, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 177) = {
    SEE = 177;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op2 = Slice(__opcode, 12, 4);
    let Rs = Slice(__opcode, 16, 5);
    let op1 = Slice(__opcode, 22, 2);
    let sz = Slice(__opcode, 30, 2);
    decode_cpyfptn_aarch64_instrs_memory_mcpymset_cpyf(Rd, Rn, op2, Rs, op1, sz)
}

val decode_cpyfptrn_aarch64_instrs_memory_mcpymset_cpyf : (bits(5), bits(5), bits(4), bits(5), bits(2), bits(2)) -> unit

function decode_cpyfptrn_aarch64_instrs_memory_mcpymset_cpyf (Rd, Rn, op2, Rs, op1, sz) = {
    if not_bool(HaveFeatMOPS()) then {
        throw(Error_Undefined())
    };
    if sz != 0b00 then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 's = UInt(Rs);
    let 'n = UInt(Rn);
    let options_name : bits(4) = op2;
    stage : MOPSStage = undefined;
    match op1 {
      0b00 => {
          stage = MOPSStage_Prologue
      },
      0b01 => {
          stage = MOPSStage_Main
      },
      0b10 => {
          stage = MOPSStage_Epilogue
      },
      _ => {
          throw(Error_See("Memory Copy and Memory Set"))
      }
    };
    let stage = stage;
    CheckMOPSEnabled();
    if ((((s == n | s == d) | n == d) | d == 31) | s == 31) | n == 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_MOPSOVERLAP31);
        assert(c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    execute_aarch64_instrs_memory_mcpymset_cpyf(d, n, options_name, s, stage)
}

function clause __DecodeA64_LoadStore ((pc, ([_, _, bitzero, bitone, bitone, bitzero, bitzero, bitone, _, _, bitzero, _, _, _, _, _, bitone, bitzero, bitone, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 178) = {
    SEE = 178;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op2 = Slice(__opcode, 12, 4);
    let Rs = Slice(__opcode, 16, 5);
    let op1 = Slice(__opcode, 22, 2);
    let sz = Slice(__opcode, 30, 2);
    decode_cpyfptrn_aarch64_instrs_memory_mcpymset_cpyf(Rd, Rn, op2, Rs, op1, sz)
}

val decode_cpyfptwn_aarch64_instrs_memory_mcpymset_cpyf : (bits(5), bits(5), bits(4), bits(5), bits(2), bits(2)) -> unit

function decode_cpyfptwn_aarch64_instrs_memory_mcpymset_cpyf (Rd, Rn, op2, Rs, op1, sz) = {
    if not_bool(HaveFeatMOPS()) then {
        throw(Error_Undefined())
    };
    if sz != 0b00 then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 's = UInt(Rs);
    let 'n = UInt(Rn);
    let options_name : bits(4) = op2;
    stage : MOPSStage = undefined;
    match op1 {
      0b00 => {
          stage = MOPSStage_Prologue
      },
      0b01 => {
          stage = MOPSStage_Main
      },
      0b10 => {
          stage = MOPSStage_Epilogue
      },
      _ => {
          throw(Error_See("Memory Copy and Memory Set"))
      }
    };
    let stage = stage;
    CheckMOPSEnabled();
    if ((((s == n | s == d) | n == d) | d == 31) | s == 31) | n == 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_MOPSOVERLAP31);
        assert(c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    execute_aarch64_instrs_memory_mcpymset_cpyf(d, n, options_name, s, stage)
}

function clause __DecodeA64_LoadStore ((pc, ([_, _, bitzero, bitone, bitone, bitzero, bitzero, bitone, _, _, bitzero, _, _, _, _, _, bitzero, bitone, bitone, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 179) = {
    SEE = 179;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op2 = Slice(__opcode, 12, 4);
    let Rs = Slice(__opcode, 16, 5);
    let op1 = Slice(__opcode, 22, 2);
    let sz = Slice(__opcode, 30, 2);
    decode_cpyfptwn_aarch64_instrs_memory_mcpymset_cpyf(Rd, Rn, op2, Rs, op1, sz)
}

val decode_cpyfpwn_aarch64_instrs_memory_mcpymset_cpyf : (bits(5), bits(5), bits(4), bits(5), bits(2), bits(2)) -> unit

function decode_cpyfpwn_aarch64_instrs_memory_mcpymset_cpyf (Rd, Rn, op2, Rs, op1, sz) = {
    if not_bool(HaveFeatMOPS()) then {
        throw(Error_Undefined())
    };
    if sz != 0b00 then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 's = UInt(Rs);
    let 'n = UInt(Rn);
    let options_name : bits(4) = op2;
    stage : MOPSStage = undefined;
    match op1 {
      0b00 => {
          stage = MOPSStage_Prologue
      },
      0b01 => {
          stage = MOPSStage_Main
      },
      0b10 => {
          stage = MOPSStage_Epilogue
      },
      _ => {
          throw(Error_See("Memory Copy and Memory Set"))
      }
    };
    let stage = stage;
    CheckMOPSEnabled();
    if ((((s == n | s == d) | n == d) | d == 31) | s == 31) | n == 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_MOPSOVERLAP31);
        assert(c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    execute_aarch64_instrs_memory_mcpymset_cpyf(d, n, options_name, s, stage)
}

function clause __DecodeA64_LoadStore ((pc, ([_, _, bitzero, bitone, bitone, bitzero, bitzero, bitone, _, _, bitzero, _, _, _, _, _, bitzero, bitone, bitzero, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 180) = {
    SEE = 180;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op2 = Slice(__opcode, 12, 4);
    let Rs = Slice(__opcode, 16, 5);
    let op1 = Slice(__opcode, 22, 2);
    let sz = Slice(__opcode, 30, 2);
    decode_cpyfpwn_aarch64_instrs_memory_mcpymset_cpyf(Rd, Rn, op2, Rs, op1, sz)
}

val decode_cpyfpwt_aarch64_instrs_memory_mcpymset_cpyf : (bits(5), bits(5), bits(4), bits(5), bits(2), bits(2)) -> unit

function decode_cpyfpwt_aarch64_instrs_memory_mcpymset_cpyf (Rd, Rn, op2, Rs, op1, sz) = {
    if not_bool(HaveFeatMOPS()) then {
        throw(Error_Undefined())
    };
    if sz != 0b00 then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 's = UInt(Rs);
    let 'n = UInt(Rn);
    let options_name : bits(4) = op2;
    stage : MOPSStage = undefined;
    match op1 {
      0b00 => {
          stage = MOPSStage_Prologue
      },
      0b01 => {
          stage = MOPSStage_Main
      },
      0b10 => {
          stage = MOPSStage_Epilogue
      },
      _ => {
          throw(Error_See("Memory Copy and Memory Set"))
      }
    };
    let stage = stage;
    CheckMOPSEnabled();
    if ((((s == n | s == d) | n == d) | d == 31) | s == 31) | n == 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_MOPSOVERLAP31);
        assert(c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    execute_aarch64_instrs_memory_mcpymset_cpyf(d, n, options_name, s, stage)
}

function clause __DecodeA64_LoadStore ((pc, ([_, _, bitzero, bitone, bitone, bitzero, bitzero, bitone, _, _, bitzero, _, _, _, _, _, bitzero, bitzero, bitzero, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 181) = {
    SEE = 181;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op2 = Slice(__opcode, 12, 4);
    let Rs = Slice(__opcode, 16, 5);
    let op1 = Slice(__opcode, 22, 2);
    let sz = Slice(__opcode, 30, 2);
    decode_cpyfpwt_aarch64_instrs_memory_mcpymset_cpyf(Rd, Rn, op2, Rs, op1, sz)
}

val decode_cpyfpwtn_aarch64_instrs_memory_mcpymset_cpyf : (bits(5), bits(5), bits(4), bits(5), bits(2), bits(2)) -> unit

function decode_cpyfpwtn_aarch64_instrs_memory_mcpymset_cpyf (Rd, Rn, op2, Rs, op1, sz) = {
    if not_bool(HaveFeatMOPS()) then {
        throw(Error_Undefined())
    };
    if sz != 0b00 then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 's = UInt(Rs);
    let 'n = UInt(Rn);
    let options_name : bits(4) = op2;
    stage : MOPSStage = undefined;
    match op1 {
      0b00 => {
          stage = MOPSStage_Prologue
      },
      0b01 => {
          stage = MOPSStage_Main
      },
      0b10 => {
          stage = MOPSStage_Epilogue
      },
      _ => {
          throw(Error_See("Memory Copy and Memory Set"))
      }
    };
    let stage = stage;
    CheckMOPSEnabled();
    if ((((s == n | s == d) | n == d) | d == 31) | s == 31) | n == 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_MOPSOVERLAP31);
        assert(c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    execute_aarch64_instrs_memory_mcpymset_cpyf(d, n, options_name, s, stage)
}

function clause __DecodeA64_LoadStore ((pc, ([_, _, bitzero, bitone, bitone, bitzero, bitzero, bitone, _, _, bitzero, _, _, _, _, _, bitone, bitone, bitzero, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 182) = {
    SEE = 182;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op2 = Slice(__opcode, 12, 4);
    let Rs = Slice(__opcode, 16, 5);
    let op1 = Slice(__opcode, 22, 2);
    let sz = Slice(__opcode, 30, 2);
    decode_cpyfpwtn_aarch64_instrs_memory_mcpymset_cpyf(Rd, Rn, op2, Rs, op1, sz)
}

val decode_cpyfpwtrn_aarch64_instrs_memory_mcpymset_cpyf : (bits(5), bits(5), bits(4), bits(5), bits(2), bits(2)) -> unit

function decode_cpyfpwtrn_aarch64_instrs_memory_mcpymset_cpyf (Rd, Rn, op2, Rs, op1, sz) = {
    if not_bool(HaveFeatMOPS()) then {
        throw(Error_Undefined())
    };
    if sz != 0b00 then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 's = UInt(Rs);
    let 'n = UInt(Rn);
    let options_name : bits(4) = op2;
    stage : MOPSStage = undefined;
    match op1 {
      0b00 => {
          stage = MOPSStage_Prologue
      },
      0b01 => {
          stage = MOPSStage_Main
      },
      0b10 => {
          stage = MOPSStage_Epilogue
      },
      _ => {
          throw(Error_See("Memory Copy and Memory Set"))
      }
    };
    let stage = stage;
    CheckMOPSEnabled();
    if ((((s == n | s == d) | n == d) | d == 31) | s == 31) | n == 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_MOPSOVERLAP31);
        assert(c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    execute_aarch64_instrs_memory_mcpymset_cpyf(d, n, options_name, s, stage)
}

function clause __DecodeA64_LoadStore ((pc, ([_, _, bitzero, bitone, bitone, bitzero, bitzero, bitone, _, _, bitzero, _, _, _, _, _, bitone, bitzero, bitzero, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 183) = {
    SEE = 183;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op2 = Slice(__opcode, 12, 4);
    let Rs = Slice(__opcode, 16, 5);
    let op1 = Slice(__opcode, 22, 2);
    let sz = Slice(__opcode, 30, 2);
    decode_cpyfpwtrn_aarch64_instrs_memory_mcpymset_cpyf(Rd, Rn, op2, Rs, op1, sz)
}

val decode_cpyfpwtwn_aarch64_instrs_memory_mcpymset_cpyf : (bits(5), bits(5), bits(4), bits(5), bits(2), bits(2)) -> unit

function decode_cpyfpwtwn_aarch64_instrs_memory_mcpymset_cpyf (Rd, Rn, op2, Rs, op1, sz) = {
    if not_bool(HaveFeatMOPS()) then {
        throw(Error_Undefined())
    };
    if sz != 0b00 then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 's = UInt(Rs);
    let 'n = UInt(Rn);
    let options_name : bits(4) = op2;
    stage : MOPSStage = undefined;
    match op1 {
      0b00 => {
          stage = MOPSStage_Prologue
      },
      0b01 => {
          stage = MOPSStage_Main
      },
      0b10 => {
          stage = MOPSStage_Epilogue
      },
      _ => {
          throw(Error_See("Memory Copy and Memory Set"))
      }
    };
    let stage = stage;
    CheckMOPSEnabled();
    if ((((s == n | s == d) | n == d) | d == 31) | s == 31) | n == 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_MOPSOVERLAP31);
        assert(c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    execute_aarch64_instrs_memory_mcpymset_cpyf(d, n, options_name, s, stage)
}

function clause __DecodeA64_LoadStore ((pc, ([_, _, bitzero, bitone, bitone, bitzero, bitzero, bitone, _, _, bitzero, _, _, _, _, _, bitzero, bitone, bitzero, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 184) = {
    SEE = 184;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op2 = Slice(__opcode, 12, 4);
    let Rs = Slice(__opcode, 16, 5);
    let op1 = Slice(__opcode, 22, 2);
    let sz = Slice(__opcode, 30, 2);
    decode_cpyfpwtwn_aarch64_instrs_memory_mcpymset_cpyf(Rd, Rn, op2, Rs, op1, sz)
}

val execute_aarch64_instrs_integer_crc : forall ('crc32c : Bool) 'd 'm 'n 'size,
  ('size in {8, 16, 32, 64} & 0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 0 <= 'd & 'd <= 31).
  (bool('crc32c), int('d), int('m), int('n), int('size)) -> unit

function execute_aarch64_instrs_integer_crc (crc32c, d, m, n, size) = {
    let acc : bits(32) = X_read(n, 32);
    let val_name : bits('size) = X_read(m, size);
    let poly : bits(32) = (if crc32c then UInt(0x1EDC6F41) else UInt(0x04C11DB7))[31 .. 0];
    let tempacc : bits(32 + 'size) = BitReverse(acc) @ Zeros(size);
    let tempval : bits('size + 32) = BitReverse(val_name) @ Zeros(32);
    X_set(d, 32) = BitReverse(Poly32Mod2(EOR(tempacc, tempval), poly))
}

val decode_crc32_aarch64_instrs_integer_crc : (bits(5), bits(5), bits(2), bits(1), bits(5), bits(1)) -> unit

function decode_crc32_aarch64_instrs_integer_crc (Rd, Rn, sz, C, Rm, sf) = {
    if not_bool(HaveCRCExt()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if sf == 0b1 & sz != 0b11 then {
        throw(Error_Undefined())
    };
    if sf == 0b0 & sz == 0b11 then {
        throw(Error_Undefined())
    };
    let 'size = (8 << UInt(sz));
    let crc32c : bool = C == 0b1;
    execute_aarch64_instrs_integer_crc(crc32c, d, m, n, size)
}

function clause __DecodeA64_DataProcReg ((pc, ([_, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 185) = {
    SEE = 185;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let sz = Slice(__opcode, 10, 2);
    let C = Slice(__opcode, 12, 1);
    let Rm = Slice(__opcode, 16, 5);
    let sf = Slice(__opcode, 31, 1);
    decode_crc32_aarch64_instrs_integer_crc(Rd, Rn, sz, C, Rm, sf)
}

val decode_crc32c_aarch64_instrs_integer_crc : (bits(5), bits(5), bits(2), bits(1), bits(5), bits(1)) -> unit

function decode_crc32c_aarch64_instrs_integer_crc (Rd, Rn, sz, C, Rm, sf) = {
    if not_bool(HaveCRCExt()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if sf == 0b1 & sz != 0b11 then {
        throw(Error_Undefined())
    };
    if sf == 0b0 & sz == 0b11 then {
        throw(Error_Undefined())
    };
    let 'size = (8 << UInt(sz));
    let crc32c : bool = C == 0b1;
    execute_aarch64_instrs_integer_crc(crc32c, d, m, n, size)
}

function clause __DecodeA64_DataProcReg ((pc, ([_, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, bitzero, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 186) = {
    SEE = 186;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let sz = Slice(__opcode, 10, 2);
    let C = Slice(__opcode, 12, 1);
    let Rm = Slice(__opcode, 16, 5);
    let sf = Slice(__opcode, 31, 1);
    decode_crc32c_aarch64_instrs_integer_crc(Rd, Rn, sz, C, Rm, sf)
}

val execute_aarch64_instrs_integer_conditional_select : forall 'd 'datasize ('else_inc : Bool) ('else_inv : Bool) 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'datasize in {32, 64} & 0 <= 'd & 'd <= 31).
  (bits(4), int('d), int('datasize), bool('else_inc), bool('else_inv), int('m), int('n)) -> unit

function execute_aarch64_instrs_integer_conditional_select (condition, d, datasize, else_inc, else_inv, m, n) = {
    taken : bool = false;
    result : bits('datasize) = undefined;
    if ConditionHolds(condition) then {
        result = X_read(n, datasize);
        taken = true
    } else {
        result = X_read(m, datasize);
        if else_inv then {
            result = not_vec(result)
        };
        if else_inc then {
            result = result + 1
        };
        ()
    };
    X_set(d, datasize) = result;
    if SPESampleInFlight then {
        let conditional : bool = true;
        SPESampleAddOpOther(conditional, taken)
    };
    ()
}

val decode_csel_aarch64_instrs_integer_conditional_select : (bits(5), bits(5), bits(1), bits(4), bits(5), bits(1), bits(1)) -> unit

function decode_csel_aarch64_instrs_integer_conditional_select (Rd, Rn, o2, cond, Rm, op, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'datasize = if sf == 0b1 then 64 else 32;
    let condition : bits(4) = cond;
    let else_inv : bool = op == 0b1;
    let else_inc : bool = o2 == 0b1;
    execute_aarch64_instrs_integer_conditional_select(condition, d, datasize, else_inc, else_inv, m, n)
}

function clause __DecodeA64_DataProcReg ((pc, ([_, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 187) = {
    SEE = 187;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o2 = Slice(__opcode, 10, 1);
    let cond = Slice(__opcode, 12, 4);
    let Rm = Slice(__opcode, 16, 5);
    let op = Slice(__opcode, 30, 1);
    let sf = Slice(__opcode, 31, 1);
    decode_csel_aarch64_instrs_integer_conditional_select(Rd, Rn, o2, cond, Rm, op, sf)
}

val decode_csinc_aarch64_instrs_integer_conditional_select : (bits(5), bits(5), bits(1), bits(4), bits(5), bits(1), bits(1)) -> unit

function decode_csinc_aarch64_instrs_integer_conditional_select (Rd, Rn, o2, cond, Rm, op, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'datasize = if sf == 0b1 then 64 else 32;
    let condition : bits(4) = cond;
    let else_inv : bool = op == 0b1;
    let else_inc : bool = o2 == 0b1;
    execute_aarch64_instrs_integer_conditional_select(condition, d, datasize, else_inc, else_inv, m, n)
}

function clause __DecodeA64_DataProcReg ((pc, ([_, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 188) = {
    SEE = 188;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o2 = Slice(__opcode, 10, 1);
    let cond = Slice(__opcode, 12, 4);
    let Rm = Slice(__opcode, 16, 5);
    let op = Slice(__opcode, 30, 1);
    let sf = Slice(__opcode, 31, 1);
    decode_csinc_aarch64_instrs_integer_conditional_select(Rd, Rn, o2, cond, Rm, op, sf)
}

val decode_csinv_aarch64_instrs_integer_conditional_select : (bits(5), bits(5), bits(1), bits(4), bits(5), bits(1), bits(1)) -> unit

function decode_csinv_aarch64_instrs_integer_conditional_select (Rd, Rn, o2, cond, Rm, op, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'datasize = if sf == 0b1 then 64 else 32;
    let condition : bits(4) = cond;
    let else_inv : bool = op == 0b1;
    let else_inc : bool = o2 == 0b1;
    execute_aarch64_instrs_integer_conditional_select(condition, d, datasize, else_inc, else_inv, m, n)
}

function clause __DecodeA64_DataProcReg ((pc, ([_, bitone, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 189) = {
    SEE = 189;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o2 = Slice(__opcode, 10, 1);
    let cond = Slice(__opcode, 12, 4);
    let Rm = Slice(__opcode, 16, 5);
    let op = Slice(__opcode, 30, 1);
    let sf = Slice(__opcode, 31, 1);
    decode_csinv_aarch64_instrs_integer_conditional_select(Rd, Rn, o2, cond, Rm, op, sf)
}

val decode_csneg_aarch64_instrs_integer_conditional_select : (bits(5), bits(5), bits(1), bits(4), bits(5), bits(1), bits(1)) -> unit

function decode_csneg_aarch64_instrs_integer_conditional_select (Rd, Rn, o2, cond, Rm, op, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'datasize = if sf == 0b1 then 64 else 32;
    let condition : bits(4) = cond;
    let else_inv : bool = op == 0b1;
    let else_inc : bool = o2 == 0b1;
    execute_aarch64_instrs_integer_conditional_select(condition, d, datasize, else_inc, else_inv, m, n)
}

function clause __DecodeA64_DataProcReg ((pc, ([_, bitone, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 190) = {
    SEE = 190;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o2 = Slice(__opcode, 10, 1);
    let cond = Slice(__opcode, 12, 4);
    let Rm = Slice(__opcode, 16, 5);
    let op = Slice(__opcode, 30, 1);
    let sf = Slice(__opcode, 31, 1);
    decode_csneg_aarch64_instrs_integer_conditional_select(Rd, Rn, o2, cond, Rm, op, sf)
}

val execute_aarch64_instrs_integer_arithmetic_unary_ctz : forall 'd 'datasize 'n,
  (0 <= 'n & 'n <= 31 & 'datasize in {32, 64} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('n)) -> unit

function execute_aarch64_instrs_integer_arithmetic_unary_ctz (d, datasize, n) = {
    let operand1 : bits('datasize) = X_read(n, datasize);
    let 'result = CountLeadingZeroBits(BitReverse(operand1));
    X_set(d, datasize) = result[datasize - 1 .. 0]
}

val decode_ctz_aarch64_instrs_integer_arithmetic_unary_ctz : (bits(5), bits(5), bits(1)) -> unit

function decode_ctz_aarch64_instrs_integer_arithmetic_unary_ctz (Rd, Rn, sf) = {
    if not_bool(HaveCSSC()) then {
        throw(Error_Undefined())
    };
    let 'datasize = (32 << UInt(sf));
    let 'n = UInt(Rn);
    let 'd = UInt(Rd);
    execute_aarch64_instrs_integer_arithmetic_unary_ctz(d, datasize, n)
}

function clause __DecodeA64_DataProcReg ((pc, ([_, bitone, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 191) = {
    SEE = 191;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let sf = Slice(__opcode, 31, 1);
    decode_ctz_aarch64_instrs_integer_arithmetic_unary_ctz(Rd, Rn, sf)
}

val execute_aarch64_instrs_system_exceptions_debug_exception : bits(2) -> unit

function execute_aarch64_instrs_system_exceptions_debug_exception target_level = {
    DCPSInstruction(target_level)
}

val decode_dcps1_aarch64_instrs_system_exceptions_debug_exception : (bits(2), bits(16)) -> unit

function decode_dcps1_aarch64_instrs_system_exceptions_debug_exception (LL, imm16) = {
    let target_level : bits(2) = LL;
    if LL == 0b00 then {
        throw(Error_Undefined())
    };
    if not_bool(Halted()) then {
        throw(Error_Undefined())
    };
    execute_aarch64_instrs_system_exceptions_debug_exception(target_level)
}

function clause __DecodeA64_BranchExcSys ((pc, ([bitone, bitone, bitzero, bitone, bitzero, bitone, bitzero, bitzero, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, bitzero, bitzero, bitzero, bitzero, bitone] as __opcode)) if SEE < 192) = {
    SEE = 192;
    let LL = Slice(__opcode, 0, 2);
    let imm16 = Slice(__opcode, 5, 16);
    decode_dcps1_aarch64_instrs_system_exceptions_debug_exception(LL, imm16)
}

val decode_dcps2_aarch64_instrs_system_exceptions_debug_exception : (bits(2), bits(16)) -> unit

function decode_dcps2_aarch64_instrs_system_exceptions_debug_exception (LL, imm16) = {
    let target_level : bits(2) = LL;
    if LL == 0b00 then {
        throw(Error_Undefined())
    };
    if not_bool(Halted()) then {
        throw(Error_Undefined())
    };
    execute_aarch64_instrs_system_exceptions_debug_exception(target_level)
}

function clause __DecodeA64_BranchExcSys ((pc, ([bitone, bitone, bitzero, bitone, bitzero, bitone, bitzero, bitzero, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, bitzero, bitzero, bitzero, bitone, bitzero] as __opcode)) if SEE < 193) = {
    SEE = 193;
    let LL = Slice(__opcode, 0, 2);
    let imm16 = Slice(__opcode, 5, 16);
    decode_dcps2_aarch64_instrs_system_exceptions_debug_exception(LL, imm16)
}

val decode_dcps3_aarch64_instrs_system_exceptions_debug_exception : (bits(2), bits(16)) -> unit

function decode_dcps3_aarch64_instrs_system_exceptions_debug_exception (LL, imm16) = {
    let target_level : bits(2) = LL;
    if LL == 0b00 then {
        throw(Error_Undefined())
    };
    if not_bool(Halted()) then {
        throw(Error_Undefined())
    };
    execute_aarch64_instrs_system_exceptions_debug_exception(target_level)
}

function clause __DecodeA64_BranchExcSys ((pc, ([bitone, bitone, bitzero, bitone, bitzero, bitone, bitzero, bitzero, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, bitzero, bitzero, bitzero, bitone, bitone] as __opcode)) if SEE < 194) = {
    SEE = 194;
    let LL = Slice(__opcode, 0, 2);
    let imm16 = Slice(__opcode, 5, 16);
    decode_dcps3_aarch64_instrs_system_exceptions_debug_exception(LL, imm16)
}

val execute_aarch64_instrs_system_barriers_dmb : (MBReqDomain, MBReqTypes) -> unit

function execute_aarch64_instrs_system_barriers_dmb (domain, types) = {
    DataMemoryBarrier(domain, types)
}

val decode_dmb_aarch64_instrs_system_barriers_dmb : (bits(2), bits(4)) -> unit

function decode_dmb_aarch64_instrs_system_barriers_dmb (opc, CRm) = {
    domain : MBReqDomain = undefined;
    types : MBReqTypes = undefined;
    match CRm[3 .. 2] {
      0b00 => {
          domain = MBReqDomain_OuterShareable
      },
      0b01 => {
          domain = MBReqDomain_Nonshareable
      },
      0b10 => {
          domain = MBReqDomain_InnerShareable
      },
      0b11 => {
          domain = MBReqDomain_FullSystem
      }
    };
    match CRm[1 .. 0] {
      0b00 => {
          types = MBReqTypes_All;
          domain = MBReqDomain_FullSystem
      },
      0b01 => {
          types = MBReqTypes_Reads
      },
      0b10 => {
          types = MBReqTypes_Writes
      },
      0b11 => {
          types = MBReqTypes_All
      }
    };
    let types = types;
    execute_aarch64_instrs_system_barriers_dmb(domain, types)
}

function clause __DecodeA64_BranchExcSys ((pc, ([bitone, bitone, bitzero, bitone, bitzero, bitone, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitone, bitone, _, _, _, _, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, bitone] as __opcode)) if SEE < 195) = {
    SEE = 195;
    let opc = Slice(__opcode, 5, 2);
    let CRm = Slice(__opcode, 8, 4);
    decode_dmb_aarch64_instrs_system_barriers_dmb(opc, CRm)
}

val execute_aarch64_instrs_branch_unconditional_dret : unit -> unit

function execute_aarch64_instrs_branch_unconditional_dret () = {
    DRPSInstruction()
}

val decode_drps_aarch64_instrs_branch_unconditional_dret : unit -> unit

function decode_drps_aarch64_instrs_branch_unconditional_dret () = {
    if not_bool(Halted()) | PSTATE.EL == EL0 then {
        throw(Error_Undefined())
    };
    execute_aarch64_instrs_branch_unconditional_dret()
}

function clause __DecodeA64_BranchExcSys ((pc, (0b11010110101111110000001111100000 as __opcode)) if SEE < 196) = {
    SEE = 196;
    decode_drps_aarch64_instrs_branch_unconditional_dret()
}

val execute_aarch64_instrs_system_barriers_dsb : forall ('nXS : Bool).
  (DSBAlias, MBReqDomain, bool('nXS), MBReqTypes) -> unit

function execute_aarch64_instrs_system_barriers_dsb (alias, domain, nXS__arg, types) = {
    nXS : bool = nXS__arg;
    match alias {
      DSBAlias_SSBB => {
          SpeculativeStoreBypassBarrierToVA()
      },
      DSBAlias_PSSBB => {
          SpeculativeStoreBypassBarrierToPA()
      },
      DSBAlias_DSB => {
          if HaveTME() & TSTATE.depth > 0 then {
              FailTransaction(TMFailure_ERR, false)
          };
          if not_bool(nXS) & HaveFeatXS() then {
              nXS = ((PSTATE.EL == EL0 | PSTATE.EL == EL1) & IsHCRXEL2Enabled()) & HCRX_EL2[FnXS] == 0b1
          };
          DataSynchronizationBarrier(domain, types, nXS)
      },
      _ => {
          Unreachable()
      }
    }
}

val decode_dsb_aarch64_instrs_system_barriers_dsb : (bits(2), bits(4)) -> unit

function decode_dsb_aarch64_instrs_system_barriers_dsb (opc, CRm) = {
    let nXS : bool = false;
    alias : DSBAlias = undefined;
    match CRm {
      0b0000 => {
          alias = DSBAlias_SSBB
      },
      0b0100 => {
          alias = DSBAlias_PSSBB
      },
      _ => {
          alias = DSBAlias_DSB
      }
    };
    let alias = alias;
    domain : MBReqDomain = undefined;
    match CRm[3 .. 2] {
      0b00 => {
          domain = MBReqDomain_OuterShareable
      },
      0b01 => {
          domain = MBReqDomain_Nonshareable
      },
      0b10 => {
          domain = MBReqDomain_InnerShareable
      },
      0b11 => {
          domain = MBReqDomain_FullSystem
      }
    };
    types : MBReqTypes = undefined;
    match CRm[1 .. 0] {
      0b00 => {
          types = MBReqTypes_All;
          domain = MBReqDomain_FullSystem
      },
      0b01 => {
          types = MBReqTypes_Reads
      },
      0b10 => {
          types = MBReqTypes_Writes
      },
      0b11 => {
          types = MBReqTypes_All
      }
    };
    execute_aarch64_instrs_system_barriers_dsb(alias, domain, nXS, types)
}

function clause __DecodeA64_BranchExcSys ((pc, ([bitone, bitone, bitzero, bitone, bitzero, bitone, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitone, bitone, _, _, _, _, bitone, bitzero, bitzero, bitone, bitone, bitone, bitone, bitone] as __opcode)) if SEE < 197) = {
    SEE = 197;
    let opc = Slice(__opcode, 5, 2);
    let CRm = Slice(__opcode, 8, 4);
    decode_dsb_aarch64_instrs_system_barriers_dsb(opc, CRm)
}

val decode_dsb_aarch64_instrs_system_barriers_dsb_nxs : bits(2) -> unit

function decode_dsb_aarch64_instrs_system_barriers_dsb_nxs imm2 = {
    if not_bool(HaveFeatXS()) then {
        throw(Error_Undefined())
    };
    let types : MBReqTypes = MBReqTypes_All;
    let nXS : bool = true;
    let alias : DSBAlias = DSBAlias_DSB;
    domain : MBReqDomain = undefined;
    match imm2 {
      0b00 => {
          domain = MBReqDomain_OuterShareable
      },
      0b01 => {
          domain = MBReqDomain_Nonshareable
      },
      0b10 => {
          domain = MBReqDomain_InnerShareable
      },
      0b11 => {
          domain = MBReqDomain_FullSystem
      }
    };
    let domain = domain;
    execute_aarch64_instrs_system_barriers_dsb(alias, domain, nXS, types)
}

function clause __DecodeA64_BranchExcSys ((pc, ([bitone, bitone, bitzero, bitone, bitzero, bitone, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitone, bitone, _, _, bitone, bitzero, bitzero, bitzero, bitone, bitone, bitone, bitone, bitone, bitone] as __opcode)) if SEE < 198) = {
    SEE = 198;
    let imm2 = Slice(__opcode, 10, 2);
    decode_dsb_aarch64_instrs_system_barriers_dsb_nxs(imm2)
}

val execute_aarch64_instrs_vector_transfer_vector_cpy_dup_sisd : forall 'd 'datasize 'elements 'esize 'idxdsize 'index 'n,
  (0 <= 'n & 'n <= 31 & 'idxdsize in {64, 128} & 'esize in {8, 16, 32, 64, 128, 256} & 'datasize in {8, 16, 32, 64, 128, 256} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('idxdsize), int('index), int('n)) -> unit

function execute_aarch64_instrs_vector_transfer_vector_cpy_dup_sisd (d, datasize, elements, esize, idxdsize, index, n) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('idxdsize) = V_read(n, idxdsize);
    result : bits('datasize) = undefined;
    let element : bits('esize) = Elem_read(operand, index, esize);
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        result = Elem_set(result, e, esize, element)
    };
    assert(constraint('datasize in {8, 16, 32, 64, 128}));
    V_set(d, datasize) = result
}

val decode_dup_advsimd_elt_aarch64_instrs_vector_transfer_vector_cpy_dup_sisd : (bits(5), bits(5), bits(5)) -> unit

function decode_dup_advsimd_elt_aarch64_instrs_vector_transfer_vector_cpy_dup_sisd (Rd, Rn, imm5) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'size = LowestSetBit(imm5);
    if size > 3 then {
        throw(Error_Undefined())
    };
    assert(constraint(0 <= 'size + 1));
    let 'index = UInt(imm5[4 .. size + 1]);
    let 'idxdsize = if [imm5[4]] == 0b1 then 128 else 64;
    let 'esize = (8 << size);
    let 'datasize = esize;
    let 'elements = 1;
    assert(constraint(('esize in {8, 16, 32, 64, 128, 256} & 'datasize in {8, 16, 32, 64, 128, 256})));
    execute_aarch64_instrs_vector_transfer_vector_cpy_dup_sisd(d, datasize, elements, esize, idxdsize, index, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 199) = {
    SEE = 199;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm5 = Slice(__opcode, 16, 5);
    decode_dup_advsimd_elt_aarch64_instrs_vector_transfer_vector_cpy_dup_sisd(Rd, Rn, imm5)
}

val decode_dup_advsimd_elt_aarch64_instrs_vector_transfer_vector_cpy_dup_simd : (bits(5), bits(5), bits(5), bits(1)) -> unit

function decode_dup_advsimd_elt_aarch64_instrs_vector_transfer_vector_cpy_dup_simd (Rd, Rn, imm5, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'size = LowestSetBit(imm5);
    if size > 3 then {
        throw(Error_Undefined())
    };
    assert(constraint(0 <= 'size + 1));
    let 'index = UInt(imm5[4 .. size + 1]);
    let 'idxdsize = if [imm5[4]] == 0b1 then 128 else 64;
    if size == 3 & Q == 0b0 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << size);
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    assert(constraint('esize in {8, 16, 32, 64, 128, 256}));
    execute_aarch64_instrs_vector_transfer_vector_cpy_dup_sisd(d, datasize, elements, esize, idxdsize, index, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 200) = {
    SEE = 200;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm5 = Slice(__opcode, 16, 5);
    let Q = Slice(__opcode, 30, 1);
    decode_dup_advsimd_elt_aarch64_instrs_vector_transfer_vector_cpy_dup_simd(Rd, Rn, imm5, Q)
}

val execute_aarch64_instrs_vector_transfer_integer_dup : forall 'd 'datasize 'elements 'esize 'n,
  (0 <= 'n & 'n <= 31 & 'esize in {8, 16, 32, 64, 128, 256} & 'datasize in {64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('n)) -> unit

function execute_aarch64_instrs_vector_transfer_integer_dup (d, datasize, elements, esize, n) = {
    CheckFPAdvSIMDEnabled64();
    assert(constraint('esize in {8, 16, 32, 64}));
    let element : bits('esize) = X_read(n, esize);
    result : bits('datasize) = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        result = Elem_set(result, e, esize, element)
    };
    V_set(d, datasize) = result
}

val decode_dup_advsimd_gen_aarch64_instrs_vector_transfer_integer_dup : (bits(5), bits(5), bits(5), bits(1)) -> unit

function decode_dup_advsimd_gen_aarch64_instrs_vector_transfer_integer_dup (Rd, Rn, imm5, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'size = LowestSetBit(imm5);
    if size > 3 then {
        throw(Error_Undefined())
    };
    if size == 3 & Q == 0b0 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << size);
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    assert(constraint('esize in {8, 16, 32, 64, 128, 256}));
    execute_aarch64_instrs_vector_transfer_integer_dup(d, datasize, elements, esize, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, bitzero, bitzero, bitzero, bitzero, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 201) = {
    SEE = 201;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm5 = Slice(__opcode, 16, 5);
    let Q = Slice(__opcode, 30, 1);
    decode_dup_advsimd_gen_aarch64_instrs_vector_transfer_integer_dup(Rd, Rn, imm5, Q)
}

val execute_aarch64_instrs_vector_crypto_sha3_eor3 : forall 'a 'd 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 0 <= 'd & 'd <= 31 & 0 <= 'a & 'a <= 31).
  (int('a), int('d), int('m), int('n)) -> unit

function execute_aarch64_instrs_vector_crypto_sha3_eor3 (a, d, m, n) = {
    AArch64_CheckFPAdvSIMDEnabled();
    let Vm : bits(128) = V_read(m, 128);
    let Vn : bits(128) = V_read(n, 128);
    let Va : bits(128) = V_read(a, 128);
    V_set(d, 128) = EOR(EOR(Vn, Vm), Va)
}

val decode_eor3_advsimd_aarch64_instrs_vector_crypto_sha3_eor3 : (bits(5), bits(5), bits(5), bits(5)) -> unit

function decode_eor3_advsimd_aarch64_instrs_vector_crypto_sha3_eor3 (Rd, Rn, Ra, Rm) = {
    if not_bool(HaveSHA3Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'a = UInt(Ra);
    execute_aarch64_instrs_vector_crypto_sha3_eor3(a, d, m, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitone, bitone, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 202) = {
    SEE = 202;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Ra = Slice(__opcode, 10, 5);
    let Rm = Slice(__opcode, 16, 5);
    decode_eor3_advsimd_aarch64_instrs_vector_crypto_sha3_eor3(Rd, Rn, Ra, Rm)
}

val execute_aarch64_instrs_branch_unconditional_eret : forall ('pac : Bool) ('use_key_a : Bool).
  (bool('pac), bool('use_key_a)) -> unit

function execute_aarch64_instrs_branch_unconditional_eret (pac, use_key_a) = {
    AArch64_CheckForERetTrap(pac, use_key_a);
    target : bits(64) = ELR_read__1();
    let modifier : bits(64) = SP_read();
    let auth_then_branch : bool = true;
    if pac then {
        if use_key_a then {
            target = AuthIA(target, modifier, auth_then_branch)
        } else {
            target = AuthIB(target, modifier, auth_then_branch)
        }
    };
    return_exception(target[55 .. 0]);
    AArch64_ExceptionReturn(target, SPSR_read(64))
}

val decode_eret_aarch64_instrs_branch_unconditional_eret : (bits(5), bits(5), bits(1), bits(1)) -> unit

function decode_eret_aarch64_instrs_branch_unconditional_eret (op4, Rn, M, A) = {
    if PSTATE.EL == EL0 then {
        throw(Error_Undefined())
    };
    let pac : bool = A == 0b1;
    let use_key_a : bool = M == 0b0;
    if not_bool(pac) & op4 != 0b00000 then {
        throw(Error_Undefined())
    } else if pac & (not_bool(HavePACExt()) | op4 != 0b11111) then {
        throw(Error_Undefined())
    } else ();
    if Rn != 0b11111 then {
        throw(Error_Undefined())
    };
    execute_aarch64_instrs_branch_unconditional_eret(pac, use_key_a)
}

function clause __DecodeA64_BranchExcSys ((pc, (0b11010110100111110000001111100000 as __opcode)) if SEE < 203) = {
    SEE = 203;
    let op4 = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let M = Slice(__opcode, 10, 1);
    let A = Slice(__opcode, 11, 1);
    decode_eret_aarch64_instrs_branch_unconditional_eret(op4, Rn, M, A)
}

val decode_ereta_aarch64_instrs_branch_unconditional_eret : (bits(5), bits(5), bits(1), bits(1)) -> unit

function decode_ereta_aarch64_instrs_branch_unconditional_eret (op4, Rn, M, A) = {
    if PSTATE.EL == EL0 then {
        throw(Error_Undefined())
    };
    let pac : bool = A == 0b1;
    let use_key_a : bool = M == 0b0;
    if not_bool(pac) & op4 != 0b00000 then {
        throw(Error_Undefined())
    } else if pac & (not_bool(HavePACExt()) | op4 != 0b11111) then {
        throw(Error_Undefined())
    } else ();
    if Rn != 0b11111 then {
        throw(Error_Undefined())
    };
    execute_aarch64_instrs_branch_unconditional_eret(pac, use_key_a)
}

function clause __DecodeA64_BranchExcSys ((pc, ([bitone, bitone, bitzero, bitone, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, _, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitone] as __opcode)) if SEE < 204) = {
    SEE = 204;
    let op4 = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let M = Slice(__opcode, 10, 1);
    let A = Slice(__opcode, 11, 1);
    decode_ereta_aarch64_instrs_branch_unconditional_eret(op4, Rn, M, A)
}

val execute_aarch64_instrs_vector_transfer_vector_extract : forall 'd 'datasize 'm 'n 'position,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'datasize in {64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('m), int('n), int('position)) -> unit

function execute_aarch64_instrs_vector_transfer_vector_extract (d, datasize, m, n, position) = {
    CheckFPAdvSIMDEnabled64();
    let hi : bits('datasize) = V_read(m, datasize);
    let lo : bits('datasize) = V_read(n, datasize);
    let concat : bits('datasize * 2) = hi @ lo;
    assert(constraint((0 <= 'position & 'position + 'datasize - 1 < 'datasize * 2)));
    V_set(d, datasize) = concat[position + datasize - 1 .. position]
}

val decode_ext_advsimd_aarch64_instrs_vector_transfer_vector_extract : (bits(5), bits(5), bits(4), bits(5), bits(1)) -> unit

function decode_ext_advsimd_aarch64_instrs_vector_transfer_vector_extract (Rd, Rn, imm4, Rm, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if Q == 0b0 & [imm4[3]] == 0b1 then {
        throw(Error_Undefined())
    };
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'position = (UInt(imm4) << 3);
    execute_aarch64_instrs_vector_transfer_vector_extract(d, datasize, m, n, position)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, bitzero, _, _, _, _, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 205) = {
    SEE = 205;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm4 = Slice(__opcode, 11, 4);
    let Rm = Slice(__opcode, 16, 5);
    let Q = Slice(__opcode, 30, 1);
    decode_ext_advsimd_aarch64_instrs_vector_transfer_vector_extract(Rd, Rn, imm4, Rm, Q)
}

val execute_aarch64_instrs_integer_ins_ext_extract_immediate : forall 'd 'datasize 'lsb 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 0 <= 'lsb & 'lsb <= 63 & 'datasize in {32, 64} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('lsb), int('m), int('n)) -> unit

function execute_aarch64_instrs_integer_ins_ext_extract_immediate (d, datasize, lsb, m, n) = {
    let operand1 : bits('datasize) = X_read(n, datasize);
    let operand2 : bits('datasize) = X_read(m, datasize);
    let concat : bits(2 * 'datasize) = operand1 @ operand2;
    assert(constraint('lsb + 'datasize - 1 < 2 * 'datasize));
    let result : bits('datasize) = concat[lsb + datasize - 1 .. lsb];
    X_set(d, datasize) = result
}

val decode_extr_aarch64_instrs_integer_ins_ext_extract_immediate : (bits(5), bits(5), bits(6), bits(5), bits(1), bits(1)) -> unit

function decode_extr_aarch64_instrs_integer_ins_ext_extract_immediate (Rd, Rn, imms, Rm, N, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'datasize = if sf == 0b1 then 64 else 32;
    if N != sf then {
        throw(Error_Undefined())
    };
    if sf == 0b0 & [imms[5]] == 0b1 then {
        throw(Error_Undefined())
    };
    let 'lsb = UInt(imms);
    execute_aarch64_instrs_integer_ins_ext_extract_immediate(d, datasize, lsb, m, n)
}

function clause __DecodeA64_DataProcImm ((pc, ([_, bitzero, bitzero, bitone, bitzero, bitzero, bitone, bitone, bitone, _, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 206) = {
    SEE = 206;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imms = Slice(__opcode, 10, 6);
    let Rm = Slice(__opcode, 16, 5);
    let N = Slice(__opcode, 22, 1);
    let sf = Slice(__opcode, 31, 1);
    decode_extr_aarch64_instrs_integer_ins_ext_extract_immediate(Rd, Rn, imms, Rm, N, sf)
}

val execute_aarch64_instrs_vector_arithmetic_binary_uniform_sub_fp16_sisd : forall ('abs : Bool) 'd 'datasize 'elements 'esize 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'esize in {16, 32, 64} & 'datasize in {16, 32, 64, 128} & 0 <= 'd & 'd <= 31).
  (bool('abs), int('d), int('datasize), int('elements), int('esize), int('m), int('n)) -> unit

function execute_aarch64_instrs_vector_arithmetic_binary_uniform_sub_fp16_sisd (abs, d, datasize, elements, esize, m, n) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = V_read(n, datasize);
    let operand2 : bits('datasize) = V_read(m, datasize);
    element1 : bits('esize) = undefined;
    element2 : bits('esize) = undefined;
    diff : bits('esize) = undefined;
    let fpcr : FPCRType = FPCR_read();
    let merge : bool = elements == 1 & IsMerging(fpcr);
    result : bits(128) = if merge then V_read(n, 128) else Zeros(128);
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element1 = Elem_read(operand1, e, esize);
        element2 = Elem_read(operand2, e, esize);
        diff = FPSub(element1, element2, fpcr);
        result = Elem_set(result, e, esize, if abs then FPAbs(diff) else diff)
    };
    V_set(d, 128) = result
}

val decode_fabd_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_sub_fp16_sisd : (bits(5), bits(5), bits(5)) -> unit

function decode_fabd_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_sub_fp16_sisd (Rd, Rn, Rm) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = 16;
    let 'datasize = esize;
    let 'elements = 1;
    let abs : bool = true;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_sub_fp16_sisd(abs, d, datasize, elements, esize, m, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, bitzero, bitzero, bitzero, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 207) = {
    SEE = 207;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    decode_fabd_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_sub_fp16_sisd(Rd, Rn, Rm)
}

val decode_fabd_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_sub_fp_sisd : (bits(5), bits(5), bits(5), bits(1)) -> unit

function decode_fabd_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_sub_fp_sisd (Rd, Rn, Rm, sz) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = (32 << UInt(sz));
    let 'datasize = esize;
    let 'elements = 1;
    let abs : bool = true;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_sub_fp16_sisd(abs, d, datasize, elements, esize, m, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, bitone, _, bitone, _, _, _, _, _, bitone, bitone, bitzero, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 208) = {
    SEE = 208;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let sz = Slice(__opcode, 22, 1);
    decode_fabd_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_sub_fp_sisd(Rd, Rn, Rm, sz)
}

val decode_fabd_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_sub_fp16_simd : (bits(5), bits(5), bits(5), bits(1), bits(1)) -> unit

function decode_fabd_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_sub_fp16_simd (Rd, Rn, Rm, U, Q) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = 16;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let abs : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_sub_fp16_sisd(abs, d, datasize, elements, esize, m, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, bitzero, bitzero, bitzero, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 209) = {
    SEE = 209;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fabd_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_sub_fp16_simd(Rd, Rn, Rm, U, Q)
}

val decode_fabd_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_sub_fp_simd : (bits(5), bits(5), bits(5), bits(1), bits(1), bits(1)) -> unit

function decode_fabd_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_sub_fp_simd (Rd, Rn, Rm, sz, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    };
    let 'esize = (32 << UInt(sz));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let abs : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_sub_fp16_sisd(abs, d, datasize, elements, esize, m, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, bitone, _, bitone, _, _, _, _, _, bitone, bitone, bitzero, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 210) = {
    SEE = 210;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let sz = Slice(__opcode, 22, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fabd_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_sub_fp_simd(Rd, Rn, Rm, sz, U, Q)
}

val execute_aarch64_instrs_float_arithmetic_unary : forall 'd 'esize 'n,
  (0 <= 'n & 'n <= 31 & 'esize in {16, 32, 64} & 0 <= 'd & 'd <= 31).
  (int('d), int('esize), FPUnaryOp, int('n)) -> unit

function execute_aarch64_instrs_float_arithmetic_unary (d, esize, fpop, n) = {
    CheckFPEnabled64();
    let fpcr : FPCRType = FPCR_read();
    let merge : bool = fpop != FPUnaryOp_MOV & IsMerging(fpcr);
    result : bits(128) = if merge then V_read(d, 128) else 0[127 .. 0];
    let operand : bits('esize) = V_read(n, esize);
    match fpop {
      FPUnaryOp_MOV => {
          result = Elem_set(result, 0, esize, operand)
      },
      FPUnaryOp_ABS => {
          result = Elem_set(result, 0, esize, FPAbs(operand))
      },
      FPUnaryOp_NEG => {
          result = Elem_set(result, 0, esize, FPNeg(operand))
      },
      FPUnaryOp_SQRT => {
          result = Elem_set(result, 0, esize, FPSqrt(operand, fpcr))
      }
    };
    V_set(d, 128) = result
}

val decode_fabs_float_aarch64_instrs_float_arithmetic_unary : (bits(5), bits(5), bits(2), bits(2)) -> unit

function decode_fabs_float_aarch64_instrs_float_arithmetic_unary (Rd, Rn, opc, ftype) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    esize : {16, 32, 64} = 16;
    match ftype {
      0b00 => {
          esize = 32
      },
      0b01 => {
          esize = 64
      },
      0b10 => {
          throw(Error_Undefined())
      },
      0b11 => {
          if HaveFP16Ext() then {
              esize = 16
          } else {
              throw(Error_Undefined())
          }
      }
    };
    let 'esize = esize;
    fpop : FPUnaryOp = undefined;
    match opc {
      0b00 => {
          fpop = FPUnaryOp_MOV
      },
      0b01 => {
          fpop = FPUnaryOp_ABS
      },
      0b10 => {
          fpop = FPUnaryOp_NEG
      },
      0b11 => {
          fpop = FPUnaryOp_SQRT
      }
    };
    let fpop = fpop;
    execute_aarch64_instrs_float_arithmetic_unary(d, esize, fpop, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 211) = {
    SEE = 211;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let opc = Slice(__opcode, 15, 2);
    let ftype = Slice(__opcode, 22, 2);
    decode_fabs_float_aarch64_instrs_float_arithmetic_unary(Rd, Rn, opc, ftype)
}

val decode_fmov_float_aarch64_instrs_float_arithmetic_unary : (bits(5), bits(5), bits(2), bits(2)) -> unit

function decode_fmov_float_aarch64_instrs_float_arithmetic_unary (Rd, Rn, opc, ftype) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    esize : {16, 32, 64} = 16;
    match ftype {
      0b00 => {
          esize = 32
      },
      0b01 => {
          esize = 64
      },
      0b10 => {
          throw(Error_Undefined())
      },
      0b11 => {
          if HaveFP16Ext() then {
              esize = 16
          } else {
              throw(Error_Undefined())
          }
      }
    };
    let 'esize = esize;
    fpop : FPUnaryOp = undefined;
    match opc {
      0b00 => {
          fpop = FPUnaryOp_MOV
      },
      0b01 => {
          fpop = FPUnaryOp_ABS
      },
      0b10 => {
          fpop = FPUnaryOp_NEG
      },
      0b11 => {
          fpop = FPUnaryOp_SQRT
      }
    };
    let fpop = fpop;
    execute_aarch64_instrs_float_arithmetic_unary(d, esize, fpop, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 212) = {
    SEE = 212;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let opc = Slice(__opcode, 15, 2);
    let ftype = Slice(__opcode, 22, 2);
    decode_fmov_float_aarch64_instrs_float_arithmetic_unary(Rd, Rn, opc, ftype)
}

val decode_fneg_float_aarch64_instrs_float_arithmetic_unary : (bits(5), bits(5), bits(2), bits(2)) -> unit

function decode_fneg_float_aarch64_instrs_float_arithmetic_unary (Rd, Rn, opc, ftype) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    esize : {16, 32, 64} = 16;
    match ftype {
      0b00 => {
          esize = 32
      },
      0b01 => {
          esize = 64
      },
      0b10 => {
          throw(Error_Undefined())
      },
      0b11 => {
          if HaveFP16Ext() then {
              esize = 16
          } else {
              throw(Error_Undefined())
          }
      }
    };
    let 'esize = esize;
    fpop : FPUnaryOp = undefined;
    match opc {
      0b00 => {
          fpop = FPUnaryOp_MOV
      },
      0b01 => {
          fpop = FPUnaryOp_ABS
      },
      0b10 => {
          fpop = FPUnaryOp_NEG
      },
      0b11 => {
          fpop = FPUnaryOp_SQRT
      }
    };
    let fpop = fpop;
    execute_aarch64_instrs_float_arithmetic_unary(d, esize, fpop, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 213) = {
    SEE = 213;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let opc = Slice(__opcode, 15, 2);
    let ftype = Slice(__opcode, 22, 2);
    decode_fneg_float_aarch64_instrs_float_arithmetic_unary(Rd, Rn, opc, ftype)
}

val decode_fsqrt_float_aarch64_instrs_float_arithmetic_unary : (bits(5), bits(5), bits(2), bits(2)) -> unit

function decode_fsqrt_float_aarch64_instrs_float_arithmetic_unary (Rd, Rn, opc, ftype) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    esize : {16, 32, 64} = 16;
    match ftype {
      0b00 => {
          esize = 32
      },
      0b01 => {
          esize = 64
      },
      0b10 => {
          throw(Error_Undefined())
      },
      0b11 => {
          if HaveFP16Ext() then {
              esize = 16
          } else {
              throw(Error_Undefined())
          }
      }
    };
    let 'esize = esize;
    fpop : FPUnaryOp = undefined;
    match opc {
      0b00 => {
          fpop = FPUnaryOp_MOV
      },
      0b01 => {
          fpop = FPUnaryOp_ABS
      },
      0b10 => {
          fpop = FPUnaryOp_NEG
      },
      0b11 => {
          fpop = FPUnaryOp_SQRT
      }
    };
    let fpop = fpop;
    execute_aarch64_instrs_float_arithmetic_unary(d, esize, fpop, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 214) = {
    SEE = 214;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let opc = Slice(__opcode, 15, 2);
    let ftype = Slice(__opcode, 22, 2);
    decode_fsqrt_float_aarch64_instrs_float_arithmetic_unary(Rd, Rn, opc, ftype)
}

val execute_aarch64_instrs_vector_arithmetic_unary_diff_neg_fp16 : forall 'd 'datasize 'elements 'esize 'n ('neg : Bool),
  (0 <= 'n & 'n <= 31 & 'esize in {16, 32, 64} & 'datasize in {64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('n), bool('neg)) -> unit

function execute_aarch64_instrs_vector_arithmetic_unary_diff_neg_fp16 (d, datasize, elements, esize, n, neg) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('datasize) = V_read(n, datasize);
    result : bits('datasize) = undefined;
    element : bits('esize) = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element = Elem_read(operand, e, esize);
        if neg then {
            element = FPNeg(element)
        } else {
            element = FPAbs(element)
        };
        result = Elem_set(result, e, esize, element)
    };
    V_set(d, datasize) = result
}

val decode_fabs_advsimd_aarch64_instrs_vector_arithmetic_unary_diff_neg_fp16 : (bits(5), bits(5), bits(1), bits(1)) -> unit

function decode_fabs_advsimd_aarch64_instrs_vector_arithmetic_unary_diff_neg_fp16 (Rd, Rn, U, Q) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = 16;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let neg : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_diff_neg_fp16(d, datasize, elements, esize, n, neg)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 215) = {
    SEE = 215;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fabs_advsimd_aarch64_instrs_vector_arithmetic_unary_diff_neg_fp16(Rd, Rn, U, Q)
}

val decode_fabs_advsimd_aarch64_instrs_vector_arithmetic_unary_diff_neg_float : (bits(5), bits(5), bits(1), bits(1), bits(1)) -> unit

function decode_fabs_advsimd_aarch64_instrs_vector_arithmetic_unary_diff_neg_float (Rd, Rn, sz, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    };
    let 'esize = (32 << UInt(sz));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let neg : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_diff_neg_fp16(d, datasize, elements, esize, n, neg)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitone, _, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 216) = {
    SEE = 216;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let sz = Slice(__opcode, 22, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fabs_advsimd_aarch64_instrs_vector_arithmetic_unary_diff_neg_float(Rd, Rn, sz, U, Q)
}

val decode_fneg_advsimd_aarch64_instrs_vector_arithmetic_unary_diff_neg_fp16 : (bits(5), bits(5), bits(1), bits(1)) -> unit

function decode_fneg_advsimd_aarch64_instrs_vector_arithmetic_unary_diff_neg_fp16 (Rd, Rn, U, Q) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = 16;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let neg : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_diff_neg_fp16(d, datasize, elements, esize, n, neg)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 217) = {
    SEE = 217;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fneg_advsimd_aarch64_instrs_vector_arithmetic_unary_diff_neg_fp16(Rd, Rn, U, Q)
}

val decode_fneg_advsimd_aarch64_instrs_vector_arithmetic_unary_diff_neg_float : (bits(5), bits(5), bits(1), bits(1), bits(1)) -> unit

function decode_fneg_advsimd_aarch64_instrs_vector_arithmetic_unary_diff_neg_float (Rd, Rn, sz, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    };
    let 'esize = (32 << UInt(sz));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let neg : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_diff_neg_fp16(d, datasize, elements, esize, n, neg)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, bitone, _, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 218) = {
    SEE = 218;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let sz = Slice(__opcode, 22, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fneg_advsimd_aarch64_instrs_vector_arithmetic_unary_diff_neg_float(Rd, Rn, sz, U, Q)
}

val execute_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp16_sisd : forall ('abs : Bool) 'd 'datasize 'elements 'esize 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'esize in {16, 32, 64} & 'datasize in {16, 32, 64, 128} & 0 <= 'd & 'd <= 31).
  (bool('abs), CompareOp, int('d), int('datasize), int('elements), int('esize), int('m), int('n)) -> unit

function execute_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp16_sisd (abs, cmp, d, datasize, elements, esize, m, n) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = V_read(n, datasize);
    let operand2 : bits('datasize) = V_read(m, datasize);
    element1 : bits('esize) = undefined;
    element2 : bits('esize) = undefined;
    test_passed : bool = undefined;
    let fpcr : FPCRType = FPCR_read();
    let merge : bool = elements == 1 & IsMerging(fpcr);
    result : bits(128) = if merge then V_read(m, 128) else Zeros(128);
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element1 = Elem_read(operand1, e, esize);
        element2 = Elem_read(operand2, e, esize);
        if abs then {
            element1 = FPAbs(element1);
            element2 = FPAbs(element2)
        };
        match cmp {
          CompareOp_EQ => {
              test_passed = FPCompareEQ(element1, element2, fpcr)
          },
          CompareOp_GE => {
              test_passed = FPCompareGE(element1, element2, fpcr)
          },
          CompareOp_GT => {
              test_passed = FPCompareGT(element1, element2, fpcr)
          },
          _ => ()
        };
        result = Elem_set(result, e, esize, if test_passed then Ones(esize) else
          Zeros(esize))
    };
    V_set(d, 128) = result
}

val decode_facge_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp16_sisd : (bits(5), bits(5), bits(1), bits(5), bits(1), bits(1)) -> unit

function decode_facge_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp16_sisd (Rd, Rn, ac, Rm, E, U) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = 16;
    let 'datasize = esize;
    let 'elements = 1;
    cmp : CompareOp = undefined;
    abs : bool = undefined;
    match (E @ U) @ ac {
      0b000 => {
          cmp = CompareOp_EQ;
          abs = false
      },
      0b010 => {
          cmp = CompareOp_GE;
          abs = false
      },
      0b011 => {
          cmp = CompareOp_GE;
          abs = true
      },
      0b110 => {
          cmp = CompareOp_GT;
          abs = false
      },
      0b111 => {
          cmp = CompareOp_GT;
          abs = true
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let abs = abs;
    let cmp = cmp;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp16_sisd(abs, cmp, d, datasize, elements, esize, m, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, bitzero, bitzero, bitone, bitzero, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 219) = {
    SEE = 219;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let ac = Slice(__opcode, 11, 1);
    let Rm = Slice(__opcode, 16, 5);
    let E = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    decode_facge_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp16_sisd(Rd, Rn, ac, Rm, E, U)
}

val decode_facge_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp_sisd : (bits(5), bits(5), bits(1), bits(5), bits(1), bits(1), bits(1)) -> unit

function decode_facge_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp_sisd (Rd, Rn, ac, Rm, sz, E, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = (32 << UInt(sz));
    let 'datasize = esize;
    let 'elements = 1;
    cmp : CompareOp = undefined;
    abs : bool = undefined;
    match (E @ U) @ ac {
      0b000 => {
          cmp = CompareOp_EQ;
          abs = false
      },
      0b010 => {
          cmp = CompareOp_GE;
          abs = false
      },
      0b011 => {
          cmp = CompareOp_GE;
          abs = true
      },
      0b110 => {
          cmp = CompareOp_GT;
          abs = false
      },
      0b111 => {
          cmp = CompareOp_GT;
          abs = true
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let abs = abs;
    let cmp = cmp;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp16_sisd(abs, cmp, d, datasize, elements, esize, m, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, _, bitone, _, _, _, _, _, bitone, bitone, bitone, bitzero, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 220) = {
    SEE = 220;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let ac = Slice(__opcode, 11, 1);
    let Rm = Slice(__opcode, 16, 5);
    let sz = Slice(__opcode, 22, 1);
    let E = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    decode_facge_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp_sisd(Rd, Rn, ac, Rm, sz, E, U)
}

val decode_facge_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp16_simd : (bits(5), bits(5), bits(1), bits(5), bits(1), bits(1), bits(1)) -> unit

function decode_facge_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp16_simd (Rd, Rn, ac, Rm, E, U, Q) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = 16;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    cmp : CompareOp = undefined;
    abs : bool = undefined;
    match (E @ U) @ ac {
      0b000 => {
          cmp = CompareOp_EQ;
          abs = false
      },
      0b010 => {
          cmp = CompareOp_GE;
          abs = false
      },
      0b011 => {
          cmp = CompareOp_GE;
          abs = true
      },
      0b110 => {
          cmp = CompareOp_GT;
          abs = false
      },
      0b111 => {
          cmp = CompareOp_GT;
          abs = true
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let abs = abs;
    let cmp = cmp;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp16_sisd(abs, cmp, d, datasize, elements, esize, m, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, bitzero, bitzero, bitone, bitzero, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 221) = {
    SEE = 221;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let ac = Slice(__opcode, 11, 1);
    let Rm = Slice(__opcode, 16, 5);
    let E = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_facge_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp16_simd(Rd, Rn, ac, Rm, E, U, Q)
}

val decode_facge_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp_simd : (bits(5), bits(5), bits(1), bits(5), bits(1), bits(1), bits(1), bits(1)) -> unit

function decode_facge_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp_simd (Rd, Rn, ac, Rm, sz, E, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    };
    let 'esize = (32 << UInt(sz));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    cmp : CompareOp = undefined;
    abs : bool = undefined;
    match (E @ U) @ ac {
      0b000 => {
          cmp = CompareOp_EQ;
          abs = false
      },
      0b010 => {
          cmp = CompareOp_GE;
          abs = false
      },
      0b011 => {
          cmp = CompareOp_GE;
          abs = true
      },
      0b110 => {
          cmp = CompareOp_GT;
          abs = false
      },
      0b111 => {
          cmp = CompareOp_GT;
          abs = true
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let abs = abs;
    let cmp = cmp;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp16_sisd(abs, cmp, d, datasize, elements, esize, m, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, bitzero, _, bitone, _, _, _, _, _, bitone, bitone, bitone, bitzero, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 222) = {
    SEE = 222;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let ac = Slice(__opcode, 11, 1);
    let Rm = Slice(__opcode, 16, 5);
    let sz = Slice(__opcode, 22, 1);
    let E = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_facge_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp_simd(Rd, Rn, ac, Rm, sz, E, U, Q)
}

val decode_facgt_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp16_sisd : (bits(5), bits(5), bits(1), bits(5), bits(1), bits(1)) -> unit

function decode_facgt_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp16_sisd (Rd, Rn, ac, Rm, E, U) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = 16;
    let 'datasize = esize;
    let 'elements = 1;
    cmp : CompareOp = undefined;
    abs : bool = undefined;
    match (E @ U) @ ac {
      0b000 => {
          cmp = CompareOp_EQ;
          abs = false
      },
      0b010 => {
          cmp = CompareOp_GE;
          abs = false
      },
      0b011 => {
          cmp = CompareOp_GE;
          abs = true
      },
      0b110 => {
          cmp = CompareOp_GT;
          abs = false
      },
      0b111 => {
          cmp = CompareOp_GT;
          abs = true
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let abs = abs;
    let cmp = cmp;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp16_sisd(abs, cmp, d, datasize, elements, esize, m, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, bitzero, bitzero, bitone, bitzero, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 223) = {
    SEE = 223;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let ac = Slice(__opcode, 11, 1);
    let Rm = Slice(__opcode, 16, 5);
    let E = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    decode_facgt_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp16_sisd(Rd, Rn, ac, Rm, E, U)
}

val decode_facgt_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp_sisd : (bits(5), bits(5), bits(1), bits(5), bits(1), bits(1), bits(1)) -> unit

function decode_facgt_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp_sisd (Rd, Rn, ac, Rm, sz, E, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = (32 << UInt(sz));
    let 'datasize = esize;
    let 'elements = 1;
    cmp : CompareOp = undefined;
    abs : bool = undefined;
    match (E @ U) @ ac {
      0b000 => {
          cmp = CompareOp_EQ;
          abs = false
      },
      0b010 => {
          cmp = CompareOp_GE;
          abs = false
      },
      0b011 => {
          cmp = CompareOp_GE;
          abs = true
      },
      0b110 => {
          cmp = CompareOp_GT;
          abs = false
      },
      0b111 => {
          cmp = CompareOp_GT;
          abs = true
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let abs = abs;
    let cmp = cmp;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp16_sisd(abs, cmp, d, datasize, elements, esize, m, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, bitone, _, bitone, _, _, _, _, _, bitone, bitone, bitone, bitzero, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 224) = {
    SEE = 224;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let ac = Slice(__opcode, 11, 1);
    let Rm = Slice(__opcode, 16, 5);
    let sz = Slice(__opcode, 22, 1);
    let E = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    decode_facgt_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp_sisd(Rd, Rn, ac, Rm, sz, E, U)
}

val decode_facgt_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp16_simd : (bits(5), bits(5), bits(1), bits(5), bits(1), bits(1), bits(1)) -> unit

function decode_facgt_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp16_simd (Rd, Rn, ac, Rm, E, U, Q) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = 16;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    cmp : CompareOp = undefined;
    abs : bool = undefined;
    match (E @ U) @ ac {
      0b000 => {
          cmp = CompareOp_EQ;
          abs = false
      },
      0b010 => {
          cmp = CompareOp_GE;
          abs = false
      },
      0b011 => {
          cmp = CompareOp_GE;
          abs = true
      },
      0b110 => {
          cmp = CompareOp_GT;
          abs = false
      },
      0b111 => {
          cmp = CompareOp_GT;
          abs = true
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let abs = abs;
    let cmp = cmp;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp16_sisd(abs, cmp, d, datasize, elements, esize, m, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, bitzero, bitzero, bitone, bitzero, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 225) = {
    SEE = 225;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let ac = Slice(__opcode, 11, 1);
    let Rm = Slice(__opcode, 16, 5);
    let E = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_facgt_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp16_simd(Rd, Rn, ac, Rm, E, U, Q)
}

val decode_facgt_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp_simd : (bits(5), bits(5), bits(1), bits(5), bits(1), bits(1), bits(1), bits(1)) -> unit

function decode_facgt_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp_simd (Rd, Rn, ac, Rm, sz, E, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    };
    let 'esize = (32 << UInt(sz));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    cmp : CompareOp = undefined;
    abs : bool = undefined;
    match (E @ U) @ ac {
      0b000 => {
          cmp = CompareOp_EQ;
          abs = false
      },
      0b010 => {
          cmp = CompareOp_GE;
          abs = false
      },
      0b011 => {
          cmp = CompareOp_GE;
          abs = true
      },
      0b110 => {
          cmp = CompareOp_GT;
          abs = false
      },
      0b111 => {
          cmp = CompareOp_GT;
          abs = true
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let abs = abs;
    let cmp = cmp;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp16_sisd(abs, cmp, d, datasize, elements, esize, m, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, bitone, _, bitone, _, _, _, _, _, bitone, bitone, bitone, bitzero, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 226) = {
    SEE = 226;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let ac = Slice(__opcode, 11, 1);
    let Rm = Slice(__opcode, 16, 5);
    let sz = Slice(__opcode, 22, 1);
    let E = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_facgt_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp_simd(Rd, Rn, ac, Rm, sz, E, U, Q)
}

val decode_fcmeq_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp16_sisd : (bits(5), bits(5), bits(1), bits(5), bits(1), bits(1)) -> unit

function decode_fcmeq_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp16_sisd (Rd, Rn, ac, Rm, E, U) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = 16;
    let 'datasize = esize;
    let 'elements = 1;
    cmp : CompareOp = undefined;
    abs : bool = undefined;
    match (E @ U) @ ac {
      0b000 => {
          cmp = CompareOp_EQ;
          abs = false
      },
      0b010 => {
          cmp = CompareOp_GE;
          abs = false
      },
      0b011 => {
          cmp = CompareOp_GE;
          abs = true
      },
      0b110 => {
          cmp = CompareOp_GT;
          abs = false
      },
      0b111 => {
          cmp = CompareOp_GT;
          abs = true
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let abs = abs;
    let cmp = cmp;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp16_sisd(abs, cmp, d, datasize, elements, esize, m, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, bitzero, bitzero, bitone, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 227) = {
    SEE = 227;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let ac = Slice(__opcode, 11, 1);
    let Rm = Slice(__opcode, 16, 5);
    let E = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    decode_fcmeq_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp16_sisd(Rd, Rn, ac, Rm, E, U)
}

val decode_fcmeq_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp_sisd : (bits(5), bits(5), bits(1), bits(5), bits(1), bits(1), bits(1)) -> unit

function decode_fcmeq_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp_sisd (Rd, Rn, ac, Rm, sz, E, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = (32 << UInt(sz));
    let 'datasize = esize;
    let 'elements = 1;
    cmp : CompareOp = undefined;
    abs : bool = undefined;
    match (E @ U) @ ac {
      0b000 => {
          cmp = CompareOp_EQ;
          abs = false
      },
      0b010 => {
          cmp = CompareOp_GE;
          abs = false
      },
      0b011 => {
          cmp = CompareOp_GE;
          abs = true
      },
      0b110 => {
          cmp = CompareOp_GT;
          abs = false
      },
      0b111 => {
          cmp = CompareOp_GT;
          abs = true
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let abs = abs;
    let cmp = cmp;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp16_sisd(abs, cmp, d, datasize, elements, esize, m, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, _, bitone, _, _, _, _, _, bitone, bitone, bitone, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 228) = {
    SEE = 228;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let ac = Slice(__opcode, 11, 1);
    let Rm = Slice(__opcode, 16, 5);
    let sz = Slice(__opcode, 22, 1);
    let E = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    decode_fcmeq_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp_sisd(Rd, Rn, ac, Rm, sz, E, U)
}

val decode_fcmeq_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp16_simd : (bits(5), bits(5), bits(1), bits(5), bits(1), bits(1), bits(1)) -> unit

function decode_fcmeq_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp16_simd (Rd, Rn, ac, Rm, E, U, Q) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = 16;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    cmp : CompareOp = undefined;
    abs : bool = undefined;
    match (E @ U) @ ac {
      0b000 => {
          cmp = CompareOp_EQ;
          abs = false
      },
      0b010 => {
          cmp = CompareOp_GE;
          abs = false
      },
      0b011 => {
          cmp = CompareOp_GE;
          abs = true
      },
      0b110 => {
          cmp = CompareOp_GT;
          abs = false
      },
      0b111 => {
          cmp = CompareOp_GT;
          abs = true
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let abs = abs;
    let cmp = cmp;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp16_sisd(abs, cmp, d, datasize, elements, esize, m, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, bitzero, bitzero, bitone, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 229) = {
    SEE = 229;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let ac = Slice(__opcode, 11, 1);
    let Rm = Slice(__opcode, 16, 5);
    let E = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fcmeq_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp16_simd(Rd, Rn, ac, Rm, E, U, Q)
}

val decode_fcmeq_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp_simd : (bits(5), bits(5), bits(1), bits(5), bits(1), bits(1), bits(1), bits(1)) -> unit

function decode_fcmeq_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp_simd (Rd, Rn, ac, Rm, sz, E, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    };
    let 'esize = (32 << UInt(sz));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    cmp : CompareOp = undefined;
    abs : bool = undefined;
    match (E @ U) @ ac {
      0b000 => {
          cmp = CompareOp_EQ;
          abs = false
      },
      0b010 => {
          cmp = CompareOp_GE;
          abs = false
      },
      0b011 => {
          cmp = CompareOp_GE;
          abs = true
      },
      0b110 => {
          cmp = CompareOp_GT;
          abs = false
      },
      0b111 => {
          cmp = CompareOp_GT;
          abs = true
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let abs = abs;
    let cmp = cmp;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp16_sisd(abs, cmp, d, datasize, elements, esize, m, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, _, bitone, _, _, _, _, _, bitone, bitone, bitone, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 230) = {
    SEE = 230;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let ac = Slice(__opcode, 11, 1);
    let Rm = Slice(__opcode, 16, 5);
    let sz = Slice(__opcode, 22, 1);
    let E = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fcmeq_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp_simd(Rd, Rn, ac, Rm, sz, E, U, Q)
}

val decode_fcmge_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp16_sisd : (bits(5), bits(5), bits(1), bits(5), bits(1), bits(1)) -> unit

function decode_fcmge_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp16_sisd (Rd, Rn, ac, Rm, E, U) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = 16;
    let 'datasize = esize;
    let 'elements = 1;
    cmp : CompareOp = undefined;
    abs : bool = undefined;
    match (E @ U) @ ac {
      0b000 => {
          cmp = CompareOp_EQ;
          abs = false
      },
      0b010 => {
          cmp = CompareOp_GE;
          abs = false
      },
      0b011 => {
          cmp = CompareOp_GE;
          abs = true
      },
      0b110 => {
          cmp = CompareOp_GT;
          abs = false
      },
      0b111 => {
          cmp = CompareOp_GT;
          abs = true
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let abs = abs;
    let cmp = cmp;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp16_sisd(abs, cmp, d, datasize, elements, esize, m, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, bitzero, bitzero, bitone, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 231) = {
    SEE = 231;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let ac = Slice(__opcode, 11, 1);
    let Rm = Slice(__opcode, 16, 5);
    let E = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    decode_fcmge_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp16_sisd(Rd, Rn, ac, Rm, E, U)
}

val decode_fcmge_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp_sisd : (bits(5), bits(5), bits(1), bits(5), bits(1), bits(1), bits(1)) -> unit

function decode_fcmge_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp_sisd (Rd, Rn, ac, Rm, sz, E, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = (32 << UInt(sz));
    let 'datasize = esize;
    let 'elements = 1;
    cmp : CompareOp = undefined;
    abs : bool = undefined;
    match (E @ U) @ ac {
      0b000 => {
          cmp = CompareOp_EQ;
          abs = false
      },
      0b010 => {
          cmp = CompareOp_GE;
          abs = false
      },
      0b011 => {
          cmp = CompareOp_GE;
          abs = true
      },
      0b110 => {
          cmp = CompareOp_GT;
          abs = false
      },
      0b111 => {
          cmp = CompareOp_GT;
          abs = true
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let abs = abs;
    let cmp = cmp;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp16_sisd(abs, cmp, d, datasize, elements, esize, m, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, _, bitone, _, _, _, _, _, bitone, bitone, bitone, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 232) = {
    SEE = 232;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let ac = Slice(__opcode, 11, 1);
    let Rm = Slice(__opcode, 16, 5);
    let sz = Slice(__opcode, 22, 1);
    let E = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    decode_fcmge_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp_sisd(Rd, Rn, ac, Rm, sz, E, U)
}

val decode_fcmge_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp16_simd : (bits(5), bits(5), bits(1), bits(5), bits(1), bits(1), bits(1)) -> unit

function decode_fcmge_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp16_simd (Rd, Rn, ac, Rm, E, U, Q) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = 16;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    cmp : CompareOp = undefined;
    abs : bool = undefined;
    match (E @ U) @ ac {
      0b000 => {
          cmp = CompareOp_EQ;
          abs = false
      },
      0b010 => {
          cmp = CompareOp_GE;
          abs = false
      },
      0b011 => {
          cmp = CompareOp_GE;
          abs = true
      },
      0b110 => {
          cmp = CompareOp_GT;
          abs = false
      },
      0b111 => {
          cmp = CompareOp_GT;
          abs = true
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let abs = abs;
    let cmp = cmp;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp16_sisd(abs, cmp, d, datasize, elements, esize, m, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, bitzero, bitzero, bitone, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 233) = {
    SEE = 233;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let ac = Slice(__opcode, 11, 1);
    let Rm = Slice(__opcode, 16, 5);
    let E = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fcmge_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp16_simd(Rd, Rn, ac, Rm, E, U, Q)
}

val decode_fcmge_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp_simd : (bits(5), bits(5), bits(1), bits(5), bits(1), bits(1), bits(1), bits(1)) -> unit

function decode_fcmge_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp_simd (Rd, Rn, ac, Rm, sz, E, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    };
    let 'esize = (32 << UInt(sz));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    cmp : CompareOp = undefined;
    abs : bool = undefined;
    match (E @ U) @ ac {
      0b000 => {
          cmp = CompareOp_EQ;
          abs = false
      },
      0b010 => {
          cmp = CompareOp_GE;
          abs = false
      },
      0b011 => {
          cmp = CompareOp_GE;
          abs = true
      },
      0b110 => {
          cmp = CompareOp_GT;
          abs = false
      },
      0b111 => {
          cmp = CompareOp_GT;
          abs = true
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let abs = abs;
    let cmp = cmp;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp16_sisd(abs, cmp, d, datasize, elements, esize, m, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, bitzero, _, bitone, _, _, _, _, _, bitone, bitone, bitone, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 234) = {
    SEE = 234;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let ac = Slice(__opcode, 11, 1);
    let Rm = Slice(__opcode, 16, 5);
    let sz = Slice(__opcode, 22, 1);
    let E = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fcmge_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp_simd(Rd, Rn, ac, Rm, sz, E, U, Q)
}

val decode_fcmgt_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp16_sisd : (bits(5), bits(5), bits(1), bits(5), bits(1), bits(1)) -> unit

function decode_fcmgt_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp16_sisd (Rd, Rn, ac, Rm, E, U) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = 16;
    let 'datasize = esize;
    let 'elements = 1;
    cmp : CompareOp = undefined;
    abs : bool = undefined;
    match (E @ U) @ ac {
      0b000 => {
          cmp = CompareOp_EQ;
          abs = false
      },
      0b010 => {
          cmp = CompareOp_GE;
          abs = false
      },
      0b011 => {
          cmp = CompareOp_GE;
          abs = true
      },
      0b110 => {
          cmp = CompareOp_GT;
          abs = false
      },
      0b111 => {
          cmp = CompareOp_GT;
          abs = true
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let abs = abs;
    let cmp = cmp;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp16_sisd(abs, cmp, d, datasize, elements, esize, m, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, bitzero, bitzero, bitone, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 235) = {
    SEE = 235;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let ac = Slice(__opcode, 11, 1);
    let Rm = Slice(__opcode, 16, 5);
    let E = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    decode_fcmgt_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp16_sisd(Rd, Rn, ac, Rm, E, U)
}

val decode_fcmgt_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp_sisd : (bits(5), bits(5), bits(1), bits(5), bits(1), bits(1), bits(1)) -> unit

function decode_fcmgt_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp_sisd (Rd, Rn, ac, Rm, sz, E, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = (32 << UInt(sz));
    let 'datasize = esize;
    let 'elements = 1;
    cmp : CompareOp = undefined;
    abs : bool = undefined;
    match (E @ U) @ ac {
      0b000 => {
          cmp = CompareOp_EQ;
          abs = false
      },
      0b010 => {
          cmp = CompareOp_GE;
          abs = false
      },
      0b011 => {
          cmp = CompareOp_GE;
          abs = true
      },
      0b110 => {
          cmp = CompareOp_GT;
          abs = false
      },
      0b111 => {
          cmp = CompareOp_GT;
          abs = true
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let abs = abs;
    let cmp = cmp;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp16_sisd(abs, cmp, d, datasize, elements, esize, m, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, bitone, _, bitone, _, _, _, _, _, bitone, bitone, bitone, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 236) = {
    SEE = 236;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let ac = Slice(__opcode, 11, 1);
    let Rm = Slice(__opcode, 16, 5);
    let sz = Slice(__opcode, 22, 1);
    let E = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    decode_fcmgt_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp_sisd(Rd, Rn, ac, Rm, sz, E, U)
}

val decode_fcmgt_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp16_simd : (bits(5), bits(5), bits(1), bits(5), bits(1), bits(1), bits(1)) -> unit

function decode_fcmgt_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp16_simd (Rd, Rn, ac, Rm, E, U, Q) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = 16;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    cmp : CompareOp = undefined;
    abs : bool = undefined;
    match (E @ U) @ ac {
      0b000 => {
          cmp = CompareOp_EQ;
          abs = false
      },
      0b010 => {
          cmp = CompareOp_GE;
          abs = false
      },
      0b011 => {
          cmp = CompareOp_GE;
          abs = true
      },
      0b110 => {
          cmp = CompareOp_GT;
          abs = false
      },
      0b111 => {
          cmp = CompareOp_GT;
          abs = true
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let abs = abs;
    let cmp = cmp;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp16_sisd(abs, cmp, d, datasize, elements, esize, m, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, bitzero, bitzero, bitone, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 237) = {
    SEE = 237;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let ac = Slice(__opcode, 11, 1);
    let Rm = Slice(__opcode, 16, 5);
    let E = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fcmgt_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp16_simd(Rd, Rn, ac, Rm, E, U, Q)
}

val decode_fcmgt_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp_simd : (bits(5), bits(5), bits(1), bits(5), bits(1), bits(1), bits(1), bits(1)) -> unit

function decode_fcmgt_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp_simd (Rd, Rn, ac, Rm, sz, E, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    };
    let 'esize = (32 << UInt(sz));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    cmp : CompareOp = undefined;
    abs : bool = undefined;
    match (E @ U) @ ac {
      0b000 => {
          cmp = CompareOp_EQ;
          abs = false
      },
      0b010 => {
          cmp = CompareOp_GE;
          abs = false
      },
      0b011 => {
          cmp = CompareOp_GE;
          abs = true
      },
      0b110 => {
          cmp = CompareOp_GT;
          abs = false
      },
      0b111 => {
          cmp = CompareOp_GT;
          abs = true
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let abs = abs;
    let cmp = cmp;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp16_sisd(abs, cmp, d, datasize, elements, esize, m, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, bitone, _, bitone, _, _, _, _, _, bitone, bitone, bitone, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 238) = {
    SEE = 238;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let ac = Slice(__opcode, 11, 1);
    let Rm = Slice(__opcode, 16, 5);
    let sz = Slice(__opcode, 22, 1);
    let E = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fcmgt_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp_simd(Rd, Rn, ac, Rm, sz, E, U, Q)
}

val execute_aarch64_instrs_vector_arithmetic_binary_uniform_add_fp16 : forall 'd 'datasize 'elements 'esize 'm 'n ('pair : Bool),
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'esize in {16, 32, 64} & 'datasize in {64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('m), int('n), bool('pair)) -> unit

function execute_aarch64_instrs_vector_arithmetic_binary_uniform_add_fp16 (d, datasize, elements, esize, m, n, pair) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = V_read(n, datasize);
    let operand2 : bits('datasize) = V_read(m, datasize);
    result : bits('datasize) = undefined;
    let concat : bits(2 * 'datasize) = operand2 @ operand1;
    element1 : bits('esize) = undefined;
    element2 : bits('esize) = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        if pair then {
            element1 = Elem_read(concat, 2 * e, esize);
            element2 = Elem_read(concat, 2 * e + 1, esize)
        } else {
            element1 = Elem_read(operand1, e, esize);
            element2 = Elem_read(operand2, e, esize)
        };
        result = Elem_set(result, e, esize, FPAdd(element1, element2, FPCR_read()))
    };
    V_set(d, datasize) = result
}

val decode_fadd_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_add_fp16 : (bits(5), bits(5), bits(5), bits(1), bits(1)) -> unit

function decode_fadd_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_add_fp16 (Rd, Rn, Rm, U, Q) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = 16;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let pair : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_add_fp16(d, datasize, elements, esize, m, n, pair)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, bitzero, bitzero, bitzero, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 239) = {
    SEE = 239;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fadd_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_add_fp16(Rd, Rn, Rm, U, Q)
}

val decode_fadd_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_add_fp : (bits(5), bits(5), bits(5), bits(1), bits(1), bits(1)) -> unit

function decode_fadd_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_add_fp (Rd, Rn, Rm, sz, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    };
    let 'esize = (32 << UInt(sz));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let pair : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_add_fp16(d, datasize, elements, esize, m, n, pair)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, _, bitone, _, _, _, _, _, bitone, bitone, bitzero, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 240) = {
    SEE = 240;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let sz = Slice(__opcode, 22, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fadd_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_add_fp(Rd, Rn, Rm, sz, U, Q)
}

val decode_faddp_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_add_fp16 : (bits(5), bits(5), bits(5), bits(1), bits(1)) -> unit

function decode_faddp_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_add_fp16 (Rd, Rn, Rm, U, Q) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = 16;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let pair : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_add_fp16(d, datasize, elements, esize, m, n, pair)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, bitzero, bitzero, bitzero, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 241) = {
    SEE = 241;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_faddp_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_add_fp16(Rd, Rn, Rm, U, Q)
}

val decode_faddp_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_add_fp : (bits(5), bits(5), bits(5), bits(1), bits(1), bits(1)) -> unit

function decode_faddp_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_add_fp (Rd, Rn, Rm, sz, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    };
    let 'esize = (32 << UInt(sz));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let pair : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_add_fp16(d, datasize, elements, esize, m, n, pair)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, bitzero, _, bitone, _, _, _, _, _, bitone, bitone, bitzero, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 242) = {
    SEE = 242;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let sz = Slice(__opcode, 22, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_faddp_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_add_fp(Rd, Rn, Rm, sz, U, Q)
}

val execute_aarch64_instrs_float_arithmetic_add_sub : forall 'd 'esize 'm 'n ('sub_op : Bool),
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'esize in {16, 32, 64} & 0 <= 'd & 'd <= 31).
  (int('d), int('esize), int('m), int('n), bool('sub_op)) -> unit

function execute_aarch64_instrs_float_arithmetic_add_sub (d, esize, m, n, sub_op) = {
    CheckFPEnabled64();
    let operand1 : bits('esize) = V_read(n, esize);
    let operand2 : bits('esize) = V_read(m, esize);
    let fpcr : FPCRType = FPCR_read();
    let merge : bool = IsMerging(fpcr);
    result : bits(128) = if merge then V_read(n, 128) else Zeros(128);
    if sub_op then {
        result = Elem_set(result, 0, esize, FPSub(operand1, operand2, fpcr))
    } else {
        result = Elem_set(result, 0, esize, FPAdd(operand1, operand2, fpcr))
    };
    V_set(d, 128) = result
}

val decode_fadd_float_aarch64_instrs_float_arithmetic_add_sub : (bits(5), bits(5), bits(1), bits(5), bits(2)) -> unit

function decode_fadd_float_aarch64_instrs_float_arithmetic_add_sub (Rd, Rn, op, Rm, ftype) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    esize : {16, 32, 64} = 16;
    match ftype {
      0b00 => {
          esize = 32
      },
      0b01 => {
          esize = 64
      },
      0b10 => {
          throw(Error_Undefined())
      },
      0b11 => {
          if HaveFP16Ext() then {
              esize = 16
          } else {
              throw(Error_Undefined())
          }
      }
    };
    let 'esize = esize;
    let sub_op : bool = op == 0b1;
    execute_aarch64_instrs_float_arithmetic_add_sub(d, esize, m, n, sub_op)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitzero, bitone, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 243) = {
    SEE = 243;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 12, 1);
    let Rm = Slice(__opcode, 16, 5);
    let ftype = Slice(__opcode, 22, 2);
    decode_fadd_float_aarch64_instrs_float_arithmetic_add_sub(Rd, Rn, op, Rm, ftype)
}

val decode_fsub_float_aarch64_instrs_float_arithmetic_add_sub : (bits(5), bits(5), bits(1), bits(5), bits(2)) -> unit

function decode_fsub_float_aarch64_instrs_float_arithmetic_add_sub (Rd, Rn, op, Rm, ftype) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    esize : {16, 32, 64} = 16;
    match ftype {
      0b00 => {
          esize = 32
      },
      0b01 => {
          esize = 64
      },
      0b10 => {
          throw(Error_Undefined())
      },
      0b11 => {
          if HaveFP16Ext() then {
              esize = 16
          } else {
              throw(Error_Undefined())
          }
      }
    };
    let 'esize = esize;
    let sub_op : bool = op == 0b1;
    execute_aarch64_instrs_float_arithmetic_add_sub(d, esize, m, n, sub_op)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 244) = {
    SEE = 244;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 12, 1);
    let Rm = Slice(__opcode, 16, 5);
    let ftype = Slice(__opcode, 22, 2);
    decode_fsub_float_aarch64_instrs_float_arithmetic_add_sub(Rd, Rn, op, Rm, ftype)
}

val execute_aarch64_instrs_vector_reduce_fp16_add_sisd : forall 'd 'datasize 'esize 'n,
  (0 <= 'n & 'n <= 31 & 'esize in {16, 32, 64} & 'datasize in {32, 64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('esize), int('n), ReduceOp) -> unit

function execute_aarch64_instrs_vector_reduce_fp16_add_sisd (d, datasize, esize, n, op) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('datasize) = V_read(n, datasize);
    assert(constraint('datasize >= 'esize));
    V_set(d, esize) = Reduce(op, operand, esize)
}

val decode_faddp_advsimd_pair_aarch64_instrs_vector_reduce_fp16_add_sisd : (bits(5), bits(5), bits(1)) -> unit

function decode_faddp_advsimd_pair_aarch64_instrs_vector_reduce_fp16_add_sisd (Rd, Rn, sz) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = 16;
    if sz == 0b1 then {
        throw(Error_Undefined())
    };
    let 'datasize = esize * 2;
    let 'elements = 2;
    let op : ReduceOp = ReduceOp_FADD;
    execute_aarch64_instrs_vector_reduce_fp16_add_sisd(d, datasize, esize, n, op)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, _, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 245) = {
    SEE = 245;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let sz = Slice(__opcode, 22, 1);
    decode_faddp_advsimd_pair_aarch64_instrs_vector_reduce_fp16_add_sisd(Rd, Rn, sz)
}

val decode_faddp_advsimd_pair_aarch64_instrs_vector_reduce_fp_add_sisd : (bits(5), bits(5), bits(1)) -> unit

function decode_faddp_advsimd_pair_aarch64_instrs_vector_reduce_fp_add_sisd (Rd, Rn, sz) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = (32 << UInt(sz));
    let 'datasize = esize * 2;
    let 'elements = 2;
    let op : ReduceOp = ReduceOp_FADD;
    execute_aarch64_instrs_vector_reduce_fp16_add_sisd(d, datasize, esize, n, op)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, _, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 246) = {
    SEE = 246;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let sz = Slice(__opcode, 22, 1);
    decode_faddp_advsimd_pair_aarch64_instrs_vector_reduce_fp_add_sisd(Rd, Rn, sz)
}

val execute_aarch64_instrs_vector_arithmetic_binary_uniform_add_fp_complex : forall 'd 'datasize 'elements 'esize 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'esize in {8, 16, 32, 64} & 'datasize in {64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('m), int('n), bits(1)) -> unit

function execute_aarch64_instrs_vector_arithmetic_binary_uniform_add_fp_complex (d, datasize, elements, esize, m, n, rot) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = V_read(n, datasize);
    let operand2 : bits('datasize) = V_read(m, datasize);
    result : bits('datasize) = undefined;
    element1 : bits('esize) = undefined;
    element3 : bits('esize) = undefined;
    foreach (e from 0 to (DIV(elements, 2) - 1) by 1 in inc) {
        match rot {
          0b0 => {
              assert(constraint('esize in {16, 32, 64}));
              element1 = FPNeg(Elem_read(operand2, e * 2 + 1, esize));
              element3 = Elem_read(operand2, e * 2, esize)
          },
          0b1 => {
              element1 = Elem_read(operand2, e * 2 + 1, esize);
              assert(constraint('esize in {16, 32, 64}));
              element3 = FPNeg(Elem_read(operand2, e * 2, esize))
          }
        };
        assert(constraint('esize in {16, 32, 64}));
        result = Elem_set(result, e * 2, esize, FPAdd(Elem_read(operand1, e * 2, esize), element1, FPCR_read()));
        result = Elem_set(result, e * 2 + 1, esize, FPAdd(Elem_read(operand1, e * 2 + 1, esize), element3, FPCR_read()))
    };
    V_set(d, datasize) = result
}

val decode_fcadd_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_add_fp_complex : (bits(5), bits(5), bits(1), bits(5), bits(2), bits(1)) -> unit

function decode_fcadd_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_add_fp_complex (Rd, Rn, rot, Rm, size, Q) = {
    if not_bool(HaveFCADDExt()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b00 then {
        throw(Error_Undefined())
    };
    if Q == 0b0 & size == 0b11 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    if not_bool(HaveFP16Ext()) & esize == 16 then {
        throw(Error_Undefined())
    };
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_add_fp_complex(d, datasize, elements, esize, m, n, rot)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, bitzero, _, _, _, _, _, bitone, bitone, bitone, _, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 247) = {
    SEE = 247;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let rot = Slice(__opcode, 12, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let Q = Slice(__opcode, 30, 1);
    decode_fcadd_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_add_fp_complex(Rd, Rn, rot, Rm, size, Q)
}

val execute_aarch64_instrs_float_compare_cond : forall 'datasize 'm 'n ('signal_all_nans : Bool),
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'datasize in {16, 32, 64}).
  (bits(4), int('datasize), bits(4), int('m), int('n), bool('signal_all_nans)) -> unit

function execute_aarch64_instrs_float_compare_cond (condition, datasize, flags__arg, m, n, signal_all_nans) = {
    flags : bits(4) = flags__arg;
    CheckFPEnabled64();
    let operand1 : bits('datasize) = V_read(n, datasize);
    let operand2 : bits('datasize) = V_read(m, datasize);
    taken : bool = false;
    if ConditionHolds(condition) then {
        flags = FPCompare(operand1, operand2, signal_all_nans, FPCR_read());
        taken = true
    };
    (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V) = flags;
    if SPESampleInFlight then {
        let conditional : bool = true;
        SPESampleAddOpOther(conditional, taken)
    };
    ()
}

val decode_fccmp_float_aarch64_instrs_float_compare_cond : (bits(4), bits(1), bits(5), bits(4), bits(5), bits(2)) -> unit

function decode_fccmp_float_aarch64_instrs_float_compare_cond (nzcv, op, Rn, cond, Rm, ftype) = {
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    datasize : {16, 32, 64} = 16;
    match ftype {
      0b00 => {
          datasize = 32
      },
      0b01 => {
          datasize = 64
      },
      0b10 => {
          throw(Error_Undefined())
      },
      0b11 => {
          if HaveFP16Ext() then {
              datasize = 16
          } else {
              throw(Error_Undefined())
          }
      }
    };
    let 'datasize = datasize;
    let signal_all_nans : bool = op == 0b1;
    let condition : bits(4) = cond;
    let flags : bits(4) = nzcv;
    execute_aarch64_instrs_float_compare_cond(condition, datasize, flags, m, n, signal_all_nans)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, _, _, _, _, bitzero, bitone, _, _, _, _, _, bitzero, _, _, _, _] as __opcode)) if SEE < 248) = {
    SEE = 248;
    let nzcv = Slice(__opcode, 0, 4);
    let op = Slice(__opcode, 4, 1);
    let Rn = Slice(__opcode, 5, 5);
    let cond = Slice(__opcode, 12, 4);
    let Rm = Slice(__opcode, 16, 5);
    let ftype = Slice(__opcode, 22, 2);
    decode_fccmp_float_aarch64_instrs_float_compare_cond(nzcv, op, Rn, cond, Rm, ftype)
}

val decode_fccmpe_float_aarch64_instrs_float_compare_cond : (bits(4), bits(1), bits(5), bits(4), bits(5), bits(2)) -> unit

function decode_fccmpe_float_aarch64_instrs_float_compare_cond (nzcv, op, Rn, cond, Rm, ftype) = {
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    datasize : {16, 32, 64} = 16;
    match ftype {
      0b00 => {
          datasize = 32
      },
      0b01 => {
          datasize = 64
      },
      0b10 => {
          throw(Error_Undefined())
      },
      0b11 => {
          if HaveFP16Ext() then {
              datasize = 16
          } else {
              throw(Error_Undefined())
          }
      }
    };
    let 'datasize = datasize;
    let signal_all_nans : bool = op == 0b1;
    let condition : bits(4) = cond;
    let flags : bits(4) = nzcv;
    execute_aarch64_instrs_float_compare_cond(condition, datasize, flags, m, n, signal_all_nans)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, _, _, _, _, bitzero, bitone, _, _, _, _, _, bitone, _, _, _, _] as __opcode)) if SEE < 249) = {
    SEE = 249;
    let nzcv = Slice(__opcode, 0, 4);
    let op = Slice(__opcode, 4, 1);
    let Rn = Slice(__opcode, 5, 5);
    let cond = Slice(__opcode, 12, 4);
    let Rm = Slice(__opcode, 16, 5);
    let ftype = Slice(__opcode, 22, 2);
    decode_fccmpe_float_aarch64_instrs_float_compare_cond(nzcv, op, Rn, cond, Rm, ftype)
}

val execute_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_bulk_sisd : forall 'd 'datasize 'elements 'esize 'n,
  (0 <= 'n & 'n <= 31 & 'esize in {16, 32, 64} & 'datasize in {16, 32, 64, 128} & 0 <= 'd & 'd <= 31).
  (CompareOp, int('d), int('datasize), int('elements), int('esize), int('n)) -> unit

function execute_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_bulk_sisd (comparison, d, datasize, elements, esize, n) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('datasize) = V_read(n, datasize);
    result : bits('datasize) = undefined;
    let zero : bits('esize) = FPZero(0b0, esize);
    element : bits('esize) = undefined;
    test_passed : bool = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element = Elem_read(operand, e, esize);
        match comparison {
          CompareOp_GT => {
              test_passed = FPCompareGT(element, zero, FPCR_read())
          },
          CompareOp_GE => {
              test_passed = FPCompareGE(element, zero, FPCR_read())
          },
          CompareOp_EQ => {
              test_passed = FPCompareEQ(element, zero, FPCR_read())
          },
          CompareOp_LE => {
              test_passed = FPCompareGE(zero, element, FPCR_read())
          },
          CompareOp_LT => {
              test_passed = FPCompareGT(zero, element, FPCR_read())
          }
        };
        result = Elem_set(result, e, esize, if test_passed then Ones(esize) else
          Zeros(esize))
    };
    V_set(d, datasize) = result
}

val decode_fcmeq_advsimd_zero_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_bulk_sisd : (bits(5), bits(5), bits(1), bits(1)) -> unit

function decode_fcmeq_advsimd_zero_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_bulk_sisd (Rd, Rn, op, U) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = 16;
    let 'datasize = esize;
    let 'elements = 1;
    comparison : CompareOp = undefined;
    match op @ U {
      0b00 => {
          comparison = CompareOp_GT
      },
      0b01 => {
          comparison = CompareOp_GE
      },
      0b10 => {
          comparison = CompareOp_EQ
      },
      0b11 => {
          comparison = CompareOp_LE
      }
    };
    let comparison = comparison;
    execute_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_bulk_sisd(comparison, d, datasize, elements, esize, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 250) = {
    SEE = 250;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 12, 1);
    let U = Slice(__opcode, 29, 1);
    decode_fcmeq_advsimd_zero_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_bulk_sisd(Rd, Rn, op, U)
}

val decode_fcmeq_advsimd_zero_aarch64_instrs_vector_arithmetic_unary_cmp_float_bulk_sisd : (bits(5), bits(5), bits(1), bits(1), bits(1)) -> unit

function decode_fcmeq_advsimd_zero_aarch64_instrs_vector_arithmetic_unary_cmp_float_bulk_sisd (Rd, Rn, op, sz, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = (32 << UInt(sz));
    let 'datasize = esize;
    let 'elements = 1;
    comparison : CompareOp = undefined;
    match op @ U {
      0b00 => {
          comparison = CompareOp_GT
      },
      0b01 => {
          comparison = CompareOp_GE
      },
      0b10 => {
          comparison = CompareOp_EQ
      },
      0b11 => {
          comparison = CompareOp_LE
      }
    };
    let comparison = comparison;
    execute_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_bulk_sisd(comparison, d, datasize, elements, esize, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, bitone, _, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 251) = {
    SEE = 251;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 12, 1);
    let sz = Slice(__opcode, 22, 1);
    let U = Slice(__opcode, 29, 1);
    decode_fcmeq_advsimd_zero_aarch64_instrs_vector_arithmetic_unary_cmp_float_bulk_sisd(Rd, Rn, op, sz, U)
}

val decode_fcmeq_advsimd_zero_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_bulk_simd : (bits(5), bits(5), bits(1), bits(1), bits(1)) -> unit

function decode_fcmeq_advsimd_zero_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_bulk_simd (Rd, Rn, op, U, Q) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = 16;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    comparison : CompareOp = undefined;
    match op @ U {
      0b00 => {
          comparison = CompareOp_GT
      },
      0b01 => {
          comparison = CompareOp_GE
      },
      0b10 => {
          comparison = CompareOp_EQ
      },
      0b11 => {
          comparison = CompareOp_LE
      }
    };
    let comparison = comparison;
    execute_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_bulk_sisd(comparison, d, datasize, elements, esize, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 252) = {
    SEE = 252;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 12, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fcmeq_advsimd_zero_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_bulk_simd(Rd, Rn, op, U, Q)
}

val decode_fcmeq_advsimd_zero_aarch64_instrs_vector_arithmetic_unary_cmp_float_bulk_simd : (bits(5), bits(5), bits(1), bits(1), bits(1), bits(1)) -> unit

function decode_fcmeq_advsimd_zero_aarch64_instrs_vector_arithmetic_unary_cmp_float_bulk_simd (Rd, Rn, op, sz, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    };
    let 'esize = (32 << UInt(sz));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    comparison : CompareOp = undefined;
    match op @ U {
      0b00 => {
          comparison = CompareOp_GT
      },
      0b01 => {
          comparison = CompareOp_GE
      },
      0b10 => {
          comparison = CompareOp_EQ
      },
      0b11 => {
          comparison = CompareOp_LE
      }
    };
    let comparison = comparison;
    execute_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_bulk_sisd(comparison, d, datasize, elements, esize, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitone, _, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 253) = {
    SEE = 253;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 12, 1);
    let sz = Slice(__opcode, 22, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fcmeq_advsimd_zero_aarch64_instrs_vector_arithmetic_unary_cmp_float_bulk_simd(Rd, Rn, op, sz, U, Q)
}

val decode_fcmge_advsimd_zero_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_bulk_sisd : (bits(5), bits(5), bits(1), bits(1)) -> unit

function decode_fcmge_advsimd_zero_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_bulk_sisd (Rd, Rn, op, U) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = 16;
    let 'datasize = esize;
    let 'elements = 1;
    comparison : CompareOp = undefined;
    match op @ U {
      0b00 => {
          comparison = CompareOp_GT
      },
      0b01 => {
          comparison = CompareOp_GE
      },
      0b10 => {
          comparison = CompareOp_EQ
      },
      0b11 => {
          comparison = CompareOp_LE
      }
    };
    let comparison = comparison;
    execute_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_bulk_sisd(comparison, d, datasize, elements, esize, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 254) = {
    SEE = 254;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 12, 1);
    let U = Slice(__opcode, 29, 1);
    decode_fcmge_advsimd_zero_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_bulk_sisd(Rd, Rn, op, U)
}

val decode_fcmge_advsimd_zero_aarch64_instrs_vector_arithmetic_unary_cmp_float_bulk_sisd : (bits(5), bits(5), bits(1), bits(1), bits(1)) -> unit

function decode_fcmge_advsimd_zero_aarch64_instrs_vector_arithmetic_unary_cmp_float_bulk_sisd (Rd, Rn, op, sz, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = (32 << UInt(sz));
    let 'datasize = esize;
    let 'elements = 1;
    comparison : CompareOp = undefined;
    match op @ U {
      0b00 => {
          comparison = CompareOp_GT
      },
      0b01 => {
          comparison = CompareOp_GE
      },
      0b10 => {
          comparison = CompareOp_EQ
      },
      0b11 => {
          comparison = CompareOp_LE
      }
    };
    let comparison = comparison;
    execute_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_bulk_sisd(comparison, d, datasize, elements, esize, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, bitone, _, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 255) = {
    SEE = 255;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 12, 1);
    let sz = Slice(__opcode, 22, 1);
    let U = Slice(__opcode, 29, 1);
    decode_fcmge_advsimd_zero_aarch64_instrs_vector_arithmetic_unary_cmp_float_bulk_sisd(Rd, Rn, op, sz, U)
}

val decode_fcmge_advsimd_zero_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_bulk_simd : (bits(5), bits(5), bits(1), bits(1), bits(1)) -> unit

function decode_fcmge_advsimd_zero_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_bulk_simd (Rd, Rn, op, U, Q) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = 16;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    comparison : CompareOp = undefined;
    match op @ U {
      0b00 => {
          comparison = CompareOp_GT
      },
      0b01 => {
          comparison = CompareOp_GE
      },
      0b10 => {
          comparison = CompareOp_EQ
      },
      0b11 => {
          comparison = CompareOp_LE
      }
    };
    let comparison = comparison;
    execute_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_bulk_sisd(comparison, d, datasize, elements, esize, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 256) = {
    SEE = 256;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 12, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fcmge_advsimd_zero_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_bulk_simd(Rd, Rn, op, U, Q)
}

val decode_fcmge_advsimd_zero_aarch64_instrs_vector_arithmetic_unary_cmp_float_bulk_simd : (bits(5), bits(5), bits(1), bits(1), bits(1), bits(1)) -> unit

function decode_fcmge_advsimd_zero_aarch64_instrs_vector_arithmetic_unary_cmp_float_bulk_simd (Rd, Rn, op, sz, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    };
    let 'esize = (32 << UInt(sz));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    comparison : CompareOp = undefined;
    match op @ U {
      0b00 => {
          comparison = CompareOp_GT
      },
      0b01 => {
          comparison = CompareOp_GE
      },
      0b10 => {
          comparison = CompareOp_EQ
      },
      0b11 => {
          comparison = CompareOp_LE
      }
    };
    let comparison = comparison;
    execute_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_bulk_sisd(comparison, d, datasize, elements, esize, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, bitone, _, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 257) = {
    SEE = 257;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 12, 1);
    let sz = Slice(__opcode, 22, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fcmge_advsimd_zero_aarch64_instrs_vector_arithmetic_unary_cmp_float_bulk_simd(Rd, Rn, op, sz, U, Q)
}

val decode_fcmgt_advsimd_zero_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_bulk_sisd : (bits(5), bits(5), bits(1), bits(1)) -> unit

function decode_fcmgt_advsimd_zero_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_bulk_sisd (Rd, Rn, op, U) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = 16;
    let 'datasize = esize;
    let 'elements = 1;
    comparison : CompareOp = undefined;
    match op @ U {
      0b00 => {
          comparison = CompareOp_GT
      },
      0b01 => {
          comparison = CompareOp_GE
      },
      0b10 => {
          comparison = CompareOp_EQ
      },
      0b11 => {
          comparison = CompareOp_LE
      }
    };
    let comparison = comparison;
    execute_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_bulk_sisd(comparison, d, datasize, elements, esize, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 258) = {
    SEE = 258;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 12, 1);
    let U = Slice(__opcode, 29, 1);
    decode_fcmgt_advsimd_zero_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_bulk_sisd(Rd, Rn, op, U)
}

val decode_fcmgt_advsimd_zero_aarch64_instrs_vector_arithmetic_unary_cmp_float_bulk_sisd : (bits(5), bits(5), bits(1), bits(1), bits(1)) -> unit

function decode_fcmgt_advsimd_zero_aarch64_instrs_vector_arithmetic_unary_cmp_float_bulk_sisd (Rd, Rn, op, sz, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = (32 << UInt(sz));
    let 'datasize = esize;
    let 'elements = 1;
    comparison : CompareOp = undefined;
    match op @ U {
      0b00 => {
          comparison = CompareOp_GT
      },
      0b01 => {
          comparison = CompareOp_GE
      },
      0b10 => {
          comparison = CompareOp_EQ
      },
      0b11 => {
          comparison = CompareOp_LE
      }
    };
    let comparison = comparison;
    execute_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_bulk_sisd(comparison, d, datasize, elements, esize, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, bitone, _, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 259) = {
    SEE = 259;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 12, 1);
    let sz = Slice(__opcode, 22, 1);
    let U = Slice(__opcode, 29, 1);
    decode_fcmgt_advsimd_zero_aarch64_instrs_vector_arithmetic_unary_cmp_float_bulk_sisd(Rd, Rn, op, sz, U)
}

val decode_fcmgt_advsimd_zero_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_bulk_simd : (bits(5), bits(5), bits(1), bits(1), bits(1)) -> unit

function decode_fcmgt_advsimd_zero_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_bulk_simd (Rd, Rn, op, U, Q) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = 16;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    comparison : CompareOp = undefined;
    match op @ U {
      0b00 => {
          comparison = CompareOp_GT
      },
      0b01 => {
          comparison = CompareOp_GE
      },
      0b10 => {
          comparison = CompareOp_EQ
      },
      0b11 => {
          comparison = CompareOp_LE
      }
    };
    let comparison = comparison;
    execute_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_bulk_sisd(comparison, d, datasize, elements, esize, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 260) = {
    SEE = 260;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 12, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fcmgt_advsimd_zero_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_bulk_simd(Rd, Rn, op, U, Q)
}

val decode_fcmgt_advsimd_zero_aarch64_instrs_vector_arithmetic_unary_cmp_float_bulk_simd : (bits(5), bits(5), bits(1), bits(1), bits(1), bits(1)) -> unit

function decode_fcmgt_advsimd_zero_aarch64_instrs_vector_arithmetic_unary_cmp_float_bulk_simd (Rd, Rn, op, sz, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    };
    let 'esize = (32 << UInt(sz));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    comparison : CompareOp = undefined;
    match op @ U {
      0b00 => {
          comparison = CompareOp_GT
      },
      0b01 => {
          comparison = CompareOp_GE
      },
      0b10 => {
          comparison = CompareOp_EQ
      },
      0b11 => {
          comparison = CompareOp_LE
      }
    };
    let comparison = comparison;
    execute_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_bulk_sisd(comparison, d, datasize, elements, esize, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitone, _, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 261) = {
    SEE = 261;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 12, 1);
    let sz = Slice(__opcode, 22, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fcmgt_advsimd_zero_aarch64_instrs_vector_arithmetic_unary_cmp_float_bulk_simd(Rd, Rn, op, sz, U, Q)
}

val decode_fcmle_advsimd_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_bulk_sisd : (bits(5), bits(5), bits(1), bits(1)) -> unit

function decode_fcmle_advsimd_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_bulk_sisd (Rd, Rn, op, U) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = 16;
    let 'datasize = esize;
    let 'elements = 1;
    comparison : CompareOp = undefined;
    match op @ U {
      0b00 => {
          comparison = CompareOp_GT
      },
      0b01 => {
          comparison = CompareOp_GE
      },
      0b10 => {
          comparison = CompareOp_EQ
      },
      0b11 => {
          comparison = CompareOp_LE
      }
    };
    let comparison = comparison;
    execute_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_bulk_sisd(comparison, d, datasize, elements, esize, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 262) = {
    SEE = 262;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 12, 1);
    let U = Slice(__opcode, 29, 1);
    decode_fcmle_advsimd_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_bulk_sisd(Rd, Rn, op, U)
}

val decode_fcmle_advsimd_aarch64_instrs_vector_arithmetic_unary_cmp_float_bulk_sisd : (bits(5), bits(5), bits(1), bits(1), bits(1)) -> unit

function decode_fcmle_advsimd_aarch64_instrs_vector_arithmetic_unary_cmp_float_bulk_sisd (Rd, Rn, op, sz, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = (32 << UInt(sz));
    let 'datasize = esize;
    let 'elements = 1;
    comparison : CompareOp = undefined;
    match op @ U {
      0b00 => {
          comparison = CompareOp_GT
      },
      0b01 => {
          comparison = CompareOp_GE
      },
      0b10 => {
          comparison = CompareOp_EQ
      },
      0b11 => {
          comparison = CompareOp_LE
      }
    };
    let comparison = comparison;
    execute_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_bulk_sisd(comparison, d, datasize, elements, esize, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, bitone, _, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 263) = {
    SEE = 263;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 12, 1);
    let sz = Slice(__opcode, 22, 1);
    let U = Slice(__opcode, 29, 1);
    decode_fcmle_advsimd_aarch64_instrs_vector_arithmetic_unary_cmp_float_bulk_sisd(Rd, Rn, op, sz, U)
}

val decode_fcmle_advsimd_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_bulk_simd : (bits(5), bits(5), bits(1), bits(1), bits(1)) -> unit

function decode_fcmle_advsimd_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_bulk_simd (Rd, Rn, op, U, Q) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = 16;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    comparison : CompareOp = undefined;
    match op @ U {
      0b00 => {
          comparison = CompareOp_GT
      },
      0b01 => {
          comparison = CompareOp_GE
      },
      0b10 => {
          comparison = CompareOp_EQ
      },
      0b11 => {
          comparison = CompareOp_LE
      }
    };
    let comparison = comparison;
    execute_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_bulk_sisd(comparison, d, datasize, elements, esize, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 264) = {
    SEE = 264;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 12, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fcmle_advsimd_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_bulk_simd(Rd, Rn, op, U, Q)
}

val decode_fcmle_advsimd_aarch64_instrs_vector_arithmetic_unary_cmp_float_bulk_simd : (bits(5), bits(5), bits(1), bits(1), bits(1), bits(1)) -> unit

function decode_fcmle_advsimd_aarch64_instrs_vector_arithmetic_unary_cmp_float_bulk_simd (Rd, Rn, op, sz, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    };
    let 'esize = (32 << UInt(sz));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    comparison : CompareOp = undefined;
    match op @ U {
      0b00 => {
          comparison = CompareOp_GT
      },
      0b01 => {
          comparison = CompareOp_GE
      },
      0b10 => {
          comparison = CompareOp_EQ
      },
      0b11 => {
          comparison = CompareOp_LE
      }
    };
    let comparison = comparison;
    execute_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_bulk_sisd(comparison, d, datasize, elements, esize, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, bitone, _, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 265) = {
    SEE = 265;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 12, 1);
    let sz = Slice(__opcode, 22, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fcmle_advsimd_aarch64_instrs_vector_arithmetic_unary_cmp_float_bulk_simd(Rd, Rn, op, sz, U, Q)
}

val execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp_complex : forall 'd 'datasize 'elements 'esize 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'esize in {8, 16, 32, 64} & 'datasize in {64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('m), int('n), bits(2)) -> unit

function execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp_complex (d, datasize, elements, esize, m, n, rot) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = V_read(n, datasize);
    let operand2 : bits('datasize) = V_read(m, datasize);
    let operand3 : bits('datasize) = V_read(d, datasize);
    result : bits('datasize) = undefined;
    element1 : bits('esize) = undefined;
    element2 : bits('esize) = undefined;
    element3 : bits('esize) = undefined;
    element4 : bits('esize) = undefined;
    let fpcr : FPCRType = FPCR_read();
    foreach (e from 0 to (DIV(elements, 2) - 1) by 1 in inc) {
        match rot {
          0b00 => {
              element1 = Elem_read(operand2, e * 2, esize);
              element2 = Elem_read(operand1, e * 2, esize);
              element3 = Elem_read(operand2, e * 2 + 1, esize);
              element4 = Elem_read(operand1, e * 2, esize)
          },
          0b01 => {
              assert(constraint('esize in {16, 32, 64}));
              element1 = FPNeg(Elem_read(operand2, e * 2 + 1, esize));
              element2 = Elem_read(operand1, e * 2 + 1, esize);
              element3 = Elem_read(operand2, e * 2, esize);
              element4 = Elem_read(operand1, e * 2 + 1, esize)
          },
          0b10 => {
              assert(constraint('esize in {16, 32, 64}));
              element1 = FPNeg(Elem_read(operand2, e * 2, esize));
              element2 = Elem_read(operand1, e * 2, esize);
              element3 = FPNeg(Elem_read(operand2, e * 2 + 1, esize));
              element4 = Elem_read(operand1, e * 2, esize)
          },
          0b11 => {
              element1 = Elem_read(operand2, e * 2 + 1, esize);
              element2 = Elem_read(operand1, e * 2 + 1, esize);
              assert(constraint('esize in {16, 32, 64}));
              element3 = FPNeg(Elem_read(operand2, e * 2, esize));
              element4 = Elem_read(operand1, e * 2 + 1, esize)
          }
        };
        assert(constraint('esize in {16, 32, 64}));
        result = Elem_set(result, e * 2, esize, FPMulAdd(Elem_read(operand3, e * 2, esize), element2, element1, fpcr));
        result = Elem_set(result, e * 2 + 1, esize, FPMulAdd(Elem_read(operand3, e * 2 + 1, esize), element4, element3, fpcr))
    };
    V_set(d, datasize) = result
}

val decode_fcmla_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp_complex : (bits(5), bits(5), bits(2), bits(5), bits(2), bits(1)) -> unit

function decode_fcmla_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp_complex (Rd, Rn, rot, Rm, size, Q) = {
    if not_bool(HaveFCADDExt()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b00 then {
        throw(Error_Undefined())
    };
    if Q == 0b0 & size == 0b11 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    if not_bool(HaveFP16Ext()) & esize == 16 then {
        throw(Error_Undefined())
    };
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp_complex(d, datasize, elements, esize, m, n, rot)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, bitzero, _, _, _, _, _, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 266) = {
    SEE = 266;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let rot = Slice(__opcode, 11, 2);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let Q = Slice(__opcode, 30, 1);
    decode_fcmla_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp_complex(Rd, Rn, rot, Rm, size, Q)
}

val execute_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_complex : forall 'd 'datasize 'elements 'esize 'index 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'index in {0, 1, 2, 3} & 'esize in {8, 16, 32, 64} & 'datasize in {64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('index), int('m), int('n), bits(2)) -> unit

function execute_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_complex (d, datasize, elements, esize, index, m, n, rot) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = V_read(n, datasize);
    let operand2 : bits('datasize) = V_read(m, datasize);
    let operand3 : bits('datasize) = V_read(d, datasize);
    result : bits('datasize) = undefined;
    let fpcr : FPCRType = FPCR_read();
    foreach (e from 0 to (DIV(elements, 2) - 1) by 1 in inc) {
        element1 : bits('esize) = undefined;
        element2 : bits('esize) = undefined;
        element3 : bits('esize) = undefined;
        element4 : bits('esize) = undefined;
        match rot {
          0b00 => {
              element1 = Elem_read(operand2, index * 2, esize);
              element2 = Elem_read(operand1, e * 2, esize);
              element3 = Elem_read(operand2, index * 2 + 1, esize);
              element4 = Elem_read(operand1, e * 2, esize)
          },
          0b01 => {
              assert(constraint('esize in {16, 32, 64}));
              element1 = FPNeg(Elem_read(operand2, index * 2 + 1, esize));
              element2 = Elem_read(operand1, e * 2 + 1, esize);
              element3 = Elem_read(operand2, index * 2, esize);
              element4 = Elem_read(operand1, e * 2 + 1, esize)
          },
          0b10 => {
              assert(constraint('esize in {16, 32, 64}));
              element1 = FPNeg(Elem_read(operand2, index * 2, esize));
              element2 = Elem_read(operand1, e * 2, esize);
              element3 = FPNeg(Elem_read(operand2, index * 2 + 1, esize));
              element4 = Elem_read(operand1, e * 2, esize)
          },
          0b11 => {
              element1 = Elem_read(operand2, index * 2 + 1, esize);
              element2 = Elem_read(operand1, e * 2 + 1, esize);
              assert(constraint('esize in {16, 32, 64}));
              element3 = FPNeg(Elem_read(operand2, index * 2, esize));
              element4 = Elem_read(operand1, e * 2 + 1, esize)
          }
        };
        let element4 = element4;
        let element3 = element3;
        let element2 = element2;
        let element1 = element1;
        assert(constraint('esize in {16, 32, 64}));
        result = Elem_set(result, e * 2, esize, FPMulAdd(Elem_read(operand3, e * 2, esize), element2, element1, fpcr));
        result = Elem_set(result, e * 2 + 1, esize, FPMulAdd(Elem_read(operand3, e * 2 + 1, esize), element4, element3, fpcr))
    };
    V_set(d, datasize) = result
}

val decode_fcmla_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_complex : (bits(5), bits(5), bits(1), bits(2), bits(4), bits(1), bits(1), bits(2), bits(1)) -> unit

function decode_fcmla_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_complex (Rd, Rn, H, rot, Rm, M, L, size, Q) = {
    if not_bool(HaveFCADDExt()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(M @ Rm);
    index : int = undefined;
    if size == 0b00 | size == 0b11 then {
        throw(Error_Undefined())
    };
    if size == 0b01 then {
        index = UInt(H @ L)
    };
    if size == 0b10 then {
        index = UInt(H)
    };
    let 'index = index;
    let 'esize = (8 << UInt(size));
    if not_bool(HaveFP16Ext()) & esize == 16 then {
        throw(Error_Undefined())
    };
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    if size == 0b10 & (L == 0b1 | Q == 0b0) then {
        throw(Error_Undefined())
    };
    if (size == 0b01 & H == 0b1) & Q == 0b0 then {
        throw(Error_Undefined())
    };
    assert(constraint('index in {0, 1, 2, 3}));
    execute_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_complex(d, datasize, elements, esize, index, m, n, rot)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, bitzero, _, _, bitone, _, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 267) = {
    SEE = 267;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let H = Slice(__opcode, 11, 1);
    let rot = Slice(__opcode, 13, 2);
    let Rm = Slice(__opcode, 16, 4);
    let M = Slice(__opcode, 20, 1);
    let L = Slice(__opcode, 21, 1);
    let size = Slice(__opcode, 22, 2);
    let Q = Slice(__opcode, 30, 1);
    decode_fcmla_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_complex(Rd, Rn, H, rot, Rm, M, L, size, Q)
}

val execute_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_lessthan_sisd : forall 'd 'datasize 'elements 'esize 'n,
  (0 <= 'n & 'n <= 31 & 'esize in {16, 32, 64} & 'datasize in {16, 32, 64, 128} & 0 <= 'd & 'd <= 31).
  (CompareOp, int('d), int('datasize), int('elements), int('esize), int('n)) -> unit

function execute_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_lessthan_sisd (comparison, d, datasize, elements, esize, n) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('datasize) = V_read(n, datasize);
    result : bits('datasize) = undefined;
    let zero : bits('esize) = FPZero(0b0, esize);
    element : bits('esize) = undefined;
    test_passed : bool = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element = Elem_read(operand, e, esize);
        match comparison {
          CompareOp_GT => {
              test_passed = FPCompareGT(element, zero, FPCR_read())
          },
          CompareOp_GE => {
              test_passed = FPCompareGE(element, zero, FPCR_read())
          },
          CompareOp_EQ => {
              test_passed = FPCompareEQ(element, zero, FPCR_read())
          },
          CompareOp_LE => {
              test_passed = FPCompareGE(zero, element, FPCR_read())
          },
          CompareOp_LT => {
              test_passed = FPCompareGT(zero, element, FPCR_read())
          }
        };
        result = Elem_set(result, e, esize, if test_passed then Ones(esize) else
          Zeros(esize))
    };
    V_set(d, datasize) = result
}

val decode_fcmlt_advsimd_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_lessthan_sisd : (bits(5), bits(5)) -> unit

function decode_fcmlt_advsimd_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_lessthan_sisd (Rd, Rn) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = 16;
    let 'datasize = esize;
    let 'elements = 1;
    let comparison : CompareOp = CompareOp_LT;
    execute_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_lessthan_sisd(comparison, d, datasize, elements, esize, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 268) = {
    SEE = 268;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    decode_fcmlt_advsimd_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_lessthan_sisd(Rd, Rn)
}

val decode_fcmlt_advsimd_aarch64_instrs_vector_arithmetic_unary_cmp_float_lessthan_sisd : (bits(5), bits(5), bits(1)) -> unit

function decode_fcmlt_advsimd_aarch64_instrs_vector_arithmetic_unary_cmp_float_lessthan_sisd (Rd, Rn, sz) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = (32 << UInt(sz));
    let 'datasize = esize;
    let 'elements = 1;
    let comparison : CompareOp = CompareOp_LT;
    execute_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_lessthan_sisd(comparison, d, datasize, elements, esize, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, bitone, _, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 269) = {
    SEE = 269;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let sz = Slice(__opcode, 22, 1);
    decode_fcmlt_advsimd_aarch64_instrs_vector_arithmetic_unary_cmp_float_lessthan_sisd(Rd, Rn, sz)
}

val decode_fcmlt_advsimd_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_lessthan_simd : (bits(5), bits(5), bits(1)) -> unit

function decode_fcmlt_advsimd_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_lessthan_simd (Rd, Rn, Q) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = 16;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let comparison : CompareOp = CompareOp_LT;
    execute_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_lessthan_sisd(comparison, d, datasize, elements, esize, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 270) = {
    SEE = 270;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Q = Slice(__opcode, 30, 1);
    decode_fcmlt_advsimd_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_lessthan_simd(Rd, Rn, Q)
}

val decode_fcmlt_advsimd_aarch64_instrs_vector_arithmetic_unary_cmp_float_lessthan_simd : (bits(5), bits(5), bits(1), bits(1)) -> unit

function decode_fcmlt_advsimd_aarch64_instrs_vector_arithmetic_unary_cmp_float_lessthan_simd (Rd, Rn, sz, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    };
    let 'esize = (32 << UInt(sz));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let comparison : CompareOp = CompareOp_LT;
    execute_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_lessthan_sisd(comparison, d, datasize, elements, esize, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitone, _, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 271) = {
    SEE = 271;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let sz = Slice(__opcode, 22, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fcmlt_advsimd_aarch64_instrs_vector_arithmetic_unary_cmp_float_lessthan_simd(Rd, Rn, sz, Q)
}

val execute_aarch64_instrs_float_compare_uncond : forall ('cmp_with_zero : Bool) 'datasize 'm 'n ('signal_all_nans : Bool),
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'datasize in {16, 32, 64}).
  (bool('cmp_with_zero), int('datasize), int('m), int('n), bool('signal_all_nans)) -> unit

function execute_aarch64_instrs_float_compare_uncond (cmp_with_zero, datasize, m, n, signal_all_nans) = {
    CheckFPEnabled64();
    let operand1 : bits('datasize) = V_read(n, datasize);
    let operand2 : bits('datasize) = if cmp_with_zero then FPZero(0b0, datasize)
    else
      V_read(m, datasize);
    (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V) = FPCompare(operand1, operand2, signal_all_nans, FPCR_read())
}

val decode_fcmp_float_aarch64_instrs_float_compare_uncond : (bits(2), bits(5), bits(5), bits(2)) -> unit

function decode_fcmp_float_aarch64_instrs_float_compare_uncond (opc, Rn, Rm, ftype) = {
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    datasize : {16, 32, 64} = 16;
    match ftype {
      0b00 => {
          datasize = 32
      },
      0b01 => {
          datasize = 64
      },
      0b10 => {
          throw(Error_Undefined())
      },
      0b11 => {
          if HaveFP16Ext() then {
              datasize = 16
          } else {
              throw(Error_Undefined())
          }
      }
    };
    let 'datasize = datasize;
    let signal_all_nans : bool = [opc[1]] == 0b1;
    let cmp_with_zero : bool = [opc[0]] == 0b1;
    execute_aarch64_instrs_float_compare_uncond(cmp_with_zero, datasize, m, n, signal_all_nans)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, _, _, _, _, _, bitzero, _, bitzero, bitzero, bitzero] as __opcode)) if SEE < 272) = {
    SEE = 272;
    let opc = Slice(__opcode, 3, 2);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let ftype = Slice(__opcode, 22, 2);
    decode_fcmp_float_aarch64_instrs_float_compare_uncond(opc, Rn, Rm, ftype)
}

val decode_fcmpe_float_aarch64_instrs_float_compare_uncond : (bits(2), bits(5), bits(5), bits(2)) -> unit

function decode_fcmpe_float_aarch64_instrs_float_compare_uncond (opc, Rn, Rm, ftype) = {
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    datasize : {16, 32, 64} = 16;
    match ftype {
      0b00 => {
          datasize = 32
      },
      0b01 => {
          datasize = 64
      },
      0b10 => {
          throw(Error_Undefined())
      },
      0b11 => {
          if HaveFP16Ext() then {
              datasize = 16
          } else {
              throw(Error_Undefined())
          }
      }
    };
    let 'datasize = datasize;
    let signal_all_nans : bool = [opc[1]] == 0b1;
    let cmp_with_zero : bool = [opc[0]] == 0b1;
    execute_aarch64_instrs_float_compare_uncond(cmp_with_zero, datasize, m, n, signal_all_nans)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, _, _, _, _, _, bitone, _, bitzero, bitzero, bitzero] as __opcode)) if SEE < 273) = {
    SEE = 273;
    let opc = Slice(__opcode, 3, 2);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let ftype = Slice(__opcode, 22, 2);
    decode_fcmpe_float_aarch64_instrs_float_compare_uncond(opc, Rn, Rm, ftype)
}

val execute_aarch64_instrs_float_move_fp_select : forall 'd 'datasize 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'datasize in {16, 32, 64} & 0 <= 'd & 'd <= 31).
  (bits(4), int('d), int('datasize), int('m), int('n)) -> unit

function execute_aarch64_instrs_float_move_fp_select (condition, d, datasize, m, n) = {
    CheckFPEnabled64();
    let result : bits('datasize) = if ConditionHolds(condition) then
      V_read(n, datasize)
    else
      V_read(m, datasize);
    V_set(d, datasize) = result
}

val decode_fcsel_float_aarch64_instrs_float_move_fp_select : (bits(5), bits(5), bits(4), bits(5), bits(2)) -> unit

function decode_fcsel_float_aarch64_instrs_float_move_fp_select (Rd, Rn, cond, Rm, ftype) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    datasize : {16, 32, 64} = 16;
    match ftype {
      0b00 => {
          datasize = 32
      },
      0b01 => {
          datasize = 64
      },
      0b10 => {
          throw(Error_Undefined())
      },
      0b11 => {
          if HaveFP16Ext() then {
              datasize = 16
          } else {
              throw(Error_Undefined())
          }
      }
    };
    let 'datasize = datasize;
    let condition : bits(4) = cond;
    execute_aarch64_instrs_float_move_fp_select(condition, d, datasize, m, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, _, _, _, _, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 274) = {
    SEE = 274;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let cond = Slice(__opcode, 12, 4);
    let Rm = Slice(__opcode, 16, 5);
    let ftype = Slice(__opcode, 22, 2);
    decode_fcsel_float_aarch64_instrs_float_move_fp_select(Rd, Rn, cond, Rm, ftype)
}

val execute_aarch64_instrs_float_convert_fp : forall 'd 'dstsize 'n 'srcsize,
  ('srcsize in {16, 32, 64} & 0 <= 'n & 'n <= 31 & 'dstsize in {16, 32, 64} & 0 <= 'd & 'd <= 31).
  (int('d), int('dstsize), int('n), int('srcsize)) -> unit

function execute_aarch64_instrs_float_convert_fp (d, dstsize, n, srcsize) = {
    CheckFPEnabled64();
    let operand : bits('srcsize) = V_read(n, srcsize);
    let fpcr : FPCRType = FPCR_read();
    let merge : bool = IsMerging(fpcr);
    result : bits(128) = if merge then V_read(d, 128) else Zeros(128);
    result = Elem_set(result, 0, dstsize, FPConvert__1(operand, fpcr, dstsize));
    V_set(d, 128) = result
}

val decode_fcvt_float_aarch64_instrs_float_convert_fp : (bits(5), bits(5), bits(2), bits(2)) -> unit

function decode_fcvt_float_aarch64_instrs_float_convert_fp (Rd, Rn, opc, ftype) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    srcsize : {16, 32, 64} = 16;
    dstsize : {16, 32, 64} = 16;
    if ftype == opc then {
        throw(Error_Undefined())
    };
    match ftype {
      0b00 => {
          srcsize = 32
      },
      0b01 => {
          srcsize = 64
      },
      0b10 => {
          throw(Error_Undefined())
      },
      0b11 => {
          srcsize = 16
      }
    };
    let 'srcsize = srcsize;
    match opc {
      0b00 => {
          dstsize = 32
      },
      0b01 => {
          dstsize = 64
      },
      0b10 => {
          throw(Error_Undefined())
      },
      0b11 => {
          dstsize = 16
      }
    };
    let 'dstsize = dstsize;
    execute_aarch64_instrs_float_convert_fp(d, dstsize, n, srcsize)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, bitzero, bitzero, bitzero, bitone, _, _, bitone, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 275) = {
    SEE = 275;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let opc = Slice(__opcode, 15, 2);
    let ftype = Slice(__opcode, 22, 2);
    decode_fcvt_float_aarch64_instrs_float_convert_fp(Rd, Rn, opc, ftype)
}

val execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_tieaway_sisd : forall 'd 'datasize 'elements 'esize ('is_unsigned : Bool) 'n,
  (0 <= 'n & 'n <= 31 & 'esize in {16, 32, 64} & 'datasize in {16, 32, 64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('n), FPRounding, bool('is_unsigned)) -> unit

function execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_tieaway_sisd (d, datasize, elements, esize, n, rounding, is_unsigned) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('datasize) = V_read(n, datasize);
    element : bits('esize) = undefined;
    let fpcr : FPCRType = FPCR_read();
    let merge : bool = elements == 1 & IsMerging(fpcr);
    result : bits(128) = if merge then V_read(d, 128) else Zeros(128);
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element = Elem_read(operand, e, esize);
        result = Elem_set(result, e, esize, FPToFixed(element, 0, is_unsigned, fpcr, rounding, esize))
    };
    V_set(d, 128) = result
}

val decode_fcvtas_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_tieaway_sisd : (bits(5), bits(5), bits(1)) -> unit

function decode_fcvtas_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_tieaway_sisd (Rd, Rn, U) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = 16;
    let 'datasize = esize;
    let 'elements = 1;
    let rounding : FPRounding = FPRounding_TIEAWAY;
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_tieaway_sisd(d, datasize, elements, esize, n, rounding, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 276) = {
    SEE = 276;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let U = Slice(__opcode, 29, 1);
    decode_fcvtas_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_tieaway_sisd(Rd, Rn, U)
}

val decode_fcvtas_advsimd_aarch64_instrs_vector_arithmetic_unary_float_conv_float_tieaway_sisd : (bits(5), bits(5), bits(1), bits(1)) -> unit

function decode_fcvtas_advsimd_aarch64_instrs_vector_arithmetic_unary_float_conv_float_tieaway_sisd (Rd, Rn, sz, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = (32 << UInt(sz));
    let 'datasize = esize;
    let 'elements = 1;
    let rounding : FPRounding = FPRounding_TIEAWAY;
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_tieaway_sisd(d, datasize, elements, esize, n, rounding, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 277) = {
    SEE = 277;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let sz = Slice(__opcode, 22, 1);
    let U = Slice(__opcode, 29, 1);
    decode_fcvtas_advsimd_aarch64_instrs_vector_arithmetic_unary_float_conv_float_tieaway_sisd(Rd, Rn, sz, U)
}

val decode_fcvtas_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_tieaway_simd : (bits(5), bits(5), bits(1), bits(1)) -> unit

function decode_fcvtas_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_tieaway_simd (Rd, Rn, U, Q) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = 16;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let rounding : FPRounding = FPRounding_TIEAWAY;
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_tieaway_sisd(d, datasize, elements, esize, n, rounding, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 278) = {
    SEE = 278;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fcvtas_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_tieaway_simd(Rd, Rn, U, Q)
}

val decode_fcvtas_advsimd_aarch64_instrs_vector_arithmetic_unary_float_conv_float_tieaway_simd : (bits(5), bits(5), bits(1), bits(1), bits(1)) -> unit

function decode_fcvtas_advsimd_aarch64_instrs_vector_arithmetic_unary_float_conv_float_tieaway_simd (Rd, Rn, sz, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    };
    let 'esize = (32 << UInt(sz));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let rounding : FPRounding = FPRounding_TIEAWAY;
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_tieaway_sisd(d, datasize, elements, esize, n, rounding, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 279) = {
    SEE = 279;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let sz = Slice(__opcode, 22, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fcvtas_advsimd_aarch64_instrs_vector_arithmetic_unary_float_conv_float_tieaway_simd(Rd, Rn, sz, U, Q)
}

val decode_fcvtau_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_tieaway_sisd : (bits(5), bits(5), bits(1)) -> unit

function decode_fcvtau_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_tieaway_sisd (Rd, Rn, U) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = 16;
    let 'datasize = esize;
    let 'elements = 1;
    let rounding : FPRounding = FPRounding_TIEAWAY;
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_tieaway_sisd(d, datasize, elements, esize, n, rounding, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 280) = {
    SEE = 280;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let U = Slice(__opcode, 29, 1);
    decode_fcvtau_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_tieaway_sisd(Rd, Rn, U)
}

val decode_fcvtau_advsimd_aarch64_instrs_vector_arithmetic_unary_float_conv_float_tieaway_sisd : (bits(5), bits(5), bits(1), bits(1)) -> unit

function decode_fcvtau_advsimd_aarch64_instrs_vector_arithmetic_unary_float_conv_float_tieaway_sisd (Rd, Rn, sz, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = (32 << UInt(sz));
    let 'datasize = esize;
    let 'elements = 1;
    let rounding : FPRounding = FPRounding_TIEAWAY;
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_tieaway_sisd(d, datasize, elements, esize, n, rounding, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 281) = {
    SEE = 281;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let sz = Slice(__opcode, 22, 1);
    let U = Slice(__opcode, 29, 1);
    decode_fcvtau_advsimd_aarch64_instrs_vector_arithmetic_unary_float_conv_float_tieaway_sisd(Rd, Rn, sz, U)
}

val decode_fcvtau_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_tieaway_simd : (bits(5), bits(5), bits(1), bits(1)) -> unit

function decode_fcvtau_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_tieaway_simd (Rd, Rn, U, Q) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = 16;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let rounding : FPRounding = FPRounding_TIEAWAY;
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_tieaway_sisd(d, datasize, elements, esize, n, rounding, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 282) = {
    SEE = 282;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fcvtau_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_tieaway_simd(Rd, Rn, U, Q)
}

val decode_fcvtau_advsimd_aarch64_instrs_vector_arithmetic_unary_float_conv_float_tieaway_simd : (bits(5), bits(5), bits(1), bits(1), bits(1)) -> unit

function decode_fcvtau_advsimd_aarch64_instrs_vector_arithmetic_unary_float_conv_float_tieaway_simd (Rd, Rn, sz, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    };
    let 'esize = (32 << UInt(sz));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let rounding : FPRounding = FPRounding_TIEAWAY;
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_tieaway_sisd(d, datasize, elements, esize, n, rounding, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, bitzero, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 283) = {
    SEE = 283;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let sz = Slice(__opcode, 22, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fcvtau_advsimd_aarch64_instrs_vector_arithmetic_unary_float_conv_float_tieaway_simd(Rd, Rn, sz, U, Q)
}

val execute_aarch64_instrs_float_convert_int : forall 'd 'fltsize 'intsize ('is_unsigned : Bool) 'n 'part,
  ('part in {0, 1} & 0 <= 'n & 'n <= 31 & 'intsize in {32, 64} & 'fltsize in {16, 32, 64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('fltsize), int('intsize), int('n), FPConvOp, int('part), FPRounding, bool('is_unsigned)) -> unit

function execute_aarch64_instrs_float_convert_int (d, fltsize, intsize, n, op, part, rounding, is_unsigned) = {
    if op == FPConvOp_CVT_FtoI_JS then {
        CheckFPAdvSIMDEnabled64()
    } else {
        CheckFPEnabled64()
    };
    let fpcr : FPCRType = FPCR_read();
    let merge : bool = IsMerging(fpcr);
    let 'fsize = if op == FPConvOp_CVT_ItoF & merge then 128 else fltsize;
    fltval : bits('fsize) = undefined;
    intval : bits('intsize) = undefined;
    match op {
      FPConvOp_CVT_FtoI => {
          let fltval : bits('fsize) = V_read(n, fsize);
          assert(constraint(('fsize in {16, 32, 64} & 'intsize in {16, 32, 64})));
          let intval : bits('intsize) = FPToFixed(fltval, 0, is_unsigned, fpcr, rounding, intsize);
          X_set(d, intsize) = intval
      },
      FPConvOp_CVT_ItoF => {
          let intval : bits('intsize) = X_read(n, intsize);
          fltval : bits('fsize) = if merge then V_read(d, fsize) else
            Zeros(fsize);
          assert(constraint(('fltsize in {16, 32, 64} & 'intsize in {16, 32, 64})));
          fltval = Elem_set(fltval, 0, fltsize, FixedToFP(intval, 0, is_unsigned, fpcr, rounding, fltsize));
          V_set(d, fsize) = fltval
      },
      FPConvOp_MOV_FtoI => {
          let fltval : bits('fsize) = Vpart_read(n, part, fsize);
          assert(constraint(('fsize >= 0 & 'intsize >= 'fsize)));
          let intval : bits('intsize) = ZeroExtend(fltval, intsize);
          X_set(d, intsize) = intval
      },
      FPConvOp_MOV_ItoF => {
          let intval : bits('intsize) = X_read(n, intsize);
          assert(constraint((0 <= 'fsize - 1 & 'fsize - 1 < 'intsize)));
          let fltval : bits('fsize) = intval[fsize - 1 .. 0];
          Vpart_set(d, part, fsize) = fltval
      },
      FPConvOp_CVT_FtoI_JS => {
          z : bits(1) = undefined;
          let fltval : bits('fsize) = V_read(n, fsize);
          assert(constraint('fsize == 64));
          assert(constraint('intsize == 32));
          (intval, z) = FPToFixedJS(fltval, fpcr, true, intsize);
          (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V) = (0b0 @ z) @ 0b00;
          X_set(d, intsize) = intval
      }
    }
}

val decode_fcvtas_float_aarch64_instrs_float_convert_int : (bits(5), bits(5), bits(3), bits(2), bits(2), bits(1)) -> unit

function decode_fcvtas_float_aarch64_instrs_float_convert_int (Rd, Rn, opcode, rmode, ftype, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'intsize = if sf == 0b1 then 64 else 32;
    fltsize : {16, 32, 64, 128} = 16;
    op : FPConvOp = undefined;
    rounding : FPRounding = undefined;
    is_unsigned : bool = undefined;
    part : {0, 1} = 0;
    match ftype {
      0b00 => {
          fltsize = 32
      },
      0b01 => {
          fltsize = 64
      },
      0b10 => {
          if (opcode[2 .. 1] @ rmode) != 0b1101 then {
              throw(Error_Undefined())
          };
          fltsize = 128
      },
      0b11 => {
          if HaveFP16Ext() then {
              fltsize = 16
          } else {
              throw(Error_Undefined())
          }
      }
    };
    match opcode[2 .. 1] @ rmode {
      [bitzero, bitzero, _, _] => {
          rounding = FPDecodeRounding(rmode);
          is_unsigned = [opcode[0]] == 0b1;
          op = FPConvOp_CVT_FtoI
      },
      0b0100 => {
          rounding = FPRoundingMode(FPCR_read());
          is_unsigned = [opcode[0]] == 0b1;
          op = FPConvOp_CVT_ItoF
      },
      0b1000 => {
          rounding = FPRounding_TIEAWAY;
          is_unsigned = [opcode[0]] == 0b1;
          op = FPConvOp_CVT_FtoI
      },
      0b1100 => {
          if fltsize != 16 & fltsize != intsize then {
              throw(Error_Undefined())
          };
          op = if [opcode[0]] == 0b1 then FPConvOp_MOV_ItoF else
            FPConvOp_MOV_FtoI;
          part = 0
      },
      0b1101 => {
          if intsize != 64 | fltsize != 128 then {
              throw(Error_Undefined())
          };
          op = if [opcode[0]] == 0b1 then FPConvOp_MOV_ItoF else
            FPConvOp_MOV_FtoI;
          part = 1;
          fltsize = 64
      },
      0b1111 => {
          if not_bool(HaveFJCVTZSExt()) then {
              throw(Error_Undefined())
          };
          rounding = FPRounding_ZERO;
          is_unsigned = [opcode[0]] == 0b1;
          op = FPConvOp_CVT_FtoI_JS
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let op = op;
    let 'part = part;
    let 'fltsize = fltsize;
    match fltsize {
      16 => {
          execute_aarch64_instrs_float_convert_int(d, 16, intsize, n, op, part, rounding, is_unsigned)
      },
      32 => {
          execute_aarch64_instrs_float_convert_int(d, 32, intsize, n, op, part, rounding, is_unsigned)
      },
      64 => {
          execute_aarch64_instrs_float_convert_int(d, 64, intsize, n, op, part, rounding, is_unsigned)
      },
      128 => {
          execute_aarch64_instrs_float_convert_int(d, 128, intsize, n, op, part, rounding, is_unsigned)
      },
      _ => {
          assert(false)
      }
    }
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([_, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 284) = {
    SEE = 284;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let opcode = Slice(__opcode, 16, 3);
    let rmode = Slice(__opcode, 19, 2);
    let ftype = Slice(__opcode, 22, 2);
    let sf = Slice(__opcode, 31, 1);
    decode_fcvtas_float_aarch64_instrs_float_convert_int(Rd, Rn, opcode, rmode, ftype, sf)
}

val decode_fcvtau_float_aarch64_instrs_float_convert_int : (bits(5), bits(5), bits(3), bits(2), bits(2), bits(1)) -> unit

function decode_fcvtau_float_aarch64_instrs_float_convert_int (Rd, Rn, opcode, rmode, ftype, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'intsize = if sf == 0b1 then 64 else 32;
    fltsize : {16, 32, 64, 128} = 16;
    op : FPConvOp = undefined;
    rounding : FPRounding = undefined;
    is_unsigned : bool = undefined;
    part : {0, 1} = 0;
    match ftype {
      0b00 => {
          fltsize = 32
      },
      0b01 => {
          fltsize = 64
      },
      0b10 => {
          if (opcode[2 .. 1] @ rmode) != 0b1101 then {
              throw(Error_Undefined())
          };
          fltsize = 128
      },
      0b11 => {
          if HaveFP16Ext() then {
              fltsize = 16
          } else {
              throw(Error_Undefined())
          }
      }
    };
    match opcode[2 .. 1] @ rmode {
      [bitzero, bitzero, _, _] => {
          rounding = FPDecodeRounding(rmode);
          is_unsigned = [opcode[0]] == 0b1;
          op = FPConvOp_CVT_FtoI
      },
      0b0100 => {
          rounding = FPRoundingMode(FPCR_read());
          is_unsigned = [opcode[0]] == 0b1;
          op = FPConvOp_CVT_ItoF
      },
      0b1000 => {
          rounding = FPRounding_TIEAWAY;
          is_unsigned = [opcode[0]] == 0b1;
          op = FPConvOp_CVT_FtoI
      },
      0b1100 => {
          if fltsize != 16 & fltsize != intsize then {
              throw(Error_Undefined())
          };
          op = if [opcode[0]] == 0b1 then FPConvOp_MOV_ItoF else
            FPConvOp_MOV_FtoI;
          part = 0
      },
      0b1101 => {
          if intsize != 64 | fltsize != 128 then {
              throw(Error_Undefined())
          };
          op = if [opcode[0]] == 0b1 then FPConvOp_MOV_ItoF else
            FPConvOp_MOV_FtoI;
          part = 1;
          fltsize = 64
      },
      0b1111 => {
          if not_bool(HaveFJCVTZSExt()) then {
              throw(Error_Undefined())
          };
          rounding = FPRounding_ZERO;
          is_unsigned = [opcode[0]] == 0b1;
          op = FPConvOp_CVT_FtoI_JS
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let op = op;
    let 'part = part;
    let 'fltsize = fltsize;
    match fltsize {
      16 => {
          execute_aarch64_instrs_float_convert_int(d, 16, intsize, n, op, part, rounding, is_unsigned)
      },
      32 => {
          execute_aarch64_instrs_float_convert_int(d, 32, intsize, n, op, part, rounding, is_unsigned)
      },
      64 => {
          execute_aarch64_instrs_float_convert_int(d, 64, intsize, n, op, part, rounding, is_unsigned)
      },
      128 => {
          execute_aarch64_instrs_float_convert_int(d, 128, intsize, n, op, part, rounding, is_unsigned)
      },
      _ => {
          assert(false)
      }
    }
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([_, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, bitzero, bitzero, bitone, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 285) = {
    SEE = 285;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let opcode = Slice(__opcode, 16, 3);
    let rmode = Slice(__opcode, 19, 2);
    let ftype = Slice(__opcode, 22, 2);
    let sf = Slice(__opcode, 31, 1);
    decode_fcvtau_float_aarch64_instrs_float_convert_int(Rd, Rn, opcode, rmode, ftype, sf)
}

val decode_fcvtms_float_aarch64_instrs_float_convert_int : (bits(5), bits(5), bits(3), bits(2), bits(2), bits(1)) -> unit

function decode_fcvtms_float_aarch64_instrs_float_convert_int (Rd, Rn, opcode, rmode, ftype, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'intsize = if sf == 0b1 then 64 else 32;
    fltsize : {16, 32, 64, 128} = 16;
    op : FPConvOp = undefined;
    rounding : FPRounding = undefined;
    is_unsigned : bool = undefined;
    part : {0, 1} = 0;
    match ftype {
      0b00 => {
          fltsize = 32
      },
      0b01 => {
          fltsize = 64
      },
      0b10 => {
          if (opcode[2 .. 1] @ rmode) != 0b1101 then {
              throw(Error_Undefined())
          };
          fltsize = 128
      },
      0b11 => {
          if HaveFP16Ext() then {
              fltsize = 16
          } else {
              throw(Error_Undefined())
          }
      }
    };
    match opcode[2 .. 1] @ rmode {
      [bitzero, bitzero, _, _] => {
          rounding = FPDecodeRounding(rmode);
          is_unsigned = [opcode[0]] == 0b1;
          op = FPConvOp_CVT_FtoI
      },
      0b0100 => {
          rounding = FPRoundingMode(FPCR_read());
          is_unsigned = [opcode[0]] == 0b1;
          op = FPConvOp_CVT_ItoF
      },
      0b1000 => {
          rounding = FPRounding_TIEAWAY;
          is_unsigned = [opcode[0]] == 0b1;
          op = FPConvOp_CVT_FtoI
      },
      0b1100 => {
          if fltsize != 16 & fltsize != intsize then {
              throw(Error_Undefined())
          };
          op = if [opcode[0]] == 0b1 then FPConvOp_MOV_ItoF else
            FPConvOp_MOV_FtoI;
          part = 0
      },
      0b1101 => {
          if intsize != 64 | fltsize != 128 then {
              throw(Error_Undefined())
          };
          op = if [opcode[0]] == 0b1 then FPConvOp_MOV_ItoF else
            FPConvOp_MOV_FtoI;
          part = 1;
          fltsize = 64
      },
      0b1111 => {
          if not_bool(HaveFJCVTZSExt()) then {
              throw(Error_Undefined())
          };
          rounding = FPRounding_ZERO;
          is_unsigned = [opcode[0]] == 0b1;
          op = FPConvOp_CVT_FtoI_JS
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let op = op;
    let 'part = part;
    let 'fltsize = fltsize;
    match fltsize {
      16 => {
          execute_aarch64_instrs_float_convert_int(d, 16, intsize, n, op, part, rounding, is_unsigned)
      },
      32 => {
          execute_aarch64_instrs_float_convert_int(d, 32, intsize, n, op, part, rounding, is_unsigned)
      },
      64 => {
          execute_aarch64_instrs_float_convert_int(d, 64, intsize, n, op, part, rounding, is_unsigned)
      },
      128 => {
          execute_aarch64_instrs_float_convert_int(d, 128, intsize, n, op, part, rounding, is_unsigned)
      },
      _ => {
          assert(false)
      }
    }
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([_, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 286) = {
    SEE = 286;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let opcode = Slice(__opcode, 16, 3);
    let rmode = Slice(__opcode, 19, 2);
    let ftype = Slice(__opcode, 22, 2);
    let sf = Slice(__opcode, 31, 1);
    decode_fcvtms_float_aarch64_instrs_float_convert_int(Rd, Rn, opcode, rmode, ftype, sf)
}

val decode_fcvtmu_float_aarch64_instrs_float_convert_int : (bits(5), bits(5), bits(3), bits(2), bits(2), bits(1)) -> unit

function decode_fcvtmu_float_aarch64_instrs_float_convert_int (Rd, Rn, opcode, rmode, ftype, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'intsize = if sf == 0b1 then 64 else 32;
    fltsize : {16, 32, 64, 128} = 16;
    op : FPConvOp = undefined;
    rounding : FPRounding = undefined;
    is_unsigned : bool = undefined;
    part : {0, 1} = 0;
    match ftype {
      0b00 => {
          fltsize = 32
      },
      0b01 => {
          fltsize = 64
      },
      0b10 => {
          if (opcode[2 .. 1] @ rmode) != 0b1101 then {
              throw(Error_Undefined())
          };
          fltsize = 128
      },
      0b11 => {
          if HaveFP16Ext() then {
              fltsize = 16
          } else {
              throw(Error_Undefined())
          }
      }
    };
    match opcode[2 .. 1] @ rmode {
      [bitzero, bitzero, _, _] => {
          rounding = FPDecodeRounding(rmode);
          is_unsigned = [opcode[0]] == 0b1;
          op = FPConvOp_CVT_FtoI
      },
      0b0100 => {
          rounding = FPRoundingMode(FPCR_read());
          is_unsigned = [opcode[0]] == 0b1;
          op = FPConvOp_CVT_ItoF
      },
      0b1000 => {
          rounding = FPRounding_TIEAWAY;
          is_unsigned = [opcode[0]] == 0b1;
          op = FPConvOp_CVT_FtoI
      },
      0b1100 => {
          if fltsize != 16 & fltsize != intsize then {
              throw(Error_Undefined())
          };
          op = if [opcode[0]] == 0b1 then FPConvOp_MOV_ItoF else
            FPConvOp_MOV_FtoI;
          part = 0
      },
      0b1101 => {
          if intsize != 64 | fltsize != 128 then {
              throw(Error_Undefined())
          };
          op = if [opcode[0]] == 0b1 then FPConvOp_MOV_ItoF else
            FPConvOp_MOV_FtoI;
          part = 1;
          fltsize = 64
      },
      0b1111 => {
          if not_bool(HaveFJCVTZSExt()) then {
              throw(Error_Undefined())
          };
          rounding = FPRounding_ZERO;
          is_unsigned = [opcode[0]] == 0b1;
          op = FPConvOp_CVT_FtoI_JS
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let op = op;
    let 'part = part;
    let 'fltsize = fltsize;
    match fltsize {
      16 => {
          execute_aarch64_instrs_float_convert_int(d, 16, intsize, n, op, part, rounding, is_unsigned)
      },
      32 => {
          execute_aarch64_instrs_float_convert_int(d, 32, intsize, n, op, part, rounding, is_unsigned)
      },
      64 => {
          execute_aarch64_instrs_float_convert_int(d, 64, intsize, n, op, part, rounding, is_unsigned)
      },
      128 => {
          execute_aarch64_instrs_float_convert_int(d, 128, intsize, n, op, part, rounding, is_unsigned)
      },
      _ => {
          assert(false)
      }
    }
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([_, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 287) = {
    SEE = 287;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let opcode = Slice(__opcode, 16, 3);
    let rmode = Slice(__opcode, 19, 2);
    let ftype = Slice(__opcode, 22, 2);
    let sf = Slice(__opcode, 31, 1);
    decode_fcvtmu_float_aarch64_instrs_float_convert_int(Rd, Rn, opcode, rmode, ftype, sf)
}

val decode_fcvtns_float_aarch64_instrs_float_convert_int : (bits(5), bits(5), bits(3), bits(2), bits(2), bits(1)) -> unit

function decode_fcvtns_float_aarch64_instrs_float_convert_int (Rd, Rn, opcode, rmode, ftype, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'intsize = if sf == 0b1 then 64 else 32;
    fltsize : {16, 32, 64, 128} = 16;
    op : FPConvOp = undefined;
    rounding : FPRounding = undefined;
    is_unsigned : bool = undefined;
    part : {0, 1} = 0;
    match ftype {
      0b00 => {
          fltsize = 32
      },
      0b01 => {
          fltsize = 64
      },
      0b10 => {
          if (opcode[2 .. 1] @ rmode) != 0b1101 then {
              throw(Error_Undefined())
          };
          fltsize = 128
      },
      0b11 => {
          if HaveFP16Ext() then {
              fltsize = 16
          } else {
              throw(Error_Undefined())
          }
      }
    };
    match opcode[2 .. 1] @ rmode {
      [bitzero, bitzero, _, _] => {
          rounding = FPDecodeRounding(rmode);
          is_unsigned = [opcode[0]] == 0b1;
          op = FPConvOp_CVT_FtoI
      },
      0b0100 => {
          rounding = FPRoundingMode(FPCR_read());
          is_unsigned = [opcode[0]] == 0b1;
          op = FPConvOp_CVT_ItoF
      },
      0b1000 => {
          rounding = FPRounding_TIEAWAY;
          is_unsigned = [opcode[0]] == 0b1;
          op = FPConvOp_CVT_FtoI
      },
      0b1100 => {
          if fltsize != 16 & fltsize != intsize then {
              throw(Error_Undefined())
          };
          op = if [opcode[0]] == 0b1 then FPConvOp_MOV_ItoF else
            FPConvOp_MOV_FtoI;
          part = 0
      },
      0b1101 => {
          if intsize != 64 | fltsize != 128 then {
              throw(Error_Undefined())
          };
          op = if [opcode[0]] == 0b1 then FPConvOp_MOV_ItoF else
            FPConvOp_MOV_FtoI;
          part = 1;
          fltsize = 64
      },
      0b1111 => {
          if not_bool(HaveFJCVTZSExt()) then {
              throw(Error_Undefined())
          };
          rounding = FPRounding_ZERO;
          is_unsigned = [opcode[0]] == 0b1;
          op = FPConvOp_CVT_FtoI_JS
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let op = op;
    let 'part = part;
    let 'fltsize = fltsize;
    match fltsize {
      16 => {
          execute_aarch64_instrs_float_convert_int(d, 16, intsize, n, op, part, rounding, is_unsigned)
      },
      32 => {
          execute_aarch64_instrs_float_convert_int(d, 32, intsize, n, op, part, rounding, is_unsigned)
      },
      64 => {
          execute_aarch64_instrs_float_convert_int(d, 64, intsize, n, op, part, rounding, is_unsigned)
      },
      128 => {
          execute_aarch64_instrs_float_convert_int(d, 128, intsize, n, op, part, rounding, is_unsigned)
      },
      _ => {
          assert(false)
      }
    }
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([_, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 288) = {
    SEE = 288;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let opcode = Slice(__opcode, 16, 3);
    let rmode = Slice(__opcode, 19, 2);
    let ftype = Slice(__opcode, 22, 2);
    let sf = Slice(__opcode, 31, 1);
    decode_fcvtns_float_aarch64_instrs_float_convert_int(Rd, Rn, opcode, rmode, ftype, sf)
}

val decode_fcvtnu_float_aarch64_instrs_float_convert_int : (bits(5), bits(5), bits(3), bits(2), bits(2), bits(1)) -> unit

function decode_fcvtnu_float_aarch64_instrs_float_convert_int (Rd, Rn, opcode, rmode, ftype, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'intsize = if sf == 0b1 then 64 else 32;
    fltsize : {16, 32, 64, 128} = 16;
    op : FPConvOp = undefined;
    rounding : FPRounding = undefined;
    is_unsigned : bool = undefined;
    part : {0, 1} = 0;
    match ftype {
      0b00 => {
          fltsize = 32
      },
      0b01 => {
          fltsize = 64
      },
      0b10 => {
          if (opcode[2 .. 1] @ rmode) != 0b1101 then {
              throw(Error_Undefined())
          };
          fltsize = 128
      },
      0b11 => {
          if HaveFP16Ext() then {
              fltsize = 16
          } else {
              throw(Error_Undefined())
          }
      }
    };
    match opcode[2 .. 1] @ rmode {
      [bitzero, bitzero, _, _] => {
          rounding = FPDecodeRounding(rmode);
          is_unsigned = [opcode[0]] == 0b1;
          op = FPConvOp_CVT_FtoI
      },
      0b0100 => {
          rounding = FPRoundingMode(FPCR_read());
          is_unsigned = [opcode[0]] == 0b1;
          op = FPConvOp_CVT_ItoF
      },
      0b1000 => {
          rounding = FPRounding_TIEAWAY;
          is_unsigned = [opcode[0]] == 0b1;
          op = FPConvOp_CVT_FtoI
      },
      0b1100 => {
          if fltsize != 16 & fltsize != intsize then {
              throw(Error_Undefined())
          };
          op = if [opcode[0]] == 0b1 then FPConvOp_MOV_ItoF else
            FPConvOp_MOV_FtoI;
          part = 0
      },
      0b1101 => {
          if intsize != 64 | fltsize != 128 then {
              throw(Error_Undefined())
          };
          op = if [opcode[0]] == 0b1 then FPConvOp_MOV_ItoF else
            FPConvOp_MOV_FtoI;
          part = 1;
          fltsize = 64
      },
      0b1111 => {
          if not_bool(HaveFJCVTZSExt()) then {
              throw(Error_Undefined())
          };
          rounding = FPRounding_ZERO;
          is_unsigned = [opcode[0]] == 0b1;
          op = FPConvOp_CVT_FtoI_JS
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let op = op;
    let 'part = part;
    let 'fltsize = fltsize;
    match fltsize {
      16 => {
          execute_aarch64_instrs_float_convert_int(d, 16, intsize, n, op, part, rounding, is_unsigned)
      },
      32 => {
          execute_aarch64_instrs_float_convert_int(d, 32, intsize, n, op, part, rounding, is_unsigned)
      },
      64 => {
          execute_aarch64_instrs_float_convert_int(d, 64, intsize, n, op, part, rounding, is_unsigned)
      },
      128 => {
          execute_aarch64_instrs_float_convert_int(d, 128, intsize, n, op, part, rounding, is_unsigned)
      },
      _ => {
          assert(false)
      }
    }
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([_, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 289) = {
    SEE = 289;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let opcode = Slice(__opcode, 16, 3);
    let rmode = Slice(__opcode, 19, 2);
    let ftype = Slice(__opcode, 22, 2);
    let sf = Slice(__opcode, 31, 1);
    decode_fcvtnu_float_aarch64_instrs_float_convert_int(Rd, Rn, opcode, rmode, ftype, sf)
}

val decode_fcvtps_float_aarch64_instrs_float_convert_int : (bits(5), bits(5), bits(3), bits(2), bits(2), bits(1)) -> unit

function decode_fcvtps_float_aarch64_instrs_float_convert_int (Rd, Rn, opcode, rmode, ftype, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'intsize = if sf == 0b1 then 64 else 32;
    fltsize : {16, 32, 64, 128} = 16;
    op : FPConvOp = undefined;
    rounding : FPRounding = undefined;
    is_unsigned : bool = undefined;
    part : {0, 1} = 0;
    match ftype {
      0b00 => {
          fltsize = 32
      },
      0b01 => {
          fltsize = 64
      },
      0b10 => {
          if (opcode[2 .. 1] @ rmode) != 0b1101 then {
              throw(Error_Undefined())
          };
          fltsize = 128
      },
      0b11 => {
          if HaveFP16Ext() then {
              fltsize = 16
          } else {
              throw(Error_Undefined())
          }
      }
    };
    match opcode[2 .. 1] @ rmode {
      [bitzero, bitzero, _, _] => {
          rounding = FPDecodeRounding(rmode);
          is_unsigned = [opcode[0]] == 0b1;
          op = FPConvOp_CVT_FtoI
      },
      0b0100 => {
          rounding = FPRoundingMode(FPCR_read());
          is_unsigned = [opcode[0]] == 0b1;
          op = FPConvOp_CVT_ItoF
      },
      0b1000 => {
          rounding = FPRounding_TIEAWAY;
          is_unsigned = [opcode[0]] == 0b1;
          op = FPConvOp_CVT_FtoI
      },
      0b1100 => {
          if fltsize != 16 & fltsize != intsize then {
              throw(Error_Undefined())
          };
          op = if [opcode[0]] == 0b1 then FPConvOp_MOV_ItoF else
            FPConvOp_MOV_FtoI;
          part = 0
      },
      0b1101 => {
          if intsize != 64 | fltsize != 128 then {
              throw(Error_Undefined())
          };
          op = if [opcode[0]] == 0b1 then FPConvOp_MOV_ItoF else
            FPConvOp_MOV_FtoI;
          part = 1;
          fltsize = 64
      },
      0b1111 => {
          if not_bool(HaveFJCVTZSExt()) then {
              throw(Error_Undefined())
          };
          rounding = FPRounding_ZERO;
          is_unsigned = [opcode[0]] == 0b1;
          op = FPConvOp_CVT_FtoI_JS
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let op = op;
    let 'part = part;
    let 'fltsize = fltsize;
    match fltsize {
      16 => {
          execute_aarch64_instrs_float_convert_int(d, 16, intsize, n, op, part, rounding, is_unsigned)
      },
      32 => {
          execute_aarch64_instrs_float_convert_int(d, 32, intsize, n, op, part, rounding, is_unsigned)
      },
      64 => {
          execute_aarch64_instrs_float_convert_int(d, 64, intsize, n, op, part, rounding, is_unsigned)
      },
      128 => {
          execute_aarch64_instrs_float_convert_int(d, 128, intsize, n, op, part, rounding, is_unsigned)
      },
      _ => {
          assert(false)
      }
    }
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([_, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 290) = {
    SEE = 290;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let opcode = Slice(__opcode, 16, 3);
    let rmode = Slice(__opcode, 19, 2);
    let ftype = Slice(__opcode, 22, 2);
    let sf = Slice(__opcode, 31, 1);
    decode_fcvtps_float_aarch64_instrs_float_convert_int(Rd, Rn, opcode, rmode, ftype, sf)
}

val decode_fcvtpu_float_aarch64_instrs_float_convert_int : (bits(5), bits(5), bits(3), bits(2), bits(2), bits(1)) -> unit

function decode_fcvtpu_float_aarch64_instrs_float_convert_int (Rd, Rn, opcode, rmode, ftype, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'intsize = if sf == 0b1 then 64 else 32;
    fltsize : {16, 32, 64, 128} = 16;
    op : FPConvOp = undefined;
    rounding : FPRounding = undefined;
    is_unsigned : bool = undefined;
    part : {0, 1} = 0;
    match ftype {
      0b00 => {
          fltsize = 32
      },
      0b01 => {
          fltsize = 64
      },
      0b10 => {
          if (opcode[2 .. 1] @ rmode) != 0b1101 then {
              throw(Error_Undefined())
          };
          fltsize = 128
      },
      0b11 => {
          if HaveFP16Ext() then {
              fltsize = 16
          } else {
              throw(Error_Undefined())
          }
      }
    };
    match opcode[2 .. 1] @ rmode {
      [bitzero, bitzero, _, _] => {
          rounding = FPDecodeRounding(rmode);
          is_unsigned = [opcode[0]] == 0b1;
          op = FPConvOp_CVT_FtoI
      },
      0b0100 => {
          rounding = FPRoundingMode(FPCR_read());
          is_unsigned = [opcode[0]] == 0b1;
          op = FPConvOp_CVT_ItoF
      },
      0b1000 => {
          rounding = FPRounding_TIEAWAY;
          is_unsigned = [opcode[0]] == 0b1;
          op = FPConvOp_CVT_FtoI
      },
      0b1100 => {
          if fltsize != 16 & fltsize != intsize then {
              throw(Error_Undefined())
          };
          op = if [opcode[0]] == 0b1 then FPConvOp_MOV_ItoF else
            FPConvOp_MOV_FtoI;
          part = 0
      },
      0b1101 => {
          if intsize != 64 | fltsize != 128 then {
              throw(Error_Undefined())
          };
          op = if [opcode[0]] == 0b1 then FPConvOp_MOV_ItoF else
            FPConvOp_MOV_FtoI;
          part = 1;
          fltsize = 64
      },
      0b1111 => {
          if not_bool(HaveFJCVTZSExt()) then {
              throw(Error_Undefined())
          };
          rounding = FPRounding_ZERO;
          is_unsigned = [opcode[0]] == 0b1;
          op = FPConvOp_CVT_FtoI_JS
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let op = op;
    let 'part = part;
    let 'fltsize = fltsize;
    match fltsize {
      16 => {
          execute_aarch64_instrs_float_convert_int(d, 16, intsize, n, op, part, rounding, is_unsigned)
      },
      32 => {
          execute_aarch64_instrs_float_convert_int(d, 32, intsize, n, op, part, rounding, is_unsigned)
      },
      64 => {
          execute_aarch64_instrs_float_convert_int(d, 64, intsize, n, op, part, rounding, is_unsigned)
      },
      128 => {
          execute_aarch64_instrs_float_convert_int(d, 128, intsize, n, op, part, rounding, is_unsigned)
      },
      _ => {
          assert(false)
      }
    }
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([_, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, bitzero, bitone, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 291) = {
    SEE = 291;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let opcode = Slice(__opcode, 16, 3);
    let rmode = Slice(__opcode, 19, 2);
    let ftype = Slice(__opcode, 22, 2);
    let sf = Slice(__opcode, 31, 1);
    decode_fcvtpu_float_aarch64_instrs_float_convert_int(Rd, Rn, opcode, rmode, ftype, sf)
}

val decode_fcvtzs_float_int_aarch64_instrs_float_convert_int : (bits(5), bits(5), bits(3), bits(2), bits(2), bits(1)) -> unit

function decode_fcvtzs_float_int_aarch64_instrs_float_convert_int (Rd, Rn, opcode, rmode, ftype, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'intsize = if sf == 0b1 then 64 else 32;
    fltsize : {16, 32, 64, 128} = 16;
    op : FPConvOp = undefined;
    rounding : FPRounding = undefined;
    is_unsigned : bool = undefined;
    part : {0, 1} = 0;
    match ftype {
      0b00 => {
          fltsize = 32
      },
      0b01 => {
          fltsize = 64
      },
      0b10 => {
          if (opcode[2 .. 1] @ rmode) != 0b1101 then {
              throw(Error_Undefined())
          };
          fltsize = 128
      },
      0b11 => {
          if HaveFP16Ext() then {
              fltsize = 16
          } else {
              throw(Error_Undefined())
          }
      }
    };
    match opcode[2 .. 1] @ rmode {
      [bitzero, bitzero, _, _] => {
          rounding = FPDecodeRounding(rmode);
          is_unsigned = [opcode[0]] == 0b1;
          op = FPConvOp_CVT_FtoI
      },
      0b0100 => {
          rounding = FPRoundingMode(FPCR_read());
          is_unsigned = [opcode[0]] == 0b1;
          op = FPConvOp_CVT_ItoF
      },
      0b1000 => {
          rounding = FPRounding_TIEAWAY;
          is_unsigned = [opcode[0]] == 0b1;
          op = FPConvOp_CVT_FtoI
      },
      0b1100 => {
          if fltsize != 16 & fltsize != intsize then {
              throw(Error_Undefined())
          };
          op = if [opcode[0]] == 0b1 then FPConvOp_MOV_ItoF else
            FPConvOp_MOV_FtoI;
          part = 0
      },
      0b1101 => {
          if intsize != 64 | fltsize != 128 then {
              throw(Error_Undefined())
          };
          op = if [opcode[0]] == 0b1 then FPConvOp_MOV_ItoF else
            FPConvOp_MOV_FtoI;
          part = 1;
          fltsize = 64
      },
      0b1111 => {
          if not_bool(HaveFJCVTZSExt()) then {
              throw(Error_Undefined())
          };
          rounding = FPRounding_ZERO;
          is_unsigned = [opcode[0]] == 0b1;
          op = FPConvOp_CVT_FtoI_JS
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let op = op;
    let 'part = part;
    let 'fltsize = fltsize;
    match fltsize {
      16 => {
          execute_aarch64_instrs_float_convert_int(d, 16, intsize, n, op, part, rounding, is_unsigned)
      },
      32 => {
          execute_aarch64_instrs_float_convert_int(d, 32, intsize, n, op, part, rounding, is_unsigned)
      },
      64 => {
          execute_aarch64_instrs_float_convert_int(d, 64, intsize, n, op, part, rounding, is_unsigned)
      },
      128 => {
          execute_aarch64_instrs_float_convert_int(d, 128, intsize, n, op, part, rounding, is_unsigned)
      },
      _ => {
          assert(false)
      }
    }
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([_, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 292) = {
    SEE = 292;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let opcode = Slice(__opcode, 16, 3);
    let rmode = Slice(__opcode, 19, 2);
    let ftype = Slice(__opcode, 22, 2);
    let sf = Slice(__opcode, 31, 1);
    decode_fcvtzs_float_int_aarch64_instrs_float_convert_int(Rd, Rn, opcode, rmode, ftype, sf)
}

val decode_fcvtzu_float_int_aarch64_instrs_float_convert_int : (bits(5), bits(5), bits(3), bits(2), bits(2), bits(1)) -> unit

function decode_fcvtzu_float_int_aarch64_instrs_float_convert_int (Rd, Rn, opcode, rmode, ftype, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'intsize = if sf == 0b1 then 64 else 32;
    fltsize : {16, 32, 64, 128} = 16;
    op : FPConvOp = undefined;
    rounding : FPRounding = undefined;
    is_unsigned : bool = undefined;
    part : {0, 1} = 0;
    match ftype {
      0b00 => {
          fltsize = 32
      },
      0b01 => {
          fltsize = 64
      },
      0b10 => {
          if (opcode[2 .. 1] @ rmode) != 0b1101 then {
              throw(Error_Undefined())
          };
          fltsize = 128
      },
      0b11 => {
          if HaveFP16Ext() then {
              fltsize = 16
          } else {
              throw(Error_Undefined())
          }
      }
    };
    match opcode[2 .. 1] @ rmode {
      [bitzero, bitzero, _, _] => {
          rounding = FPDecodeRounding(rmode);
          is_unsigned = [opcode[0]] == 0b1;
          op = FPConvOp_CVT_FtoI
      },
      0b0100 => {
          rounding = FPRoundingMode(FPCR_read());
          is_unsigned = [opcode[0]] == 0b1;
          op = FPConvOp_CVT_ItoF
      },
      0b1000 => {
          rounding = FPRounding_TIEAWAY;
          is_unsigned = [opcode[0]] == 0b1;
          op = FPConvOp_CVT_FtoI
      },
      0b1100 => {
          if fltsize != 16 & fltsize != intsize then {
              throw(Error_Undefined())
          };
          op = if [opcode[0]] == 0b1 then FPConvOp_MOV_ItoF else
            FPConvOp_MOV_FtoI;
          part = 0
      },
      0b1101 => {
          if intsize != 64 | fltsize != 128 then {
              throw(Error_Undefined())
          };
          op = if [opcode[0]] == 0b1 then FPConvOp_MOV_ItoF else
            FPConvOp_MOV_FtoI;
          part = 1;
          fltsize = 64
      },
      0b1111 => {
          if not_bool(HaveFJCVTZSExt()) then {
              throw(Error_Undefined())
          };
          rounding = FPRounding_ZERO;
          is_unsigned = [opcode[0]] == 0b1;
          op = FPConvOp_CVT_FtoI_JS
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let op = op;
    let 'part = part;
    let 'fltsize = fltsize;
    match fltsize {
      16 => {
          execute_aarch64_instrs_float_convert_int(d, 16, intsize, n, op, part, rounding, is_unsigned)
      },
      32 => {
          execute_aarch64_instrs_float_convert_int(d, 32, intsize, n, op, part, rounding, is_unsigned)
      },
      64 => {
          execute_aarch64_instrs_float_convert_int(d, 64, intsize, n, op, part, rounding, is_unsigned)
      },
      128 => {
          execute_aarch64_instrs_float_convert_int(d, 128, intsize, n, op, part, rounding, is_unsigned)
      },
      _ => {
          assert(false)
      }
    }
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([_, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, bitone, bitone, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 293) = {
    SEE = 293;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let opcode = Slice(__opcode, 16, 3);
    let rmode = Slice(__opcode, 19, 2);
    let ftype = Slice(__opcode, 22, 2);
    let sf = Slice(__opcode, 31, 1);
    decode_fcvtzu_float_int_aarch64_instrs_float_convert_int(Rd, Rn, opcode, rmode, ftype, sf)
}

val decode_fjcvtzs_aarch64_instrs_float_convert_int : (bits(5), bits(5), bits(3), bits(2), bits(2), bits(1)) -> unit

function decode_fjcvtzs_aarch64_instrs_float_convert_int (Rd, Rn, opcode, rmode, ftype, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'intsize = if sf == 0b1 then 64 else 32;
    fltsize : {16, 32, 64, 128} = 16;
    op : FPConvOp = undefined;
    rounding : FPRounding = undefined;
    is_unsigned : bool = undefined;
    part : {0, 1} = 0;
    match ftype {
      0b00 => {
          fltsize = 32
      },
      0b01 => {
          fltsize = 64
      },
      0b10 => {
          if (opcode[2 .. 1] @ rmode) != 0b1101 then {
              throw(Error_Undefined())
          };
          fltsize = 128
      },
      0b11 => {
          if HaveFP16Ext() then {
              fltsize = 16
          } else {
              throw(Error_Undefined())
          }
      }
    };
    match opcode[2 .. 1] @ rmode {
      [bitzero, bitzero, _, _] => {
          rounding = FPDecodeRounding(rmode);
          is_unsigned = [opcode[0]] == 0b1;
          op = FPConvOp_CVT_FtoI
      },
      0b0100 => {
          rounding = FPRoundingMode(FPCR_read());
          is_unsigned = [opcode[0]] == 0b1;
          op = FPConvOp_CVT_ItoF
      },
      0b1000 => {
          rounding = FPRounding_TIEAWAY;
          is_unsigned = [opcode[0]] == 0b1;
          op = FPConvOp_CVT_FtoI
      },
      0b1100 => {
          if fltsize != 16 & fltsize != intsize then {
              throw(Error_Undefined())
          };
          op = if [opcode[0]] == 0b1 then FPConvOp_MOV_ItoF else
            FPConvOp_MOV_FtoI;
          part = 0
      },
      0b1101 => {
          if intsize != 64 | fltsize != 128 then {
              throw(Error_Undefined())
          };
          op = if [opcode[0]] == 0b1 then FPConvOp_MOV_ItoF else
            FPConvOp_MOV_FtoI;
          part = 1;
          fltsize = 64
      },
      0b1111 => {
          if not_bool(HaveFJCVTZSExt()) then {
              throw(Error_Undefined())
          };
          rounding = FPRounding_ZERO;
          is_unsigned = [opcode[0]] == 0b1;
          op = FPConvOp_CVT_FtoI_JS
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let op = op;
    let 'part = part;
    let 'fltsize = fltsize;
    match fltsize {
      16 => {
          execute_aarch64_instrs_float_convert_int(d, 16, intsize, n, op, part, rounding, is_unsigned)
      },
      32 => {
          execute_aarch64_instrs_float_convert_int(d, 32, intsize, n, op, part, rounding, is_unsigned)
      },
      64 => {
          execute_aarch64_instrs_float_convert_int(d, 64, intsize, n, op, part, rounding, is_unsigned)
      },
      128 => {
          execute_aarch64_instrs_float_convert_int(d, 128, intsize, n, op, part, rounding, is_unsigned)
      },
      _ => {
          assert(false)
      }
    }
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 294) = {
    SEE = 294;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let opcode = Slice(__opcode, 16, 3);
    let rmode = Slice(__opcode, 19, 2);
    let ftype = Slice(__opcode, 22, 2);
    let sf = Slice(__opcode, 31, 1);
    decode_fjcvtzs_aarch64_instrs_float_convert_int(Rd, Rn, opcode, rmode, ftype, sf)
}

val decode_fmov_float_gen_aarch64_instrs_float_convert_int : (bits(5), bits(5), bits(3), bits(2), bits(2), bits(1)) -> unit

function decode_fmov_float_gen_aarch64_instrs_float_convert_int (Rd, Rn, opcode, rmode, ftype, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'intsize = if sf == 0b1 then 64 else 32;
    fltsize : {16, 32, 64, 128} = 16;
    op : FPConvOp = undefined;
    rounding : FPRounding = undefined;
    is_unsigned : bool = undefined;
    part : {0, 1} = 0;
    match ftype {
      0b00 => {
          fltsize = 32
      },
      0b01 => {
          fltsize = 64
      },
      0b10 => {
          if (opcode[2 .. 1] @ rmode) != 0b1101 then {
              throw(Error_Undefined())
          };
          fltsize = 128
      },
      0b11 => {
          if HaveFP16Ext() then {
              fltsize = 16
          } else {
              throw(Error_Undefined())
          }
      }
    };
    match opcode[2 .. 1] @ rmode {
      [bitzero, bitzero, _, _] => {
          rounding = FPDecodeRounding(rmode);
          is_unsigned = [opcode[0]] == 0b1;
          op = FPConvOp_CVT_FtoI
      },
      0b0100 => {
          rounding = FPRoundingMode(FPCR_read());
          is_unsigned = [opcode[0]] == 0b1;
          op = FPConvOp_CVT_ItoF
      },
      0b1000 => {
          rounding = FPRounding_TIEAWAY;
          is_unsigned = [opcode[0]] == 0b1;
          op = FPConvOp_CVT_FtoI
      },
      0b1100 => {
          if fltsize != 16 & fltsize != intsize then {
              throw(Error_Undefined())
          };
          op = if [opcode[0]] == 0b1 then FPConvOp_MOV_ItoF else
            FPConvOp_MOV_FtoI;
          part = 0
      },
      0b1101 => {
          if intsize != 64 | fltsize != 128 then {
              throw(Error_Undefined())
          };
          op = if [opcode[0]] == 0b1 then FPConvOp_MOV_ItoF else
            FPConvOp_MOV_FtoI;
          part = 1;
          fltsize = 64
      },
      0b1111 => {
          if not_bool(HaveFJCVTZSExt()) then {
              throw(Error_Undefined())
          };
          rounding = FPRounding_ZERO;
          is_unsigned = [opcode[0]] == 0b1;
          op = FPConvOp_CVT_FtoI_JS
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let op = op;
    let 'part = part;
    let 'fltsize = fltsize;
    match fltsize {
      16 => {
          execute_aarch64_instrs_float_convert_int(d, 16, intsize, n, op, part, rounding, is_unsigned)
      },
      32 => {
          execute_aarch64_instrs_float_convert_int(d, 32, intsize, n, op, part, rounding, is_unsigned)
      },
      64 => {
          execute_aarch64_instrs_float_convert_int(d, 64, intsize, n, op, part, rounding, is_unsigned)
      },
      128 => {
          execute_aarch64_instrs_float_convert_int(d, 128, intsize, n, op, part, rounding, is_unsigned)
      },
      _ => {
          assert(false)
      }
    }
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([_, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, bitzero, _, bitone, bitone, _, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 295) = {
    SEE = 295;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let opcode = Slice(__opcode, 16, 3);
    let rmode = Slice(__opcode, 19, 2);
    let ftype = Slice(__opcode, 22, 2);
    let sf = Slice(__opcode, 31, 1);
    decode_fmov_float_gen_aarch64_instrs_float_convert_int(Rd, Rn, opcode, rmode, ftype, sf)
}

val decode_scvtf_float_int_aarch64_instrs_float_convert_int : (bits(5), bits(5), bits(3), bits(2), bits(2), bits(1)) -> unit

function decode_scvtf_float_int_aarch64_instrs_float_convert_int (Rd, Rn, opcode, rmode, ftype, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'intsize = if sf == 0b1 then 64 else 32;
    fltsize : {16, 32, 64, 128} = 16;
    op : FPConvOp = undefined;
    rounding : FPRounding = undefined;
    is_unsigned : bool = undefined;
    part : {0, 1} = 0;
    match ftype {
      0b00 => {
          fltsize = 32
      },
      0b01 => {
          fltsize = 64
      },
      0b10 => {
          if (opcode[2 .. 1] @ rmode) != 0b1101 then {
              throw(Error_Undefined())
          };
          fltsize = 128
      },
      0b11 => {
          if HaveFP16Ext() then {
              fltsize = 16
          } else {
              throw(Error_Undefined())
          }
      }
    };
    match opcode[2 .. 1] @ rmode {
      [bitzero, bitzero, _, _] => {
          rounding = FPDecodeRounding(rmode);
          is_unsigned = [opcode[0]] == 0b1;
          op = FPConvOp_CVT_FtoI
      },
      0b0100 => {
          rounding = FPRoundingMode(FPCR_read());
          is_unsigned = [opcode[0]] == 0b1;
          op = FPConvOp_CVT_ItoF
      },
      0b1000 => {
          rounding = FPRounding_TIEAWAY;
          is_unsigned = [opcode[0]] == 0b1;
          op = FPConvOp_CVT_FtoI
      },
      0b1100 => {
          if fltsize != 16 & fltsize != intsize then {
              throw(Error_Undefined())
          };
          op = if [opcode[0]] == 0b1 then FPConvOp_MOV_ItoF else
            FPConvOp_MOV_FtoI;
          part = 0
      },
      0b1101 => {
          if intsize != 64 | fltsize != 128 then {
              throw(Error_Undefined())
          };
          op = if [opcode[0]] == 0b1 then FPConvOp_MOV_ItoF else
            FPConvOp_MOV_FtoI;
          part = 1;
          fltsize = 64
      },
      0b1111 => {
          if not_bool(HaveFJCVTZSExt()) then {
              throw(Error_Undefined())
          };
          rounding = FPRounding_ZERO;
          is_unsigned = [opcode[0]] == 0b1;
          op = FPConvOp_CVT_FtoI_JS
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let op = op;
    let 'part = part;
    let 'fltsize = fltsize;
    match fltsize {
      16 => {
          execute_aarch64_instrs_float_convert_int(d, 16, intsize, n, op, part, rounding, is_unsigned)
      },
      32 => {
          execute_aarch64_instrs_float_convert_int(d, 32, intsize, n, op, part, rounding, is_unsigned)
      },
      64 => {
          execute_aarch64_instrs_float_convert_int(d, 64, intsize, n, op, part, rounding, is_unsigned)
      },
      128 => {
          execute_aarch64_instrs_float_convert_int(d, 128, intsize, n, op, part, rounding, is_unsigned)
      },
      _ => {
          assert(false)
      }
    }
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([_, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 296) = {
    SEE = 296;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let opcode = Slice(__opcode, 16, 3);
    let rmode = Slice(__opcode, 19, 2);
    let ftype = Slice(__opcode, 22, 2);
    let sf = Slice(__opcode, 31, 1);
    decode_scvtf_float_int_aarch64_instrs_float_convert_int(Rd, Rn, opcode, rmode, ftype, sf)
}

val decode_ucvtf_float_int_aarch64_instrs_float_convert_int : (bits(5), bits(5), bits(3), bits(2), bits(2), bits(1)) -> unit

function decode_ucvtf_float_int_aarch64_instrs_float_convert_int (Rd, Rn, opcode, rmode, ftype, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'intsize = if sf == 0b1 then 64 else 32;
    fltsize : {16, 32, 64, 128} = 16;
    op : FPConvOp = undefined;
    rounding : FPRounding = undefined;
    is_unsigned : bool = undefined;
    part : {0, 1} = 0;
    match ftype {
      0b00 => {
          fltsize = 32
      },
      0b01 => {
          fltsize = 64
      },
      0b10 => {
          if (opcode[2 .. 1] @ rmode) != 0b1101 then {
              throw(Error_Undefined())
          };
          fltsize = 128
      },
      0b11 => {
          if HaveFP16Ext() then {
              fltsize = 16
          } else {
              throw(Error_Undefined())
          }
      }
    };
    match opcode[2 .. 1] @ rmode {
      [bitzero, bitzero, _, _] => {
          rounding = FPDecodeRounding(rmode);
          is_unsigned = [opcode[0]] == 0b1;
          op = FPConvOp_CVT_FtoI
      },
      0b0100 => {
          rounding = FPRoundingMode(FPCR_read());
          is_unsigned = [opcode[0]] == 0b1;
          op = FPConvOp_CVT_ItoF
      },
      0b1000 => {
          rounding = FPRounding_TIEAWAY;
          is_unsigned = [opcode[0]] == 0b1;
          op = FPConvOp_CVT_FtoI
      },
      0b1100 => {
          if fltsize != 16 & fltsize != intsize then {
              throw(Error_Undefined())
          };
          op = if [opcode[0]] == 0b1 then FPConvOp_MOV_ItoF else
            FPConvOp_MOV_FtoI;
          part = 0
      },
      0b1101 => {
          if intsize != 64 | fltsize != 128 then {
              throw(Error_Undefined())
          };
          op = if [opcode[0]] == 0b1 then FPConvOp_MOV_ItoF else
            FPConvOp_MOV_FtoI;
          part = 1;
          fltsize = 64
      },
      0b1111 => {
          if not_bool(HaveFJCVTZSExt()) then {
              throw(Error_Undefined())
          };
          rounding = FPRounding_ZERO;
          is_unsigned = [opcode[0]] == 0b1;
          op = FPConvOp_CVT_FtoI_JS
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let op = op;
    let 'part = part;
    let 'fltsize = fltsize;
    match fltsize {
      16 => {
          execute_aarch64_instrs_float_convert_int(d, 16, intsize, n, op, part, rounding, is_unsigned)
      },
      32 => {
          execute_aarch64_instrs_float_convert_int(d, 32, intsize, n, op, part, rounding, is_unsigned)
      },
      64 => {
          execute_aarch64_instrs_float_convert_int(d, 64, intsize, n, op, part, rounding, is_unsigned)
      },
      128 => {
          execute_aarch64_instrs_float_convert_int(d, 128, intsize, n, op, part, rounding, is_unsigned)
      },
      _ => {
          assert(false)
      }
    }
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([_, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 297) = {
    SEE = 297;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let opcode = Slice(__opcode, 16, 3);
    let rmode = Slice(__opcode, 19, 2);
    let ftype = Slice(__opcode, 22, 2);
    let sf = Slice(__opcode, 31, 1);
    decode_ucvtf_float_int_aarch64_instrs_float_convert_int(Rd, Rn, opcode, rmode, ftype, sf)
}

val execute_aarch64_instrs_vector_arithmetic_unary_float_widen : forall 'd 'datasize 'elements 'esize 'n 'part,
  ('part in {0, 1} & 0 <= 'n & 'n <= 31 & 'esize in {16, 32} & 'datasize == 64 & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('n), int('part)) -> unit

function execute_aarch64_instrs_vector_arithmetic_unary_float_widen (d, datasize, elements, esize, n, part) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('datasize) = Vpart_read(n, part, datasize);
    result : bits(2 * 'datasize) = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        result = Elem_set(result, e, 2 * esize, FPConvert__1(Elem_read(operand, e, esize), FPCR_read(), 2 * esize))
    };
    V_set(d, 2 * datasize) = result
}

val decode_fcvtl_advsimd_aarch64_instrs_vector_arithmetic_unary_float_widen : (bits(5), bits(5), bits(1), bits(1)) -> unit

function decode_fcvtl_advsimd_aarch64_instrs_vector_arithmetic_unary_float_widen (Rd, Rn, sz, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = (16 << UInt(sz));
    let 'datasize = 64;
    let 'part = UInt(Q);
    let 'elements = DIV(datasize, esize);
    assert(constraint('esize in {16, 32}));
    execute_aarch64_instrs_vector_arithmetic_unary_float_widen(d, datasize, elements, esize, n, part)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 298) = {
    SEE = 298;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let sz = Slice(__opcode, 22, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fcvtl_advsimd_aarch64_instrs_vector_arithmetic_unary_float_widen(Rd, Rn, sz, Q)
}

val execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd : forall 'd 'datasize 'elements 'esize ('is_unsigned : Bool) 'n,
  (0 <= 'n & 'n <= 31 & 'esize in {16, 32, 64} & 'datasize in {16, 32, 64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('n), FPRounding, bool('is_unsigned)) -> unit

function execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd (d, datasize, elements, esize, n, rounding, is_unsigned) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('datasize) = V_read(n, datasize);
    element : bits('esize) = undefined;
    let fpcr : FPCRType = FPCR_read();
    let merge : bool = elements == 1 & IsMerging(fpcr);
    result : bits(128) = if merge then V_read(d, 128) else Zeros(128);
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element = Elem_read(operand, e, esize);
        result = Elem_set(result, e, esize, FPToFixed(element, 0, is_unsigned, fpcr, rounding, esize))
    };
    V_set(d, 128) = result
}

val decode_fcvtms_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd : (bits(5), bits(5), bits(1), bits(1), bits(1)) -> unit

function decode_fcvtms_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd (Rd, Rn, o1, o2, U) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = 16;
    let 'datasize = esize;
    let 'elements = 1;
    let rounding : FPRounding = FPDecodeRounding(o1 @ o2);
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd(d, datasize, elements, esize, n, rounding, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 299) = {
    SEE = 299;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 12, 1);
    let o2 = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    decode_fcvtms_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd(Rd, Rn, o1, o2, U)
}

val decode_fcvtms_advsimd_aarch64_instrs_vector_arithmetic_unary_float_conv_float_bulk_sisd : (bits(5), bits(5), bits(1), bits(1), bits(1), bits(1)) -> unit

function decode_fcvtms_advsimd_aarch64_instrs_vector_arithmetic_unary_float_conv_float_bulk_sisd (Rd, Rn, o1, sz, o2, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = (32 << UInt(sz));
    let 'datasize = esize;
    let 'elements = 1;
    let rounding : FPRounding = FPDecodeRounding(o1 @ o2);
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd(d, datasize, elements, esize, n, rounding, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 300) = {
    SEE = 300;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 12, 1);
    let sz = Slice(__opcode, 22, 1);
    let o2 = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    decode_fcvtms_advsimd_aarch64_instrs_vector_arithmetic_unary_float_conv_float_bulk_sisd(Rd, Rn, o1, sz, o2, U)
}

val decode_fcvtms_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_simd : (bits(5), bits(5), bits(1), bits(1), bits(1), bits(1)) -> unit

function decode_fcvtms_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_simd (Rd, Rn, o1, o2, U, Q) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = 16;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let rounding : FPRounding = FPDecodeRounding(o1 @ o2);
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd(d, datasize, elements, esize, n, rounding, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 301) = {
    SEE = 301;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 12, 1);
    let o2 = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fcvtms_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_simd(Rd, Rn, o1, o2, U, Q)
}

val decode_fcvtms_advsimd_aarch64_instrs_vector_arithmetic_unary_float_conv_float_bulk_simd : (bits(5), bits(5), bits(1), bits(1), bits(1), bits(1), bits(1)) -> unit

function decode_fcvtms_advsimd_aarch64_instrs_vector_arithmetic_unary_float_conv_float_bulk_simd (Rd, Rn, o1, sz, o2, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    };
    let 'esize = (32 << UInt(sz));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let rounding : FPRounding = FPDecodeRounding(o1 @ o2);
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd(d, datasize, elements, esize, n, rounding, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 302) = {
    SEE = 302;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 12, 1);
    let sz = Slice(__opcode, 22, 1);
    let o2 = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fcvtms_advsimd_aarch64_instrs_vector_arithmetic_unary_float_conv_float_bulk_simd(Rd, Rn, o1, sz, o2, U, Q)
}

val decode_fcvtmu_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd : (bits(5), bits(5), bits(1), bits(1), bits(1)) -> unit

function decode_fcvtmu_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd (Rd, Rn, o1, o2, U) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = 16;
    let 'datasize = esize;
    let 'elements = 1;
    let rounding : FPRounding = FPDecodeRounding(o1 @ o2);
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd(d, datasize, elements, esize, n, rounding, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 303) = {
    SEE = 303;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 12, 1);
    let o2 = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    decode_fcvtmu_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd(Rd, Rn, o1, o2, U)
}

val decode_fcvtmu_advsimd_aarch64_instrs_vector_arithmetic_unary_float_conv_float_bulk_sisd : (bits(5), bits(5), bits(1), bits(1), bits(1), bits(1)) -> unit

function decode_fcvtmu_advsimd_aarch64_instrs_vector_arithmetic_unary_float_conv_float_bulk_sisd (Rd, Rn, o1, sz, o2, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = (32 << UInt(sz));
    let 'datasize = esize;
    let 'elements = 1;
    let rounding : FPRounding = FPDecodeRounding(o1 @ o2);
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd(d, datasize, elements, esize, n, rounding, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 304) = {
    SEE = 304;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 12, 1);
    let sz = Slice(__opcode, 22, 1);
    let o2 = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    decode_fcvtmu_advsimd_aarch64_instrs_vector_arithmetic_unary_float_conv_float_bulk_sisd(Rd, Rn, o1, sz, o2, U)
}

val decode_fcvtmu_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_simd : (bits(5), bits(5), bits(1), bits(1), bits(1), bits(1)) -> unit

function decode_fcvtmu_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_simd (Rd, Rn, o1, o2, U, Q) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = 16;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let rounding : FPRounding = FPDecodeRounding(o1 @ o2);
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd(d, datasize, elements, esize, n, rounding, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 305) = {
    SEE = 305;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 12, 1);
    let o2 = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fcvtmu_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_simd(Rd, Rn, o1, o2, U, Q)
}

val decode_fcvtmu_advsimd_aarch64_instrs_vector_arithmetic_unary_float_conv_float_bulk_simd : (bits(5), bits(5), bits(1), bits(1), bits(1), bits(1), bits(1)) -> unit

function decode_fcvtmu_advsimd_aarch64_instrs_vector_arithmetic_unary_float_conv_float_bulk_simd (Rd, Rn, o1, sz, o2, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    };
    let 'esize = (32 << UInt(sz));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let rounding : FPRounding = FPDecodeRounding(o1 @ o2);
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd(d, datasize, elements, esize, n, rounding, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, bitzero, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 306) = {
    SEE = 306;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 12, 1);
    let sz = Slice(__opcode, 22, 1);
    let o2 = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fcvtmu_advsimd_aarch64_instrs_vector_arithmetic_unary_float_conv_float_bulk_simd(Rd, Rn, o1, sz, o2, U, Q)
}

val decode_fcvtns_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd : (bits(5), bits(5), bits(1), bits(1), bits(1)) -> unit

function decode_fcvtns_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd (Rd, Rn, o1, o2, U) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = 16;
    let 'datasize = esize;
    let 'elements = 1;
    let rounding : FPRounding = FPDecodeRounding(o1 @ o2);
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd(d, datasize, elements, esize, n, rounding, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 307) = {
    SEE = 307;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 12, 1);
    let o2 = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    decode_fcvtns_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd(Rd, Rn, o1, o2, U)
}

val decode_fcvtns_advsimd_aarch64_instrs_vector_arithmetic_unary_float_conv_float_bulk_sisd : (bits(5), bits(5), bits(1), bits(1), bits(1), bits(1)) -> unit

function decode_fcvtns_advsimd_aarch64_instrs_vector_arithmetic_unary_float_conv_float_bulk_sisd (Rd, Rn, o1, sz, o2, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = (32 << UInt(sz));
    let 'datasize = esize;
    let 'elements = 1;
    let rounding : FPRounding = FPDecodeRounding(o1 @ o2);
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd(d, datasize, elements, esize, n, rounding, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 308) = {
    SEE = 308;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 12, 1);
    let sz = Slice(__opcode, 22, 1);
    let o2 = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    decode_fcvtns_advsimd_aarch64_instrs_vector_arithmetic_unary_float_conv_float_bulk_sisd(Rd, Rn, o1, sz, o2, U)
}

val decode_fcvtns_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_simd : (bits(5), bits(5), bits(1), bits(1), bits(1), bits(1)) -> unit

function decode_fcvtns_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_simd (Rd, Rn, o1, o2, U, Q) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = 16;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let rounding : FPRounding = FPDecodeRounding(o1 @ o2);
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd(d, datasize, elements, esize, n, rounding, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 309) = {
    SEE = 309;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 12, 1);
    let o2 = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fcvtns_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_simd(Rd, Rn, o1, o2, U, Q)
}

val decode_fcvtns_advsimd_aarch64_instrs_vector_arithmetic_unary_float_conv_float_bulk_simd : (bits(5), bits(5), bits(1), bits(1), bits(1), bits(1), bits(1)) -> unit

function decode_fcvtns_advsimd_aarch64_instrs_vector_arithmetic_unary_float_conv_float_bulk_simd (Rd, Rn, o1, sz, o2, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    };
    let 'esize = (32 << UInt(sz));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let rounding : FPRounding = FPDecodeRounding(o1 @ o2);
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd(d, datasize, elements, esize, n, rounding, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 310) = {
    SEE = 310;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 12, 1);
    let sz = Slice(__opcode, 22, 1);
    let o2 = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fcvtns_advsimd_aarch64_instrs_vector_arithmetic_unary_float_conv_float_bulk_simd(Rd, Rn, o1, sz, o2, U, Q)
}

val decode_fcvtnu_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd : (bits(5), bits(5), bits(1), bits(1), bits(1)) -> unit

function decode_fcvtnu_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd (Rd, Rn, o1, o2, U) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = 16;
    let 'datasize = esize;
    let 'elements = 1;
    let rounding : FPRounding = FPDecodeRounding(o1 @ o2);
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd(d, datasize, elements, esize, n, rounding, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 311) = {
    SEE = 311;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 12, 1);
    let o2 = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    decode_fcvtnu_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd(Rd, Rn, o1, o2, U)
}

val decode_fcvtnu_advsimd_aarch64_instrs_vector_arithmetic_unary_float_conv_float_bulk_sisd : (bits(5), bits(5), bits(1), bits(1), bits(1), bits(1)) -> unit

function decode_fcvtnu_advsimd_aarch64_instrs_vector_arithmetic_unary_float_conv_float_bulk_sisd (Rd, Rn, o1, sz, o2, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = (32 << UInt(sz));
    let 'datasize = esize;
    let 'elements = 1;
    let rounding : FPRounding = FPDecodeRounding(o1 @ o2);
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd(d, datasize, elements, esize, n, rounding, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 312) = {
    SEE = 312;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 12, 1);
    let sz = Slice(__opcode, 22, 1);
    let o2 = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    decode_fcvtnu_advsimd_aarch64_instrs_vector_arithmetic_unary_float_conv_float_bulk_sisd(Rd, Rn, o1, sz, o2, U)
}

val decode_fcvtnu_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_simd : (bits(5), bits(5), bits(1), bits(1), bits(1), bits(1)) -> unit

function decode_fcvtnu_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_simd (Rd, Rn, o1, o2, U, Q) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = 16;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let rounding : FPRounding = FPDecodeRounding(o1 @ o2);
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd(d, datasize, elements, esize, n, rounding, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 313) = {
    SEE = 313;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 12, 1);
    let o2 = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fcvtnu_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_simd(Rd, Rn, o1, o2, U, Q)
}

val decode_fcvtnu_advsimd_aarch64_instrs_vector_arithmetic_unary_float_conv_float_bulk_simd : (bits(5), bits(5), bits(1), bits(1), bits(1), bits(1), bits(1)) -> unit

function decode_fcvtnu_advsimd_aarch64_instrs_vector_arithmetic_unary_float_conv_float_bulk_simd (Rd, Rn, o1, sz, o2, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    };
    let 'esize = (32 << UInt(sz));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let rounding : FPRounding = FPDecodeRounding(o1 @ o2);
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd(d, datasize, elements, esize, n, rounding, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, bitzero, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 314) = {
    SEE = 314;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 12, 1);
    let sz = Slice(__opcode, 22, 1);
    let o2 = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fcvtnu_advsimd_aarch64_instrs_vector_arithmetic_unary_float_conv_float_bulk_simd(Rd, Rn, o1, sz, o2, U, Q)
}

val decode_fcvtps_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd : (bits(5), bits(5), bits(1), bits(1), bits(1)) -> unit

function decode_fcvtps_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd (Rd, Rn, o1, o2, U) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = 16;
    let 'datasize = esize;
    let 'elements = 1;
    let rounding : FPRounding = FPDecodeRounding(o1 @ o2);
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd(d, datasize, elements, esize, n, rounding, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 315) = {
    SEE = 315;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 12, 1);
    let o2 = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    decode_fcvtps_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd(Rd, Rn, o1, o2, U)
}

val decode_fcvtps_advsimd_aarch64_instrs_vector_arithmetic_unary_float_conv_float_bulk_sisd : (bits(5), bits(5), bits(1), bits(1), bits(1), bits(1)) -> unit

function decode_fcvtps_advsimd_aarch64_instrs_vector_arithmetic_unary_float_conv_float_bulk_sisd (Rd, Rn, o1, sz, o2, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = (32 << UInt(sz));
    let 'datasize = esize;
    let 'elements = 1;
    let rounding : FPRounding = FPDecodeRounding(o1 @ o2);
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd(d, datasize, elements, esize, n, rounding, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, bitone, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 316) = {
    SEE = 316;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 12, 1);
    let sz = Slice(__opcode, 22, 1);
    let o2 = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    decode_fcvtps_advsimd_aarch64_instrs_vector_arithmetic_unary_float_conv_float_bulk_sisd(Rd, Rn, o1, sz, o2, U)
}

val decode_fcvtps_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_simd : (bits(5), bits(5), bits(1), bits(1), bits(1), bits(1)) -> unit

function decode_fcvtps_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_simd (Rd, Rn, o1, o2, U, Q) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = 16;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let rounding : FPRounding = FPDecodeRounding(o1 @ o2);
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd(d, datasize, elements, esize, n, rounding, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 317) = {
    SEE = 317;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 12, 1);
    let o2 = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fcvtps_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_simd(Rd, Rn, o1, o2, U, Q)
}

val decode_fcvtps_advsimd_aarch64_instrs_vector_arithmetic_unary_float_conv_float_bulk_simd : (bits(5), bits(5), bits(1), bits(1), bits(1), bits(1), bits(1)) -> unit

function decode_fcvtps_advsimd_aarch64_instrs_vector_arithmetic_unary_float_conv_float_bulk_simd (Rd, Rn, o1, sz, o2, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    };
    let 'esize = (32 << UInt(sz));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let rounding : FPRounding = FPDecodeRounding(o1 @ o2);
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd(d, datasize, elements, esize, n, rounding, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitone, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 318) = {
    SEE = 318;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 12, 1);
    let sz = Slice(__opcode, 22, 1);
    let o2 = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fcvtps_advsimd_aarch64_instrs_vector_arithmetic_unary_float_conv_float_bulk_simd(Rd, Rn, o1, sz, o2, U, Q)
}

val decode_fcvtpu_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd : (bits(5), bits(5), bits(1), bits(1), bits(1)) -> unit

function decode_fcvtpu_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd (Rd, Rn, o1, o2, U) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = 16;
    let 'datasize = esize;
    let 'elements = 1;
    let rounding : FPRounding = FPDecodeRounding(o1 @ o2);
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd(d, datasize, elements, esize, n, rounding, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 319) = {
    SEE = 319;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 12, 1);
    let o2 = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    decode_fcvtpu_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd(Rd, Rn, o1, o2, U)
}

val decode_fcvtpu_advsimd_aarch64_instrs_vector_arithmetic_unary_float_conv_float_bulk_sisd : (bits(5), bits(5), bits(1), bits(1), bits(1), bits(1)) -> unit

function decode_fcvtpu_advsimd_aarch64_instrs_vector_arithmetic_unary_float_conv_float_bulk_sisd (Rd, Rn, o1, sz, o2, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = (32 << UInt(sz));
    let 'datasize = esize;
    let 'elements = 1;
    let rounding : FPRounding = FPDecodeRounding(o1 @ o2);
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd(d, datasize, elements, esize, n, rounding, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, bitone, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 320) = {
    SEE = 320;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 12, 1);
    let sz = Slice(__opcode, 22, 1);
    let o2 = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    decode_fcvtpu_advsimd_aarch64_instrs_vector_arithmetic_unary_float_conv_float_bulk_sisd(Rd, Rn, o1, sz, o2, U)
}

val decode_fcvtpu_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_simd : (bits(5), bits(5), bits(1), bits(1), bits(1), bits(1)) -> unit

function decode_fcvtpu_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_simd (Rd, Rn, o1, o2, U, Q) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = 16;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let rounding : FPRounding = FPDecodeRounding(o1 @ o2);
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd(d, datasize, elements, esize, n, rounding, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 321) = {
    SEE = 321;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 12, 1);
    let o2 = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fcvtpu_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_simd(Rd, Rn, o1, o2, U, Q)
}

val decode_fcvtpu_advsimd_aarch64_instrs_vector_arithmetic_unary_float_conv_float_bulk_simd : (bits(5), bits(5), bits(1), bits(1), bits(1), bits(1), bits(1)) -> unit

function decode_fcvtpu_advsimd_aarch64_instrs_vector_arithmetic_unary_float_conv_float_bulk_simd (Rd, Rn, o1, sz, o2, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    };
    let 'esize = (32 << UInt(sz));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let rounding : FPRounding = FPDecodeRounding(o1 @ o2);
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd(d, datasize, elements, esize, n, rounding, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, bitone, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 322) = {
    SEE = 322;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 12, 1);
    let sz = Slice(__opcode, 22, 1);
    let o2 = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fcvtpu_advsimd_aarch64_instrs_vector_arithmetic_unary_float_conv_float_bulk_simd(Rd, Rn, o1, sz, o2, U, Q)
}

val decode_fcvtzs_advsimd_int_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd : (bits(5), bits(5), bits(1), bits(1), bits(1)) -> unit

function decode_fcvtzs_advsimd_int_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd (Rd, Rn, o1, o2, U) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = 16;
    let 'datasize = esize;
    let 'elements = 1;
    let rounding : FPRounding = FPDecodeRounding(o1 @ o2);
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd(d, datasize, elements, esize, n, rounding, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 323) = {
    SEE = 323;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 12, 1);
    let o2 = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    decode_fcvtzs_advsimd_int_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd(Rd, Rn, o1, o2, U)
}

val decode_fcvtzs_advsimd_int_aarch64_instrs_vector_arithmetic_unary_float_conv_float_bulk_sisd : (bits(5), bits(5), bits(1), bits(1), bits(1), bits(1)) -> unit

function decode_fcvtzs_advsimd_int_aarch64_instrs_vector_arithmetic_unary_float_conv_float_bulk_sisd (Rd, Rn, o1, sz, o2, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = (32 << UInt(sz));
    let 'datasize = esize;
    let 'elements = 1;
    let rounding : FPRounding = FPDecodeRounding(o1 @ o2);
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd(d, datasize, elements, esize, n, rounding, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, bitone, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 324) = {
    SEE = 324;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 12, 1);
    let sz = Slice(__opcode, 22, 1);
    let o2 = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    decode_fcvtzs_advsimd_int_aarch64_instrs_vector_arithmetic_unary_float_conv_float_bulk_sisd(Rd, Rn, o1, sz, o2, U)
}

val decode_fcvtzs_advsimd_int_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_simd : (bits(5), bits(5), bits(1), bits(1), bits(1), bits(1)) -> unit

function decode_fcvtzs_advsimd_int_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_simd (Rd, Rn, o1, o2, U, Q) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = 16;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let rounding : FPRounding = FPDecodeRounding(o1 @ o2);
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd(d, datasize, elements, esize, n, rounding, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 325) = {
    SEE = 325;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 12, 1);
    let o2 = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fcvtzs_advsimd_int_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_simd(Rd, Rn, o1, o2, U, Q)
}

val decode_fcvtzs_advsimd_int_aarch64_instrs_vector_arithmetic_unary_float_conv_float_bulk_simd : (bits(5), bits(5), bits(1), bits(1), bits(1), bits(1), bits(1)) -> unit

function decode_fcvtzs_advsimd_int_aarch64_instrs_vector_arithmetic_unary_float_conv_float_bulk_simd (Rd, Rn, o1, sz, o2, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    };
    let 'esize = (32 << UInt(sz));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let rounding : FPRounding = FPDecodeRounding(o1 @ o2);
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd(d, datasize, elements, esize, n, rounding, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitone, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 326) = {
    SEE = 326;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 12, 1);
    let sz = Slice(__opcode, 22, 1);
    let o2 = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fcvtzs_advsimd_int_aarch64_instrs_vector_arithmetic_unary_float_conv_float_bulk_simd(Rd, Rn, o1, sz, o2, U, Q)
}

val decode_fcvtzu_advsimd_int_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd : (bits(5), bits(5), bits(1), bits(1), bits(1)) -> unit

function decode_fcvtzu_advsimd_int_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd (Rd, Rn, o1, o2, U) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = 16;
    let 'datasize = esize;
    let 'elements = 1;
    let rounding : FPRounding = FPDecodeRounding(o1 @ o2);
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd(d, datasize, elements, esize, n, rounding, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 327) = {
    SEE = 327;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 12, 1);
    let o2 = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    decode_fcvtzu_advsimd_int_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd(Rd, Rn, o1, o2, U)
}

val decode_fcvtzu_advsimd_int_aarch64_instrs_vector_arithmetic_unary_float_conv_float_bulk_sisd : (bits(5), bits(5), bits(1), bits(1), bits(1), bits(1)) -> unit

function decode_fcvtzu_advsimd_int_aarch64_instrs_vector_arithmetic_unary_float_conv_float_bulk_sisd (Rd, Rn, o1, sz, o2, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = (32 << UInt(sz));
    let 'datasize = esize;
    let 'elements = 1;
    let rounding : FPRounding = FPDecodeRounding(o1 @ o2);
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd(d, datasize, elements, esize, n, rounding, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, bitone, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 328) = {
    SEE = 328;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 12, 1);
    let sz = Slice(__opcode, 22, 1);
    let o2 = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    decode_fcvtzu_advsimd_int_aarch64_instrs_vector_arithmetic_unary_float_conv_float_bulk_sisd(Rd, Rn, o1, sz, o2, U)
}

val decode_fcvtzu_advsimd_int_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_simd : (bits(5), bits(5), bits(1), bits(1), bits(1), bits(1)) -> unit

function decode_fcvtzu_advsimd_int_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_simd (Rd, Rn, o1, o2, U, Q) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = 16;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let rounding : FPRounding = FPDecodeRounding(o1 @ o2);
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd(d, datasize, elements, esize, n, rounding, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 329) = {
    SEE = 329;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 12, 1);
    let o2 = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fcvtzu_advsimd_int_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_simd(Rd, Rn, o1, o2, U, Q)
}

val decode_fcvtzu_advsimd_int_aarch64_instrs_vector_arithmetic_unary_float_conv_float_bulk_simd : (bits(5), bits(5), bits(1), bits(1), bits(1), bits(1), bits(1)) -> unit

function decode_fcvtzu_advsimd_int_aarch64_instrs_vector_arithmetic_unary_float_conv_float_bulk_simd (Rd, Rn, o1, sz, o2, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    };
    let 'esize = (32 << UInt(sz));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let rounding : FPRounding = FPDecodeRounding(o1 @ o2);
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd(d, datasize, elements, esize, n, rounding, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, bitone, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 330) = {
    SEE = 330;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 12, 1);
    let sz = Slice(__opcode, 22, 1);
    let o2 = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fcvtzu_advsimd_int_aarch64_instrs_vector_arithmetic_unary_float_conv_float_bulk_simd(Rd, Rn, o1, sz, o2, U, Q)
}

val execute_aarch64_instrs_vector_arithmetic_unary_float_narrow : forall 'd 'datasize 'elements 'esize 'n 'part,
  ('part in {0, 1} & 0 <= 'n & 'n <= 31 & 'esize in {16, 32} & 'datasize == 64 & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('n), int('part)) -> unit

function execute_aarch64_instrs_vector_arithmetic_unary_float_narrow (d, datasize, elements, esize, n, part) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits(2 * 'datasize) = V_read(n, 2 * datasize);
    result : bits('datasize) = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        result = Elem_set(result, e, esize, FPConvert__1(Elem_read(operand, e, 2 * esize), FPCR_read(), esize))
    };
    Vpart_set(d, part, datasize) = result
}

val decode_fcvtn_advsimd_aarch64_instrs_vector_arithmetic_unary_float_narrow : (bits(5), bits(5), bits(1), bits(1)) -> unit

function decode_fcvtn_advsimd_aarch64_instrs_vector_arithmetic_unary_float_narrow (Rd, Rn, sz, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = (16 << UInt(sz));
    let 'datasize = 64;
    let 'part = UInt(Q);
    let 'elements = DIV(datasize, esize);
    assert(constraint('esize in {16, 32}));
    execute_aarch64_instrs_vector_arithmetic_unary_float_narrow(d, datasize, elements, esize, n, part)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 331) = {
    SEE = 331;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let sz = Slice(__opcode, 22, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fcvtn_advsimd_aarch64_instrs_vector_arithmetic_unary_float_narrow(Rd, Rn, sz, Q)
}

val execute_aarch64_instrs_vector_arithmetic_unary_float_xtn_sisd : forall 'd 'datasize 'elements 'esize 'n 'part,
  ('part in {0, 1} & 0 <= 'n & 'n <= 31 & 'esize == 32 & 'elements in {1, 2} & 'datasize in {32, 64} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('n), int('part)) -> unit

function execute_aarch64_instrs_vector_arithmetic_unary_float_xtn_sisd (d, datasize, elements, esize, n, part) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits(2 * 'datasize) = V_read(n, 2 * datasize);
    let fpcr : FPCRType = FPCR_read();
    let merge : bool = elements == 1 & IsMerging(fpcr);
    result : bits(128) = if merge then V_read(d, 128) else Zeros(128);
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        result = Elem_set(result, e, esize, FPConvert(Elem_read(operand, e, 2 * esize), fpcr, FPRounding_ODD, esize))
    };
    if merge then {
        V_set(d, 128) = result
    } else {
        Vpart_set(d, part, datasize) = Elem_read(result, 0, datasize)
    }
}

val decode_fcvtxn_advsimd_aarch64_instrs_vector_arithmetic_unary_float_xtn_sisd : (bits(5), bits(5), bits(1)) -> unit

function decode_fcvtxn_advsimd_aarch64_instrs_vector_arithmetic_unary_float_xtn_sisd (Rd, Rn, sz) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if sz == 0b0 then {
        throw(Error_Undefined())
    };
    let 'esize = 32;
    let 'datasize = esize;
    let 'elements = 1;
    let 'part = 0;
    execute_aarch64_instrs_vector_arithmetic_unary_float_xtn_sisd(d, datasize, elements, esize, n, part)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 332) = {
    SEE = 332;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let sz = Slice(__opcode, 22, 1);
    decode_fcvtxn_advsimd_aarch64_instrs_vector_arithmetic_unary_float_xtn_sisd(Rd, Rn, sz)
}

val decode_fcvtxn_advsimd_aarch64_instrs_vector_arithmetic_unary_float_xtn_simd : (bits(5), bits(5), bits(1), bits(1)) -> unit

function decode_fcvtxn_advsimd_aarch64_instrs_vector_arithmetic_unary_float_xtn_simd (Rd, Rn, sz, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if sz == 0b0 then {
        throw(Error_Undefined())
    };
    let 'esize = 32;
    let 'datasize = 64;
    let 'elements = 2;
    let 'part = UInt(Q);
    execute_aarch64_instrs_vector_arithmetic_unary_float_xtn_sisd(d, datasize, elements, esize, n, part)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, bitzero, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 333) = {
    SEE = 333;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let sz = Slice(__opcode, 22, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fcvtxn_advsimd_aarch64_instrs_vector_arithmetic_unary_float_xtn_simd(Rd, Rn, sz, Q)
}

val execute_aarch64_instrs_float_convert_fix : forall 'd 'fltsize 'fracbits 'intsize ('is_unsigned : Bool) 'n,
  (0 <= 'n & 'n <= 31 & 'intsize in {32, 64} & 1 <= 'fracbits & 'fracbits <= 64 & 'fltsize in {16, 32, 64} & 0 <= 'd & 'd <= 31).
  (int('d), int('fltsize), int('fracbits), int('intsize), int('n), FPConvOp, FPRounding, bool('is_unsigned)) -> unit

function execute_aarch64_instrs_float_convert_fix (d, fltsize, fracbits, intsize, n, op, rounding, is_unsigned) = {
    CheckFPEnabled64();
    let fpcr : FPCRType = FPCR_read();
    let merge : bool = IsMerging(fpcr);
    let 'fsize = if op == FPConvOp_CVT_ItoF & merge then 128 else fltsize;
    fltval : bits('fsize) = undefined;
    intval : bits('intsize) = undefined;
    match op {
      FPConvOp_CVT_FtoI => {
          let fltval : bits('fsize) = V_read(n, fsize);
          assert(constraint(('fsize in {16, 32, 64} & 'intsize in {16, 32, 64})));
          let intval : bits('intsize) = FPToFixed(fltval, fracbits, is_unsigned, fpcr, rounding, intsize);
          X_set(d, intsize) = intval
      },
      FPConvOp_CVT_ItoF => {
          let intval : bits('intsize) = X_read(n, intsize);
          fltval : bits('fsize) = if merge then V_read(d, fsize) else
            Zeros(fsize);
          fltval = Elem_set(fltval, 0, fltsize, FixedToFP(intval, fracbits, is_unsigned, fpcr, rounding, fltsize));
          V_set(d, fsize) = fltval
      },
      _ => ()
    }
}

val decode_fcvtzs_float_fix_aarch64_instrs_float_convert_fix : (bits(5), bits(5), bits(6), bits(3), bits(2), bits(2), bits(1)) -> unit

function decode_fcvtzs_float_fix_aarch64_instrs_float_convert_fix (Rd, Rn, scale, opcode, rmode, ftype, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'intsize = if sf == 0b1 then 64 else 32;
    fltsize : {16, 32, 64} = 16;
    op : FPConvOp = undefined;
    rounding : FPRounding = undefined;
    is_unsigned : bool = undefined;
    match ftype {
      0b00 => {
          fltsize = 32
      },
      0b01 => {
          fltsize = 64
      },
      0b10 => {
          throw(Error_Undefined())
      },
      0b11 => {
          if HaveFP16Ext() then {
              fltsize = 16
          } else {
              throw(Error_Undefined())
          }
      }
    };
    let 'fltsize = fltsize;
    if sf == 0b0 & [scale[5]] == 0b0 then {
        throw(Error_Undefined())
    };
    let 'fracbits = 64 - UInt(scale);
    match opcode[2 .. 1] @ rmode {
      0b0011 => {
          rounding = FPRounding_ZERO;
          is_unsigned = [opcode[0]] == 0b1;
          op = FPConvOp_CVT_FtoI
      },
      0b0100 => {
          rounding = FPRoundingMode(FPCR_read());
          is_unsigned = [opcode[0]] == 0b1;
          op = FPConvOp_CVT_ItoF
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    execute_aarch64_instrs_float_convert_fix(d, fltsize, fracbits, intsize, n, op, rounding, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([_, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, bitzero, bitone, bitone, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 334) = {
    SEE = 334;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let scale = Slice(__opcode, 10, 6);
    let opcode = Slice(__opcode, 16, 3);
    let rmode = Slice(__opcode, 19, 2);
    let ftype = Slice(__opcode, 22, 2);
    let sf = Slice(__opcode, 31, 1);
    decode_fcvtzs_float_fix_aarch64_instrs_float_convert_fix(Rd, Rn, scale, opcode, rmode, ftype, sf)
}

val decode_fcvtzu_float_fix_aarch64_instrs_float_convert_fix : (bits(5), bits(5), bits(6), bits(3), bits(2), bits(2), bits(1)) -> unit

function decode_fcvtzu_float_fix_aarch64_instrs_float_convert_fix (Rd, Rn, scale, opcode, rmode, ftype, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'intsize = if sf == 0b1 then 64 else 32;
    fltsize : {16, 32, 64} = 16;
    op : FPConvOp = undefined;
    rounding : FPRounding = undefined;
    is_unsigned : bool = undefined;
    match ftype {
      0b00 => {
          fltsize = 32
      },
      0b01 => {
          fltsize = 64
      },
      0b10 => {
          throw(Error_Undefined())
      },
      0b11 => {
          if HaveFP16Ext() then {
              fltsize = 16
          } else {
              throw(Error_Undefined())
          }
      }
    };
    let 'fltsize = fltsize;
    if sf == 0b0 & [scale[5]] == 0b0 then {
        throw(Error_Undefined())
    };
    let 'fracbits = 64 - UInt(scale);
    match opcode[2 .. 1] @ rmode {
      0b0011 => {
          rounding = FPRounding_ZERO;
          is_unsigned = [opcode[0]] == 0b1;
          op = FPConvOp_CVT_FtoI
      },
      0b0100 => {
          rounding = FPRoundingMode(FPCR_read());
          is_unsigned = [opcode[0]] == 0b1;
          op = FPConvOp_CVT_ItoF
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    execute_aarch64_instrs_float_convert_fix(d, fltsize, fracbits, intsize, n, op, rounding, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([_, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, bitzero, bitone, bitone, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 335) = {
    SEE = 335;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let scale = Slice(__opcode, 10, 6);
    let opcode = Slice(__opcode, 16, 3);
    let rmode = Slice(__opcode, 19, 2);
    let ftype = Slice(__opcode, 22, 2);
    let sf = Slice(__opcode, 31, 1);
    decode_fcvtzu_float_fix_aarch64_instrs_float_convert_fix(Rd, Rn, scale, opcode, rmode, ftype, sf)
}

val decode_scvtf_float_fix_aarch64_instrs_float_convert_fix : (bits(5), bits(5), bits(6), bits(3), bits(2), bits(2), bits(1)) -> unit

function decode_scvtf_float_fix_aarch64_instrs_float_convert_fix (Rd, Rn, scale, opcode, rmode, ftype, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'intsize = if sf == 0b1 then 64 else 32;
    fltsize : {16, 32, 64} = 16;
    op : FPConvOp = undefined;
    rounding : FPRounding = undefined;
    is_unsigned : bool = undefined;
    match ftype {
      0b00 => {
          fltsize = 32
      },
      0b01 => {
          fltsize = 64
      },
      0b10 => {
          throw(Error_Undefined())
      },
      0b11 => {
          if HaveFP16Ext() then {
              fltsize = 16
          } else {
              throw(Error_Undefined())
          }
      }
    };
    let 'fltsize = fltsize;
    if sf == 0b0 & [scale[5]] == 0b0 then {
        throw(Error_Undefined())
    };
    let 'fracbits = 64 - UInt(scale);
    match opcode[2 .. 1] @ rmode {
      0b0011 => {
          rounding = FPRounding_ZERO;
          is_unsigned = [opcode[0]] == 0b1;
          op = FPConvOp_CVT_FtoI
      },
      0b0100 => {
          rounding = FPRoundingMode(FPCR_read());
          is_unsigned = [opcode[0]] == 0b1;
          op = FPConvOp_CVT_ItoF
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    execute_aarch64_instrs_float_convert_fix(d, fltsize, fracbits, intsize, n, op, rounding, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([_, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 336) = {
    SEE = 336;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let scale = Slice(__opcode, 10, 6);
    let opcode = Slice(__opcode, 16, 3);
    let rmode = Slice(__opcode, 19, 2);
    let ftype = Slice(__opcode, 22, 2);
    let sf = Slice(__opcode, 31, 1);
    decode_scvtf_float_fix_aarch64_instrs_float_convert_fix(Rd, Rn, scale, opcode, rmode, ftype, sf)
}

val decode_ucvtf_float_fix_aarch64_instrs_float_convert_fix : (bits(5), bits(5), bits(6), bits(3), bits(2), bits(2), bits(1)) -> unit

function decode_ucvtf_float_fix_aarch64_instrs_float_convert_fix (Rd, Rn, scale, opcode, rmode, ftype, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'intsize = if sf == 0b1 then 64 else 32;
    fltsize : {16, 32, 64} = 16;
    op : FPConvOp = undefined;
    rounding : FPRounding = undefined;
    is_unsigned : bool = undefined;
    match ftype {
      0b00 => {
          fltsize = 32
      },
      0b01 => {
          fltsize = 64
      },
      0b10 => {
          throw(Error_Undefined())
      },
      0b11 => {
          if HaveFP16Ext() then {
              fltsize = 16
          } else {
              throw(Error_Undefined())
          }
      }
    };
    let 'fltsize = fltsize;
    if sf == 0b0 & [scale[5]] == 0b0 then {
        throw(Error_Undefined())
    };
    let 'fracbits = 64 - UInt(scale);
    match opcode[2 .. 1] @ rmode {
      0b0011 => {
          rounding = FPRounding_ZERO;
          is_unsigned = [opcode[0]] == 0b1;
          op = FPConvOp_CVT_FtoI
      },
      0b0100 => {
          rounding = FPRoundingMode(FPCR_read());
          is_unsigned = [opcode[0]] == 0b1;
          op = FPConvOp_CVT_ItoF
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    execute_aarch64_instrs_float_convert_fix(d, fltsize, fracbits, intsize, n, op, rounding, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([_, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, bitzero, bitzero, bitzero, bitzero, bitone, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 337) = {
    SEE = 337;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let scale = Slice(__opcode, 10, 6);
    let opcode = Slice(__opcode, 16, 3);
    let rmode = Slice(__opcode, 19, 2);
    let ftype = Slice(__opcode, 22, 2);
    let sf = Slice(__opcode, 31, 1);
    decode_ucvtf_float_fix_aarch64_instrs_float_convert_fix(Rd, Rn, scale, opcode, rmode, ftype, sf)
}

val execute_aarch64_instrs_vector_shift_conv_float_sisd : forall 'd 'datasize 'elements 'esize 'fracbits ('is_unsigned : Bool) 'n,
  (0 <= 'n & 'n <= 31 & 'esize in {16, 32, 64} & 'datasize in {16, 32, 64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('fracbits), int('n), FPRounding, bool('is_unsigned)) -> unit

function execute_aarch64_instrs_vector_shift_conv_float_sisd (d, datasize, elements, esize, fracbits, n, rounding, is_unsigned) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('datasize) = V_read(n, datasize);
    element : bits('esize) = undefined;
    let fpcr : FPCRType = FPCR_read();
    let merge : bool = elements == 1 & IsMerging(fpcr);
    result : bits(128) = if merge then V_read(d, 128) else Zeros(128);
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element = Elem_read(operand, e, esize);
        result = Elem_set(result, e, esize, FPToFixed(element, fracbits, is_unsigned, fpcr, rounding, esize))
    };
    V_set(d, 128) = result
}

val decode_fcvtzs_advsimd_fix_aarch64_instrs_vector_shift_conv_float_sisd : (bits(5), bits(5), bits(3), bits(4), bits(1)) -> unit

function decode_fcvtzs_advsimd_fix_aarch64_instrs_vector_shift_conv_float_sisd (Rd, Rn, immb, immh, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (match immh {
      [bitzero, bitzero, bitzero, _] => true,
      _ => false
    }) : bool | (match immh {
      [bitzero, bitzero, bitone, _] => true,
      _ => false
    }) : bool & not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'esize = if (match immh {
      [bitone, _, _, _] => true,
      _ => false
    }) : bool then
      64
    else
      if (match immh {
        [bitzero, bitone, _, _] => true,
        _ => false
      }) : bool then
        32
      else
        16;
    let 'datasize = esize;
    let 'elements = 1;
    let 'fracbits = esize * 2 - UInt(immh @ immb);
    let is_unsigned : bool = U == 0b1;
    let rounding : FPRounding = FPRounding_ZERO;
    execute_aarch64_instrs_vector_shift_conv_float_sisd(d, datasize, elements, esize, fracbits, n, rounding, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, bitone, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 338) = {
    SEE = 338;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let immb = Slice(__opcode, 16, 3);
    let immh = Slice(__opcode, 19, 4);
    let U = Slice(__opcode, 29, 1);
    decode_fcvtzs_advsimd_fix_aarch64_instrs_vector_shift_conv_float_sisd(Rd, Rn, immb, immh, U)
}

val decode_fcvtzs_advsimd_fix_aarch64_instrs_vector_shift_conv_float_simd : (bits(5), bits(5), bits(3), bits(4), bits(1), bits(1)) -> unit

function decode_fcvtzs_advsimd_fix_aarch64_instrs_vector_shift_conv_float_simd (Rd, Rn, immb, immh, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if immh == 0b0000 then {
        throw(Error_See("asimdimm"))
    };
    if (match immh {
      [bitzero, bitzero, bitzero, _] => true,
      _ => false
    }) : bool | (match immh {
      [bitzero, bitzero, bitone, _] => true,
      _ => false
    }) : bool & not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    if ([immh[3]] @ Q) == 0b10 then {
        throw(Error_Undefined())
    };
    let 'esize = if (match immh {
      [bitone, _, _, _] => true,
      _ => false
    }) : bool then
      64
    else
      if (match immh {
        [bitzero, bitone, _, _] => true,
        _ => false
      }) : bool then
        32
      else
        16;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let 'fracbits = esize * 2 - UInt(immh @ immb);
    let is_unsigned : bool = U == 0b1;
    let rounding : FPRounding = FPRounding_ZERO;
    execute_aarch64_instrs_vector_shift_conv_float_sisd(d, datasize, elements, esize, fracbits, n, rounding, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, bitone, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 339) = {
    SEE = 339;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let immb = Slice(__opcode, 16, 3);
    let immh = Slice(__opcode, 19, 4);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fcvtzs_advsimd_fix_aarch64_instrs_vector_shift_conv_float_simd(Rd, Rn, immb, immh, U, Q)
}

val decode_fcvtzu_advsimd_fix_aarch64_instrs_vector_shift_conv_float_sisd : (bits(5), bits(5), bits(3), bits(4), bits(1)) -> unit

function decode_fcvtzu_advsimd_fix_aarch64_instrs_vector_shift_conv_float_sisd (Rd, Rn, immb, immh, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (match immh {
      [bitzero, bitzero, bitzero, _] => true,
      _ => false
    }) : bool | (match immh {
      [bitzero, bitzero, bitone, _] => true,
      _ => false
    }) : bool & not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'esize = if (match immh {
      [bitone, _, _, _] => true,
      _ => false
    }) : bool then
      64
    else
      if (match immh {
        [bitzero, bitone, _, _] => true,
        _ => false
      }) : bool then
        32
      else
        16;
    let 'datasize = esize;
    let 'elements = 1;
    let 'fracbits = esize * 2 - UInt(immh @ immb);
    let is_unsigned : bool = U == 0b1;
    let rounding : FPRounding = FPRounding_ZERO;
    execute_aarch64_instrs_vector_shift_conv_float_sisd(d, datasize, elements, esize, fracbits, n, rounding, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, bitone, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 340) = {
    SEE = 340;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let immb = Slice(__opcode, 16, 3);
    let immh = Slice(__opcode, 19, 4);
    let U = Slice(__opcode, 29, 1);
    decode_fcvtzu_advsimd_fix_aarch64_instrs_vector_shift_conv_float_sisd(Rd, Rn, immb, immh, U)
}

val decode_fcvtzu_advsimd_fix_aarch64_instrs_vector_shift_conv_float_simd : (bits(5), bits(5), bits(3), bits(4), bits(1), bits(1)) -> unit

function decode_fcvtzu_advsimd_fix_aarch64_instrs_vector_shift_conv_float_simd (Rd, Rn, immb, immh, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if immh == 0b0000 then {
        throw(Error_See("asimdimm"))
    };
    if (match immh {
      [bitzero, bitzero, bitzero, _] => true,
      _ => false
    }) : bool | (match immh {
      [bitzero, bitzero, bitone, _] => true,
      _ => false
    }) : bool & not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    if ([immh[3]] @ Q) == 0b10 then {
        throw(Error_Undefined())
    };
    let 'esize = if (match immh {
      [bitone, _, _, _] => true,
      _ => false
    }) : bool then
      64
    else
      if (match immh {
        [bitzero, bitone, _, _] => true,
        _ => false
      }) : bool then
        32
      else
        16;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let 'fracbits = esize * 2 - UInt(immh @ immb);
    let is_unsigned : bool = U == 0b1;
    let rounding : FPRounding = FPRounding_ZERO;
    execute_aarch64_instrs_vector_shift_conv_float_sisd(d, datasize, elements, esize, fracbits, n, rounding, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, bitone, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 341) = {
    SEE = 341;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let immb = Slice(__opcode, 16, 3);
    let immh = Slice(__opcode, 19, 4);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fcvtzu_advsimd_fix_aarch64_instrs_vector_shift_conv_float_simd(Rd, Rn, immb, immh, U, Q)
}

val execute_aarch64_instrs_vector_arithmetic_binary_uniform_div_fp16 : forall 'd 'datasize 'elements 'esize 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'esize in {16, 32, 64} & 'datasize in {64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('m), int('n)) -> unit

function execute_aarch64_instrs_vector_arithmetic_binary_uniform_div_fp16 (d, datasize, elements, esize, m, n) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = V_read(n, datasize);
    let operand2 : bits('datasize) = V_read(m, datasize);
    result : bits('datasize) = undefined;
    element1 : bits('esize) = undefined;
    element2 : bits('esize) = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element1 = Elem_read(operand1, e, esize);
        element2 = Elem_read(operand2, e, esize);
        result = Elem_set(result, e, esize, FPDiv(element1, element2, FPCR_read()))
    };
    V_set(d, datasize) = result
}

val decode_fdiv_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_div_fp16 : (bits(5), bits(5), bits(5), bits(1)) -> unit

function decode_fdiv_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_div_fp16 (Rd, Rn, Rm, Q) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = 16;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_div_fp16(d, datasize, elements, esize, m, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, bitzero, bitzero, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 342) = {
    SEE = 342;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let Q = Slice(__opcode, 30, 1);
    decode_fdiv_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_div_fp16(Rd, Rn, Rm, Q)
}

val decode_fdiv_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_div : (bits(5), bits(5), bits(5), bits(1), bits(1)) -> unit

function decode_fdiv_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_div (Rd, Rn, Rm, sz, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    };
    let 'esize = (32 << UInt(sz));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_div_fp16(d, datasize, elements, esize, m, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, bitzero, _, bitone, _, _, _, _, _, bitone, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 343) = {
    SEE = 343;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let sz = Slice(__opcode, 22, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fdiv_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_div(Rd, Rn, Rm, sz, Q)
}

val execute_aarch64_instrs_float_arithmetic_div : forall 'd 'esize 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'esize in {16, 32, 64} & 0 <= 'd & 'd <= 31).
  (int('d), int('esize), int('m), int('n)) -> unit

function execute_aarch64_instrs_float_arithmetic_div (d, esize, m, n) = {
    CheckFPEnabled64();
    let operand1 : bits('esize) = V_read(n, esize);
    let operand2 : bits('esize) = V_read(m, esize);
    let fpcr : FPCRType = FPCR_read();
    let merge : bool = IsMerging(fpcr);
    result : bits(128) = if merge then V_read(n, 128) else Zeros(128);
    result = Elem_set(result, 0, esize, FPDiv(operand1, operand2, FPCR_read()));
    V_set(d, 128) = result
}

val decode_fdiv_float_aarch64_instrs_float_arithmetic_div : (bits(5), bits(5), bits(5), bits(2)) -> unit

function decode_fdiv_float_aarch64_instrs_float_arithmetic_div (Rd, Rn, Rm, ftype) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    esize : {16, 32, 64} = 16;
    match ftype {
      0b00 => {
          esize = 32
      },
      0b01 => {
          esize = 64
      },
      0b10 => {
          throw(Error_Undefined())
      },
      0b11 => {
          if HaveFP16Ext() then {
              esize = 16
          } else {
              throw(Error_Undefined())
          }
      }
    };
    let 'esize = esize;
    execute_aarch64_instrs_float_arithmetic_div(d, esize, m, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitzero, bitzero, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 344) = {
    SEE = 344;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let ftype = Slice(__opcode, 22, 2);
    decode_fdiv_float_aarch64_instrs_float_arithmetic_div(Rd, Rn, Rm, ftype)
}

val execute_aarch64_instrs_float_arithmetic_mul_add_sub : forall 'a 'd 'esize 'm 'n ('op1_neg : Bool) ('opa_neg : Bool),
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'esize in {16, 32, 64} & 0 <= 'd & 'd <= 31 & 0 <= 'a & 'a <= 31).
  (int('a), int('d), int('esize), int('m), int('n), bool('op1_neg), bool('opa_neg)) -> unit

function execute_aarch64_instrs_float_arithmetic_mul_add_sub (a, d, esize, m, n, op1_neg, opa_neg) = {
    CheckFPEnabled64();
    operanda : bits('esize) = V_read(a, esize);
    operand1 : bits('esize) = V_read(n, esize);
    let operand2 : bits('esize) = V_read(m, esize);
    let fpcr : FPCRType = FPCR_read();
    let merge : bool = IsMerging(fpcr);
    result : bits(128) = if merge then V_read(a, 128) else Zeros(128);
    if opa_neg then {
        operanda = FPNeg(operanda)
    };
    if op1_neg then {
        operand1 = FPNeg(operand1)
    };
    result = Elem_set(result, 0, esize, FPMulAdd(operanda, operand1, operand2, fpcr));
    V_set(d, 128) = result
}

val decode_fmadd_float_aarch64_instrs_float_arithmetic_mul_add_sub : (bits(5), bits(5), bits(5), bits(1), bits(5), bits(1), bits(2)) -> unit

function decode_fmadd_float_aarch64_instrs_float_arithmetic_mul_add_sub (Rd, Rn, Ra, o0, Rm, o1, ftype) = {
    let 'd = UInt(Rd);
    let 'a = UInt(Ra);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    esize : {16, 32, 64} = 16;
    match ftype {
      0b00 => {
          esize = 32
      },
      0b01 => {
          esize = 64
      },
      0b10 => {
          throw(Error_Undefined())
      },
      0b11 => {
          if HaveFP16Ext() then {
              esize = 16
          } else {
              throw(Error_Undefined())
          }
      }
    };
    let 'esize = esize;
    let opa_neg : bool = o1 == 0b1;
    let op1_neg : bool = o0 != o1;
    execute_aarch64_instrs_float_arithmetic_mul_add_sub(a, d, esize, m, n, op1_neg, opa_neg)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitzero, bitzero, bitone, bitone, bitone, bitone, bitone, _, _, bitzero, _, _, _, _, _, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 345) = {
    SEE = 345;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Ra = Slice(__opcode, 10, 5);
    let o0 = Slice(__opcode, 15, 1);
    let Rm = Slice(__opcode, 16, 5);
    let o1 = Slice(__opcode, 21, 1);
    let ftype = Slice(__opcode, 22, 2);
    decode_fmadd_float_aarch64_instrs_float_arithmetic_mul_add_sub(Rd, Rn, Ra, o0, Rm, o1, ftype)
}

val decode_fmsub_float_aarch64_instrs_float_arithmetic_mul_add_sub : (bits(5), bits(5), bits(5), bits(1), bits(5), bits(1), bits(2)) -> unit

function decode_fmsub_float_aarch64_instrs_float_arithmetic_mul_add_sub (Rd, Rn, Ra, o0, Rm, o1, ftype) = {
    let 'd = UInt(Rd);
    let 'a = UInt(Ra);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    esize : {16, 32, 64} = 16;
    match ftype {
      0b00 => {
          esize = 32
      },
      0b01 => {
          esize = 64
      },
      0b10 => {
          throw(Error_Undefined())
      },
      0b11 => {
          if HaveFP16Ext() then {
              esize = 16
          } else {
              throw(Error_Undefined())
          }
      }
    };
    let 'esize = esize;
    let opa_neg : bool = o1 == 0b1;
    let op1_neg : bool = o0 != o1;
    execute_aarch64_instrs_float_arithmetic_mul_add_sub(a, d, esize, m, n, op1_neg, opa_neg)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitzero, bitzero, bitone, bitone, bitone, bitone, bitone, _, _, bitzero, _, _, _, _, _, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 346) = {
    SEE = 346;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Ra = Slice(__opcode, 10, 5);
    let o0 = Slice(__opcode, 15, 1);
    let Rm = Slice(__opcode, 16, 5);
    let o1 = Slice(__opcode, 21, 1);
    let ftype = Slice(__opcode, 22, 2);
    decode_fmsub_float_aarch64_instrs_float_arithmetic_mul_add_sub(Rd, Rn, Ra, o0, Rm, o1, ftype)
}

val decode_fnmadd_float_aarch64_instrs_float_arithmetic_mul_add_sub : (bits(5), bits(5), bits(5), bits(1), bits(5), bits(1), bits(2)) -> unit

function decode_fnmadd_float_aarch64_instrs_float_arithmetic_mul_add_sub (Rd, Rn, Ra, o0, Rm, o1, ftype) = {
    let 'd = UInt(Rd);
    let 'a = UInt(Ra);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    esize : {16, 32, 64} = 16;
    match ftype {
      0b00 => {
          esize = 32
      },
      0b01 => {
          esize = 64
      },
      0b10 => {
          throw(Error_Undefined())
      },
      0b11 => {
          if HaveFP16Ext() then {
              esize = 16
          } else {
              throw(Error_Undefined())
          }
      }
    };
    let 'esize = esize;
    let opa_neg : bool = o1 == 0b1;
    let op1_neg : bool = o0 != o1;
    execute_aarch64_instrs_float_arithmetic_mul_add_sub(a, d, esize, m, n, op1_neg, opa_neg)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitzero, bitzero, bitone, bitone, bitone, bitone, bitone, _, _, bitone, _, _, _, _, _, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 347) = {
    SEE = 347;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Ra = Slice(__opcode, 10, 5);
    let o0 = Slice(__opcode, 15, 1);
    let Rm = Slice(__opcode, 16, 5);
    let o1 = Slice(__opcode, 21, 1);
    let ftype = Slice(__opcode, 22, 2);
    decode_fnmadd_float_aarch64_instrs_float_arithmetic_mul_add_sub(Rd, Rn, Ra, o0, Rm, o1, ftype)
}

val decode_fnmsub_float_aarch64_instrs_float_arithmetic_mul_add_sub : (bits(5), bits(5), bits(5), bits(1), bits(5), bits(1), bits(2)) -> unit

function decode_fnmsub_float_aarch64_instrs_float_arithmetic_mul_add_sub (Rd, Rn, Ra, o0, Rm, o1, ftype) = {
    let 'd = UInt(Rd);
    let 'a = UInt(Ra);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    esize : {16, 32, 64} = 16;
    match ftype {
      0b00 => {
          esize = 32
      },
      0b01 => {
          esize = 64
      },
      0b10 => {
          throw(Error_Undefined())
      },
      0b11 => {
          if HaveFP16Ext() then {
              esize = 16
          } else {
              throw(Error_Undefined())
          }
      }
    };
    let 'esize = esize;
    let opa_neg : bool = o1 == 0b1;
    let op1_neg : bool = o0 != o1;
    execute_aarch64_instrs_float_arithmetic_mul_add_sub(a, d, esize, m, n, op1_neg, opa_neg)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitzero, bitzero, bitone, bitone, bitone, bitone, bitone, _, _, bitone, _, _, _, _, _, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 348) = {
    SEE = 348;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Ra = Slice(__opcode, 10, 5);
    let o0 = Slice(__opcode, 15, 1);
    let Rm = Slice(__opcode, 16, 5);
    let o1 = Slice(__opcode, 21, 1);
    let ftype = Slice(__opcode, 22, 2);
    decode_fnmsub_float_aarch64_instrs_float_arithmetic_mul_add_sub(Rd, Rn, Ra, o0, Rm, o1, ftype)
}

val execute_aarch64_instrs_float_arithmetic_max_min : forall 'd 'esize 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'esize in {16, 32, 64} & 0 <= 'd & 'd <= 31).
  (int('d), int('esize), int('m), int('n), FPMaxMinOp) -> unit

function execute_aarch64_instrs_float_arithmetic_max_min (d, esize, m, n, operation) = {
    CheckFPEnabled64();
    let operand1 : bits('esize) = V_read(n, esize);
    let operand2 : bits('esize) = V_read(m, esize);
    let fpcr : FPCRType = FPCR_read();
    let merge : bool = IsMerging(fpcr);
    result : bits(128) = if merge then V_read(n, 128) else Zeros(128);
    match operation {
      FPMaxMinOp_MAX => {
          result = Elem_set(result, 0, esize, FPMax(operand1, operand2, fpcr))
      },
      FPMaxMinOp_MIN => {
          result = Elem_set(result, 0, esize, FPMin(operand1, operand2, fpcr))
      },
      FPMaxMinOp_MAXNUM => {
          result = Elem_set(result, 0, esize, FPMaxNum(operand1, operand2, fpcr))
      },
      FPMaxMinOp_MINNUM => {
          result = Elem_set(result, 0, esize, FPMinNum(operand1, operand2, fpcr))
      }
    };
    V_set(d, 128) = result
}

val decode_fmax_float_aarch64_instrs_float_arithmetic_max_min : (bits(5), bits(5), bits(2), bits(5), bits(2)) -> unit

function decode_fmax_float_aarch64_instrs_float_arithmetic_max_min (Rd, Rn, op, Rm, ftype) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    esize : {16, 32, 64} = 16;
    match ftype {
      0b00 => {
          esize = 32
      },
      0b01 => {
          esize = 64
      },
      0b10 => {
          throw(Error_Undefined())
      },
      0b11 => {
          if HaveFP16Ext() then {
              esize = 16
          } else {
              throw(Error_Undefined())
          }
      }
    };
    let 'esize = esize;
    operation : FPMaxMinOp = undefined;
    match op {
      0b00 => {
          operation = FPMaxMinOp_MAX
      },
      0b01 => {
          operation = FPMaxMinOp_MIN
      },
      0b10 => {
          operation = FPMaxMinOp_MAXNUM
      },
      0b11 => {
          operation = FPMaxMinOp_MINNUM
      }
    };
    let operation = operation;
    execute_aarch64_instrs_float_arithmetic_max_min(d, esize, m, n, operation)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 349) = {
    SEE = 349;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 12, 2);
    let Rm = Slice(__opcode, 16, 5);
    let ftype = Slice(__opcode, 22, 2);
    decode_fmax_float_aarch64_instrs_float_arithmetic_max_min(Rd, Rn, op, Rm, ftype)
}

val decode_fmaxnm_float_aarch64_instrs_float_arithmetic_max_min : (bits(5), bits(5), bits(2), bits(5), bits(2)) -> unit

function decode_fmaxnm_float_aarch64_instrs_float_arithmetic_max_min (Rd, Rn, op, Rm, ftype) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    esize : {16, 32, 64} = 16;
    match ftype {
      0b00 => {
          esize = 32
      },
      0b01 => {
          esize = 64
      },
      0b10 => {
          throw(Error_Undefined())
      },
      0b11 => {
          if HaveFP16Ext() then {
              esize = 16
          } else {
              throw(Error_Undefined())
          }
      }
    };
    let 'esize = esize;
    operation : FPMaxMinOp = undefined;
    match op {
      0b00 => {
          operation = FPMaxMinOp_MAX
      },
      0b01 => {
          operation = FPMaxMinOp_MIN
      },
      0b10 => {
          operation = FPMaxMinOp_MAXNUM
      },
      0b11 => {
          operation = FPMaxMinOp_MINNUM
      }
    };
    let operation = operation;
    execute_aarch64_instrs_float_arithmetic_max_min(d, esize, m, n, operation)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitone, bitone, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 350) = {
    SEE = 350;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 12, 2);
    let Rm = Slice(__opcode, 16, 5);
    let ftype = Slice(__opcode, 22, 2);
    decode_fmaxnm_float_aarch64_instrs_float_arithmetic_max_min(Rd, Rn, op, Rm, ftype)
}

val decode_fmin_float_aarch64_instrs_float_arithmetic_max_min : (bits(5), bits(5), bits(2), bits(5), bits(2)) -> unit

function decode_fmin_float_aarch64_instrs_float_arithmetic_max_min (Rd, Rn, op, Rm, ftype) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    esize : {16, 32, 64} = 16;
    match ftype {
      0b00 => {
          esize = 32
      },
      0b01 => {
          esize = 64
      },
      0b10 => {
          throw(Error_Undefined())
      },
      0b11 => {
          if HaveFP16Ext() then {
              esize = 16
          } else {
              throw(Error_Undefined())
          }
      }
    };
    let 'esize = esize;
    operation : FPMaxMinOp = undefined;
    match op {
      0b00 => {
          operation = FPMaxMinOp_MAX
      },
      0b01 => {
          operation = FPMaxMinOp_MIN
      },
      0b10 => {
          operation = FPMaxMinOp_MAXNUM
      },
      0b11 => {
          operation = FPMaxMinOp_MINNUM
      }
    };
    let operation = operation;
    execute_aarch64_instrs_float_arithmetic_max_min(d, esize, m, n, operation)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 351) = {
    SEE = 351;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 12, 2);
    let Rm = Slice(__opcode, 16, 5);
    let ftype = Slice(__opcode, 22, 2);
    decode_fmin_float_aarch64_instrs_float_arithmetic_max_min(Rd, Rn, op, Rm, ftype)
}

val decode_fminnm_float_aarch64_instrs_float_arithmetic_max_min : (bits(5), bits(5), bits(2), bits(5), bits(2)) -> unit

function decode_fminnm_float_aarch64_instrs_float_arithmetic_max_min (Rd, Rn, op, Rm, ftype) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    esize : {16, 32, 64} = 16;
    match ftype {
      0b00 => {
          esize = 32
      },
      0b01 => {
          esize = 64
      },
      0b10 => {
          throw(Error_Undefined())
      },
      0b11 => {
          if HaveFP16Ext() then {
              esize = 16
          } else {
              throw(Error_Undefined())
          }
      }
    };
    let 'esize = esize;
    operation : FPMaxMinOp = undefined;
    match op {
      0b00 => {
          operation = FPMaxMinOp_MAX
      },
      0b01 => {
          operation = FPMaxMinOp_MIN
      },
      0b10 => {
          operation = FPMaxMinOp_MAXNUM
      },
      0b11 => {
          operation = FPMaxMinOp_MINNUM
      }
    };
    let operation = operation;
    execute_aarch64_instrs_float_arithmetic_max_min(d, esize, m, n, operation)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 352) = {
    SEE = 352;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 12, 2);
    let Rm = Slice(__opcode, 16, 5);
    let ftype = Slice(__opcode, 22, 2);
    decode_fminnm_float_aarch64_instrs_float_arithmetic_max_min(Rd, Rn, op, Rm, ftype)
}

val execute_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp16_1985 : forall 'd 'datasize 'elements 'esize 'm ('minimum : Bool) 'n ('pair : Bool),
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'esize in {16, 32, 64} & 'datasize in {64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('m), bool('minimum), int('n), bool('pair)) -> unit

function execute_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp16_1985 (d, datasize, elements, esize, m, minimum, n, pair) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = V_read(n, datasize);
    let operand2 : bits('datasize) = V_read(m, datasize);
    result : bits('datasize) = undefined;
    let concat : bits(2 * 'datasize) = operand2 @ operand1;
    element1 : bits('esize) = undefined;
    element2 : bits('esize) = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        if pair then {
            element1 = Elem_read(concat, 2 * e, esize);
            element2 = Elem_read(concat, 2 * e + 1, esize)
        } else {
            element1 = Elem_read(operand1, e, esize);
            element2 = Elem_read(operand2, e, esize)
        };
        if minimum then {
            result = Elem_set(result, e, esize, FPMin(element1, element2, FPCR_read()))
        } else {
            result = Elem_set(result, e, esize, FPMax(element1, element2, FPCR_read()))
        }
    };
    V_set(d, datasize) = result
}

val decode_fmax_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp16_1985 : (bits(5), bits(5), bits(5), bits(1), bits(1), bits(1)) -> unit

function decode_fmax_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp16_1985 (Rd, Rn, Rm, o1, U, Q) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = 16;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let pair : bool = U == 0b1;
    let minimum : bool = o1 == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp16_1985(d, datasize, elements, esize, m, minimum, n, pair)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, bitzero, bitzero, bitone, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 353) = {
    SEE = 353;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let o1 = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fmax_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp16_1985(Rd, Rn, Rm, o1, U, Q)
}

val decode_fmax_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp_1985 : (bits(5), bits(5), bits(5), bits(1), bits(1), bits(1), bits(1)) -> unit

function decode_fmax_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp_1985 (Rd, Rn, Rm, sz, o1, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    };
    let 'esize = (32 << UInt(sz));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let pair : bool = U == 0b1;
    let minimum : bool = o1 == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp16_1985(d, datasize, elements, esize, m, minimum, n, pair)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, _, bitone, _, _, _, _, _, bitone, bitone, bitone, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 354) = {
    SEE = 354;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let sz = Slice(__opcode, 22, 1);
    let o1 = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fmax_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp_1985(Rd, Rn, Rm, sz, o1, U, Q)
}

val decode_fmaxp_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp16_1985 : (bits(5), bits(5), bits(5), bits(1), bits(1), bits(1)) -> unit

function decode_fmaxp_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp16_1985 (Rd, Rn, Rm, o1, U, Q) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = 16;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let pair : bool = U == 0b1;
    let minimum : bool = o1 == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp16_1985(d, datasize, elements, esize, m, minimum, n, pair)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, bitzero, bitzero, bitone, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 355) = {
    SEE = 355;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let o1 = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fmaxp_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp16_1985(Rd, Rn, Rm, o1, U, Q)
}

val decode_fmaxp_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp_1985 : (bits(5), bits(5), bits(5), bits(1), bits(1), bits(1), bits(1)) -> unit

function decode_fmaxp_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp_1985 (Rd, Rn, Rm, sz, o1, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    };
    let 'esize = (32 << UInt(sz));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let pair : bool = U == 0b1;
    let minimum : bool = o1 == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp16_1985(d, datasize, elements, esize, m, minimum, n, pair)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, bitzero, _, bitone, _, _, _, _, _, bitone, bitone, bitone, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 356) = {
    SEE = 356;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let sz = Slice(__opcode, 22, 1);
    let o1 = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fmaxp_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp_1985(Rd, Rn, Rm, sz, o1, U, Q)
}

val decode_fmin_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp16_1985 : (bits(5), bits(5), bits(5), bits(1), bits(1), bits(1)) -> unit

function decode_fmin_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp16_1985 (Rd, Rn, Rm, o1, U, Q) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = 16;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let pair : bool = U == 0b1;
    let minimum : bool = o1 == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp16_1985(d, datasize, elements, esize, m, minimum, n, pair)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, bitzero, bitzero, bitone, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 357) = {
    SEE = 357;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let o1 = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fmin_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp16_1985(Rd, Rn, Rm, o1, U, Q)
}

val decode_fmin_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp_1985 : (bits(5), bits(5), bits(5), bits(1), bits(1), bits(1), bits(1)) -> unit

function decode_fmin_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp_1985 (Rd, Rn, Rm, sz, o1, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    };
    let 'esize = (32 << UInt(sz));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let pair : bool = U == 0b1;
    let minimum : bool = o1 == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp16_1985(d, datasize, elements, esize, m, minimum, n, pair)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitone, _, bitone, _, _, _, _, _, bitone, bitone, bitone, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 358) = {
    SEE = 358;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let sz = Slice(__opcode, 22, 1);
    let o1 = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fmin_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp_1985(Rd, Rn, Rm, sz, o1, U, Q)
}

val decode_fminp_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp16_1985 : (bits(5), bits(5), bits(5), bits(1), bits(1), bits(1)) -> unit

function decode_fminp_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp16_1985 (Rd, Rn, Rm, o1, U, Q) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = 16;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let pair : bool = U == 0b1;
    let minimum : bool = o1 == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp16_1985(d, datasize, elements, esize, m, minimum, n, pair)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, bitzero, bitzero, bitone, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 359) = {
    SEE = 359;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let o1 = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fminp_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp16_1985(Rd, Rn, Rm, o1, U, Q)
}

val decode_fminp_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp_1985 : (bits(5), bits(5), bits(5), bits(1), bits(1), bits(1), bits(1)) -> unit

function decode_fminp_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp_1985 (Rd, Rn, Rm, sz, o1, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    };
    let 'esize = (32 << UInt(sz));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let pair : bool = U == 0b1;
    let minimum : bool = o1 == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp16_1985(d, datasize, elements, esize, m, minimum, n, pair)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, bitone, _, bitone, _, _, _, _, _, bitone, bitone, bitone, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 360) = {
    SEE = 360;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let sz = Slice(__opcode, 22, 1);
    let o1 = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fminp_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp_1985(Rd, Rn, Rm, sz, o1, U, Q)
}

val execute_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp16_2008 : forall 'd 'datasize 'elements 'esize 'm ('minimum : Bool) 'n ('pair : Bool),
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'esize in {16, 32, 64} & 'datasize in {64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('m), bool('minimum), int('n), bool('pair)) -> unit

function execute_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp16_2008 (d, datasize, elements, esize, m, minimum, n, pair) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = V_read(n, datasize);
    let operand2 : bits('datasize) = V_read(m, datasize);
    result : bits('datasize) = undefined;
    let concat : bits(2 * 'datasize) = operand2 @ operand1;
    element1 : bits('esize) = undefined;
    element2 : bits('esize) = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        if pair then {
            element1 = Elem_read(concat, 2 * e, esize);
            element2 = Elem_read(concat, 2 * e + 1, esize)
        } else {
            element1 = Elem_read(operand1, e, esize);
            element2 = Elem_read(operand2, e, esize)
        };
        if minimum then {
            result = Elem_set(result, e, esize, FPMinNum(element1, element2, FPCR_read()))
        } else {
            result = Elem_set(result, e, esize, FPMaxNum(element1, element2, FPCR_read()))
        }
    };
    V_set(d, datasize) = result
}

val decode_fmaxnm_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp16_2008 : (bits(5), bits(5), bits(5), bits(1), bits(1), bits(1)) -> unit

function decode_fmaxnm_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp16_2008 (Rd, Rn, Rm, a, U, Q) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = 16;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let pair : bool = U == 0b1;
    let minimum : bool = a == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp16_2008(d, datasize, elements, esize, m, minimum, n, pair)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 361) = {
    SEE = 361;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let a = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fmaxnm_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp16_2008(Rd, Rn, Rm, a, U, Q)
}

val decode_fmaxnm_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp_2008 : (bits(5), bits(5), bits(5), bits(1), bits(1), bits(1), bits(1)) -> unit

function decode_fmaxnm_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp_2008 (Rd, Rn, Rm, sz, o1, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    };
    let 'esize = (32 << UInt(sz));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let pair : bool = U == 0b1;
    let minimum : bool = o1 == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp16_2008(d, datasize, elements, esize, m, minimum, n, pair)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, _, bitone, _, _, _, _, _, bitone, bitone, bitzero, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 362) = {
    SEE = 362;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let sz = Slice(__opcode, 22, 1);
    let o1 = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fmaxnm_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp_2008(Rd, Rn, Rm, sz, o1, U, Q)
}

val decode_fmaxnmp_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp16_2008 : (bits(5), bits(5), bits(5), bits(1), bits(1), bits(1)) -> unit

function decode_fmaxnmp_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp16_2008 (Rd, Rn, Rm, a, U, Q) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = 16;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let pair : bool = U == 0b1;
    let minimum : bool = a == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp16_2008(d, datasize, elements, esize, m, minimum, n, pair)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 363) = {
    SEE = 363;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let a = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fmaxnmp_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp16_2008(Rd, Rn, Rm, a, U, Q)
}

val decode_fmaxnmp_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp_2008 : (bits(5), bits(5), bits(5), bits(1), bits(1), bits(1), bits(1)) -> unit

function decode_fmaxnmp_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp_2008 (Rd, Rn, Rm, sz, o1, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    };
    let 'esize = (32 << UInt(sz));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let pair : bool = U == 0b1;
    let minimum : bool = o1 == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp16_2008(d, datasize, elements, esize, m, minimum, n, pair)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, bitzero, _, bitone, _, _, _, _, _, bitone, bitone, bitzero, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 364) = {
    SEE = 364;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let sz = Slice(__opcode, 22, 1);
    let o1 = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fmaxnmp_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp_2008(Rd, Rn, Rm, sz, o1, U, Q)
}

val decode_fminnm_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp16_2008 : (bits(5), bits(5), bits(5), bits(1), bits(1), bits(1)) -> unit

function decode_fminnm_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp16_2008 (Rd, Rn, Rm, a, U, Q) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = 16;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let pair : bool = U == 0b1;
    let minimum : bool = a == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp16_2008(d, datasize, elements, esize, m, minimum, n, pair)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 365) = {
    SEE = 365;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let a = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fminnm_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp16_2008(Rd, Rn, Rm, a, U, Q)
}

val decode_fminnm_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp_2008 : (bits(5), bits(5), bits(5), bits(1), bits(1), bits(1), bits(1)) -> unit

function decode_fminnm_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp_2008 (Rd, Rn, Rm, sz, o1, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    };
    let 'esize = (32 << UInt(sz));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let pair : bool = U == 0b1;
    let minimum : bool = o1 == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp16_2008(d, datasize, elements, esize, m, minimum, n, pair)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitone, _, bitone, _, _, _, _, _, bitone, bitone, bitzero, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 366) = {
    SEE = 366;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let sz = Slice(__opcode, 22, 1);
    let o1 = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fminnm_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp_2008(Rd, Rn, Rm, sz, o1, U, Q)
}

val decode_fminnmp_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp16_2008 : (bits(5), bits(5), bits(5), bits(1), bits(1), bits(1)) -> unit

function decode_fminnmp_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp16_2008 (Rd, Rn, Rm, a, U, Q) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = 16;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let pair : bool = U == 0b1;
    let minimum : bool = a == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp16_2008(d, datasize, elements, esize, m, minimum, n, pair)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 367) = {
    SEE = 367;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let a = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fminnmp_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp16_2008(Rd, Rn, Rm, a, U, Q)
}

val decode_fminnmp_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp_2008 : (bits(5), bits(5), bits(5), bits(1), bits(1), bits(1), bits(1)) -> unit

function decode_fminnmp_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp_2008 (Rd, Rn, Rm, sz, o1, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    };
    let 'esize = (32 << UInt(sz));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let pair : bool = U == 0b1;
    let minimum : bool = o1 == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp16_2008(d, datasize, elements, esize, m, minimum, n, pair)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, bitone, _, bitone, _, _, _, _, _, bitone, bitone, bitzero, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 368) = {
    SEE = 368;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let sz = Slice(__opcode, 22, 1);
    let o1 = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fminnmp_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp_2008(Rd, Rn, Rm, sz, o1, U, Q)
}

val execute_aarch64_instrs_vector_reduce_fp16_maxnm_sisd : forall 'd 'datasize 'esize 'n,
  (0 <= 'n & 'n <= 31 & 'esize in {16, 32, 64} & 'datasize in {32, 64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('esize), int('n), ReduceOp) -> unit

function execute_aarch64_instrs_vector_reduce_fp16_maxnm_sisd (d, datasize, esize, n, op) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('datasize) = V_read(n, datasize);
    let altfp : bool = false;
    assert(constraint('datasize >= 'esize));
    V_set(d, esize) = Reduce__1(op, operand, esize, altfp)
}

val decode_fmaxnmp_advsimd_pair_aarch64_instrs_vector_reduce_fp16_maxnm_sisd : (bits(5), bits(5), bits(1), bits(1)) -> unit

function decode_fmaxnmp_advsimd_pair_aarch64_instrs_vector_reduce_fp16_maxnm_sisd (Rd, Rn, sz, o1) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = 16;
    if sz == 0b1 then {
        throw(Error_Undefined())
    };
    let 'datasize = esize * 2;
    let 'elements = 2;
    let op : ReduceOp = if o1 == 0b1 then ReduceOp_FMINNUM else ReduceOp_FMAXNUM;
    execute_aarch64_instrs_vector_reduce_fp16_maxnm_sisd(d, datasize, esize, n, op)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, _, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 369) = {
    SEE = 369;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let sz = Slice(__opcode, 22, 1);
    let o1 = Slice(__opcode, 23, 1);
    decode_fmaxnmp_advsimd_pair_aarch64_instrs_vector_reduce_fp16_maxnm_sisd(Rd, Rn, sz, o1)
}

val decode_fmaxnmp_advsimd_pair_aarch64_instrs_vector_reduce_fp_maxnm_sisd : (bits(5), bits(5), bits(1), bits(1)) -> unit

function decode_fmaxnmp_advsimd_pair_aarch64_instrs_vector_reduce_fp_maxnm_sisd (Rd, Rn, sz, o1) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = (32 << UInt(sz));
    let 'datasize = esize * 2;
    let 'elements = 2;
    let op : ReduceOp = if o1 == 0b1 then ReduceOp_FMINNUM else ReduceOp_FMAXNUM;
    execute_aarch64_instrs_vector_reduce_fp16_maxnm_sisd(d, datasize, esize, n, op)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, _, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 370) = {
    SEE = 370;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let sz = Slice(__opcode, 22, 1);
    let o1 = Slice(__opcode, 23, 1);
    decode_fmaxnmp_advsimd_pair_aarch64_instrs_vector_reduce_fp_maxnm_sisd(Rd, Rn, sz, o1)
}

val decode_fminnmp_advsimd_pair_aarch64_instrs_vector_reduce_fp16_maxnm_sisd : (bits(5), bits(5), bits(1), bits(1)) -> unit

function decode_fminnmp_advsimd_pair_aarch64_instrs_vector_reduce_fp16_maxnm_sisd (Rd, Rn, sz, o1) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = 16;
    if sz == 0b1 then {
        throw(Error_Undefined())
    };
    let 'datasize = esize * 2;
    let 'elements = 2;
    let op : ReduceOp = if o1 == 0b1 then ReduceOp_FMINNUM else ReduceOp_FMAXNUM;
    execute_aarch64_instrs_vector_reduce_fp16_maxnm_sisd(d, datasize, esize, n, op)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, bitone, _, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 371) = {
    SEE = 371;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let sz = Slice(__opcode, 22, 1);
    let o1 = Slice(__opcode, 23, 1);
    decode_fminnmp_advsimd_pair_aarch64_instrs_vector_reduce_fp16_maxnm_sisd(Rd, Rn, sz, o1)
}

val decode_fminnmp_advsimd_pair_aarch64_instrs_vector_reduce_fp_maxnm_sisd : (bits(5), bits(5), bits(1), bits(1)) -> unit

function decode_fminnmp_advsimd_pair_aarch64_instrs_vector_reduce_fp_maxnm_sisd (Rd, Rn, sz, o1) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = (32 << UInt(sz));
    let 'datasize = esize * 2;
    let 'elements = 2;
    let op : ReduceOp = if o1 == 0b1 then ReduceOp_FMINNUM else ReduceOp_FMAXNUM;
    execute_aarch64_instrs_vector_reduce_fp16_maxnm_sisd(d, datasize, esize, n, op)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, bitone, _, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 372) = {
    SEE = 372;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let sz = Slice(__opcode, 22, 1);
    let o1 = Slice(__opcode, 23, 1);
    decode_fminnmp_advsimd_pair_aarch64_instrs_vector_reduce_fp_maxnm_sisd(Rd, Rn, sz, o1)
}

val execute_aarch64_instrs_vector_reduce_fp16_maxnm_simd : forall 'd 'datasize 'esize 'n,
  (0 <= 'n & 'n <= 31 & 'esize in {16, 32, 64} & 'datasize in {64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('esize), int('n), ReduceOp) -> unit

function execute_aarch64_instrs_vector_reduce_fp16_maxnm_simd (d, datasize, esize, n, op) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('datasize) = V_read(n, datasize);
    let altfp : bool = false;
    V_set(d, esize) = Reduce__1(op, operand, esize, altfp)
}

val decode_fmaxnmv_advsimd_aarch64_instrs_vector_reduce_fp16_maxnm_simd : (bits(5), bits(5), bits(1), bits(1)) -> unit

function decode_fmaxnmv_advsimd_aarch64_instrs_vector_reduce_fp16_maxnm_simd (Rd, Rn, o1, Q) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = 16;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let op : ReduceOp = if o1 == 0b1 then ReduceOp_FMINNUM else ReduceOp_FMAXNUM;
    execute_aarch64_instrs_vector_reduce_fp16_maxnm_simd(d, datasize, esize, n, op)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 373) = {
    SEE = 373;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 23, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fmaxnmv_advsimd_aarch64_instrs_vector_reduce_fp16_maxnm_simd(Rd, Rn, o1, Q)
}

val decode_fmaxnmv_advsimd_aarch64_instrs_vector_reduce_fp_maxnm_simd : (bits(5), bits(5), bits(1), bits(1), bits(1)) -> unit

function decode_fmaxnmv_advsimd_aarch64_instrs_vector_reduce_fp_maxnm_simd (Rd, Rn, sz, o1, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (sz @ Q) != 0b01 then {
        throw(Error_Undefined())
    };
    let 'esize = (32 << UInt(sz));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let op : ReduceOp = if o1 == 0b1 then ReduceOp_FMINNUM else ReduceOp_FMAXNUM;
    execute_aarch64_instrs_vector_reduce_fp16_maxnm_simd(d, datasize, esize, n, op)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, bitzero, _, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 374) = {
    SEE = 374;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let sz = Slice(__opcode, 22, 1);
    let o1 = Slice(__opcode, 23, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fmaxnmv_advsimd_aarch64_instrs_vector_reduce_fp_maxnm_simd(Rd, Rn, sz, o1, Q)
}

val decode_fminnmv_advsimd_aarch64_instrs_vector_reduce_fp16_maxnm_simd : (bits(5), bits(5), bits(1), bits(1)) -> unit

function decode_fminnmv_advsimd_aarch64_instrs_vector_reduce_fp16_maxnm_simd (Rd, Rn, o1, Q) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = 16;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let op : ReduceOp = if o1 == 0b1 then ReduceOp_FMINNUM else ReduceOp_FMAXNUM;
    execute_aarch64_instrs_vector_reduce_fp16_maxnm_simd(d, datasize, esize, n, op)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 375) = {
    SEE = 375;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 23, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fminnmv_advsimd_aarch64_instrs_vector_reduce_fp16_maxnm_simd(Rd, Rn, o1, Q)
}

val decode_fminnmv_advsimd_aarch64_instrs_vector_reduce_fp_maxnm_simd : (bits(5), bits(5), bits(1), bits(1), bits(1)) -> unit

function decode_fminnmv_advsimd_aarch64_instrs_vector_reduce_fp_maxnm_simd (Rd, Rn, sz, o1, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (sz @ Q) != 0b01 then {
        throw(Error_Undefined())
    };
    let 'esize = (32 << UInt(sz));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let op : ReduceOp = if o1 == 0b1 then ReduceOp_FMINNUM else ReduceOp_FMAXNUM;
    execute_aarch64_instrs_vector_reduce_fp16_maxnm_simd(d, datasize, esize, n, op)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, bitone, _, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 376) = {
    SEE = 376;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let sz = Slice(__opcode, 22, 1);
    let o1 = Slice(__opcode, 23, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fminnmv_advsimd_aarch64_instrs_vector_reduce_fp_maxnm_simd(Rd, Rn, sz, o1, Q)
}

val execute_aarch64_instrs_vector_reduce_fp16_max_sisd : forall 'd 'datasize 'esize 'n,
  (0 <= 'n & 'n <= 31 & 'esize in {16, 32, 64} & 'datasize in {32, 64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('esize), int('n), ReduceOp) -> unit

function execute_aarch64_instrs_vector_reduce_fp16_max_sisd (d, datasize, esize, n, op) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('datasize) = V_read(n, datasize);
    assert(constraint('datasize >= 'esize));
    V_set(d, esize) = Reduce(op, operand, esize)
}

val decode_fmaxp_advsimd_pair_aarch64_instrs_vector_reduce_fp16_max_sisd : (bits(5), bits(5), bits(1), bits(1)) -> unit

function decode_fmaxp_advsimd_pair_aarch64_instrs_vector_reduce_fp16_max_sisd (Rd, Rn, sz, o1) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = 16;
    if sz == 0b1 then {
        throw(Error_Undefined())
    };
    let 'datasize = esize * 2;
    let 'elements = 2;
    let op : ReduceOp = if o1 == 0b1 then ReduceOp_FMIN else ReduceOp_FMAX;
    execute_aarch64_instrs_vector_reduce_fp16_max_sisd(d, datasize, esize, n, op)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, _, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 377) = {
    SEE = 377;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let sz = Slice(__opcode, 22, 1);
    let o1 = Slice(__opcode, 23, 1);
    decode_fmaxp_advsimd_pair_aarch64_instrs_vector_reduce_fp16_max_sisd(Rd, Rn, sz, o1)
}

val decode_fmaxp_advsimd_pair_aarch64_instrs_vector_reduce_fp_max_sisd : (bits(5), bits(5), bits(1), bits(1)) -> unit

function decode_fmaxp_advsimd_pair_aarch64_instrs_vector_reduce_fp_max_sisd (Rd, Rn, sz, o1) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = (32 << UInt(sz));
    let 'datasize = esize * 2;
    let 'elements = 2;
    let op : ReduceOp = if o1 == 0b1 then ReduceOp_FMIN else ReduceOp_FMAX;
    execute_aarch64_instrs_vector_reduce_fp16_max_sisd(d, datasize, esize, n, op)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, _, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 378) = {
    SEE = 378;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let sz = Slice(__opcode, 22, 1);
    let o1 = Slice(__opcode, 23, 1);
    decode_fmaxp_advsimd_pair_aarch64_instrs_vector_reduce_fp_max_sisd(Rd, Rn, sz, o1)
}

val decode_fminp_advsimd_pair_aarch64_instrs_vector_reduce_fp16_max_sisd : (bits(5), bits(5), bits(1), bits(1)) -> unit

function decode_fminp_advsimd_pair_aarch64_instrs_vector_reduce_fp16_max_sisd (Rd, Rn, sz, o1) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = 16;
    if sz == 0b1 then {
        throw(Error_Undefined())
    };
    let 'datasize = esize * 2;
    let 'elements = 2;
    let op : ReduceOp = if o1 == 0b1 then ReduceOp_FMIN else ReduceOp_FMAX;
    execute_aarch64_instrs_vector_reduce_fp16_max_sisd(d, datasize, esize, n, op)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, bitone, _, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 379) = {
    SEE = 379;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let sz = Slice(__opcode, 22, 1);
    let o1 = Slice(__opcode, 23, 1);
    decode_fminp_advsimd_pair_aarch64_instrs_vector_reduce_fp16_max_sisd(Rd, Rn, sz, o1)
}

val decode_fminp_advsimd_pair_aarch64_instrs_vector_reduce_fp_max_sisd : (bits(5), bits(5), bits(1), bits(1)) -> unit

function decode_fminp_advsimd_pair_aarch64_instrs_vector_reduce_fp_max_sisd (Rd, Rn, sz, o1) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = (32 << UInt(sz));
    let 'datasize = esize * 2;
    let 'elements = 2;
    let op : ReduceOp = if o1 == 0b1 then ReduceOp_FMIN else ReduceOp_FMAX;
    execute_aarch64_instrs_vector_reduce_fp16_max_sisd(d, datasize, esize, n, op)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, bitone, _, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 380) = {
    SEE = 380;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let sz = Slice(__opcode, 22, 1);
    let o1 = Slice(__opcode, 23, 1);
    decode_fminp_advsimd_pair_aarch64_instrs_vector_reduce_fp_max_sisd(Rd, Rn, sz, o1)
}

val execute_aarch64_instrs_vector_reduce_fp16_max_simd : forall 'd 'datasize 'esize 'n,
  (0 <= 'n & 'n <= 31 & 'esize in {16, 32, 64} & 'datasize in {64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('esize), int('n), ReduceOp) -> unit

function execute_aarch64_instrs_vector_reduce_fp16_max_simd (d, datasize, esize, n, op) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('datasize) = V_read(n, datasize);
    V_set(d, esize) = Reduce(op, operand, esize)
}

val decode_fmaxv_advsimd_aarch64_instrs_vector_reduce_fp16_max_simd : (bits(5), bits(5), bits(1), bits(1)) -> unit

function decode_fmaxv_advsimd_aarch64_instrs_vector_reduce_fp16_max_simd (Rd, Rn, o1, Q) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = 16;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let op : ReduceOp = if o1 == 0b1 then ReduceOp_FMIN else ReduceOp_FMAX;
    execute_aarch64_instrs_vector_reduce_fp16_max_simd(d, datasize, esize, n, op)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 381) = {
    SEE = 381;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 23, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fmaxv_advsimd_aarch64_instrs_vector_reduce_fp16_max_simd(Rd, Rn, o1, Q)
}

val decode_fmaxv_advsimd_aarch64_instrs_vector_reduce_fp_max_simd : (bits(5), bits(5), bits(1), bits(1), bits(1)) -> unit

function decode_fmaxv_advsimd_aarch64_instrs_vector_reduce_fp_max_simd (Rd, Rn, sz, o1, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (sz @ Q) != 0b01 then {
        throw(Error_Undefined())
    };
    let 'esize = (32 << UInt(sz));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let op : ReduceOp = if o1 == 0b1 then ReduceOp_FMIN else ReduceOp_FMAX;
    execute_aarch64_instrs_vector_reduce_fp16_max_simd(d, datasize, esize, n, op)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, bitzero, _, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 382) = {
    SEE = 382;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let sz = Slice(__opcode, 22, 1);
    let o1 = Slice(__opcode, 23, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fmaxv_advsimd_aarch64_instrs_vector_reduce_fp_max_simd(Rd, Rn, sz, o1, Q)
}

val decode_fminv_advsimd_aarch64_instrs_vector_reduce_fp16_max_simd : (bits(5), bits(5), bits(1), bits(1)) -> unit

function decode_fminv_advsimd_aarch64_instrs_vector_reduce_fp16_max_simd (Rd, Rn, o1, Q) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = 16;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let op : ReduceOp = if o1 == 0b1 then ReduceOp_FMIN else ReduceOp_FMAX;
    execute_aarch64_instrs_vector_reduce_fp16_max_simd(d, datasize, esize, n, op)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 383) = {
    SEE = 383;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 23, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fminv_advsimd_aarch64_instrs_vector_reduce_fp16_max_simd(Rd, Rn, o1, Q)
}

val decode_fminv_advsimd_aarch64_instrs_vector_reduce_fp_max_simd : (bits(5), bits(5), bits(1), bits(1), bits(1)) -> unit

function decode_fminv_advsimd_aarch64_instrs_vector_reduce_fp_max_simd (Rd, Rn, sz, o1, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (sz @ Q) != 0b01 then {
        throw(Error_Undefined())
    };
    let 'esize = (32 << UInt(sz));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let op : ReduceOp = if o1 == 0b1 then ReduceOp_FMIN else ReduceOp_FMAX;
    execute_aarch64_instrs_vector_reduce_fp16_max_simd(d, datasize, esize, n, op)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, bitone, _, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 384) = {
    SEE = 384;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let sz = Slice(__opcode, 22, 1);
    let o1 = Slice(__opcode, 23, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fminv_advsimd_aarch64_instrs_vector_reduce_fp_max_simd(Rd, Rn, sz, o1, Q)
}

val execute_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_fp16_sisd : forall 'd 'datasize 'elements 'esize 'idxdsize 'index 'm 'n ('sub_op : Bool),
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'index in {0, 1, 2, 3, 4, 5, 6, 7} & 'idxdsize in {64, 128} & 'esize in {16, 32, 64} & 'datasize in {16, 32, 64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('idxdsize), int('index), int('m), int('n), bool('sub_op)) -> unit

function execute_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_fp16_sisd (d, datasize, elements, esize, idxdsize, index, m, n, sub_op) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = V_read(n, datasize);
    let operand2 : bits('idxdsize) = V_read(m, idxdsize);
    let operand3 : bits('datasize) = V_read(d, datasize);
    element1 : bits('esize) = undefined;
    let element2 : bits('esize) = Elem_read(operand2, index, esize);
    let fpcr : FPCRType = FPCR_read();
    let merge : bool = elements == 1 & IsMerging(fpcr);
    result : bits(128) = if merge then V_read(d, 128) else Zeros(128);
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element1 = Elem_read(operand1, e, esize);
        if sub_op then {
            element1 = FPNeg(element1)
        };
        result = Elem_set(result, e, esize, FPMulAdd(Elem_read(operand3, e, esize), element1, element2, fpcr))
    };
    V_set(d, 128) = result
}

val decode_fmla_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_fp16_sisd : (bits(5), bits(5), bits(1), bits(1), bits(4), bits(1), bits(1)) -> unit

function decode_fmla_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_fp16_sisd (Rd, Rn, H, o2, Rm, M, L) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'idxdsize = if H == 0b1 then 128 else 64;
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'd = UInt(Rd);
    let 'index = UInt((H @ L) @ M);
    let 'esize = 16;
    let 'datasize = esize;
    let 'elements = 1;
    let sub_op : bool = o2 == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_fp16_sisd(d, datasize, elements, esize, idxdsize, index, m, n, sub_op)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, _, _, _, _, _, _, bitzero, bitzero, bitzero, bitone, _, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 385) = {
    SEE = 385;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let H = Slice(__opcode, 11, 1);
    let o2 = Slice(__opcode, 14, 1);
    let Rm = Slice(__opcode, 16, 4);
    let M = Slice(__opcode, 20, 1);
    let L = Slice(__opcode, 21, 1);
    decode_fmla_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_fp16_sisd(Rd, Rn, H, o2, Rm, M, L)
}

val decode_fmla_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_fp_sisd : (bits(5), bits(5), bits(1), bits(1), bits(4), bits(1), bits(1), bits(1)) -> unit

function decode_fmla_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_fp_sisd (Rd, Rn, H, o2, Rm, M, L, sz) = {
    let 'idxdsize = if H == 0b1 then 128 else 64;
    index : range(0, 3) = undefined;
    let Rmhi : bits(1) = M;
    match sz @ L {
      [bitzero, _] => {
          index = UInt(H @ L)
      },
      0b10 => {
          index = UInt(H)
      },
      0b11 => {
          throw(Error_Undefined())
      }
    };
    let 'index = index;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rmhi @ Rm);
    let 'esize = (32 << UInt(sz));
    let 'datasize = esize;
    let 'elements = 1;
    let sub_op : bool = o2 == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_fp16_sisd(d, datasize, elements, esize, idxdsize, index, m, n, sub_op)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, bitzero, bitzero, bitzero, bitone, _, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 386) = {
    SEE = 386;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let H = Slice(__opcode, 11, 1);
    let o2 = Slice(__opcode, 14, 1);
    let Rm = Slice(__opcode, 16, 4);
    let M = Slice(__opcode, 20, 1);
    let L = Slice(__opcode, 21, 1);
    let sz = Slice(__opcode, 22, 1);
    decode_fmla_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_fp_sisd(Rd, Rn, H, o2, Rm, M, L, sz)
}

val decode_fmla_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_fp16_simd : (bits(5), bits(5), bits(1), bits(1), bits(4), bits(1), bits(1), bits(1)) -> unit

function decode_fmla_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_fp16_simd (Rd, Rn, H, o2, Rm, M, L, Q) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'idxdsize = if H == 0b1 then 128 else 64;
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'd = UInt(Rd);
    let 'index = UInt((H @ L) @ M);
    let 'esize = 16;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let sub_op : bool = o2 == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_fp16_sisd(d, datasize, elements, esize, idxdsize, index, m, n, sub_op)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, _, _, _, _, _, _, bitzero, bitzero, bitzero, bitone, _, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 387) = {
    SEE = 387;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let H = Slice(__opcode, 11, 1);
    let o2 = Slice(__opcode, 14, 1);
    let Rm = Slice(__opcode, 16, 4);
    let M = Slice(__opcode, 20, 1);
    let L = Slice(__opcode, 21, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fmla_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_fp16_simd(Rd, Rn, H, o2, Rm, M, L, Q)
}

val decode_fmla_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_fp_simd : (bits(5), bits(5), bits(1), bits(1), bits(4), bits(1), bits(1), bits(1), bits(1)) -> unit

function decode_fmla_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_fp_simd (Rd, Rn, H, o2, Rm, M, L, sz, Q) = {
    let 'idxdsize = if H == 0b1 then 128 else 64;
    index : range(0, 3) = undefined;
    let Rmhi : bits(1) = M;
    match sz @ L {
      [bitzero, _] => {
          index = UInt(H @ L)
      },
      0b10 => {
          index = UInt(H)
      },
      0b11 => {
          throw(Error_Undefined())
      }
    };
    let 'index = index;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rmhi @ Rm);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    };
    let 'esize = (32 << UInt(sz));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let sub_op : bool = o2 == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_fp16_sisd(d, datasize, elements, esize, idxdsize, index, m, n, sub_op)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, bitzero, bitzero, bitzero, bitone, _, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 388) = {
    SEE = 388;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let H = Slice(__opcode, 11, 1);
    let o2 = Slice(__opcode, 14, 1);
    let Rm = Slice(__opcode, 16, 4);
    let M = Slice(__opcode, 20, 1);
    let L = Slice(__opcode, 21, 1);
    let sz = Slice(__opcode, 22, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fmla_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_fp_simd(Rd, Rn, H, o2, Rm, M, L, sz, Q)
}

val decode_fmls_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_fp16_sisd : (bits(5), bits(5), bits(1), bits(1), bits(4), bits(1), bits(1)) -> unit

function decode_fmls_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_fp16_sisd (Rd, Rn, H, o2, Rm, M, L) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'idxdsize = if H == 0b1 then 128 else 64;
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'd = UInt(Rd);
    let 'index = UInt((H @ L) @ M);
    let 'esize = 16;
    let 'datasize = esize;
    let 'elements = 1;
    let sub_op : bool = o2 == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_fp16_sisd(d, datasize, elements, esize, idxdsize, index, m, n, sub_op)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, _, _, _, _, _, _, bitzero, bitone, bitzero, bitone, _, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 389) = {
    SEE = 389;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let H = Slice(__opcode, 11, 1);
    let o2 = Slice(__opcode, 14, 1);
    let Rm = Slice(__opcode, 16, 4);
    let M = Slice(__opcode, 20, 1);
    let L = Slice(__opcode, 21, 1);
    decode_fmls_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_fp16_sisd(Rd, Rn, H, o2, Rm, M, L)
}

val decode_fmls_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_fp_sisd : (bits(5), bits(5), bits(1), bits(1), bits(4), bits(1), bits(1), bits(1)) -> unit

function decode_fmls_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_fp_sisd (Rd, Rn, H, o2, Rm, M, L, sz) = {
    let 'idxdsize = if H == 0b1 then 128 else 64;
    index : range(0, 3) = undefined;
    let Rmhi : bits(1) = M;
    match sz @ L {
      [bitzero, _] => {
          index = UInt(H @ L)
      },
      0b10 => {
          index = UInt(H)
      },
      0b11 => {
          throw(Error_Undefined())
      }
    };
    let 'index = index;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rmhi @ Rm);
    let 'esize = (32 << UInt(sz));
    let 'datasize = esize;
    let 'elements = 1;
    let sub_op : bool = o2 == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_fp16_sisd(d, datasize, elements, esize, idxdsize, index, m, n, sub_op)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, bitzero, bitone, bitzero, bitone, _, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 390) = {
    SEE = 390;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let H = Slice(__opcode, 11, 1);
    let o2 = Slice(__opcode, 14, 1);
    let Rm = Slice(__opcode, 16, 4);
    let M = Slice(__opcode, 20, 1);
    let L = Slice(__opcode, 21, 1);
    let sz = Slice(__opcode, 22, 1);
    decode_fmls_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_fp_sisd(Rd, Rn, H, o2, Rm, M, L, sz)
}

val decode_fmls_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_fp16_simd : (bits(5), bits(5), bits(1), bits(1), bits(4), bits(1), bits(1), bits(1)) -> unit

function decode_fmls_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_fp16_simd (Rd, Rn, H, o2, Rm, M, L, Q) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'idxdsize = if H == 0b1 then 128 else 64;
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'd = UInt(Rd);
    let 'index = UInt((H @ L) @ M);
    let 'esize = 16;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let sub_op : bool = o2 == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_fp16_sisd(d, datasize, elements, esize, idxdsize, index, m, n, sub_op)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, _, _, _, _, _, _, bitzero, bitone, bitzero, bitone, _, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 391) = {
    SEE = 391;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let H = Slice(__opcode, 11, 1);
    let o2 = Slice(__opcode, 14, 1);
    let Rm = Slice(__opcode, 16, 4);
    let M = Slice(__opcode, 20, 1);
    let L = Slice(__opcode, 21, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fmls_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_fp16_simd(Rd, Rn, H, o2, Rm, M, L, Q)
}

val decode_fmls_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_fp_simd : (bits(5), bits(5), bits(1), bits(1), bits(4), bits(1), bits(1), bits(1), bits(1)) -> unit

function decode_fmls_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_fp_simd (Rd, Rn, H, o2, Rm, M, L, sz, Q) = {
    let 'idxdsize = if H == 0b1 then 128 else 64;
    index : range(0, 3) = undefined;
    let Rmhi : bits(1) = M;
    match sz @ L {
      [bitzero, _] => {
          index = UInt(H @ L)
      },
      0b10 => {
          index = UInt(H)
      },
      0b11 => {
          throw(Error_Undefined())
      }
    };
    let 'index = index;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rmhi @ Rm);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    };
    let 'esize = (32 << UInt(sz));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let sub_op : bool = o2 == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_fp16_sisd(d, datasize, elements, esize, idxdsize, index, m, n, sub_op)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, bitzero, bitone, bitzero, bitone, _, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 392) = {
    SEE = 392;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let H = Slice(__opcode, 11, 1);
    let o2 = Slice(__opcode, 14, 1);
    let Rm = Slice(__opcode, 16, 4);
    let M = Slice(__opcode, 20, 1);
    let L = Slice(__opcode, 21, 1);
    let sz = Slice(__opcode, 22, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fmls_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_fp_simd(Rd, Rn, H, o2, Rm, M, L, sz, Q)
}

val execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp16_fused : forall 'd 'datasize 'elements 'esize 'm 'n ('sub_op : Bool),
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'esize in {16, 32, 64} & 'datasize in {64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('m), int('n), bool('sub_op)) -> unit

function execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp16_fused (d, datasize, elements, esize, m, n, sub_op) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = V_read(n, datasize);
    let operand2 : bits('datasize) = V_read(m, datasize);
    let operand3 : bits('datasize) = V_read(d, datasize);
    result : bits('datasize) = undefined;
    element1 : bits('esize) = undefined;
    element2 : bits('esize) = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element1 = Elem_read(operand1, e, esize);
        element2 = Elem_read(operand2, e, esize);
        if sub_op then {
            element1 = FPNeg(element1)
        };
        result = Elem_set(result, e, esize, FPMulAdd(Elem_read(operand3, e, esize), element1, element2, FPCR_read()))
    };
    V_set(d, datasize) = result
}

val decode_fmla_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp16_fused : (bits(5), bits(5), bits(5), bits(1), bits(1)) -> unit

function decode_fmla_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp16_fused (Rd, Rn, Rm, a, Q) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = 16;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let sub_op : bool = a == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp16_fused(d, datasize, elements, esize, m, n, sub_op)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, bitzero, bitzero, bitzero, bitzero, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 393) = {
    SEE = 393;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let a = Slice(__opcode, 23, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fmla_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp16_fused(Rd, Rn, Rm, a, Q)
}

val decode_fmla_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp_fused : (bits(5), bits(5), bits(5), bits(1), bits(1), bits(1)) -> unit

function decode_fmla_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp_fused (Rd, Rn, Rm, sz, op, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    };
    let 'esize = (32 << UInt(sz));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let sub_op : bool = op == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp16_fused(d, datasize, elements, esize, m, n, sub_op)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, _, bitone, _, _, _, _, _, bitone, bitone, bitzero, bitzero, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 394) = {
    SEE = 394;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let sz = Slice(__opcode, 22, 1);
    let op = Slice(__opcode, 23, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fmla_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp_fused(Rd, Rn, Rm, sz, op, Q)
}

val decode_fmls_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp16_fused : (bits(5), bits(5), bits(5), bits(1), bits(1)) -> unit

function decode_fmls_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp16_fused (Rd, Rn, Rm, a, Q) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = 16;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let sub_op : bool = a == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp16_fused(d, datasize, elements, esize, m, n, sub_op)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, bitzero, bitzero, bitzero, bitzero, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 395) = {
    SEE = 395;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let a = Slice(__opcode, 23, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fmls_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp16_fused(Rd, Rn, Rm, a, Q)
}

val decode_fmls_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp_fused : (bits(5), bits(5), bits(5), bits(1), bits(1), bits(1)) -> unit

function decode_fmls_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp_fused (Rd, Rn, Rm, sz, op, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    };
    let 'esize = (32 << UInt(sz));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let sub_op : bool = op == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp16_fused(d, datasize, elements, esize, m, n, sub_op)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitone, _, bitone, _, _, _, _, _, bitone, bitone, bitzero, bitzero, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 396) = {
    SEE = 396;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let sz = Slice(__opcode, 22, 1);
    let op = Slice(__opcode, 23, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fmls_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp_fused(Rd, Rn, Rm, sz, op, Q)
}

val execute_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower : forall 'd 'datasize 'elements 'esize 'index 'm 'n 'part ('sub_op : Bool),
  ('part in {0, 1} & 0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'index in {0, 1, 2, 3, 4, 5, 6, 7} & 'esize == 32 & 'datasize in {64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('index), int('m), int('n), int('part), bool('sub_op)) -> unit

function execute_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower (d, datasize, elements, esize, index, m, n, part, sub_op) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits(div('datasize, 2)) = Vpart_read(n, part, DIV(datasize, 2));
    let operand2 : bits(128) = V_read(m, 128);
    let operand3 : bits('datasize) = V_read(d, datasize);
    result : bits('datasize) = undefined;
    element1 : bits(div('esize, 2)) = undefined;
    let element2 : bits(div('esize, 2)) = Elem_read(operand2, index, DIV(esize, 2));
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element1 = Elem_read(operand1, e, DIV(esize, 2));
        if sub_op then {
            element1 = FPNeg(element1)
        };
        result = Elem_set(result, e, esize, FPMulAddH(Elem_read(operand3, e, esize), element1, element2, FPCR_read()))
    };
    V_set(d, datasize) = result
}

val decode_fmlal_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower : (bits(5), bits(5), bits(1), bits(1), bits(4), bits(1), bits(1), bits(1), bits(1)) -> unit

function decode_fmlal_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower (Rd, Rn, H, S, Rm, M, L, sz, Q) = {
    if not_bool(HaveFP16MulNoRoundingToFP32Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(0b0 @ Rm);
    if sz == 0b1 then {
        throw(Error_Undefined())
    };
    let 'index = UInt((H @ L) @ M);
    let 'esize = 32;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let sub_op : bool = S == 0b1;
    let 'part = 0;
    execute_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower(d, datasize, elements, esize, index, m, n, part, sub_op)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, bitzero, bitzero, bitzero, bitzero, _, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 397) = {
    SEE = 397;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let H = Slice(__opcode, 11, 1);
    let S = Slice(__opcode, 14, 1);
    let Rm = Slice(__opcode, 16, 4);
    let M = Slice(__opcode, 20, 1);
    let L = Slice(__opcode, 21, 1);
    let sz = Slice(__opcode, 22, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fmlal_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower(Rd, Rn, H, S, Rm, M, L, sz, Q)
}

val decode_fmlal_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_upper : (bits(5), bits(5), bits(1), bits(1), bits(4), bits(1), bits(1), bits(1), bits(1)) -> unit

function decode_fmlal_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_upper (Rd, Rn, H, S, Rm, M, L, sz, Q) = {
    if not_bool(HaveFP16MulNoRoundingToFP32Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(0b0 @ Rm);
    if sz == 0b1 then {
        throw(Error_Undefined())
    };
    let 'index = UInt((H @ L) @ M);
    let 'esize = 32;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let sub_op : bool = S == 0b1;
    let 'part = 1;
    execute_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower(d, datasize, elements, esize, index, m, n, part, sub_op)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, bitone, bitzero, bitzero, bitzero, _, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 398) = {
    SEE = 398;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let H = Slice(__opcode, 11, 1);
    let S = Slice(__opcode, 14, 1);
    let Rm = Slice(__opcode, 16, 4);
    let M = Slice(__opcode, 20, 1);
    let L = Slice(__opcode, 21, 1);
    let sz = Slice(__opcode, 22, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fmlal_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_upper(Rd, Rn, H, S, Rm, M, L, sz, Q)
}

val decode_fmlsl_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower : (bits(5), bits(5), bits(1), bits(1), bits(4), bits(1), bits(1), bits(1), bits(1)) -> unit

function decode_fmlsl_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower (Rd, Rn, H, S, Rm, M, L, sz, Q) = {
    if not_bool(HaveFP16MulNoRoundingToFP32Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(0b0 @ Rm);
    if sz == 0b1 then {
        throw(Error_Undefined())
    };
    let 'index = UInt((H @ L) @ M);
    let 'esize = 32;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let sub_op : bool = S == 0b1;
    let 'part = 0;
    execute_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower(d, datasize, elements, esize, index, m, n, part, sub_op)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, bitzero, bitone, bitzero, bitzero, _, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 399) = {
    SEE = 399;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let H = Slice(__opcode, 11, 1);
    let S = Slice(__opcode, 14, 1);
    let Rm = Slice(__opcode, 16, 4);
    let M = Slice(__opcode, 20, 1);
    let L = Slice(__opcode, 21, 1);
    let sz = Slice(__opcode, 22, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fmlsl_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower(Rd, Rn, H, S, Rm, M, L, sz, Q)
}

val decode_fmlsl_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_upper : (bits(5), bits(5), bits(1), bits(1), bits(4), bits(1), bits(1), bits(1), bits(1)) -> unit

function decode_fmlsl_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_upper (Rd, Rn, H, S, Rm, M, L, sz, Q) = {
    if not_bool(HaveFP16MulNoRoundingToFP32Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(0b0 @ Rm);
    if sz == 0b1 then {
        throw(Error_Undefined())
    };
    let 'index = UInt((H @ L) @ M);
    let 'esize = 32;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let sub_op : bool = S == 0b1;
    let 'part = 1;
    execute_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower(d, datasize, elements, esize, index, m, n, part, sub_op)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, bitone, bitone, bitzero, bitzero, _, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 400) = {
    SEE = 400;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let H = Slice(__opcode, 11, 1);
    let S = Slice(__opcode, 14, 1);
    let Rm = Slice(__opcode, 16, 4);
    let M = Slice(__opcode, 20, 1);
    let L = Slice(__opcode, 21, 1);
    let sz = Slice(__opcode, 22, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fmlsl_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_upper(Rd, Rn, H, S, Rm, M, L, sz, Q)
}

val execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_lower : forall 'd 'datasize 'elements 'esize 'm 'n 'part ('sub_op : Bool),
  ('part in {0, 1} & 0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'esize == 32 & 'datasize in {64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('m), int('n), int('part), bool('sub_op)) -> unit

function execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_lower (d, datasize, elements, esize, m, n, part, sub_op) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits(div('datasize, 2)) = Vpart_read(n, part, DIV(datasize, 2));
    let operand2 : bits(div('datasize, 2)) = Vpart_read(m, part, DIV(datasize, 2));
    let operand3 : bits('datasize) = V_read(d, datasize);
    result : bits('datasize) = undefined;
    element1 : bits(div('esize, 2)) = undefined;
    element2 : bits(div('esize, 2)) = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element1 = Elem_read(operand1, e, DIV(esize, 2));
        element2 = Elem_read(operand2, e, DIV(esize, 2));
        if sub_op then {
            element1 = FPNeg(element1)
        };
        result = Elem_set(result, e, esize, FPMulAddH(Elem_read(operand3, e, esize), element1, element2, FPCR_read()))
    };
    V_set(d, datasize) = result
}

val decode_fmlal_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_lower : (bits(5), bits(5), bits(5), bits(1), bits(1), bits(1)) -> unit

function decode_fmlal_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_lower (Rd, Rn, Rm, sz, S, Q) = {
    if not_bool(HaveFP16MulNoRoundingToFP32Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if sz == 0b1 then {
        throw(Error_Undefined())
    };
    let 'esize = 32;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let sub_op : bool = S == 0b1;
    let 'part = 0;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_lower(d, datasize, elements, esize, m, n, part, sub_op)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitone, _, _, _, _, _, bitone, bitone, bitone, bitzero, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 401) = {
    SEE = 401;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let sz = Slice(__opcode, 22, 1);
    let S = Slice(__opcode, 23, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fmlal_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_lower(Rd, Rn, Rm, sz, S, Q)
}

val decode_fmlal_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_upper : (bits(5), bits(5), bits(5), bits(1), bits(1), bits(1)) -> unit

function decode_fmlal_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_upper (Rd, Rn, Rm, sz, S, Q) = {
    if not_bool(HaveFP16MulNoRoundingToFP32Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if sz == 0b1 then {
        throw(Error_Undefined())
    };
    let 'esize = 32;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let sub_op : bool = S == 0b1;
    let 'part = 1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_lower(d, datasize, elements, esize, m, n, part, sub_op)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitone, _, _, _, _, _, bitone, bitone, bitzero, bitzero, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 402) = {
    SEE = 402;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let sz = Slice(__opcode, 22, 1);
    let S = Slice(__opcode, 23, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fmlal_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_upper(Rd, Rn, Rm, sz, S, Q)
}

val decode_fmlsl_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_lower : (bits(5), bits(5), bits(5), bits(1), bits(1), bits(1)) -> unit

function decode_fmlsl_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_lower (Rd, Rn, Rm, sz, S, Q) = {
    if not_bool(HaveFP16MulNoRoundingToFP32Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if sz == 0b1 then {
        throw(Error_Undefined())
    };
    let 'esize = 32;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let sub_op : bool = S == 0b1;
    let 'part = 0;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_lower(d, datasize, elements, esize, m, n, part, sub_op)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitone, bitzero, bitone, _, _, _, _, _, bitone, bitone, bitone, bitzero, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 403) = {
    SEE = 403;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let sz = Slice(__opcode, 22, 1);
    let S = Slice(__opcode, 23, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fmlsl_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_lower(Rd, Rn, Rm, sz, S, Q)
}

val decode_fmlsl_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_upper : (bits(5), bits(5), bits(5), bits(1), bits(1), bits(1)) -> unit

function decode_fmlsl_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_upper (Rd, Rn, Rm, sz, S, Q) = {
    if not_bool(HaveFP16MulNoRoundingToFP32Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if sz == 0b1 then {
        throw(Error_Undefined())
    };
    let 'esize = 32;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let sub_op : bool = S == 0b1;
    let 'part = 1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_lower(d, datasize, elements, esize, m, n, part, sub_op)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, bitone, bitzero, bitone, _, _, _, _, _, bitone, bitone, bitzero, bitzero, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 404) = {
    SEE = 404;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let sz = Slice(__opcode, 22, 1);
    let S = Slice(__opcode, 23, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fmlsl_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_upper(Rd, Rn, Rm, sz, S, Q)
}

val execute_aarch64_instrs_vector_fp16_movi : forall 'datasize 'rd,
  (0 <= 'rd & 'rd <= 31 & 'datasize in {64, 128}).
  (int('datasize), bits('datasize), int('rd)) -> unit

function execute_aarch64_instrs_vector_fp16_movi (datasize, imm, rd) = {
    CheckFPAdvSIMDEnabled64();
    V_set(rd, datasize) = imm
}

val decode_fmov_advsimd_aarch64_instrs_vector_fp16_movi : (bits(5), bits(1), bits(1), bits(1), bits(1), bits(1), bits(1), bits(1), bits(1), bits(1)) -> unit

function decode_fmov_advsimd_aarch64_instrs_vector_fp16_movi (Rd, h, g, f, e, d, c, b, a, Q) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'rd = UInt(Rd);
    let 'datasize = if Q == 0b1 then 128 else 64;
    let imm8 : bits(8) = ((((((a @ b) @ c) @ d) @ e) @ f) @ g) @ h;
    let imm16 : bits(16) = ((([imm8[7]] @ not_vec([imm8[6]])) @ Replicate([imm8[6]], 2)) @ imm8[5 .. 0]) @ Zeros(6);
    let imm : bits('datasize) = Replicate(imm16, DIV(datasize, 16));
    execute_aarch64_instrs_vector_fp16_movi(datasize, imm, rd)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, bitone, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 405) = {
    SEE = 405;
    let Rd = Slice(__opcode, 0, 5);
    let h = Slice(__opcode, 5, 1);
    let g = Slice(__opcode, 6, 1);
    let f = Slice(__opcode, 7, 1);
    let e = Slice(__opcode, 8, 1);
    let d = Slice(__opcode, 9, 1);
    let c = Slice(__opcode, 16, 1);
    let b = Slice(__opcode, 17, 1);
    let a = Slice(__opcode, 18, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fmov_advsimd_aarch64_instrs_vector_fp16_movi(Rd, h, g, f, e, d, c, b, a, Q)
}

val decode_fmov_advsimd_aarch64_instrs_vector_logical : (bits(5), bits(1), bits(1), bits(1), bits(1), bits(1), bits(4), bits(1), bits(1), bits(1), bits(1), bits(1)) -> unit

function decode_fmov_advsimd_aarch64_instrs_vector_logical (Rd, h, g, f, e, d, cmode, c, b, a, op, Q) = {
    let 'rd = UInt(Rd);
    let 'datasize = if Q == 0b1 then 128 else 64;
    operation : ImmediateOp = undefined;
    match cmode @ op {
      [bitzero, _, _, bitzero, bitzero] => {
          operation = ImmediateOp_MOVI
      },
      [bitzero, _, _, bitzero, bitone] => {
          operation = ImmediateOp_MVNI
      },
      [bitzero, _, _, bitone, bitzero] => {
          operation = ImmediateOp_ORR
      },
      [bitzero, _, _, bitone, bitone] => {
          operation = ImmediateOp_BIC
      },
      [bitone, bitzero, _, bitzero, bitzero] => {
          operation = ImmediateOp_MOVI
      },
      [bitone, bitzero, _, bitzero, bitone] => {
          operation = ImmediateOp_MVNI
      },
      [bitone, bitzero, _, bitone, bitzero] => {
          operation = ImmediateOp_ORR
      },
      [bitone, bitzero, _, bitone, bitone] => {
          operation = ImmediateOp_BIC
      },
      [bitone, bitone, bitzero, _, bitzero] => {
          operation = ImmediateOp_MOVI
      },
      [bitone, bitone, bitzero, _, bitone] => {
          operation = ImmediateOp_MVNI
      },
      [bitone, bitone, bitone, bitzero, _] => {
          operation = ImmediateOp_MOVI
      },
      0b11110 => {
          operation = ImmediateOp_MOVI
      },
      0b11111 => {
          if Q == 0b0 then {
              throw(Error_Undefined())
          };
          operation = ImmediateOp_MOVI
      }
    };
    let operation = operation;
    let imm64 : bits(64) = AdvSIMDExpandImm(op, cmode, ((((((a @ b) @ c) @ d) @ e) @ f) @ g) @ h);
    let imm : bits('datasize) = Replicate(imm64, DIV(datasize, 64));
    execute_aarch64_instrs_vector_fp16_movi(datasize, imm, rd)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, _, bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, bitone, bitone, bitone, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 406) = {
    SEE = 406;
    let Rd = Slice(__opcode, 0, 5);
    let h = Slice(__opcode, 5, 1);
    let g = Slice(__opcode, 6, 1);
    let f = Slice(__opcode, 7, 1);
    let e = Slice(__opcode, 8, 1);
    let d = Slice(__opcode, 9, 1);
    let cmode = Slice(__opcode, 12, 4);
    let c = Slice(__opcode, 16, 1);
    let b = Slice(__opcode, 17, 1);
    let a = Slice(__opcode, 18, 1);
    let op = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fmov_advsimd_aarch64_instrs_vector_logical(Rd, h, g, f, e, d, cmode, c, b, a, op, Q)
}

val execute_aarch64_instrs_float_move_fp_imm : forall 'd 'datasize,
  ('datasize in {16, 32, 64} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), bits('datasize)) -> unit

function execute_aarch64_instrs_float_move_fp_imm (d, datasize, imm) = {
    CheckFPEnabled64();
    V_set(d, datasize) = imm
}

val decode_fmov_float_imm_aarch64_instrs_float_move_fp_imm : (bits(5), bits(8), bits(2)) -> unit

function decode_fmov_float_imm_aarch64_instrs_float_move_fp_imm (Rd, imm8, ftype) = {
    let 'd = UInt(Rd);
    datasize : {16, 32, 64} = 16;
    match ftype {
      0b00 => {
          datasize = 32
      },
      0b01 => {
          datasize = 64
      },
      0b10 => {
          throw(Error_Undefined())
      },
      0b11 => {
          if HaveFP16Ext() then {
              datasize = 16
          } else {
              throw(Error_Undefined())
          }
      }
    };
    let 'datasize = datasize;
    let imm : bits('datasize) = VFPExpandImm(imm8, datasize);
    execute_aarch64_instrs_float_move_fp_imm(d, datasize, imm)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, _, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _] as __opcode)) if SEE < 407) = {
    SEE = 407;
    let Rd = Slice(__opcode, 0, 5);
    let imm8 = Slice(__opcode, 13, 8);
    let ftype = Slice(__opcode, 22, 2);
    decode_fmov_float_imm_aarch64_instrs_float_move_fp_imm(Rd, imm8, ftype)
}

val execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp16_product : forall 'd 'datasize 'elements 'esize 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'esize in {16, 32, 64} & 'datasize in {64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('m), int('n)) -> unit

function execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp16_product (d, datasize, elements, esize, m, n) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = V_read(n, datasize);
    let operand2 : bits('datasize) = V_read(m, datasize);
    result : bits('datasize) = undefined;
    element1 : bits('esize) = undefined;
    element2 : bits('esize) = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element1 = Elem_read(operand1, e, esize);
        element2 = Elem_read(operand2, e, esize);
        result = Elem_set(result, e, esize, FPMul(element1, element2, FPCR_read()))
    };
    V_set(d, datasize) = result
}

val decode_fmul_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp16_product : (bits(5), bits(5), bits(5), bits(1)) -> unit

function decode_fmul_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp16_product (Rd, Rn, Rm, Q) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = 16;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp16_product(d, datasize, elements, esize, m, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, bitzero, bitzero, bitzero, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 408) = {
    SEE = 408;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let Q = Slice(__opcode, 30, 1);
    decode_fmul_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp16_product(Rd, Rn, Rm, Q)
}

val decode_fmul_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp_product : (bits(5), bits(5), bits(5), bits(1), bits(1)) -> unit

function decode_fmul_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp_product (Rd, Rn, Rm, sz, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    };
    let 'esize = (32 << UInt(sz));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp16_product(d, datasize, elements, esize, m, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, bitzero, _, bitone, _, _, _, _, _, bitone, bitone, bitzero, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 409) = {
    SEE = 409;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let sz = Slice(__opcode, 22, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fmul_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp_product(Rd, Rn, Rm, sz, Q)
}

val execute_aarch64_instrs_float_arithmetic_mul_product : forall 'd 'esize 'm 'n ('negated : Bool),
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'esize in {16, 32, 64} & 0 <= 'd & 'd <= 31).
  (int('d), int('esize), int('m), int('n), bool('negated)) -> unit

function execute_aarch64_instrs_float_arithmetic_mul_product (d, esize, m, n, negated) = {
    CheckFPEnabled64();
    let operand1 : bits('esize) = V_read(n, esize);
    let operand2 : bits('esize) = V_read(m, esize);
    let fpcr : FPCRType = FPCR_read();
    let merge : bool = IsMerging(fpcr);
    result : bits(128) = if merge then V_read(n, 128) else Zeros(128);
    product : bits('esize) = FPMul(operand1, operand2, fpcr);
    if negated then {
        product = FPNeg(product)
    };
    result = Elem_set(result, 0, esize, product);
    V_set(d, 128) = result
}

val decode_fmul_float_aarch64_instrs_float_arithmetic_mul_product : (bits(5), bits(5), bits(1), bits(5), bits(2)) -> unit

function decode_fmul_float_aarch64_instrs_float_arithmetic_mul_product (Rd, Rn, op, Rm, ftype) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    esize : {16, 32, 64} = 16;
    match ftype {
      0b00 => {
          esize = 32
      },
      0b01 => {
          esize = 64
      },
      0b10 => {
          throw(Error_Undefined())
      },
      0b11 => {
          if HaveFP16Ext() then {
              esize = 16
          } else {
              throw(Error_Undefined())
          }
      }
    };
    let 'esize = esize;
    let negated : bool = op == 0b1;
    execute_aarch64_instrs_float_arithmetic_mul_product(d, esize, m, n, negated)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 410) = {
    SEE = 410;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 15, 1);
    let Rm = Slice(__opcode, 16, 5);
    let ftype = Slice(__opcode, 22, 2);
    decode_fmul_float_aarch64_instrs_float_arithmetic_mul_product(Rd, Rn, op, Rm, ftype)
}

val decode_fnmul_float_aarch64_instrs_float_arithmetic_mul_product : (bits(5), bits(5), bits(1), bits(5), bits(2)) -> unit

function decode_fnmul_float_aarch64_instrs_float_arithmetic_mul_product (Rd, Rn, op, Rm, ftype) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    esize : {16, 32, 64} = 16;
    match ftype {
      0b00 => {
          esize = 32
      },
      0b01 => {
          esize = 64
      },
      0b10 => {
          throw(Error_Undefined())
      },
      0b11 => {
          if HaveFP16Ext() then {
              esize = 16
          } else {
              throw(Error_Undefined())
          }
      }
    };
    let 'esize = esize;
    let negated : bool = op == 0b1;
    execute_aarch64_instrs_float_arithmetic_mul_product(d, esize, m, n, negated)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitone, bitzero, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 411) = {
    SEE = 411;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 15, 1);
    let Rm = Slice(__opcode, 16, 5);
    let ftype = Slice(__opcode, 22, 2);
    decode_fnmul_float_aarch64_instrs_float_arithmetic_mul_product(Rd, Rn, op, Rm, ftype)
}

val execute_aarch64_instrs_vector_arithmetic_binary_element_mul_fp16_sisd : forall 'd 'datasize 'elements 'esize 'idxdsize 'index 'm ('mulx_op : Bool) 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'index in {0, 1, 2, 3, 4, 5, 6, 7} & 'idxdsize in {64, 128} & 'esize in {16, 32, 64} & 'datasize in {16, 32, 64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('idxdsize), int('index), int('m), bool('mulx_op), int('n)) -> unit

function execute_aarch64_instrs_vector_arithmetic_binary_element_mul_fp16_sisd (d, datasize, elements, esize, idxdsize, index, m, mulx_op, n) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = V_read(n, datasize);
    let operand2 : bits('idxdsize) = V_read(m, idxdsize);
    element1 : bits('esize) = undefined;
    let element2 : bits('esize) = Elem_read(operand2, index, esize);
    let fpcr : FPCRType = FPCR_read();
    let merge : bool = elements == 1 & IsMerging(fpcr);
    result : bits(128) = if merge then V_read(n, 128) else Zeros(128);
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element1 = Elem_read(operand1, e, esize);
        if mulx_op then {
            result = Elem_set(result, e, esize, FPMulX(element1, element2, fpcr))
        } else {
            result = Elem_set(result, e, esize, FPMul(element1, element2, fpcr))
        }
    };
    V_set(d, 128) = result
}

val decode_fmul_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_fp16_sisd : (bits(5), bits(5), bits(1), bits(4), bits(1), bits(1), bits(1)) -> unit

function decode_fmul_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_fp16_sisd (Rd, Rn, H, Rm, M, L, U) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'idxdsize = if H == 0b1 then 128 else 64;
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'd = UInt(Rd);
    let 'index = UInt((H @ L) @ M);
    let 'esize = 16;
    let 'datasize = esize;
    let 'elements = 1;
    let mulx_op : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_element_mul_fp16_sisd(d, datasize, elements, esize, idxdsize, index, m, mulx_op, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, _, _, _, _, _, _, bitone, bitzero, bitzero, bitone, _, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 412) = {
    SEE = 412;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let H = Slice(__opcode, 11, 1);
    let Rm = Slice(__opcode, 16, 4);
    let M = Slice(__opcode, 20, 1);
    let L = Slice(__opcode, 21, 1);
    let U = Slice(__opcode, 29, 1);
    decode_fmul_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_fp16_sisd(Rd, Rn, H, Rm, M, L, U)
}

val decode_fmul_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_fp_sisd : (bits(5), bits(5), bits(1), bits(4), bits(1), bits(1), bits(1), bits(1)) -> unit

function decode_fmul_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_fp_sisd (Rd, Rn, H, Rm, M, L, sz, U) = {
    let 'idxdsize = if H == 0b1 then 128 else 64;
    index : range(0, 3) = undefined;
    let Rmhi : bits(1) = M;
    match sz @ L {
      [bitzero, _] => {
          index = UInt(H @ L)
      },
      0b10 => {
          index = UInt(H)
      },
      0b11 => {
          throw(Error_Undefined())
      }
    };
    let 'index = index;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rmhi @ Rm);
    let 'esize = (32 << UInt(sz));
    let 'datasize = esize;
    let 'elements = 1;
    let mulx_op : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_element_mul_fp16_sisd(d, datasize, elements, esize, idxdsize, index, m, mulx_op, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, bitone, bitzero, bitzero, bitone, _, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 413) = {
    SEE = 413;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let H = Slice(__opcode, 11, 1);
    let Rm = Slice(__opcode, 16, 4);
    let M = Slice(__opcode, 20, 1);
    let L = Slice(__opcode, 21, 1);
    let sz = Slice(__opcode, 22, 1);
    let U = Slice(__opcode, 29, 1);
    decode_fmul_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_fp_sisd(Rd, Rn, H, Rm, M, L, sz, U)
}

val decode_fmul_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_fp16_simd : (bits(5), bits(5), bits(1), bits(4), bits(1), bits(1), bits(1), bits(1)) -> unit

function decode_fmul_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_fp16_simd (Rd, Rn, H, Rm, M, L, U, Q) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'idxdsize = if H == 0b1 then 128 else 64;
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'd = UInt(Rd);
    let 'index = UInt((H @ L) @ M);
    let 'esize = 16;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let mulx_op : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_element_mul_fp16_sisd(d, datasize, elements, esize, idxdsize, index, m, mulx_op, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, _, _, _, _, _, _, bitone, bitzero, bitzero, bitone, _, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 414) = {
    SEE = 414;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let H = Slice(__opcode, 11, 1);
    let Rm = Slice(__opcode, 16, 4);
    let M = Slice(__opcode, 20, 1);
    let L = Slice(__opcode, 21, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fmul_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_fp16_simd(Rd, Rn, H, Rm, M, L, U, Q)
}

val decode_fmul_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_fp_simd : (bits(5), bits(5), bits(1), bits(4), bits(1), bits(1), bits(1), bits(1), bits(1)) -> unit

function decode_fmul_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_fp_simd (Rd, Rn, H, Rm, M, L, sz, U, Q) = {
    let 'idxdsize = if H == 0b1 then 128 else 64;
    index : range(0, 3) = undefined;
    let Rmhi : bits(1) = M;
    match sz @ L {
      [bitzero, _] => {
          index = UInt(H @ L)
      },
      0b10 => {
          index = UInt(H)
      },
      0b11 => {
          throw(Error_Undefined())
      }
    };
    let 'index = index;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rmhi @ Rm);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    };
    let 'esize = (32 << UInt(sz));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let mulx_op : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_element_mul_fp16_sisd(d, datasize, elements, esize, idxdsize, index, m, mulx_op, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, bitone, bitzero, bitzero, bitone, _, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 415) = {
    SEE = 415;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let H = Slice(__opcode, 11, 1);
    let Rm = Slice(__opcode, 16, 4);
    let M = Slice(__opcode, 20, 1);
    let L = Slice(__opcode, 21, 1);
    let sz = Slice(__opcode, 22, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fmul_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_fp_simd(Rd, Rn, H, Rm, M, L, sz, U, Q)
}

val decode_fmulx_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_fp16_sisd : (bits(5), bits(5), bits(1), bits(4), bits(1), bits(1), bits(1)) -> unit

function decode_fmulx_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_fp16_sisd (Rd, Rn, H, Rm, M, L, U) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'idxdsize = if H == 0b1 then 128 else 64;
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'd = UInt(Rd);
    let 'index = UInt((H @ L) @ M);
    let 'esize = 16;
    let 'datasize = esize;
    let 'elements = 1;
    let mulx_op : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_element_mul_fp16_sisd(d, datasize, elements, esize, idxdsize, index, m, mulx_op, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, _, _, _, _, _, _, bitone, bitzero, bitzero, bitone, _, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 416) = {
    SEE = 416;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let H = Slice(__opcode, 11, 1);
    let Rm = Slice(__opcode, 16, 4);
    let M = Slice(__opcode, 20, 1);
    let L = Slice(__opcode, 21, 1);
    let U = Slice(__opcode, 29, 1);
    decode_fmulx_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_fp16_sisd(Rd, Rn, H, Rm, M, L, U)
}

val decode_fmulx_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_fp_sisd : (bits(5), bits(5), bits(1), bits(4), bits(1), bits(1), bits(1), bits(1)) -> unit

function decode_fmulx_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_fp_sisd (Rd, Rn, H, Rm, M, L, sz, U) = {
    let 'idxdsize = if H == 0b1 then 128 else 64;
    index : range(0, 3) = undefined;
    let Rmhi : bits(1) = M;
    match sz @ L {
      [bitzero, _] => {
          index = UInt(H @ L)
      },
      0b10 => {
          index = UInt(H)
      },
      0b11 => {
          throw(Error_Undefined())
      }
    };
    let 'index = index;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rmhi @ Rm);
    let 'esize = (32 << UInt(sz));
    let 'datasize = esize;
    let 'elements = 1;
    let mulx_op : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_element_mul_fp16_sisd(d, datasize, elements, esize, idxdsize, index, m, mulx_op, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, bitone, bitzero, bitzero, bitone, _, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 417) = {
    SEE = 417;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let H = Slice(__opcode, 11, 1);
    let Rm = Slice(__opcode, 16, 4);
    let M = Slice(__opcode, 20, 1);
    let L = Slice(__opcode, 21, 1);
    let sz = Slice(__opcode, 22, 1);
    let U = Slice(__opcode, 29, 1);
    decode_fmulx_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_fp_sisd(Rd, Rn, H, Rm, M, L, sz, U)
}

val decode_fmulx_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_fp16_simd : (bits(5), bits(5), bits(1), bits(4), bits(1), bits(1), bits(1), bits(1)) -> unit

function decode_fmulx_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_fp16_simd (Rd, Rn, H, Rm, M, L, U, Q) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'idxdsize = if H == 0b1 then 128 else 64;
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'd = UInt(Rd);
    let 'index = UInt((H @ L) @ M);
    let 'esize = 16;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let mulx_op : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_element_mul_fp16_sisd(d, datasize, elements, esize, idxdsize, index, m, mulx_op, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, _, _, _, _, _, _, bitone, bitzero, bitzero, bitone, _, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 418) = {
    SEE = 418;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let H = Slice(__opcode, 11, 1);
    let Rm = Slice(__opcode, 16, 4);
    let M = Slice(__opcode, 20, 1);
    let L = Slice(__opcode, 21, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fmulx_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_fp16_simd(Rd, Rn, H, Rm, M, L, U, Q)
}

val decode_fmulx_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_fp_simd : (bits(5), bits(5), bits(1), bits(4), bits(1), bits(1), bits(1), bits(1), bits(1)) -> unit

function decode_fmulx_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_fp_simd (Rd, Rn, H, Rm, M, L, sz, U, Q) = {
    let 'idxdsize = if H == 0b1 then 128 else 64;
    index : range(0, 3) = undefined;
    let Rmhi : bits(1) = M;
    match sz @ L {
      [bitzero, _] => {
          index = UInt(H @ L)
      },
      0b10 => {
          index = UInt(H)
      },
      0b11 => {
          throw(Error_Undefined())
      }
    };
    let 'index = index;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rmhi @ Rm);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    };
    let 'esize = (32 << UInt(sz));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let mulx_op : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_element_mul_fp16_sisd(d, datasize, elements, esize, idxdsize, index, m, mulx_op, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, bitone, bitzero, bitzero, bitone, _, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 419) = {
    SEE = 419;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let H = Slice(__opcode, 11, 1);
    let Rm = Slice(__opcode, 16, 4);
    let M = Slice(__opcode, 20, 1);
    let L = Slice(__opcode, 21, 1);
    let sz = Slice(__opcode, 22, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fmulx_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_fp_simd(Rd, Rn, H, Rm, M, L, sz, U, Q)
}

val execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp16_extended_sisd : forall 'd 'datasize 'elements 'esize 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'esize in {16, 32, 64} & 'datasize in {16, 32, 64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('m), int('n)) -> unit

function execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp16_extended_sisd (d, datasize, elements, esize, m, n) = {
    if elements == 1 then {
        CheckFPEnabled64()
    } else {
        CheckFPAdvSIMDEnabled64()
    };
    let operand1 : bits('datasize) = V_read(n, datasize);
    let operand2 : bits('datasize) = V_read(m, datasize);
    element1 : bits('esize) = undefined;
    element2 : bits('esize) = undefined;
    let fpcr : FPCRType = FPCR_read();
    let merge : bool = elements == 1 & IsMerging(fpcr);
    result : bits(128) = if merge then V_read(n, 128) else Zeros(128);
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element1 = Elem_read(operand1, e, esize);
        element2 = Elem_read(operand2, e, esize);
        result = Elem_set(result, e, esize, FPMulX(element1, element2, fpcr))
    };
    V_set(d, 128) = result
}

val decode_fmulx_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp16_extended_sisd : (bits(5), bits(5), bits(5)) -> unit

function decode_fmulx_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp16_extended_sisd (Rd, Rn, Rm) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = 16;
    let 'datasize = esize;
    let 'elements = 1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp16_extended_sisd(d, datasize, elements, esize, m, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, bitzero, bitzero, bitzero, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 420) = {
    SEE = 420;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    decode_fmulx_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp16_extended_sisd(Rd, Rn, Rm)
}

val decode_fmulx_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp_extended_sisd : (bits(5), bits(5), bits(5), bits(1)) -> unit

function decode_fmulx_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp_extended_sisd (Rd, Rn, Rm, sz) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = (32 << UInt(sz));
    let 'datasize = esize;
    let 'elements = 1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp16_extended_sisd(d, datasize, elements, esize, m, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, _, bitone, _, _, _, _, _, bitone, bitone, bitzero, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 421) = {
    SEE = 421;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let sz = Slice(__opcode, 22, 1);
    decode_fmulx_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp_extended_sisd(Rd, Rn, Rm, sz)
}

val decode_fmulx_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp16_extended_simd : (bits(5), bits(5), bits(5), bits(1)) -> unit

function decode_fmulx_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp16_extended_simd (Rd, Rn, Rm, Q) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = 16;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp16_extended_sisd(d, datasize, elements, esize, m, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, bitzero, bitzero, bitzero, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 422) = {
    SEE = 422;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let Q = Slice(__opcode, 30, 1);
    decode_fmulx_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp16_extended_simd(Rd, Rn, Rm, Q)
}

val decode_fmulx_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp_extended_simd : (bits(5), bits(5), bits(5), bits(1), bits(1)) -> unit

function decode_fmulx_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp_extended_simd (Rd, Rn, Rm, sz, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    };
    let 'esize = (32 << UInt(sz));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp16_extended_sisd(d, datasize, elements, esize, m, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, _, bitone, _, _, _, _, _, bitone, bitone, bitzero, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 423) = {
    SEE = 423;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let sz = Slice(__opcode, 22, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fmulx_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp_extended_simd(Rd, Rn, Rm, sz, Q)
}

val execute_aarch64_instrs_vector_arithmetic_unary_special_recip_fp16_sisd : forall 'd 'datasize 'elements 'esize 'n,
  (0 <= 'n & 'n <= 31 & 'esize in {16, 32, 64} & 'datasize in {16, 32, 64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('n)) -> unit

function execute_aarch64_instrs_vector_arithmetic_unary_special_recip_fp16_sisd (d, datasize, elements, esize, n) = {
    if elements == 1 then {
        CheckFPEnabled64()
    } else {
        CheckFPAdvSIMDEnabled64()
    };
    let operand : bits('datasize) = V_read(n, datasize);
    let fpcr : FPCRType = FPCR_read();
    let merge : bool = elements == 1 & IsMerging(fpcr);
    result : bits(128) = if merge then V_read(d, 128) else Zeros(128);
    element : bits('esize) = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element = Elem_read(operand, e, esize);
        result = Elem_set(result, e, esize, FPRecipEstimate(element, FPCR_read()))
    };
    V_set(d, 128) = result
}

val decode_frecpe_advsimd_aarch64_instrs_vector_arithmetic_unary_special_recip_fp16_sisd : (bits(5), bits(5)) -> unit

function decode_frecpe_advsimd_aarch64_instrs_vector_arithmetic_unary_special_recip_fp16_sisd (Rd, Rn) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = 16;
    let 'datasize = esize;
    let 'elements = 1;
    execute_aarch64_instrs_vector_arithmetic_unary_special_recip_fp16_sisd(d, datasize, elements, esize, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 424) = {
    SEE = 424;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    decode_frecpe_advsimd_aarch64_instrs_vector_arithmetic_unary_special_recip_fp16_sisd(Rd, Rn)
}

val decode_frecpe_advsimd_aarch64_instrs_vector_arithmetic_unary_special_recip_float_sisd : (bits(5), bits(5), bits(1)) -> unit

function decode_frecpe_advsimd_aarch64_instrs_vector_arithmetic_unary_special_recip_float_sisd (Rd, Rn, sz) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = (32 << UInt(sz));
    let 'datasize = esize;
    let 'elements = 1;
    execute_aarch64_instrs_vector_arithmetic_unary_special_recip_fp16_sisd(d, datasize, elements, esize, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, bitone, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 425) = {
    SEE = 425;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let sz = Slice(__opcode, 22, 1);
    decode_frecpe_advsimd_aarch64_instrs_vector_arithmetic_unary_special_recip_float_sisd(Rd, Rn, sz)
}

val decode_frecpe_advsimd_aarch64_instrs_vector_arithmetic_unary_special_recip_fp16_simd : (bits(5), bits(5), bits(1)) -> unit

function decode_frecpe_advsimd_aarch64_instrs_vector_arithmetic_unary_special_recip_fp16_simd (Rd, Rn, Q) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = 16;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    execute_aarch64_instrs_vector_arithmetic_unary_special_recip_fp16_sisd(d, datasize, elements, esize, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 426) = {
    SEE = 426;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Q = Slice(__opcode, 30, 1);
    decode_frecpe_advsimd_aarch64_instrs_vector_arithmetic_unary_special_recip_fp16_simd(Rd, Rn, Q)
}

val decode_frecpe_advsimd_aarch64_instrs_vector_arithmetic_unary_special_recip_float_simd : (bits(5), bits(5), bits(1), bits(1)) -> unit

function decode_frecpe_advsimd_aarch64_instrs_vector_arithmetic_unary_special_recip_float_simd (Rd, Rn, sz, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    };
    let 'esize = (32 << UInt(sz));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    execute_aarch64_instrs_vector_arithmetic_unary_special_recip_fp16_sisd(d, datasize, elements, esize, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitone, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 427) = {
    SEE = 427;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let sz = Slice(__opcode, 22, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_frecpe_advsimd_aarch64_instrs_vector_arithmetic_unary_special_recip_float_simd(Rd, Rn, sz, Q)
}

val execute_aarch64_instrs_vector_arithmetic_binary_uniform_recps_fp16_sisd : forall 'd 'datasize 'elements 'esize 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'esize in {16, 32, 64} & 'datasize in {16, 32, 64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('m), int('n)) -> unit

function execute_aarch64_instrs_vector_arithmetic_binary_uniform_recps_fp16_sisd (d, datasize, elements, esize, m, n) = {
    if elements == 1 then {
        CheckFPEnabled64()
    } else {
        CheckFPAdvSIMDEnabled64()
    };
    let operand1 : bits('datasize) = V_read(n, datasize);
    let operand2 : bits('datasize) = V_read(m, datasize);
    element1 : bits('esize) = undefined;
    element2 : bits('esize) = undefined;
    let fpcr : FPCRType = FPCR_read();
    let merge : bool = elements == 1 & IsMerging(fpcr);
    result : bits(128) = if merge then V_read(n, 128) else Zeros(128);
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element1 = Elem_read(operand1, e, esize);
        element2 = Elem_read(operand2, e, esize);
        result = Elem_set(result, e, esize, FPRecipStepFused(element1, element2))
    };
    V_set(d, 128) = result
}

val decode_frecps_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_recps_fp16_sisd : (bits(5), bits(5), bits(5)) -> unit

function decode_frecps_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_recps_fp16_sisd (Rd, Rn, Rm) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = 16;
    let 'datasize = esize;
    let 'elements = 1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_recps_fp16_sisd(d, datasize, elements, esize, m, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, bitzero, bitzero, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 428) = {
    SEE = 428;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    decode_frecps_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_recps_fp16_sisd(Rd, Rn, Rm)
}

val decode_frecps_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_recps_sisd : (bits(5), bits(5), bits(5), bits(1)) -> unit

function decode_frecps_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_recps_sisd (Rd, Rn, Rm, sz) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = (32 << UInt(sz));
    let 'datasize = esize;
    let 'elements = 1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_recps_fp16_sisd(d, datasize, elements, esize, m, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, _, bitone, _, _, _, _, _, bitone, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 429) = {
    SEE = 429;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let sz = Slice(__opcode, 22, 1);
    decode_frecps_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_recps_sisd(Rd, Rn, Rm, sz)
}

val decode_frecps_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_recps_fp16_simd : (bits(5), bits(5), bits(5), bits(1)) -> unit

function decode_frecps_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_recps_fp16_simd (Rd, Rn, Rm, Q) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = 16;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_recps_fp16_sisd(d, datasize, elements, esize, m, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, bitzero, bitzero, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 430) = {
    SEE = 430;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let Q = Slice(__opcode, 30, 1);
    decode_frecps_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_recps_fp16_simd(Rd, Rn, Rm, Q)
}

val decode_frecps_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_recps_simd : (bits(5), bits(5), bits(5), bits(1), bits(1)) -> unit

function decode_frecps_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_recps_simd (Rd, Rn, Rm, sz, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    };
    let 'esize = (32 << UInt(sz));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_recps_fp16_sisd(d, datasize, elements, esize, m, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, _, bitone, _, _, _, _, _, bitone, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 431) = {
    SEE = 431;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let sz = Slice(__opcode, 22, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_frecps_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_recps_simd(Rd, Rn, Rm, sz, Q)
}

val execute_aarch64_instrs_vector_arithmetic_unary_special_frecpx_fp16 : forall 'd 'esize 'n,
  (0 <= 'n & 'n <= 31 & 'esize in {16, 32, 64} & 0 <= 'd & 'd <= 31).
  (int('d), int('esize), int('n)) -> unit

function execute_aarch64_instrs_vector_arithmetic_unary_special_frecpx_fp16 (d, esize, n) = {
    CheckFPEnabled64();
    let operand : bits('esize) = V_read(n, esize);
    let fpcr : FPCRType = FPCR_read();
    let merge : bool = IsMerging(fpcr);
    result : bits(128) = if merge then V_read(d, 128) else Zeros(128);
    result = Elem_set(result, 0, esize, FPRecpX(operand, fpcr));
    V_set(d, 128) = result
}

val decode_frecpx_advsimd_aarch64_instrs_vector_arithmetic_unary_special_frecpx_fp16 : (bits(5), bits(5)) -> unit

function decode_frecpx_advsimd_aarch64_instrs_vector_arithmetic_unary_special_frecpx_fp16 (Rd, Rn) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = 16;
    execute_aarch64_instrs_vector_arithmetic_unary_special_frecpx_fp16(d, esize, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 432) = {
    SEE = 432;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    decode_frecpx_advsimd_aarch64_instrs_vector_arithmetic_unary_special_frecpx_fp16(Rd, Rn)
}

val decode_frecpx_advsimd_aarch64_instrs_vector_arithmetic_unary_special_frecpx : (bits(5), bits(5), bits(1)) -> unit

function decode_frecpx_advsimd_aarch64_instrs_vector_arithmetic_unary_special_frecpx (Rd, Rn, sz) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = (32 << UInt(sz));
    execute_aarch64_instrs_vector_arithmetic_unary_special_frecpx_fp16(d, esize, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, bitone, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 433) = {
    SEE = 433;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let sz = Slice(__opcode, 22, 1);
    decode_frecpx_advsimd_aarch64_instrs_vector_arithmetic_unary_special_frecpx(Rd, Rn, sz)
}

val execute_aarch64_instrs_vector_arithmetic_unary_float_round_frint_32_64 : forall 'd 'datasize 'elements 'esize 'intsize 'n,
  (0 <= 'n & 'n <= 31 & 'intsize in {32, 64} & 'esize in {32, 64} & 'datasize in {64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('intsize), int('n), FPRounding) -> unit

function execute_aarch64_instrs_vector_arithmetic_unary_float_round_frint_32_64 (d, datasize, elements, esize, intsize, n, rounding) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('datasize) = V_read(n, datasize);
    result : bits('datasize) = undefined;
    element : bits('esize) = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element = Elem_read(operand, e, esize);
        result = Elem_set(result, e, esize, FPRoundIntN(element, FPCR_read(), rounding, intsize))
    };
    V_set(d, datasize) = result
}

val decode_frint32x_advsimd_aarch64_instrs_vector_arithmetic_unary_float_round_frint_32_64 : (bits(5), bits(5), bits(1), bits(1), bits(1), bits(1)) -> unit

function decode_frint32x_advsimd_aarch64_instrs_vector_arithmetic_unary_float_round_frint_32_64 (Rd, Rn, op, sz, U, Q) = {
    if not_bool(HaveFrintExt()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    };
    let 'esize = (32 << UInt(sz));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let 'intsize = if op == 0b0 then 32 else 64;
    let rounding : FPRounding = if U == 0b0 then FPRounding_ZERO else
      FPRoundingMode(FPCR_read());
    execute_aarch64_instrs_vector_arithmetic_unary_float_round_frint_32_64(d, datasize, elements, esize, intsize, n, rounding)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, bitzero, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 434) = {
    SEE = 434;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 12, 1);
    let sz = Slice(__opcode, 22, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_frint32x_advsimd_aarch64_instrs_vector_arithmetic_unary_float_round_frint_32_64(Rd, Rn, op, sz, U, Q)
}

val decode_frint32z_advsimd_aarch64_instrs_vector_arithmetic_unary_float_round_frint_32_64 : (bits(5), bits(5), bits(1), bits(1), bits(1), bits(1)) -> unit

function decode_frint32z_advsimd_aarch64_instrs_vector_arithmetic_unary_float_round_frint_32_64 (Rd, Rn, op, sz, U, Q) = {
    if not_bool(HaveFrintExt()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    };
    let 'esize = (32 << UInt(sz));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let 'intsize = if op == 0b0 then 32 else 64;
    let rounding : FPRounding = if U == 0b0 then FPRounding_ZERO else
      FPRoundingMode(FPCR_read());
    execute_aarch64_instrs_vector_arithmetic_unary_float_round_frint_32_64(d, datasize, elements, esize, intsize, n, rounding)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 435) = {
    SEE = 435;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 12, 1);
    let sz = Slice(__opcode, 22, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_frint32z_advsimd_aarch64_instrs_vector_arithmetic_unary_float_round_frint_32_64(Rd, Rn, op, sz, U, Q)
}

val decode_frint64x_advsimd_aarch64_instrs_vector_arithmetic_unary_float_round_frint_32_64 : (bits(5), bits(5), bits(1), bits(1), bits(1), bits(1)) -> unit

function decode_frint64x_advsimd_aarch64_instrs_vector_arithmetic_unary_float_round_frint_32_64 (Rd, Rn, op, sz, U, Q) = {
    if not_bool(HaveFrintExt()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    };
    let 'esize = (32 << UInt(sz));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let 'intsize = if op == 0b0 then 32 else 64;
    let rounding : FPRounding = if U == 0b0 then FPRounding_ZERO else
      FPRoundingMode(FPCR_read());
    execute_aarch64_instrs_vector_arithmetic_unary_float_round_frint_32_64(d, datasize, elements, esize, intsize, n, rounding)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, bitzero, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 436) = {
    SEE = 436;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 12, 1);
    let sz = Slice(__opcode, 22, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_frint64x_advsimd_aarch64_instrs_vector_arithmetic_unary_float_round_frint_32_64(Rd, Rn, op, sz, U, Q)
}

val decode_frint64z_advsimd_aarch64_instrs_vector_arithmetic_unary_float_round_frint_32_64 : (bits(5), bits(5), bits(1), bits(1), bits(1), bits(1)) -> unit

function decode_frint64z_advsimd_aarch64_instrs_vector_arithmetic_unary_float_round_frint_32_64 (Rd, Rn, op, sz, U, Q) = {
    if not_bool(HaveFrintExt()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    };
    let 'esize = (32 << UInt(sz));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let 'intsize = if op == 0b0 then 32 else 64;
    let rounding : FPRounding = if U == 0b0 then FPRounding_ZERO else
      FPRoundingMode(FPCR_read());
    execute_aarch64_instrs_vector_arithmetic_unary_float_round_frint_32_64(d, datasize, elements, esize, intsize, n, rounding)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 437) = {
    SEE = 437;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 12, 1);
    let sz = Slice(__opcode, 22, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_frint64z_advsimd_aarch64_instrs_vector_arithmetic_unary_float_round_frint_32_64(Rd, Rn, op, sz, U, Q)
}

val execute_aarch64_instrs_float_arithmetic_round_frint_32_64 : forall 'd 'esize 'intsize 'n,
  (0 <= 'n & 'n <= 31 & 'intsize in {32, 64} & 'esize in {32, 64} & 0 <= 'd & 'd <= 31).
  (int('d), int('esize), int('intsize), int('n), FPRounding) -> unit

function execute_aarch64_instrs_float_arithmetic_round_frint_32_64 (d, esize, intsize, n, rounding) = {
    CheckFPEnabled64();
    let fpcr : FPCRType = FPCR_read();
    let merge : bool = IsMerging(fpcr);
    result : bits(128) = if merge then V_read(d, 128) else Zeros(128);
    let operand : bits('esize) = V_read(n, esize);
    result = Elem_set(result, 0, esize, FPRoundIntN(operand, fpcr, rounding, intsize));
    V_set(d, 128) = result
}

val decode_frint32x_float_aarch64_instrs_float_arithmetic_round_frint_32_64 : (bits(5), bits(5), bits(2), bits(2)) -> unit

function decode_frint32x_float_aarch64_instrs_float_arithmetic_round_frint_32_64 (Rd, Rn, op, ftype) = {
    if not_bool(HaveFrintExt()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    esize : {32, 64} = 32;
    match ftype {
      0b00 => {
          esize = 32
      },
      0b01 => {
          esize = 64
      },
      [bitone, _] => {
          throw(Error_Undefined())
      }
    };
    let 'esize = esize;
    let 'intsize = if [op[1]] == 0b0 then 32 else 64;
    let rounding : FPRounding = if [op[0]] == 0b0 then FPRounding_ZERO else
      FPRoundingMode(FPCR_read());
    execute_aarch64_instrs_float_arithmetic_round_frint_32_64(d, esize, intsize, n, rounding)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, _, bitone, bitzero, bitone, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 438) = {
    SEE = 438;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 15, 2);
    let ftype = Slice(__opcode, 22, 2);
    decode_frint32x_float_aarch64_instrs_float_arithmetic_round_frint_32_64(Rd, Rn, op, ftype)
}

val decode_frint32z_float_aarch64_instrs_float_arithmetic_round_frint_32_64 : (bits(5), bits(5), bits(2), bits(2)) -> unit

function decode_frint32z_float_aarch64_instrs_float_arithmetic_round_frint_32_64 (Rd, Rn, op, ftype) = {
    if not_bool(HaveFrintExt()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    esize : {32, 64} = 32;
    match ftype {
      0b00 => {
          esize = 32
      },
      0b01 => {
          esize = 64
      },
      [bitone, _] => {
          throw(Error_Undefined())
      }
    };
    let 'esize = esize;
    let 'intsize = if [op[1]] == 0b0 then 32 else 64;
    let rounding : FPRounding = if [op[0]] == 0b0 then FPRounding_ZERO else
      FPRoundingMode(FPCR_read());
    execute_aarch64_instrs_float_arithmetic_round_frint_32_64(d, esize, intsize, n, rounding)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, _, bitone, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 439) = {
    SEE = 439;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 15, 2);
    let ftype = Slice(__opcode, 22, 2);
    decode_frint32z_float_aarch64_instrs_float_arithmetic_round_frint_32_64(Rd, Rn, op, ftype)
}

val decode_frint64x_float_aarch64_instrs_float_arithmetic_round_frint_32_64 : (bits(5), bits(5), bits(2), bits(2)) -> unit

function decode_frint64x_float_aarch64_instrs_float_arithmetic_round_frint_32_64 (Rd, Rn, op, ftype) = {
    if not_bool(HaveFrintExt()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    esize : {32, 64} = 32;
    match ftype {
      0b00 => {
          esize = 32
      },
      0b01 => {
          esize = 64
      },
      [bitone, _] => {
          throw(Error_Undefined())
      }
    };
    let 'esize = esize;
    let 'intsize = if [op[1]] == 0b0 then 32 else 64;
    let rounding : FPRounding = if [op[0]] == 0b0 then FPRounding_ZERO else
      FPRoundingMode(FPCR_read());
    execute_aarch64_instrs_float_arithmetic_round_frint_32_64(d, esize, intsize, n, rounding)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, _, bitone, bitzero, bitone, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 440) = {
    SEE = 440;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 15, 2);
    let ftype = Slice(__opcode, 22, 2);
    decode_frint64x_float_aarch64_instrs_float_arithmetic_round_frint_32_64(Rd, Rn, op, ftype)
}

val decode_frint64z_float_aarch64_instrs_float_arithmetic_round_frint_32_64 : (bits(5), bits(5), bits(2), bits(2)) -> unit

function decode_frint64z_float_aarch64_instrs_float_arithmetic_round_frint_32_64 (Rd, Rn, op, ftype) = {
    if not_bool(HaveFrintExt()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    esize : {32, 64} = 32;
    match ftype {
      0b00 => {
          esize = 32
      },
      0b01 => {
          esize = 64
      },
      [bitone, _] => {
          throw(Error_Undefined())
      }
    };
    let 'esize = esize;
    let 'intsize = if [op[1]] == 0b0 then 32 else 64;
    let rounding : FPRounding = if [op[0]] == 0b0 then FPRounding_ZERO else
      FPRoundingMode(FPCR_read());
    execute_aarch64_instrs_float_arithmetic_round_frint_32_64(d, esize, intsize, n, rounding)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, _, bitone, bitzero, bitone, bitzero, bitzero, bitone, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 441) = {
    SEE = 441;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 15, 2);
    let ftype = Slice(__opcode, 22, 2);
    decode_frint64z_float_aarch64_instrs_float_arithmetic_round_frint_32_64(Rd, Rn, op, ftype)
}

val execute_aarch64_instrs_vector_arithmetic_unary_fp16_round : forall 'd 'datasize 'elements 'esize ('exact : Bool) 'n,
  (0 <= 'n & 'n <= 31 & 'esize in {16, 32, 64} & 'datasize in {64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), bool('exact), int('n), FPRounding) -> unit

function execute_aarch64_instrs_vector_arithmetic_unary_fp16_round (d, datasize, elements, esize, exact, n, rounding) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('datasize) = V_read(n, datasize);
    result : bits('datasize) = undefined;
    element : bits('esize) = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element = Elem_read(operand, e, esize);
        result = Elem_set(result, e, esize, FPRoundInt(element, FPCR_read(), rounding, exact))
    };
    V_set(d, datasize) = result
}

val decode_frinta_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_round : (bits(5), bits(5), bits(1), bits(1), bits(1), bits(1)) -> unit

function decode_frinta_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_round (Rd, Rn, o1, o2, U, Q) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = 16;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    exact : bool = false;
    rounding : FPRounding = undefined;
    match (U @ o1) @ o2 {
      [bitzero, _, _] => {
          rounding = FPDecodeRounding(o1 @ o2)
      },
      0b100 => {
          rounding = FPRounding_TIEAWAY
      },
      0b101 => {
          throw(Error_Undefined())
      },
      0b110 => {
          rounding = FPRoundingMode(FPCR_read());
          exact = true
      },
      0b111 => {
          rounding = FPRoundingMode(FPCR_read())
      }
    };
    let rounding = rounding;
    execute_aarch64_instrs_vector_arithmetic_unary_fp16_round(d, datasize, elements, esize, exact, n, rounding)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 442) = {
    SEE = 442;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 12, 1);
    let o2 = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_frinta_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_round(Rd, Rn, o1, o2, U, Q)
}

val decode_frinta_advsimd_aarch64_instrs_vector_arithmetic_unary_float_round : (bits(5), bits(5), bits(1), bits(1), bits(1), bits(1), bits(1)) -> unit

function decode_frinta_advsimd_aarch64_instrs_vector_arithmetic_unary_float_round (Rd, Rn, o1, sz, o2, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    };
    let 'esize = (32 << UInt(sz));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    exact : bool = false;
    rounding : FPRounding = undefined;
    match (U @ o1) @ o2 {
      [bitzero, _, _] => {
          rounding = FPDecodeRounding(o1 @ o2)
      },
      0b100 => {
          rounding = FPRounding_TIEAWAY
      },
      0b101 => {
          throw(Error_Undefined())
      },
      0b110 => {
          rounding = FPRoundingMode(FPCR_read());
          exact = true
      },
      0b111 => {
          rounding = FPRoundingMode(FPCR_read())
      }
    };
    let rounding = rounding;
    execute_aarch64_instrs_vector_arithmetic_unary_fp16_round(d, datasize, elements, esize, exact, n, rounding)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, bitzero, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 443) = {
    SEE = 443;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 12, 1);
    let sz = Slice(__opcode, 22, 1);
    let o2 = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_frinta_advsimd_aarch64_instrs_vector_arithmetic_unary_float_round(Rd, Rn, o1, sz, o2, U, Q)
}

val decode_frinti_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_round : (bits(5), bits(5), bits(1), bits(1), bits(1), bits(1)) -> unit

function decode_frinti_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_round (Rd, Rn, o1, o2, U, Q) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = 16;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    exact : bool = false;
    rounding : FPRounding = undefined;
    match (U @ o1) @ o2 {
      [bitzero, _, _] => {
          rounding = FPDecodeRounding(o1 @ o2)
      },
      0b100 => {
          rounding = FPRounding_TIEAWAY
      },
      0b101 => {
          throw(Error_Undefined())
      },
      0b110 => {
          rounding = FPRoundingMode(FPCR_read());
          exact = true
      },
      0b111 => {
          rounding = FPRoundingMode(FPCR_read())
      }
    };
    let rounding = rounding;
    execute_aarch64_instrs_vector_arithmetic_unary_fp16_round(d, datasize, elements, esize, exact, n, rounding)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 444) = {
    SEE = 444;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 12, 1);
    let o2 = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_frinti_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_round(Rd, Rn, o1, o2, U, Q)
}

val decode_frinti_advsimd_aarch64_instrs_vector_arithmetic_unary_float_round : (bits(5), bits(5), bits(1), bits(1), bits(1), bits(1), bits(1)) -> unit

function decode_frinti_advsimd_aarch64_instrs_vector_arithmetic_unary_float_round (Rd, Rn, o1, sz, o2, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    };
    let 'esize = (32 << UInt(sz));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    exact : bool = false;
    rounding : FPRounding = undefined;
    match (U @ o1) @ o2 {
      [bitzero, _, _] => {
          rounding = FPDecodeRounding(o1 @ o2)
      },
      0b100 => {
          rounding = FPRounding_TIEAWAY
      },
      0b101 => {
          throw(Error_Undefined())
      },
      0b110 => {
          rounding = FPRoundingMode(FPCR_read());
          exact = true
      },
      0b111 => {
          rounding = FPRoundingMode(FPCR_read())
      }
    };
    let rounding = rounding;
    execute_aarch64_instrs_vector_arithmetic_unary_fp16_round(d, datasize, elements, esize, exact, n, rounding)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, bitone, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 445) = {
    SEE = 445;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 12, 1);
    let sz = Slice(__opcode, 22, 1);
    let o2 = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_frinti_advsimd_aarch64_instrs_vector_arithmetic_unary_float_round(Rd, Rn, o1, sz, o2, U, Q)
}

val decode_frintm_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_round : (bits(5), bits(5), bits(1), bits(1), bits(1), bits(1)) -> unit

function decode_frintm_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_round (Rd, Rn, o1, o2, U, Q) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = 16;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    exact : bool = false;
    rounding : FPRounding = undefined;
    match (U @ o1) @ o2 {
      [bitzero, _, _] => {
          rounding = FPDecodeRounding(o1 @ o2)
      },
      0b100 => {
          rounding = FPRounding_TIEAWAY
      },
      0b101 => {
          throw(Error_Undefined())
      },
      0b110 => {
          rounding = FPRoundingMode(FPCR_read());
          exact = true
      },
      0b111 => {
          rounding = FPRoundingMode(FPCR_read())
      }
    };
    let rounding = rounding;
    execute_aarch64_instrs_vector_arithmetic_unary_fp16_round(d, datasize, elements, esize, exact, n, rounding)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 446) = {
    SEE = 446;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 12, 1);
    let o2 = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_frintm_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_round(Rd, Rn, o1, o2, U, Q)
}

val decode_frintm_advsimd_aarch64_instrs_vector_arithmetic_unary_float_round : (bits(5), bits(5), bits(1), bits(1), bits(1), bits(1), bits(1)) -> unit

function decode_frintm_advsimd_aarch64_instrs_vector_arithmetic_unary_float_round (Rd, Rn, o1, sz, o2, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    };
    let 'esize = (32 << UInt(sz));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    exact : bool = false;
    rounding : FPRounding = undefined;
    match (U @ o1) @ o2 {
      [bitzero, _, _] => {
          rounding = FPDecodeRounding(o1 @ o2)
      },
      0b100 => {
          rounding = FPRounding_TIEAWAY
      },
      0b101 => {
          throw(Error_Undefined())
      },
      0b110 => {
          rounding = FPRoundingMode(FPCR_read());
          exact = true
      },
      0b111 => {
          rounding = FPRoundingMode(FPCR_read())
      }
    };
    let rounding = rounding;
    execute_aarch64_instrs_vector_arithmetic_unary_fp16_round(d, datasize, elements, esize, exact, n, rounding)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 447) = {
    SEE = 447;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 12, 1);
    let sz = Slice(__opcode, 22, 1);
    let o2 = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_frintm_advsimd_aarch64_instrs_vector_arithmetic_unary_float_round(Rd, Rn, o1, sz, o2, U, Q)
}

val decode_frintn_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_round : (bits(5), bits(5), bits(1), bits(1), bits(1), bits(1)) -> unit

function decode_frintn_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_round (Rd, Rn, o1, o2, U, Q) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = 16;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    exact : bool = false;
    rounding : FPRounding = undefined;
    match (U @ o1) @ o2 {
      [bitzero, _, _] => {
          rounding = FPDecodeRounding(o1 @ o2)
      },
      0b100 => {
          rounding = FPRounding_TIEAWAY
      },
      0b101 => {
          throw(Error_Undefined())
      },
      0b110 => {
          rounding = FPRoundingMode(FPCR_read());
          exact = true
      },
      0b111 => {
          rounding = FPRoundingMode(FPCR_read())
      }
    };
    let rounding = rounding;
    execute_aarch64_instrs_vector_arithmetic_unary_fp16_round(d, datasize, elements, esize, exact, n, rounding)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 448) = {
    SEE = 448;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 12, 1);
    let o2 = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_frintn_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_round(Rd, Rn, o1, o2, U, Q)
}

val decode_frintn_advsimd_aarch64_instrs_vector_arithmetic_unary_float_round : (bits(5), bits(5), bits(1), bits(1), bits(1), bits(1), bits(1)) -> unit

function decode_frintn_advsimd_aarch64_instrs_vector_arithmetic_unary_float_round (Rd, Rn, o1, sz, o2, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    };
    let 'esize = (32 << UInt(sz));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    exact : bool = false;
    rounding : FPRounding = undefined;
    match (U @ o1) @ o2 {
      [bitzero, _, _] => {
          rounding = FPDecodeRounding(o1 @ o2)
      },
      0b100 => {
          rounding = FPRounding_TIEAWAY
      },
      0b101 => {
          throw(Error_Undefined())
      },
      0b110 => {
          rounding = FPRoundingMode(FPCR_read());
          exact = true
      },
      0b111 => {
          rounding = FPRoundingMode(FPCR_read())
      }
    };
    let rounding = rounding;
    execute_aarch64_instrs_vector_arithmetic_unary_fp16_round(d, datasize, elements, esize, exact, n, rounding)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 449) = {
    SEE = 449;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 12, 1);
    let sz = Slice(__opcode, 22, 1);
    let o2 = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_frintn_advsimd_aarch64_instrs_vector_arithmetic_unary_float_round(Rd, Rn, o1, sz, o2, U, Q)
}

val decode_frintp_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_round : (bits(5), bits(5), bits(1), bits(1), bits(1), bits(1)) -> unit

function decode_frintp_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_round (Rd, Rn, o1, o2, U, Q) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = 16;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    exact : bool = false;
    rounding : FPRounding = undefined;
    match (U @ o1) @ o2 {
      [bitzero, _, _] => {
          rounding = FPDecodeRounding(o1 @ o2)
      },
      0b100 => {
          rounding = FPRounding_TIEAWAY
      },
      0b101 => {
          throw(Error_Undefined())
      },
      0b110 => {
          rounding = FPRoundingMode(FPCR_read());
          exact = true
      },
      0b111 => {
          rounding = FPRoundingMode(FPCR_read())
      }
    };
    let rounding = rounding;
    execute_aarch64_instrs_vector_arithmetic_unary_fp16_round(d, datasize, elements, esize, exact, n, rounding)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 450) = {
    SEE = 450;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 12, 1);
    let o2 = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_frintp_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_round(Rd, Rn, o1, o2, U, Q)
}

val decode_frintp_advsimd_aarch64_instrs_vector_arithmetic_unary_float_round : (bits(5), bits(5), bits(1), bits(1), bits(1), bits(1), bits(1)) -> unit

function decode_frintp_advsimd_aarch64_instrs_vector_arithmetic_unary_float_round (Rd, Rn, o1, sz, o2, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    };
    let 'esize = (32 << UInt(sz));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    exact : bool = false;
    rounding : FPRounding = undefined;
    match (U @ o1) @ o2 {
      [bitzero, _, _] => {
          rounding = FPDecodeRounding(o1 @ o2)
      },
      0b100 => {
          rounding = FPRounding_TIEAWAY
      },
      0b101 => {
          throw(Error_Undefined())
      },
      0b110 => {
          rounding = FPRoundingMode(FPCR_read());
          exact = true
      },
      0b111 => {
          rounding = FPRoundingMode(FPCR_read())
      }
    };
    let rounding = rounding;
    execute_aarch64_instrs_vector_arithmetic_unary_fp16_round(d, datasize, elements, esize, exact, n, rounding)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitone, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 451) = {
    SEE = 451;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 12, 1);
    let sz = Slice(__opcode, 22, 1);
    let o2 = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_frintp_advsimd_aarch64_instrs_vector_arithmetic_unary_float_round(Rd, Rn, o1, sz, o2, U, Q)
}

val decode_frintx_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_round : (bits(5), bits(5), bits(1), bits(1), bits(1), bits(1)) -> unit

function decode_frintx_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_round (Rd, Rn, o1, o2, U, Q) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = 16;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    exact : bool = false;
    rounding : FPRounding = undefined;
    match (U @ o1) @ o2 {
      [bitzero, _, _] => {
          rounding = FPDecodeRounding(o1 @ o2)
      },
      0b100 => {
          rounding = FPRounding_TIEAWAY
      },
      0b101 => {
          throw(Error_Undefined())
      },
      0b110 => {
          rounding = FPRoundingMode(FPCR_read());
          exact = true
      },
      0b111 => {
          rounding = FPRoundingMode(FPCR_read())
      }
    };
    let rounding = rounding;
    execute_aarch64_instrs_vector_arithmetic_unary_fp16_round(d, datasize, elements, esize, exact, n, rounding)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 452) = {
    SEE = 452;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 12, 1);
    let o2 = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_frintx_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_round(Rd, Rn, o1, o2, U, Q)
}

val decode_frintx_advsimd_aarch64_instrs_vector_arithmetic_unary_float_round : (bits(5), bits(5), bits(1), bits(1), bits(1), bits(1), bits(1)) -> unit

function decode_frintx_advsimd_aarch64_instrs_vector_arithmetic_unary_float_round (Rd, Rn, o1, sz, o2, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    };
    let 'esize = (32 << UInt(sz));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    exact : bool = false;
    rounding : FPRounding = undefined;
    match (U @ o1) @ o2 {
      [bitzero, _, _] => {
          rounding = FPDecodeRounding(o1 @ o2)
      },
      0b100 => {
          rounding = FPRounding_TIEAWAY
      },
      0b101 => {
          throw(Error_Undefined())
      },
      0b110 => {
          rounding = FPRoundingMode(FPCR_read());
          exact = true
      },
      0b111 => {
          rounding = FPRoundingMode(FPCR_read())
      }
    };
    let rounding = rounding;
    execute_aarch64_instrs_vector_arithmetic_unary_fp16_round(d, datasize, elements, esize, exact, n, rounding)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, bitzero, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 453) = {
    SEE = 453;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 12, 1);
    let sz = Slice(__opcode, 22, 1);
    let o2 = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_frintx_advsimd_aarch64_instrs_vector_arithmetic_unary_float_round(Rd, Rn, o1, sz, o2, U, Q)
}

val decode_frintz_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_round : (bits(5), bits(5), bits(1), bits(1), bits(1), bits(1)) -> unit

function decode_frintz_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_round (Rd, Rn, o1, o2, U, Q) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = 16;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    exact : bool = false;
    rounding : FPRounding = undefined;
    match (U @ o1) @ o2 {
      [bitzero, _, _] => {
          rounding = FPDecodeRounding(o1 @ o2)
      },
      0b100 => {
          rounding = FPRounding_TIEAWAY
      },
      0b101 => {
          throw(Error_Undefined())
      },
      0b110 => {
          rounding = FPRoundingMode(FPCR_read());
          exact = true
      },
      0b111 => {
          rounding = FPRoundingMode(FPCR_read())
      }
    };
    let rounding = rounding;
    execute_aarch64_instrs_vector_arithmetic_unary_fp16_round(d, datasize, elements, esize, exact, n, rounding)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 454) = {
    SEE = 454;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 12, 1);
    let o2 = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_frintz_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_round(Rd, Rn, o1, o2, U, Q)
}

val decode_frintz_advsimd_aarch64_instrs_vector_arithmetic_unary_float_round : (bits(5), bits(5), bits(1), bits(1), bits(1), bits(1), bits(1)) -> unit

function decode_frintz_advsimd_aarch64_instrs_vector_arithmetic_unary_float_round (Rd, Rn, o1, sz, o2, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    };
    let 'esize = (32 << UInt(sz));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    exact : bool = false;
    rounding : FPRounding = undefined;
    match (U @ o1) @ o2 {
      [bitzero, _, _] => {
          rounding = FPDecodeRounding(o1 @ o2)
      },
      0b100 => {
          rounding = FPRounding_TIEAWAY
      },
      0b101 => {
          throw(Error_Undefined())
      },
      0b110 => {
          rounding = FPRoundingMode(FPCR_read());
          exact = true
      },
      0b111 => {
          rounding = FPRoundingMode(FPCR_read())
      }
    };
    let rounding = rounding;
    execute_aarch64_instrs_vector_arithmetic_unary_fp16_round(d, datasize, elements, esize, exact, n, rounding)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitone, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 455) = {
    SEE = 455;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 12, 1);
    let sz = Slice(__opcode, 22, 1);
    let o2 = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_frintz_advsimd_aarch64_instrs_vector_arithmetic_unary_float_round(Rd, Rn, o1, sz, o2, U, Q)
}

val execute_aarch64_instrs_float_arithmetic_round_frint : forall 'd 'esize ('exact : Bool) 'n,
  (0 <= 'n & 'n <= 31 & 'esize in {16, 32, 64} & 0 <= 'd & 'd <= 31).
  (int('d), int('esize), bool('exact), int('n), FPRounding) -> unit

function execute_aarch64_instrs_float_arithmetic_round_frint (d, esize, exact, n, rounding) = {
    CheckFPEnabled64();
    let fpcr : FPCRType = FPCR_read();
    let merge : bool = IsMerging(fpcr);
    result : bits(128) = if merge then V_read(d, 128) else Zeros(128);
    let operand : bits('esize) = V_read(n, esize);
    result = Elem_set(result, 0, esize, FPRoundInt(operand, fpcr, rounding, exact));
    V_set(d, 128) = result
}

val decode_frinta_float_aarch64_instrs_float_arithmetic_round_frint : (bits(5), bits(5), bits(3), bits(2)) -> unit

function decode_frinta_float_aarch64_instrs_float_arithmetic_round_frint (Rd, Rn, rmode, ftype) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    esize : {16, 32, 64} = 16;
    match ftype {
      0b00 => {
          esize = 32
      },
      0b01 => {
          esize = 64
      },
      0b10 => {
          throw(Error_Undefined())
      },
      0b11 => {
          if HaveFP16Ext() then {
              esize = 16
          } else {
              throw(Error_Undefined())
          }
      }
    };
    let 'esize = esize;
    exact : bool = false;
    rounding : FPRounding = undefined;
    match rmode {
      [bitzero, _, _] => {
          rounding = FPDecodeRounding(rmode[1 .. 0])
      },
      0b100 => {
          rounding = FPRounding_TIEAWAY
      },
      0b101 => {
          throw(Error_Undefined())
      },
      0b110 => {
          rounding = FPRoundingMode(FPCR_read());
          exact = true
      },
      0b111 => {
          rounding = FPRoundingMode(FPCR_read())
      }
    };
    let rounding = rounding;
    execute_aarch64_instrs_float_arithmetic_round_frint(d, esize, exact, n, rounding)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 456) = {
    SEE = 456;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let rmode = Slice(__opcode, 15, 3);
    let ftype = Slice(__opcode, 22, 2);
    decode_frinta_float_aarch64_instrs_float_arithmetic_round_frint(Rd, Rn, rmode, ftype)
}

val decode_frinti_float_aarch64_instrs_float_arithmetic_round_frint : (bits(5), bits(5), bits(3), bits(2)) -> unit

function decode_frinti_float_aarch64_instrs_float_arithmetic_round_frint (Rd, Rn, rmode, ftype) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    esize : {16, 32, 64} = 16;
    match ftype {
      0b00 => {
          esize = 32
      },
      0b01 => {
          esize = 64
      },
      0b10 => {
          throw(Error_Undefined())
      },
      0b11 => {
          if HaveFP16Ext() then {
              esize = 16
          } else {
              throw(Error_Undefined())
          }
      }
    };
    let 'esize = esize;
    exact : bool = false;
    rounding : FPRounding = undefined;
    match rmode {
      [bitzero, _, _] => {
          rounding = FPDecodeRounding(rmode[1 .. 0])
      },
      0b100 => {
          rounding = FPRounding_TIEAWAY
      },
      0b101 => {
          throw(Error_Undefined())
      },
      0b110 => {
          rounding = FPRoundingMode(FPCR_read());
          exact = true
      },
      0b111 => {
          rounding = FPRoundingMode(FPCR_read())
      }
    };
    let rounding = rounding;
    execute_aarch64_instrs_float_arithmetic_round_frint(d, esize, exact, n, rounding)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, bitzero, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 457) = {
    SEE = 457;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let rmode = Slice(__opcode, 15, 3);
    let ftype = Slice(__opcode, 22, 2);
    decode_frinti_float_aarch64_instrs_float_arithmetic_round_frint(Rd, Rn, rmode, ftype)
}

val decode_frintm_float_aarch64_instrs_float_arithmetic_round_frint : (bits(5), bits(5), bits(3), bits(2)) -> unit

function decode_frintm_float_aarch64_instrs_float_arithmetic_round_frint (Rd, Rn, rmode, ftype) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    esize : {16, 32, 64} = 16;
    match ftype {
      0b00 => {
          esize = 32
      },
      0b01 => {
          esize = 64
      },
      0b10 => {
          throw(Error_Undefined())
      },
      0b11 => {
          if HaveFP16Ext() then {
              esize = 16
          } else {
              throw(Error_Undefined())
          }
      }
    };
    let 'esize = esize;
    exact : bool = false;
    rounding : FPRounding = undefined;
    match rmode {
      [bitzero, _, _] => {
          rounding = FPDecodeRounding(rmode[1 .. 0])
      },
      0b100 => {
          rounding = FPRounding_TIEAWAY
      },
      0b101 => {
          throw(Error_Undefined())
      },
      0b110 => {
          rounding = FPRoundingMode(FPCR_read());
          exact = true
      },
      0b111 => {
          rounding = FPRoundingMode(FPCR_read())
      }
    };
    let rounding = rounding;
    execute_aarch64_instrs_float_arithmetic_round_frint(d, esize, exact, n, rounding)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, bitzero, bitzero, bitone, bitzero, bitone, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 458) = {
    SEE = 458;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let rmode = Slice(__opcode, 15, 3);
    let ftype = Slice(__opcode, 22, 2);
    decode_frintm_float_aarch64_instrs_float_arithmetic_round_frint(Rd, Rn, rmode, ftype)
}

val decode_frintn_float_aarch64_instrs_float_arithmetic_round_frint : (bits(5), bits(5), bits(3), bits(2)) -> unit

function decode_frintn_float_aarch64_instrs_float_arithmetic_round_frint (Rd, Rn, rmode, ftype) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    esize : {16, 32, 64} = 16;
    match ftype {
      0b00 => {
          esize = 32
      },
      0b01 => {
          esize = 64
      },
      0b10 => {
          throw(Error_Undefined())
      },
      0b11 => {
          if HaveFP16Ext() then {
              esize = 16
          } else {
              throw(Error_Undefined())
          }
      }
    };
    let 'esize = esize;
    exact : bool = false;
    rounding : FPRounding = undefined;
    match rmode {
      [bitzero, _, _] => {
          rounding = FPDecodeRounding(rmode[1 .. 0])
      },
      0b100 => {
          rounding = FPRounding_TIEAWAY
      },
      0b101 => {
          throw(Error_Undefined())
      },
      0b110 => {
          rounding = FPRoundingMode(FPCR_read());
          exact = true
      },
      0b111 => {
          rounding = FPRoundingMode(FPCR_read())
      }
    };
    let rounding = rounding;
    execute_aarch64_instrs_float_arithmetic_round_frint(d, esize, exact, n, rounding)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 459) = {
    SEE = 459;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let rmode = Slice(__opcode, 15, 3);
    let ftype = Slice(__opcode, 22, 2);
    decode_frintn_float_aarch64_instrs_float_arithmetic_round_frint(Rd, Rn, rmode, ftype)
}

val decode_frintp_float_aarch64_instrs_float_arithmetic_round_frint : (bits(5), bits(5), bits(3), bits(2)) -> unit

function decode_frintp_float_aarch64_instrs_float_arithmetic_round_frint (Rd, Rn, rmode, ftype) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    esize : {16, 32, 64} = 16;
    match ftype {
      0b00 => {
          esize = 32
      },
      0b01 => {
          esize = 64
      },
      0b10 => {
          throw(Error_Undefined())
      },
      0b11 => {
          if HaveFP16Ext() then {
              esize = 16
          } else {
              throw(Error_Undefined())
          }
      }
    };
    let 'esize = esize;
    exact : bool = false;
    rounding : FPRounding = undefined;
    match rmode {
      [bitzero, _, _] => {
          rounding = FPDecodeRounding(rmode[1 .. 0])
      },
      0b100 => {
          rounding = FPRounding_TIEAWAY
      },
      0b101 => {
          throw(Error_Undefined())
      },
      0b110 => {
          rounding = FPRoundingMode(FPCR_read());
          exact = true
      },
      0b111 => {
          rounding = FPRoundingMode(FPCR_read())
      }
    };
    let rounding = rounding;
    execute_aarch64_instrs_float_arithmetic_round_frint(d, esize, exact, n, rounding)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, bitzero, bitzero, bitone, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 460) = {
    SEE = 460;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let rmode = Slice(__opcode, 15, 3);
    let ftype = Slice(__opcode, 22, 2);
    decode_frintp_float_aarch64_instrs_float_arithmetic_round_frint(Rd, Rn, rmode, ftype)
}

val decode_frintx_float_aarch64_instrs_float_arithmetic_round_frint : (bits(5), bits(5), bits(3), bits(2)) -> unit

function decode_frintx_float_aarch64_instrs_float_arithmetic_round_frint (Rd, Rn, rmode, ftype) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    esize : {16, 32, 64} = 16;
    match ftype {
      0b00 => {
          esize = 32
      },
      0b01 => {
          esize = 64
      },
      0b10 => {
          throw(Error_Undefined())
      },
      0b11 => {
          if HaveFP16Ext() then {
              esize = 16
          } else {
              throw(Error_Undefined())
          }
      }
    };
    let 'esize = esize;
    exact : bool = false;
    rounding : FPRounding = undefined;
    match rmode {
      [bitzero, _, _] => {
          rounding = FPDecodeRounding(rmode[1 .. 0])
      },
      0b100 => {
          rounding = FPRounding_TIEAWAY
      },
      0b101 => {
          throw(Error_Undefined())
      },
      0b110 => {
          rounding = FPRoundingMode(FPCR_read());
          exact = true
      },
      0b111 => {
          rounding = FPRoundingMode(FPCR_read())
      }
    };
    let rounding = rounding;
    execute_aarch64_instrs_float_arithmetic_round_frint(d, esize, exact, n, rounding)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 461) = {
    SEE = 461;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let rmode = Slice(__opcode, 15, 3);
    let ftype = Slice(__opcode, 22, 2);
    decode_frintx_float_aarch64_instrs_float_arithmetic_round_frint(Rd, Rn, rmode, ftype)
}

val decode_frintz_float_aarch64_instrs_float_arithmetic_round_frint : (bits(5), bits(5), bits(3), bits(2)) -> unit

function decode_frintz_float_aarch64_instrs_float_arithmetic_round_frint (Rd, Rn, rmode, ftype) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    esize : {16, 32, 64} = 16;
    match ftype {
      0b00 => {
          esize = 32
      },
      0b01 => {
          esize = 64
      },
      0b10 => {
          throw(Error_Undefined())
      },
      0b11 => {
          if HaveFP16Ext() then {
              esize = 16
          } else {
              throw(Error_Undefined())
          }
      }
    };
    let 'esize = esize;
    exact : bool = false;
    rounding : FPRounding = undefined;
    match rmode {
      [bitzero, _, _] => {
          rounding = FPDecodeRounding(rmode[1 .. 0])
      },
      0b100 => {
          rounding = FPRounding_TIEAWAY
      },
      0b101 => {
          throw(Error_Undefined())
      },
      0b110 => {
          rounding = FPRoundingMode(FPCR_read());
          exact = true
      },
      0b111 => {
          rounding = FPRoundingMode(FPCR_read())
      }
    };
    let rounding = rounding;
    execute_aarch64_instrs_float_arithmetic_round_frint(d, esize, exact, n, rounding)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 462) = {
    SEE = 462;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let rmode = Slice(__opcode, 15, 3);
    let ftype = Slice(__opcode, 22, 2);
    decode_frintz_float_aarch64_instrs_float_arithmetic_round_frint(Rd, Rn, rmode, ftype)
}

val execute_aarch64_instrs_vector_arithmetic_unary_special_sqrt_est_fp16_sisd : forall 'd 'datasize 'elements 'esize 'n,
  (0 <= 'n & 'n <= 31 & 'esize in {16, 32, 64} & 'datasize in {16, 32, 64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('n)) -> unit

function execute_aarch64_instrs_vector_arithmetic_unary_special_sqrt_est_fp16_sisd (d, datasize, elements, esize, n) = {
    if elements == 1 then {
        CheckFPEnabled64()
    } else {
        CheckFPAdvSIMDEnabled64()
    };
    let operand : bits('datasize) = V_read(n, datasize);
    element : bits('esize) = undefined;
    let fpcr : FPCRType = FPCR_read();
    let merge : bool = elements == 1 & IsMerging(fpcr);
    result : bits(128) = if merge then V_read(d, 128) else Zeros(128);
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element = Elem_read(operand, e, esize);
        result = Elem_set(result, e, esize, FPRSqrtEstimate(element, fpcr))
    };
    V_set(d, 128) = result
}

val decode_frsqrte_advsimd_aarch64_instrs_vector_arithmetic_unary_special_sqrt_est_fp16_sisd : (bits(5), bits(5)) -> unit

function decode_frsqrte_advsimd_aarch64_instrs_vector_arithmetic_unary_special_sqrt_est_fp16_sisd (Rd, Rn) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = 16;
    let 'datasize = esize;
    let 'elements = 1;
    execute_aarch64_instrs_vector_arithmetic_unary_special_sqrt_est_fp16_sisd(d, datasize, elements, esize, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 463) = {
    SEE = 463;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    decode_frsqrte_advsimd_aarch64_instrs_vector_arithmetic_unary_special_sqrt_est_fp16_sisd(Rd, Rn)
}

val decode_frsqrte_advsimd_aarch64_instrs_vector_arithmetic_unary_special_sqrt_est_float_sisd : (bits(5), bits(5), bits(1)) -> unit

function decode_frsqrte_advsimd_aarch64_instrs_vector_arithmetic_unary_special_sqrt_est_float_sisd (Rd, Rn, sz) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = (32 << UInt(sz));
    let 'datasize = esize;
    let 'elements = 1;
    execute_aarch64_instrs_vector_arithmetic_unary_special_sqrt_est_fp16_sisd(d, datasize, elements, esize, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, bitone, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 464) = {
    SEE = 464;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let sz = Slice(__opcode, 22, 1);
    decode_frsqrte_advsimd_aarch64_instrs_vector_arithmetic_unary_special_sqrt_est_float_sisd(Rd, Rn, sz)
}

val decode_frsqrte_advsimd_aarch64_instrs_vector_arithmetic_unary_special_sqrt_est_fp16_simd : (bits(5), bits(5), bits(1)) -> unit

function decode_frsqrte_advsimd_aarch64_instrs_vector_arithmetic_unary_special_sqrt_est_fp16_simd (Rd, Rn, Q) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = 16;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    execute_aarch64_instrs_vector_arithmetic_unary_special_sqrt_est_fp16_sisd(d, datasize, elements, esize, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 465) = {
    SEE = 465;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Q = Slice(__opcode, 30, 1);
    decode_frsqrte_advsimd_aarch64_instrs_vector_arithmetic_unary_special_sqrt_est_fp16_simd(Rd, Rn, Q)
}

val decode_frsqrte_advsimd_aarch64_instrs_vector_arithmetic_unary_special_sqrt_est_float_simd : (bits(5), bits(5), bits(1), bits(1)) -> unit

function decode_frsqrte_advsimd_aarch64_instrs_vector_arithmetic_unary_special_sqrt_est_float_simd (Rd, Rn, sz, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    };
    let 'esize = (32 << UInt(sz));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    execute_aarch64_instrs_vector_arithmetic_unary_special_sqrt_est_fp16_sisd(d, datasize, elements, esize, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, bitone, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 466) = {
    SEE = 466;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let sz = Slice(__opcode, 22, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_frsqrte_advsimd_aarch64_instrs_vector_arithmetic_unary_special_sqrt_est_float_simd(Rd, Rn, sz, Q)
}

val execute_aarch64_instrs_vector_arithmetic_binary_uniform_rsqrts_fp16_sisd : forall 'd 'datasize 'elements 'esize 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'esize in {16, 32, 64} & 'datasize in {16, 32, 64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('m), int('n)) -> unit

function execute_aarch64_instrs_vector_arithmetic_binary_uniform_rsqrts_fp16_sisd (d, datasize, elements, esize, m, n) = {
    if elements == 1 then {
        CheckFPEnabled64()
    } else {
        CheckFPAdvSIMDEnabled64()
    };
    let operand1 : bits('datasize) = V_read(n, datasize);
    let operand2 : bits('datasize) = V_read(m, datasize);
    element1 : bits('esize) = undefined;
    element2 : bits('esize) = undefined;
    let fpcr : FPCRType = FPCR_read();
    let merge : bool = elements == 1 & IsMerging(fpcr);
    result : bits(128) = if merge then V_read(n, 128) else Zeros(128);
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element1 = Elem_read(operand1, e, esize);
        element2 = Elem_read(operand2, e, esize);
        result = Elem_set(result, e, esize, FPRSqrtStepFused(element1, element2))
    };
    V_set(d, 128) = result
}

val decode_frsqrts_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_rsqrts_fp16_sisd : (bits(5), bits(5), bits(5)) -> unit

function decode_frsqrts_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_rsqrts_fp16_sisd (Rd, Rn, Rm) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = 16;
    let 'datasize = esize;
    let 'elements = 1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_rsqrts_fp16_sisd(d, datasize, elements, esize, m, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, bitzero, bitzero, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 467) = {
    SEE = 467;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    decode_frsqrts_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_rsqrts_fp16_sisd(Rd, Rn, Rm)
}

val decode_frsqrts_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_rsqrts_sisd : (bits(5), bits(5), bits(5), bits(1)) -> unit

function decode_frsqrts_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_rsqrts_sisd (Rd, Rn, Rm, sz) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = (32 << UInt(sz));
    let 'datasize = esize;
    let 'elements = 1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_rsqrts_fp16_sisd(d, datasize, elements, esize, m, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, bitone, _, bitone, _, _, _, _, _, bitone, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 468) = {
    SEE = 468;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let sz = Slice(__opcode, 22, 1);
    decode_frsqrts_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_rsqrts_sisd(Rd, Rn, Rm, sz)
}

val decode_frsqrts_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_rsqrts_fp16_simd : (bits(5), bits(5), bits(5), bits(1)) -> unit

function decode_frsqrts_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_rsqrts_fp16_simd (Rd, Rn, Rm, Q) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = 16;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_rsqrts_fp16_sisd(d, datasize, elements, esize, m, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, bitzero, bitzero, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 469) = {
    SEE = 469;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let Q = Slice(__opcode, 30, 1);
    decode_frsqrts_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_rsqrts_fp16_simd(Rd, Rn, Rm, Q)
}

val decode_frsqrts_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_rsqrts_simd : (bits(5), bits(5), bits(5), bits(1), bits(1)) -> unit

function decode_frsqrts_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_rsqrts_simd (Rd, Rn, Rm, sz, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    };
    let 'esize = (32 << UInt(sz));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_rsqrts_fp16_sisd(d, datasize, elements, esize, m, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitone, _, bitone, _, _, _, _, _, bitone, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 470) = {
    SEE = 470;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let sz = Slice(__opcode, 22, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_frsqrts_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_rsqrts_simd(Rd, Rn, Rm, sz, Q)
}

val execute_aarch64_instrs_vector_arithmetic_unary_special_sqrt_fp16 : forall 'd 'datasize 'elements 'esize 'n,
  (0 <= 'n & 'n <= 31 & 'esize in {16, 32, 64} & 'datasize in {64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('n)) -> unit

function execute_aarch64_instrs_vector_arithmetic_unary_special_sqrt_fp16 (d, datasize, elements, esize, n) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('datasize) = V_read(n, datasize);
    result : bits('datasize) = undefined;
    element : bits('esize) = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element = Elem_read(operand, e, esize);
        result = Elem_set(result, e, esize, FPSqrt(element, FPCR_read()))
    };
    V_set(d, datasize) = result
}

val decode_fsqrt_advsimd_aarch64_instrs_vector_arithmetic_unary_special_sqrt_fp16 : (bits(5), bits(5), bits(1)) -> unit

function decode_fsqrt_advsimd_aarch64_instrs_vector_arithmetic_unary_special_sqrt_fp16 (Rd, Rn, Q) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = 16;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    execute_aarch64_instrs_vector_arithmetic_unary_special_sqrt_fp16(d, datasize, elements, esize, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 471) = {
    SEE = 471;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Q = Slice(__opcode, 30, 1);
    decode_fsqrt_advsimd_aarch64_instrs_vector_arithmetic_unary_special_sqrt_fp16(Rd, Rn, Q)
}

val decode_fsqrt_advsimd_aarch64_instrs_vector_arithmetic_unary_special_sqrt : (bits(5), bits(5), bits(1), bits(1)) -> unit

function decode_fsqrt_advsimd_aarch64_instrs_vector_arithmetic_unary_special_sqrt (Rd, Rn, sz, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    };
    let 'esize = (32 << UInt(sz));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    execute_aarch64_instrs_vector_arithmetic_unary_special_sqrt_fp16(d, datasize, elements, esize, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, bitone, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 472) = {
    SEE = 472;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let sz = Slice(__opcode, 22, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fsqrt_advsimd_aarch64_instrs_vector_arithmetic_unary_special_sqrt(Rd, Rn, sz, Q)
}

val execute_aarch64_instrs_vector_arithmetic_binary_uniform_sub_fp16_simd : forall ('abs : Bool) 'd 'datasize 'elements 'esize 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'esize in {16, 32, 64} & 'datasize in {64, 128} & 0 <= 'd & 'd <= 31).
  (bool('abs), int('d), int('datasize), int('elements), int('esize), int('m), int('n)) -> unit

function execute_aarch64_instrs_vector_arithmetic_binary_uniform_sub_fp16_simd (abs, d, datasize, elements, esize, m, n) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = V_read(n, datasize);
    let operand2 : bits('datasize) = V_read(m, datasize);
    element1 : bits('esize) = undefined;
    element2 : bits('esize) = undefined;
    diff : bits('esize) = undefined;
    let fpcr : FPCRType = FPCR_read();
    result : bits('datasize) = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element1 = Elem_read(operand1, e, esize);
        element2 = Elem_read(operand2, e, esize);
        diff = FPSub(element1, element2, fpcr);
        result = Elem_set(result, e, esize, if abs then FPAbs(diff) else diff)
    };
    V_set(d, datasize) = result
}

val decode_fsub_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_sub_fp16_simd : (bits(5), bits(5), bits(5), bits(1), bits(1)) -> unit

function decode_fsub_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_sub_fp16_simd (Rd, Rn, Rm, U, Q) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = 16;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let abs : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_sub_fp16_simd(abs, d, datasize, elements, esize, m, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, bitzero, bitzero, bitzero, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 473) = {
    SEE = 473;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fsub_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_sub_fp16_simd(Rd, Rn, Rm, U, Q)
}

val decode_fsub_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_sub_fp_simd : (bits(5), bits(5), bits(5), bits(1), bits(1), bits(1)) -> unit

function decode_fsub_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_sub_fp_simd (Rd, Rn, Rm, sz, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    };
    let 'esize = (32 << UInt(sz));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let abs : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_sub_fp16_simd(abs, d, datasize, elements, esize, m, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitone, _, bitone, _, _, _, _, _, bitone, bitone, bitzero, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 474) = {
    SEE = 474;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let sz = Slice(__opcode, 22, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fsub_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_sub_fp_simd(Rd, Rn, Rm, sz, U, Q)
}

val execute_aarch64_instrs_memory_gcs_general_register : forall ('is_gcssttr : Bool) 'n 't,
  (0 <= 't & 't <= 31 & 0 <= 'n & 'n <= 31).
  (bool('is_gcssttr), int('n), int('t)) -> unit

function execute_aarch64_instrs_memory_gcs_general_register (is_gcssttr, n, t) = {
    address : bits(64) = undefined;
    let effective_el : bits(2) = if not_bool(is_gcssttr) | AArch64_IsUnprivAccessPriv() then
      PSTATE.EL
    else
      EL0;
    if effective_el == PSTATE.EL then {
        CheckGCSSTREnabled()
    };
    let accdesc : AccessDescriptor = CreateAccDescGCS(effective_el, MemOp_STORE);
    if n == 31 then {
        CheckSPAlignment();
        address = SP_read()
    } else {
        address = X_read(n, 64)
    };
    let data : bits(64) = X_read(t, 64);
    Mem_set(address, 8, accdesc) = data
}

val decode_gcsstr_aarch64_instrs_memory_gcs_general_register : (bits(5), bits(5), bits(3)) -> unit

function decode_gcsstr_aarch64_instrs_memory_gcs_general_register (Rt, Rn, opc) = {
    if not_bool(HaveGCS()) then {
        throw(Error_Undefined())
    };
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let is_gcssttr : bool = opc == 0b001;
    execute_aarch64_instrs_memory_gcs_general_register(is_gcssttr, n, t)
}

function clause __DecodeA64_LoadStore ((pc, ([bitone, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 475) = {
    SEE = 475;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let opc = Slice(__opcode, 12, 3);
    decode_gcsstr_aarch64_instrs_memory_gcs_general_register(Rt, Rn, opc)
}

val decode_gcssttr_aarch64_instrs_memory_gcs_general_register : (bits(5), bits(5), bits(3)) -> unit

function decode_gcssttr_aarch64_instrs_memory_gcs_general_register (Rt, Rn, opc) = {
    if not_bool(HaveGCS()) then {
        throw(Error_Undefined())
    };
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let is_gcssttr : bool = opc == 0b001;
    execute_aarch64_instrs_memory_gcs_general_register(is_gcssttr, n, t)
}

function clause __DecodeA64_LoadStore ((pc, ([bitone, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 476) = {
    SEE = 476;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let opc = Slice(__opcode, 12, 3);
    decode_gcssttr_aarch64_instrs_memory_gcs_general_register(Rt, Rn, opc)
}

val execute_aarch64_instrs_integer_tags_mcinserttagmask : forall 'd 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 0 <= 'd & 'd <= 31).
  (int('d), int('m), int('n)) -> unit

function execute_aarch64_instrs_integer_tags_mcinserttagmask (d, m, n) = {
    let address : bits(64) = if n == 31 then SP_read() else X_read(n, 64);
    mask : bits(64) = X_read(m, 64);
    let tag : bits(4) = AArch64_AllocationTagFromAddress(address);
    mask[UInt(tag)] = Bit(0b1);
    X_set(d, 64) = mask
}

val decode_gmi_aarch64_instrs_integer_tags_mcinserttagmask : (bits(5), bits(5), bits(5)) -> unit

function decode_gmi_aarch64_instrs_integer_tags_mcinserttagmask (Xd, Xn, Xm) = {
    if not_bool(HaveMTEExt()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Xd);
    let 'n = UInt(Xn);
    let 'm = UInt(Xm);
    execute_aarch64_instrs_integer_tags_mcinserttagmask(d, m, n)
}

function clause __DecodeA64_DataProcReg ((pc, ([bitone, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, bitzero, bitzero, bitzero, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 477) = {
    SEE = 477;
    let Xd = Slice(__opcode, 0, 5);
    let Xn = Slice(__opcode, 5, 5);
    let Xm = Slice(__opcode, 16, 5);
    decode_gmi_aarch64_instrs_integer_tags_mcinserttagmask(Xd, Xn, Xm)
}

val execute_aarch64_instrs_system_exceptions_debug_halt : unit -> unit

function execute_aarch64_instrs_system_exceptions_debug_halt () = {
    let is_async : bool = false;
    Halt__1(DebugHalt_HaltInstruction, is_async)
}

val decode_hlt_aarch64_instrs_system_exceptions_debug_halt : bits(16) -> unit

function decode_hlt_aarch64_instrs_system_exceptions_debug_halt imm16 = {
    if EDSCR_read()[HDE] == 0b0 | not_bool(HaltingAllowed()) then {
        throw(Error_Undefined())
    };
    if HaveBTIExt() then {
        SetBTypeCompatible(true)
    };
    execute_aarch64_instrs_system_exceptions_debug_halt()
}

function clause __DecodeA64_BranchExcSys ((pc, ([bitone, bitone, bitzero, bitone, bitzero, bitone, bitzero, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, bitzero, bitzero, bitzero, bitzero, bitzero] as __opcode)) if SEE < 478) = {
    SEE = 478;
    let imm16 = Slice(__opcode, 5, 16);
    decode_hlt_aarch64_instrs_system_exceptions_debug_halt(imm16)
}

val execute_aarch64_instrs_system_exceptions_runtime_hvc : bits(16) -> unit

function execute_aarch64_instrs_system_exceptions_runtime_hvc imm = {
    if (not_bool(HaveEL(EL2)) | PSTATE.EL == EL0) | PSTATE.EL == EL1 & not_bool(EL2Enabled()) then {
        throw(Error_Undefined())
    };
    let hvc_enable : bits(1) = if HaveEL(EL3) then SCR_EL3[HCE] else
      not_vec(HCR_EL2[HCD]);
    if hvc_enable == 0b0 then {
        throw(Error_Undefined())
    } else {
        AArch64_CallHypervisor(imm)
    }
}

val decode_hvc_aarch64_instrs_system_exceptions_runtime_hvc : bits(16) -> unit

function decode_hvc_aarch64_instrs_system_exceptions_runtime_hvc imm16 = {
    let imm : bits(16) = imm16;
    execute_aarch64_instrs_system_exceptions_runtime_hvc(imm)
}

function clause __DecodeA64_BranchExcSys ((pc, ([bitone, bitone, bitzero, bitone, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, bitzero, bitzero, bitzero, bitone, bitzero] as __opcode)) if SEE < 479) = {
    SEE = 479;
    let imm16 = Slice(__opcode, 5, 16);
    decode_hvc_aarch64_instrs_system_exceptions_runtime_hvc(imm16)
}

val execute_aarch64_instrs_vector_transfer_vector_insert : forall 'd 'dst_index 'esize 'idxdsize 'n 'src_index,
  (0 <= 'n & 'n <= 31 & 'idxdsize in {64, 128} & 'esize in {8, 16, 32, 64, 128, 256} & 0 <= 'd & 'd <= 31).
  (int('d), int('dst_index), int('esize), int('idxdsize), int('n), int('src_index)) -> unit

function execute_aarch64_instrs_vector_transfer_vector_insert (d, dst_index, esize, idxdsize, n, src_index) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('idxdsize) = V_read(n, idxdsize);
    result : bits(128) = V_read(d, 128);
    result = Elem_set(result, dst_index, esize, Elem_read(operand, src_index, esize));
    V_set(d, 128) = result
}

val decode_ins_advsimd_elt_aarch64_instrs_vector_transfer_vector_insert : (bits(5), bits(5), bits(4), bits(5)) -> unit

function decode_ins_advsimd_elt_aarch64_instrs_vector_transfer_vector_insert (Rd, Rn, imm4, imm5) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'size = LowestSetBit(imm5);
    if size > 3 then {
        throw(Error_Undefined())
    };
    assert(constraint(0 <= 'size + 1));
    let 'dst_index = UInt(imm5[4 .. size + 1]);
    assert(constraint(0 <= 'size));
    let 'src_index = UInt(imm4[3 .. size]);
    let 'idxdsize = if [imm4[3]] == 0b1 then 128 else 64;
    let 'esize = (8 << size);
    match esize {
      8 => {
          match idxdsize {
            64 => {
                execute_aarch64_instrs_vector_transfer_vector_insert(d, dst_index, 8, 64, n, src_index)
            },
            128 => {
                execute_aarch64_instrs_vector_transfer_vector_insert(d, dst_index, 8, 128, n, src_index)
            },
            _ => {
                assert(false)
            }
          }
      },
      16 => {
          match idxdsize {
            64 => {
                execute_aarch64_instrs_vector_transfer_vector_insert(d, dst_index, 16, 64, n, src_index)
            },
            128 => {
                execute_aarch64_instrs_vector_transfer_vector_insert(d, dst_index, 16, 128, n, src_index)
            },
            _ => {
                assert(false)
            }
          }
      },
      32 => {
          match idxdsize {
            64 => {
                execute_aarch64_instrs_vector_transfer_vector_insert(d, dst_index, 32, 64, n, src_index)
            },
            128 => {
                execute_aarch64_instrs_vector_transfer_vector_insert(d, dst_index, 32, 128, n, src_index)
            },
            _ => {
                assert(false)
            }
          }
      },
      64 => {
          match idxdsize {
            64 => {
                execute_aarch64_instrs_vector_transfer_vector_insert(d, dst_index, 64, 64, n, src_index)
            },
            128 => {
                execute_aarch64_instrs_vector_transfer_vector_insert(d, dst_index, 64, 128, n, src_index)
            },
            _ => {
                assert(false)
            }
          }
      },
      128 => {
          match idxdsize {
            64 => {
                execute_aarch64_instrs_vector_transfer_vector_insert(d, dst_index, 128, 64, n, src_index)
            },
            128 => {
                execute_aarch64_instrs_vector_transfer_vector_insert(d, dst_index, 128, 128, n, src_index)
            },
            _ => {
                assert(false)
            }
          }
      },
      256 => {
          match idxdsize {
            64 => {
                execute_aarch64_instrs_vector_transfer_vector_insert(d, dst_index, 256, 64, n, src_index)
            },
            128 => {
                execute_aarch64_instrs_vector_transfer_vector_insert(d, dst_index, 256, 128, n, src_index)
            },
            _ => {
                assert(false)
            }
          }
      },
      _ => {
          assert(false)
      }
    }
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitone, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, bitzero, _, _, _, _, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 480) = {
    SEE = 480;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm4 = Slice(__opcode, 11, 4);
    let imm5 = Slice(__opcode, 16, 5);
    decode_ins_advsimd_elt_aarch64_instrs_vector_transfer_vector_insert(Rd, Rn, imm4, imm5)
}

val execute_aarch64_instrs_vector_transfer_integer_insert : forall 'd 'datasize 'esize 'index 'n,
  (0 <= 'n & 'n <= 31 & 'esize in {8, 16, 32, 64, 128, 256} & 'datasize == 128 & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('esize), int('index), int('n)) -> unit

function execute_aarch64_instrs_vector_transfer_integer_insert (d, datasize, esize, index, n) = {
    CheckFPAdvSIMDEnabled64();
    assert(constraint('esize in {8, 16, 32, 64}));
    let element : bits('esize) = X_read(n, esize);
    result : bits('datasize) = V_read(d, datasize);
    result = Elem_set(result, index, esize, element);
    V_set(d, datasize) = result
}

val decode_ins_advsimd_gen_aarch64_instrs_vector_transfer_integer_insert : (bits(5), bits(5), bits(5)) -> unit

function decode_ins_advsimd_gen_aarch64_instrs_vector_transfer_integer_insert (Rd, Rn, imm5) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'size = LowestSetBit(imm5);
    if size > 3 then {
        throw(Error_Undefined())
    };
    assert(constraint(0 <= 'size + 1));
    let 'index = UInt(imm5[4 .. size + 1]);
    let 'esize = (8 << size);
    let 'datasize = 128;
    assert(constraint('esize in {8, 16, 32, 64, 128, 256}));
    execute_aarch64_instrs_vector_transfer_integer_insert(d, datasize, esize, index, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, bitzero, bitzero, bitzero, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 481) = {
    SEE = 481;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm5 = Slice(__opcode, 16, 5);
    decode_ins_advsimd_gen_aarch64_instrs_vector_transfer_integer_insert(Rd, Rn, imm5)
}

val execute_aarch64_instrs_integer_tags_mcinsertrandomtag : forall 'd 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 0 <= 'd & 'd <= 31).
  (int('d), int('m), int('n)) -> unit

function execute_aarch64_instrs_integer_tags_mcinsertrandomtag (d, m, n) = {
    let operand : bits(64) = if n == 31 then SP_read() else X_read(n, 64);
    let exclude_reg : bits(64) = X_read(m, 64);
    let exclude : bits(16) = exclude_reg[15 .. 0] | GCR_EL1[Exclude];
    rtag : bits(4) = undefined;
    if AArch64_AllocationTagAccessIsEnabled(PSTATE.EL) then {
        if GCR_EL1[RRND] == 0b1 then {
            if IsOnes(exclude) then {
                rtag = 0b0000
            } else {
                rtag = ChooseRandomNonExcludedTag(exclude)
            }
        } else {
            let start_tag : bits(4) = RGSR_EL1[TAG];
            let offset : bits(4) = AArch64_RandomTag();
            rtag = AArch64_ChooseNonExcludedTag(start_tag, offset, exclude);
            RGSR_EL1[TAG] = rtag
        }
    } else {
        rtag = 0b0000
    };
    let result : bits(64) = AArch64_AddressWithAllocationTag(operand, rtag);
    if d == 31 then {
        SP_set() = result
    } else {
        X_set(d, 64) = result
    }
}

val decode_irg_aarch64_instrs_integer_tags_mcinsertrandomtag : (bits(5), bits(5), bits(5)) -> unit

function decode_irg_aarch64_instrs_integer_tags_mcinsertrandomtag (Xd, Xn, Xm) = {
    if not_bool(HaveMTEExt()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Xd);
    let 'n = UInt(Xn);
    let 'm = UInt(Xm);
    execute_aarch64_instrs_integer_tags_mcinsertrandomtag(d, m, n)
}

function clause __DecodeA64_DataProcReg ((pc, ([bitone, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 482) = {
    SEE = 482;
    let Xd = Slice(__opcode, 0, 5);
    let Xn = Slice(__opcode, 5, 5);
    let Xm = Slice(__opcode, 16, 5);
    decode_irg_aarch64_instrs_integer_tags_mcinsertrandomtag(Xd, Xn, Xm)
}

val execute_aarch64_instrs_system_barriers_isb : unit -> unit

function execute_aarch64_instrs_system_barriers_isb () = {
    InstructionSynchronizationBarrier();
    if HaveBRBExt() & BRBEBranchOnISB() then {
        BRBEISB()
    };
    if HaveStatisticalProfiling() then {
        SPEISB()
    };
    ()
}

val decode_isb_aarch64_instrs_system_barriers_isb : (bits(2), bits(4)) -> unit

function decode_isb_aarch64_instrs_system_barriers_isb (opc, CRm) = {
    execute_aarch64_instrs_system_barriers_isb()
}

function clause __DecodeA64_BranchExcSys ((pc, ([bitone, bitone, bitzero, bitone, bitzero, bitone, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitone, bitone, _, _, _, _, bitone, bitone, bitzero, bitone, bitone, bitone, bitone, bitone] as __opcode)) if SEE < 483) = {
    SEE = 483;
    let opc = Slice(__opcode, 5, 2);
    let CRm = Slice(__opcode, 8, 4);
    decode_isb_aarch64_instrs_system_barriers_isb(opc, CRm)
}

val execute_aarch64_instrs_memory_vector_single_no_wb : forall 'datasize 'esize 'index 'm 'n ('nontemporal : Bool) ('replicate : Bool) 'selem 't ('tagchecked : Bool) ('wback : Bool),
  (0 <= 't & 't <= 31 & 'selem in {1, 2, 3, 4} & 0 <= 'n & 'n <= 31 & 'esize in {8, 16, 32, 64} & 'datasize in {64, 128}).
  (int('datasize), int('esize), int('index), int('m), MemOp, int('n), bool('nontemporal), bool('replicate), int('selem), int('t), bool('tagchecked), bool('wback)) -> unit

function execute_aarch64_instrs_memory_vector_single_no_wb (datasize, esize, index, m, memop, n, nontemporal, replicate, selem, t__arg, tagchecked, wback) = {
    t : int = t__arg;
    CheckFPAdvSIMDEnabled64();
    address : bits(64) = undefined;
    rval : bits(128) = undefined;
    element : bits('esize) = undefined;
    let 'ebytes = DIV(esize, 8);
    let accdesc : AccessDescriptor = CreateAccDescASIMD(memop, nontemporal, tagchecked);
    if n == 31 then {
        CheckSPAlignment();
        address = SP_read()
    } else {
        address = X_read(n, 64)
    };
    offs : bits(64) = Zeros(64);
    if replicate then {
        foreach (s from 0 to (selem - 1) by 1 in inc) {
            element = Mem_read(address + offs, ebytes, accdesc);
            V_set(t, datasize) = Replicate(element, DIV(datasize, esize));
            offs = offs + ebytes;
            t = MOD(t + 1, 32)
        }
    } else {
        foreach (s from 0 to (selem - 1) by 1 in inc) {
            rval = V_read(t, 128);
            if memop == MemOp_LOAD then {
                rval = Elem_set(rval, index, esize, Mem_read(address + offs, ebytes, accdesc));
                V_set(t, 128) = rval
            } else {
                Mem_set(address + offs, ebytes, accdesc) = Elem_read(rval, index, esize)
            };
            offs = offs + ebytes;
            t = MOD(t + 1, 32)
        }
    };
    if SPESampleInFlight then {
        SPESampleSIMDFPLoadStore()
    };
    if wback then {
        if m != 31 then {
            offs = X_read(m, 64)
        };
        if n == 31 then {
            SP_set() = address + offs
        } else {
            X_set(n, 64) = address + offs
        }
    };
    ()
}

val decode_ld1_advsimd_sngl_aarch64_instrs_memory_vector_single_no_wb : (bits(5), bits(5), bits(2), bits(1), bits(3), bits(1), bits(1), bits(1), bits(1)) -> unit

function decode_ld1_advsimd_sngl_aarch64_instrs_memory_vector_single_no_wb (Rt, Rn, size, S, opcode, o2, R, L, Q) = {
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 'm = __UNKNOWN_integer();
    let wback : bool = false;
    let nontemporal : bool = false;
    let tagchecked : bool = wback | n != 31;
    let 'init_scale = UInt(opcode[2 .. 1]);
    scale : int = init_scale;
    let 'selem = UInt([opcode[0]] @ R) + 1;
    replicate : bool = false;
    index : int = undefined;
    match scale {
      3 => {
          if L == 0b0 | S == 0b1 then {
              throw(Error_Undefined())
          };
          scale = UInt(size);
          replicate = true
      },
      0 => {
          index = UInt((Q @ S) @ size)
      },
      1 => {
          if [size[0]] == 0b1 then {
              throw(Error_Undefined())
          };
          index = UInt((Q @ S) @ [size[1]])
      },
      2 => {
          if [size[1]] == 0b1 then {
              throw(Error_Undefined())
          };
          if [size[0]] == 0b0 then {
              index = UInt(Q @ S)
          } else {
              if S == 0b1 then {
                  throw(Error_Undefined())
              };
              index = UInt(Q);
              scale = 3
          }
      },
      _ => ()
    };
    let 'scale = scale;
    let 'index = index;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'esize = (8 << scale);
    assert(constraint('esize in {8, 16, 32, 64}));
    execute_aarch64_instrs_memory_vector_single_no_wb(datasize, esize, index, m, memop, n, nontemporal, replicate, selem, t, tagchecked, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 484) = {
    SEE = 484;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 10, 2);
    let S = Slice(__opcode, 12, 1);
    let opcode = Slice(__opcode, 13, 3);
    let o2 = Slice(__opcode, 16, 1);
    let R = Slice(__opcode, 21, 1);
    let L = Slice(__opcode, 22, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_ld1_advsimd_sngl_aarch64_instrs_memory_vector_single_no_wb(Rt, Rn, size, S, opcode, o2, R, L, Q)
}

val decode_ld1_advsimd_sngl_aarch64_instrs_memory_vector_single_post_inc : (bits(5), bits(5), bits(2), bits(1), bits(3), bits(5), bits(1), bits(1), bits(1)) -> unit

function decode_ld1_advsimd_sngl_aarch64_instrs_memory_vector_single_post_inc (Rt, Rn, size, S, opcode, Rm, R, L, Q) = {
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let wback : bool = true;
    let nontemporal : bool = false;
    let tagchecked : bool = wback | n != 31;
    let 'init_scale = UInt(opcode[2 .. 1]);
    scale : int = init_scale;
    let 'selem = UInt([opcode[0]] @ R) + 1;
    replicate : bool = false;
    index : int = undefined;
    match scale {
      3 => {
          if L == 0b0 | S == 0b1 then {
              throw(Error_Undefined())
          };
          scale = UInt(size);
          replicate = true
      },
      0 => {
          index = UInt((Q @ S) @ size)
      },
      1 => {
          if [size[0]] == 0b1 then {
              throw(Error_Undefined())
          };
          index = UInt((Q @ S) @ [size[1]])
      },
      2 => {
          if [size[1]] == 0b1 then {
              throw(Error_Undefined())
          };
          if [size[0]] == 0b0 then {
              index = UInt(Q @ S)
          } else {
              if S == 0b1 then {
                  throw(Error_Undefined())
              };
              index = UInt(Q);
              scale = 3
          }
      },
      _ => ()
    };
    let 'scale = scale;
    let 'index = index;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'esize = (8 << scale);
    assert(constraint('esize in {8, 16, 32, 64}));
    execute_aarch64_instrs_memory_vector_single_no_wb(datasize, esize, index, m, memop, n, nontemporal, replicate, selem, t, tagchecked, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 485) = {
    SEE = 485;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 10, 2);
    let S = Slice(__opcode, 12, 1);
    let opcode = Slice(__opcode, 13, 3);
    let Rm = Slice(__opcode, 16, 5);
    let R = Slice(__opcode, 21, 1);
    let L = Slice(__opcode, 22, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_ld1_advsimd_sngl_aarch64_instrs_memory_vector_single_post_inc(Rt, Rn, size, S, opcode, Rm, R, L, Q)
}

val decode_ld1r_advsimd_aarch64_instrs_memory_vector_single_no_wb : (bits(5), bits(5), bits(2), bits(1), bits(3), bits(1), bits(1), bits(1), bits(1)) -> unit

function decode_ld1r_advsimd_aarch64_instrs_memory_vector_single_no_wb (Rt, Rn, size, S, opcode, o2, R, L, Q) = {
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 'm = __UNKNOWN_integer();
    let wback : bool = false;
    let nontemporal : bool = false;
    let tagchecked : bool = wback | n != 31;
    let 'init_scale = UInt(opcode[2 .. 1]);
    scale : int = init_scale;
    let 'selem = UInt([opcode[0]] @ R) + 1;
    replicate : bool = false;
    index : int = undefined;
    match scale {
      3 => {
          if L == 0b0 | S == 0b1 then {
              throw(Error_Undefined())
          };
          scale = UInt(size);
          replicate = true
      },
      0 => {
          index = UInt((Q @ S) @ size)
      },
      1 => {
          if [size[0]] == 0b1 then {
              throw(Error_Undefined())
          };
          index = UInt((Q @ S) @ [size[1]])
      },
      2 => {
          if [size[1]] == 0b1 then {
              throw(Error_Undefined())
          };
          if [size[0]] == 0b0 then {
              index = UInt(Q @ S)
          } else {
              if S == 0b1 then {
                  throw(Error_Undefined())
              };
              index = UInt(Q);
              scale = 3
          }
      },
      _ => ()
    };
    let 'scale = scale;
    let 'index = index;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'esize = (8 << scale);
    assert(constraint('esize in {8, 16, 32, 64}));
    execute_aarch64_instrs_memory_vector_single_no_wb(datasize, esize, index, m, memop, n, nontemporal, replicate, selem, t, tagchecked, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 486) = {
    SEE = 486;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 10, 2);
    let S = Slice(__opcode, 12, 1);
    let opcode = Slice(__opcode, 13, 3);
    let o2 = Slice(__opcode, 16, 1);
    let R = Slice(__opcode, 21, 1);
    let L = Slice(__opcode, 22, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_ld1r_advsimd_aarch64_instrs_memory_vector_single_no_wb(Rt, Rn, size, S, opcode, o2, R, L, Q)
}

val decode_ld1r_advsimd_aarch64_instrs_memory_vector_single_post_inc : (bits(5), bits(5), bits(2), bits(1), bits(3), bits(5), bits(1), bits(1), bits(1)) -> unit

function decode_ld1r_advsimd_aarch64_instrs_memory_vector_single_post_inc (Rt, Rn, size, S, opcode, Rm, R, L, Q) = {
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let wback : bool = true;
    let nontemporal : bool = false;
    let tagchecked : bool = wback | n != 31;
    let 'init_scale = UInt(opcode[2 .. 1]);
    scale : int = init_scale;
    let 'selem = UInt([opcode[0]] @ R) + 1;
    replicate : bool = false;
    index : int = undefined;
    match scale {
      3 => {
          if L == 0b0 | S == 0b1 then {
              throw(Error_Undefined())
          };
          scale = UInt(size);
          replicate = true
      },
      0 => {
          index = UInt((Q @ S) @ size)
      },
      1 => {
          if [size[0]] == 0b1 then {
              throw(Error_Undefined())
          };
          index = UInt((Q @ S) @ [size[1]])
      },
      2 => {
          if [size[1]] == 0b1 then {
              throw(Error_Undefined())
          };
          if [size[0]] == 0b0 then {
              index = UInt(Q @ S)
          } else {
              if S == 0b1 then {
                  throw(Error_Undefined())
              };
              index = UInt(Q);
              scale = 3
          }
      },
      _ => ()
    };
    let 'scale = scale;
    let 'index = index;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'esize = (8 << scale);
    assert(constraint('esize in {8, 16, 32, 64}));
    execute_aarch64_instrs_memory_vector_single_no_wb(datasize, esize, index, m, memop, n, nontemporal, replicate, selem, t, tagchecked, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, _, _, _, bitone, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 487) = {
    SEE = 487;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 10, 2);
    let S = Slice(__opcode, 12, 1);
    let opcode = Slice(__opcode, 13, 3);
    let Rm = Slice(__opcode, 16, 5);
    let R = Slice(__opcode, 21, 1);
    let L = Slice(__opcode, 22, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_ld1r_advsimd_aarch64_instrs_memory_vector_single_post_inc(Rt, Rn, size, S, opcode, Rm, R, L, Q)
}

val decode_ld2_advsimd_sngl_aarch64_instrs_memory_vector_single_no_wb : (bits(5), bits(5), bits(2), bits(1), bits(3), bits(1), bits(1), bits(1), bits(1)) -> unit

function decode_ld2_advsimd_sngl_aarch64_instrs_memory_vector_single_no_wb (Rt, Rn, size, S, opcode, o2, R, L, Q) = {
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 'm = __UNKNOWN_integer();
    let wback : bool = false;
    let nontemporal : bool = false;
    let tagchecked : bool = wback | n != 31;
    let 'init_scale = UInt(opcode[2 .. 1]);
    scale : int = init_scale;
    let 'selem = UInt([opcode[0]] @ R) + 1;
    replicate : bool = false;
    index : int = undefined;
    match scale {
      3 => {
          if L == 0b0 | S == 0b1 then {
              throw(Error_Undefined())
          };
          scale = UInt(size);
          replicate = true
      },
      0 => {
          index = UInt((Q @ S) @ size)
      },
      1 => {
          if [size[0]] == 0b1 then {
              throw(Error_Undefined())
          };
          index = UInt((Q @ S) @ [size[1]])
      },
      2 => {
          if [size[1]] == 0b1 then {
              throw(Error_Undefined())
          };
          if [size[0]] == 0b0 then {
              index = UInt(Q @ S)
          } else {
              if S == 0b1 then {
                  throw(Error_Undefined())
              };
              index = UInt(Q);
              scale = 3
          }
      },
      _ => ()
    };
    let 'scale = scale;
    let 'index = index;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'esize = (8 << scale);
    assert(constraint('esize in {8, 16, 32, 64}));
    execute_aarch64_instrs_memory_vector_single_no_wb(datasize, esize, index, m, memop, n, nontemporal, replicate, selem, t, tagchecked, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 488) = {
    SEE = 488;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 10, 2);
    let S = Slice(__opcode, 12, 1);
    let opcode = Slice(__opcode, 13, 3);
    let o2 = Slice(__opcode, 16, 1);
    let R = Slice(__opcode, 21, 1);
    let L = Slice(__opcode, 22, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_ld2_advsimd_sngl_aarch64_instrs_memory_vector_single_no_wb(Rt, Rn, size, S, opcode, o2, R, L, Q)
}

val decode_ld2_advsimd_sngl_aarch64_instrs_memory_vector_single_post_inc : (bits(5), bits(5), bits(2), bits(1), bits(3), bits(5), bits(1), bits(1), bits(1)) -> unit

function decode_ld2_advsimd_sngl_aarch64_instrs_memory_vector_single_post_inc (Rt, Rn, size, S, opcode, Rm, R, L, Q) = {
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let wback : bool = true;
    let nontemporal : bool = false;
    let tagchecked : bool = wback | n != 31;
    let 'init_scale = UInt(opcode[2 .. 1]);
    scale : int = init_scale;
    let 'selem = UInt([opcode[0]] @ R) + 1;
    replicate : bool = false;
    index : int = undefined;
    match scale {
      3 => {
          if L == 0b0 | S == 0b1 then {
              throw(Error_Undefined())
          };
          scale = UInt(size);
          replicate = true
      },
      0 => {
          index = UInt((Q @ S) @ size)
      },
      1 => {
          if [size[0]] == 0b1 then {
              throw(Error_Undefined())
          };
          index = UInt((Q @ S) @ [size[1]])
      },
      2 => {
          if [size[1]] == 0b1 then {
              throw(Error_Undefined())
          };
          if [size[0]] == 0b0 then {
              index = UInt(Q @ S)
          } else {
              if S == 0b1 then {
                  throw(Error_Undefined())
              };
              index = UInt(Q);
              scale = 3
          }
      },
      _ => ()
    };
    let 'scale = scale;
    let 'index = index;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'esize = (8 << scale);
    assert(constraint('esize in {8, 16, 32, 64}));
    execute_aarch64_instrs_memory_vector_single_no_wb(datasize, esize, index, m, memop, n, nontemporal, replicate, selem, t, tagchecked, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 489) = {
    SEE = 489;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 10, 2);
    let S = Slice(__opcode, 12, 1);
    let opcode = Slice(__opcode, 13, 3);
    let Rm = Slice(__opcode, 16, 5);
    let R = Slice(__opcode, 21, 1);
    let L = Slice(__opcode, 22, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_ld2_advsimd_sngl_aarch64_instrs_memory_vector_single_post_inc(Rt, Rn, size, S, opcode, Rm, R, L, Q)
}

val decode_ld2r_advsimd_aarch64_instrs_memory_vector_single_no_wb : (bits(5), bits(5), bits(2), bits(1), bits(3), bits(1), bits(1), bits(1), bits(1)) -> unit

function decode_ld2r_advsimd_aarch64_instrs_memory_vector_single_no_wb (Rt, Rn, size, S, opcode, o2, R, L, Q) = {
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 'm = __UNKNOWN_integer();
    let wback : bool = false;
    let nontemporal : bool = false;
    let tagchecked : bool = wback | n != 31;
    let 'init_scale = UInt(opcode[2 .. 1]);
    scale : int = init_scale;
    let 'selem = UInt([opcode[0]] @ R) + 1;
    replicate : bool = false;
    index : int = undefined;
    match scale {
      3 => {
          if L == 0b0 | S == 0b1 then {
              throw(Error_Undefined())
          };
          scale = UInt(size);
          replicate = true
      },
      0 => {
          index = UInt((Q @ S) @ size)
      },
      1 => {
          if [size[0]] == 0b1 then {
              throw(Error_Undefined())
          };
          index = UInt((Q @ S) @ [size[1]])
      },
      2 => {
          if [size[1]] == 0b1 then {
              throw(Error_Undefined())
          };
          if [size[0]] == 0b0 then {
              index = UInt(Q @ S)
          } else {
              if S == 0b1 then {
                  throw(Error_Undefined())
              };
              index = UInt(Q);
              scale = 3
          }
      },
      _ => ()
    };
    let 'scale = scale;
    let 'index = index;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'esize = (8 << scale);
    assert(constraint('esize in {8, 16, 32, 64}));
    execute_aarch64_instrs_memory_vector_single_no_wb(datasize, esize, index, m, memop, n, nontemporal, replicate, selem, t, tagchecked, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 490) = {
    SEE = 490;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 10, 2);
    let S = Slice(__opcode, 12, 1);
    let opcode = Slice(__opcode, 13, 3);
    let o2 = Slice(__opcode, 16, 1);
    let R = Slice(__opcode, 21, 1);
    let L = Slice(__opcode, 22, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_ld2r_advsimd_aarch64_instrs_memory_vector_single_no_wb(Rt, Rn, size, S, opcode, o2, R, L, Q)
}

val decode_ld2r_advsimd_aarch64_instrs_memory_vector_single_post_inc : (bits(5), bits(5), bits(2), bits(1), bits(3), bits(5), bits(1), bits(1), bits(1)) -> unit

function decode_ld2r_advsimd_aarch64_instrs_memory_vector_single_post_inc (Rt, Rn, size, S, opcode, Rm, R, L, Q) = {
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let wback : bool = true;
    let nontemporal : bool = false;
    let tagchecked : bool = wback | n != 31;
    let 'init_scale = UInt(opcode[2 .. 1]);
    scale : int = init_scale;
    let 'selem = UInt([opcode[0]] @ R) + 1;
    replicate : bool = false;
    index : int = undefined;
    match scale {
      3 => {
          if L == 0b0 | S == 0b1 then {
              throw(Error_Undefined())
          };
          scale = UInt(size);
          replicate = true
      },
      0 => {
          index = UInt((Q @ S) @ size)
      },
      1 => {
          if [size[0]] == 0b1 then {
              throw(Error_Undefined())
          };
          index = UInt((Q @ S) @ [size[1]])
      },
      2 => {
          if [size[1]] == 0b1 then {
              throw(Error_Undefined())
          };
          if [size[0]] == 0b0 then {
              index = UInt(Q @ S)
          } else {
              if S == 0b1 then {
                  throw(Error_Undefined())
              };
              index = UInt(Q);
              scale = 3
          }
      },
      _ => ()
    };
    let 'scale = scale;
    let 'index = index;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'esize = (8 << scale);
    assert(constraint('esize in {8, 16, 32, 64}));
    execute_aarch64_instrs_memory_vector_single_no_wb(datasize, esize, index, m, memop, n, nontemporal, replicate, selem, t, tagchecked, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitone, bitone, bitone, _, _, _, _, _, bitone, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 491) = {
    SEE = 491;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 10, 2);
    let S = Slice(__opcode, 12, 1);
    let opcode = Slice(__opcode, 13, 3);
    let Rm = Slice(__opcode, 16, 5);
    let R = Slice(__opcode, 21, 1);
    let L = Slice(__opcode, 22, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_ld2r_advsimd_aarch64_instrs_memory_vector_single_post_inc(Rt, Rn, size, S, opcode, Rm, R, L, Q)
}

val decode_ld3_advsimd_sngl_aarch64_instrs_memory_vector_single_no_wb : (bits(5), bits(5), bits(2), bits(1), bits(3), bits(1), bits(1), bits(1), bits(1)) -> unit

function decode_ld3_advsimd_sngl_aarch64_instrs_memory_vector_single_no_wb (Rt, Rn, size, S, opcode, o2, R, L, Q) = {
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 'm = __UNKNOWN_integer();
    let wback : bool = false;
    let nontemporal : bool = false;
    let tagchecked : bool = wback | n != 31;
    let 'init_scale = UInt(opcode[2 .. 1]);
    scale : int = init_scale;
    let 'selem = UInt([opcode[0]] @ R) + 1;
    replicate : bool = false;
    index : int = undefined;
    match scale {
      3 => {
          if L == 0b0 | S == 0b1 then {
              throw(Error_Undefined())
          };
          scale = UInt(size);
          replicate = true
      },
      0 => {
          index = UInt((Q @ S) @ size)
      },
      1 => {
          if [size[0]] == 0b1 then {
              throw(Error_Undefined())
          };
          index = UInt((Q @ S) @ [size[1]])
      },
      2 => {
          if [size[1]] == 0b1 then {
              throw(Error_Undefined())
          };
          if [size[0]] == 0b0 then {
              index = UInt(Q @ S)
          } else {
              if S == 0b1 then {
                  throw(Error_Undefined())
              };
              index = UInt(Q);
              scale = 3
          }
      },
      _ => ()
    };
    let 'scale = scale;
    let 'index = index;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'esize = (8 << scale);
    assert(constraint('esize in {8, 16, 32, 64}));
    execute_aarch64_instrs_memory_vector_single_no_wb(datasize, esize, index, m, memop, n, nontemporal, replicate, selem, t, tagchecked, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 492) = {
    SEE = 492;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 10, 2);
    let S = Slice(__opcode, 12, 1);
    let opcode = Slice(__opcode, 13, 3);
    let o2 = Slice(__opcode, 16, 1);
    let R = Slice(__opcode, 21, 1);
    let L = Slice(__opcode, 22, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_ld3_advsimd_sngl_aarch64_instrs_memory_vector_single_no_wb(Rt, Rn, size, S, opcode, o2, R, L, Q)
}

val decode_ld3_advsimd_sngl_aarch64_instrs_memory_vector_single_post_inc : (bits(5), bits(5), bits(2), bits(1), bits(3), bits(5), bits(1), bits(1), bits(1)) -> unit

function decode_ld3_advsimd_sngl_aarch64_instrs_memory_vector_single_post_inc (Rt, Rn, size, S, opcode, Rm, R, L, Q) = {
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let wback : bool = true;
    let nontemporal : bool = false;
    let tagchecked : bool = wback | n != 31;
    let 'init_scale = UInt(opcode[2 .. 1]);
    scale : int = init_scale;
    let 'selem = UInt([opcode[0]] @ R) + 1;
    replicate : bool = false;
    index : int = undefined;
    match scale {
      3 => {
          if L == 0b0 | S == 0b1 then {
              throw(Error_Undefined())
          };
          scale = UInt(size);
          replicate = true
      },
      0 => {
          index = UInt((Q @ S) @ size)
      },
      1 => {
          if [size[0]] == 0b1 then {
              throw(Error_Undefined())
          };
          index = UInt((Q @ S) @ [size[1]])
      },
      2 => {
          if [size[1]] == 0b1 then {
              throw(Error_Undefined())
          };
          if [size[0]] == 0b0 then {
              index = UInt(Q @ S)
          } else {
              if S == 0b1 then {
                  throw(Error_Undefined())
              };
              index = UInt(Q);
              scale = 3
          }
      },
      _ => ()
    };
    let 'scale = scale;
    let 'index = index;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'esize = (8 << scale);
    assert(constraint('esize in {8, 16, 32, 64}));
    execute_aarch64_instrs_memory_vector_single_no_wb(datasize, esize, index, m, memop, n, nontemporal, replicate, selem, t, tagchecked, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 493) = {
    SEE = 493;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 10, 2);
    let S = Slice(__opcode, 12, 1);
    let opcode = Slice(__opcode, 13, 3);
    let Rm = Slice(__opcode, 16, 5);
    let R = Slice(__opcode, 21, 1);
    let L = Slice(__opcode, 22, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_ld3_advsimd_sngl_aarch64_instrs_memory_vector_single_post_inc(Rt, Rn, size, S, opcode, Rm, R, L, Q)
}

val decode_ld3r_advsimd_aarch64_instrs_memory_vector_single_no_wb : (bits(5), bits(5), bits(2), bits(1), bits(3), bits(1), bits(1), bits(1), bits(1)) -> unit

function decode_ld3r_advsimd_aarch64_instrs_memory_vector_single_no_wb (Rt, Rn, size, S, opcode, o2, R, L, Q) = {
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 'm = __UNKNOWN_integer();
    let wback : bool = false;
    let nontemporal : bool = false;
    let tagchecked : bool = wback | n != 31;
    let 'init_scale = UInt(opcode[2 .. 1]);
    scale : int = init_scale;
    let 'selem = UInt([opcode[0]] @ R) + 1;
    replicate : bool = false;
    index : int = undefined;
    match scale {
      3 => {
          if L == 0b0 | S == 0b1 then {
              throw(Error_Undefined())
          };
          scale = UInt(size);
          replicate = true
      },
      0 => {
          index = UInt((Q @ S) @ size)
      },
      1 => {
          if [size[0]] == 0b1 then {
              throw(Error_Undefined())
          };
          index = UInt((Q @ S) @ [size[1]])
      },
      2 => {
          if [size[1]] == 0b1 then {
              throw(Error_Undefined())
          };
          if [size[0]] == 0b0 then {
              index = UInt(Q @ S)
          } else {
              if S == 0b1 then {
                  throw(Error_Undefined())
              };
              index = UInt(Q);
              scale = 3
          }
      },
      _ => ()
    };
    let 'scale = scale;
    let 'index = index;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'esize = (8 << scale);
    assert(constraint('esize in {8, 16, 32, 64}));
    execute_aarch64_instrs_memory_vector_single_no_wb(datasize, esize, index, m, memop, n, nontemporal, replicate, selem, t, tagchecked, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 494) = {
    SEE = 494;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 10, 2);
    let S = Slice(__opcode, 12, 1);
    let opcode = Slice(__opcode, 13, 3);
    let o2 = Slice(__opcode, 16, 1);
    let R = Slice(__opcode, 21, 1);
    let L = Slice(__opcode, 22, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_ld3r_advsimd_aarch64_instrs_memory_vector_single_no_wb(Rt, Rn, size, S, opcode, o2, R, L, Q)
}

val decode_ld3r_advsimd_aarch64_instrs_memory_vector_single_post_inc : (bits(5), bits(5), bits(2), bits(1), bits(3), bits(5), bits(1), bits(1), bits(1)) -> unit

function decode_ld3r_advsimd_aarch64_instrs_memory_vector_single_post_inc (Rt, Rn, size, S, opcode, Rm, R, L, Q) = {
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let wback : bool = true;
    let nontemporal : bool = false;
    let tagchecked : bool = wback | n != 31;
    let 'init_scale = UInt(opcode[2 .. 1]);
    scale : int = init_scale;
    let 'selem = UInt([opcode[0]] @ R) + 1;
    replicate : bool = false;
    index : int = undefined;
    match scale {
      3 => {
          if L == 0b0 | S == 0b1 then {
              throw(Error_Undefined())
          };
          scale = UInt(size);
          replicate = true
      },
      0 => {
          index = UInt((Q @ S) @ size)
      },
      1 => {
          if [size[0]] == 0b1 then {
              throw(Error_Undefined())
          };
          index = UInt((Q @ S) @ [size[1]])
      },
      2 => {
          if [size[1]] == 0b1 then {
              throw(Error_Undefined())
          };
          if [size[0]] == 0b0 then {
              index = UInt(Q @ S)
          } else {
              if S == 0b1 then {
                  throw(Error_Undefined())
              };
              index = UInt(Q);
              scale = 3
          }
      },
      _ => ()
    };
    let 'scale = scale;
    let 'index = index;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'esize = (8 << scale);
    assert(constraint('esize in {8, 16, 32, 64}));
    execute_aarch64_instrs_memory_vector_single_no_wb(datasize, esize, index, m, memop, n, nontemporal, replicate, selem, t, tagchecked, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, _, _, _, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 495) = {
    SEE = 495;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 10, 2);
    let S = Slice(__opcode, 12, 1);
    let opcode = Slice(__opcode, 13, 3);
    let Rm = Slice(__opcode, 16, 5);
    let R = Slice(__opcode, 21, 1);
    let L = Slice(__opcode, 22, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_ld3r_advsimd_aarch64_instrs_memory_vector_single_post_inc(Rt, Rn, size, S, opcode, Rm, R, L, Q)
}

val decode_ld4_advsimd_sngl_aarch64_instrs_memory_vector_single_no_wb : (bits(5), bits(5), bits(2), bits(1), bits(3), bits(1), bits(1), bits(1), bits(1)) -> unit

function decode_ld4_advsimd_sngl_aarch64_instrs_memory_vector_single_no_wb (Rt, Rn, size, S, opcode, o2, R, L, Q) = {
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 'm = __UNKNOWN_integer();
    let wback : bool = false;
    let nontemporal : bool = false;
    let tagchecked : bool = wback | n != 31;
    let 'init_scale = UInt(opcode[2 .. 1]);
    scale : int = init_scale;
    let 'selem = UInt([opcode[0]] @ R) + 1;
    replicate : bool = false;
    index : int = undefined;
    match scale {
      3 => {
          if L == 0b0 | S == 0b1 then {
              throw(Error_Undefined())
          };
          scale = UInt(size);
          replicate = true
      },
      0 => {
          index = UInt((Q @ S) @ size)
      },
      1 => {
          if [size[0]] == 0b1 then {
              throw(Error_Undefined())
          };
          index = UInt((Q @ S) @ [size[1]])
      },
      2 => {
          if [size[1]] == 0b1 then {
              throw(Error_Undefined())
          };
          if [size[0]] == 0b0 then {
              index = UInt(Q @ S)
          } else {
              if S == 0b1 then {
                  throw(Error_Undefined())
              };
              index = UInt(Q);
              scale = 3
          }
      },
      _ => ()
    };
    let 'scale = scale;
    let 'index = index;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'esize = (8 << scale);
    assert(constraint('esize in {8, 16, 32, 64}));
    execute_aarch64_instrs_memory_vector_single_no_wb(datasize, esize, index, m, memop, n, nontemporal, replicate, selem, t, tagchecked, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 496) = {
    SEE = 496;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 10, 2);
    let S = Slice(__opcode, 12, 1);
    let opcode = Slice(__opcode, 13, 3);
    let o2 = Slice(__opcode, 16, 1);
    let R = Slice(__opcode, 21, 1);
    let L = Slice(__opcode, 22, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_ld4_advsimd_sngl_aarch64_instrs_memory_vector_single_no_wb(Rt, Rn, size, S, opcode, o2, R, L, Q)
}

val decode_ld4_advsimd_sngl_aarch64_instrs_memory_vector_single_post_inc : (bits(5), bits(5), bits(2), bits(1), bits(3), bits(5), bits(1), bits(1), bits(1)) -> unit

function decode_ld4_advsimd_sngl_aarch64_instrs_memory_vector_single_post_inc (Rt, Rn, size, S, opcode, Rm, R, L, Q) = {
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let wback : bool = true;
    let nontemporal : bool = false;
    let tagchecked : bool = wback | n != 31;
    let 'init_scale = UInt(opcode[2 .. 1]);
    scale : int = init_scale;
    let 'selem = UInt([opcode[0]] @ R) + 1;
    replicate : bool = false;
    index : int = undefined;
    match scale {
      3 => {
          if L == 0b0 | S == 0b1 then {
              throw(Error_Undefined())
          };
          scale = UInt(size);
          replicate = true
      },
      0 => {
          index = UInt((Q @ S) @ size)
      },
      1 => {
          if [size[0]] == 0b1 then {
              throw(Error_Undefined())
          };
          index = UInt((Q @ S) @ [size[1]])
      },
      2 => {
          if [size[1]] == 0b1 then {
              throw(Error_Undefined())
          };
          if [size[0]] == 0b0 then {
              index = UInt(Q @ S)
          } else {
              if S == 0b1 then {
                  throw(Error_Undefined())
              };
              index = UInt(Q);
              scale = 3
          }
      },
      _ => ()
    };
    let 'scale = scale;
    let 'index = index;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'esize = (8 << scale);
    assert(constraint('esize in {8, 16, 32, 64}));
    execute_aarch64_instrs_memory_vector_single_no_wb(datasize, esize, index, m, memop, n, nontemporal, replicate, selem, t, tagchecked, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 497) = {
    SEE = 497;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 10, 2);
    let S = Slice(__opcode, 12, 1);
    let opcode = Slice(__opcode, 13, 3);
    let Rm = Slice(__opcode, 16, 5);
    let R = Slice(__opcode, 21, 1);
    let L = Slice(__opcode, 22, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_ld4_advsimd_sngl_aarch64_instrs_memory_vector_single_post_inc(Rt, Rn, size, S, opcode, Rm, R, L, Q)
}

val decode_ld4r_advsimd_aarch64_instrs_memory_vector_single_no_wb : (bits(5), bits(5), bits(2), bits(1), bits(3), bits(1), bits(1), bits(1), bits(1)) -> unit

function decode_ld4r_advsimd_aarch64_instrs_memory_vector_single_no_wb (Rt, Rn, size, S, opcode, o2, R, L, Q) = {
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 'm = __UNKNOWN_integer();
    let wback : bool = false;
    let nontemporal : bool = false;
    let tagchecked : bool = wback | n != 31;
    let 'init_scale = UInt(opcode[2 .. 1]);
    scale : int = init_scale;
    let 'selem = UInt([opcode[0]] @ R) + 1;
    replicate : bool = false;
    index : int = undefined;
    match scale {
      3 => {
          if L == 0b0 | S == 0b1 then {
              throw(Error_Undefined())
          };
          scale = UInt(size);
          replicate = true
      },
      0 => {
          index = UInt((Q @ S) @ size)
      },
      1 => {
          if [size[0]] == 0b1 then {
              throw(Error_Undefined())
          };
          index = UInt((Q @ S) @ [size[1]])
      },
      2 => {
          if [size[1]] == 0b1 then {
              throw(Error_Undefined())
          };
          if [size[0]] == 0b0 then {
              index = UInt(Q @ S)
          } else {
              if S == 0b1 then {
                  throw(Error_Undefined())
              };
              index = UInt(Q);
              scale = 3
          }
      },
      _ => ()
    };
    let 'scale = scale;
    let 'index = index;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'esize = (8 << scale);
    assert(constraint('esize in {8, 16, 32, 64}));
    execute_aarch64_instrs_memory_vector_single_no_wb(datasize, esize, index, m, memop, n, nontemporal, replicate, selem, t, tagchecked, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 498) = {
    SEE = 498;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 10, 2);
    let S = Slice(__opcode, 12, 1);
    let opcode = Slice(__opcode, 13, 3);
    let o2 = Slice(__opcode, 16, 1);
    let R = Slice(__opcode, 21, 1);
    let L = Slice(__opcode, 22, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_ld4r_advsimd_aarch64_instrs_memory_vector_single_no_wb(Rt, Rn, size, S, opcode, o2, R, L, Q)
}

val decode_ld4r_advsimd_aarch64_instrs_memory_vector_single_post_inc : (bits(5), bits(5), bits(2), bits(1), bits(3), bits(5), bits(1), bits(1), bits(1)) -> unit

function decode_ld4r_advsimd_aarch64_instrs_memory_vector_single_post_inc (Rt, Rn, size, S, opcode, Rm, R, L, Q) = {
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let wback : bool = true;
    let nontemporal : bool = false;
    let tagchecked : bool = wback | n != 31;
    let 'init_scale = UInt(opcode[2 .. 1]);
    scale : int = init_scale;
    let 'selem = UInt([opcode[0]] @ R) + 1;
    replicate : bool = false;
    index : int = undefined;
    match scale {
      3 => {
          if L == 0b0 | S == 0b1 then {
              throw(Error_Undefined())
          };
          scale = UInt(size);
          replicate = true
      },
      0 => {
          index = UInt((Q @ S) @ size)
      },
      1 => {
          if [size[0]] == 0b1 then {
              throw(Error_Undefined())
          };
          index = UInt((Q @ S) @ [size[1]])
      },
      2 => {
          if [size[1]] == 0b1 then {
              throw(Error_Undefined())
          };
          if [size[0]] == 0b0 then {
              index = UInt(Q @ S)
          } else {
              if S == 0b1 then {
                  throw(Error_Undefined())
              };
              index = UInt(Q);
              scale = 3
          }
      },
      _ => ()
    };
    let 'scale = scale;
    let 'index = index;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'esize = (8 << scale);
    assert(constraint('esize in {8, 16, 32, 64}));
    execute_aarch64_instrs_memory_vector_single_no_wb(datasize, esize, index, m, memop, n, nontemporal, replicate, selem, t, tagchecked, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitone, bitone, bitone, _, _, _, _, _, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 499) = {
    SEE = 499;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 10, 2);
    let S = Slice(__opcode, 12, 1);
    let opcode = Slice(__opcode, 13, 3);
    let Rm = Slice(__opcode, 16, 5);
    let R = Slice(__opcode, 21, 1);
    let L = Slice(__opcode, 22, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_ld4r_advsimd_aarch64_instrs_memory_vector_single_post_inc(Rt, Rn, size, S, opcode, Rm, R, L, Q)
}

val decode_st1_advsimd_sngl_aarch64_instrs_memory_vector_single_no_wb : (bits(5), bits(5), bits(2), bits(1), bits(3), bits(1), bits(1), bits(1), bits(1)) -> unit

function decode_st1_advsimd_sngl_aarch64_instrs_memory_vector_single_no_wb (Rt, Rn, size, S, opcode, o2, R, L, Q) = {
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 'm = __UNKNOWN_integer();
    let wback : bool = false;
    let nontemporal : bool = false;
    let tagchecked : bool = wback | n != 31;
    let 'init_scale = UInt(opcode[2 .. 1]);
    scale : int = init_scale;
    let 'selem = UInt([opcode[0]] @ R) + 1;
    replicate : bool = false;
    index : int = undefined;
    match scale {
      3 => {
          if L == 0b0 | S == 0b1 then {
              throw(Error_Undefined())
          };
          scale = UInt(size);
          replicate = true
      },
      0 => {
          index = UInt((Q @ S) @ size)
      },
      1 => {
          if [size[0]] == 0b1 then {
              throw(Error_Undefined())
          };
          index = UInt((Q @ S) @ [size[1]])
      },
      2 => {
          if [size[1]] == 0b1 then {
              throw(Error_Undefined())
          };
          if [size[0]] == 0b0 then {
              index = UInt(Q @ S)
          } else {
              if S == 0b1 then {
                  throw(Error_Undefined())
              };
              index = UInt(Q);
              scale = 3
          }
      },
      _ => ()
    };
    let 'scale = scale;
    let 'index = index;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'esize = (8 << scale);
    assert(constraint('esize in {8, 16, 32, 64}));
    execute_aarch64_instrs_memory_vector_single_no_wb(datasize, esize, index, m, memop, n, nontemporal, replicate, selem, t, tagchecked, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 500) = {
    SEE = 500;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 10, 2);
    let S = Slice(__opcode, 12, 1);
    let opcode = Slice(__opcode, 13, 3);
    let o2 = Slice(__opcode, 16, 1);
    let R = Slice(__opcode, 21, 1);
    let L = Slice(__opcode, 22, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_st1_advsimd_sngl_aarch64_instrs_memory_vector_single_no_wb(Rt, Rn, size, S, opcode, o2, R, L, Q)
}

val decode_st1_advsimd_sngl_aarch64_instrs_memory_vector_single_post_inc : (bits(5), bits(5), bits(2), bits(1), bits(3), bits(5), bits(1), bits(1), bits(1)) -> unit

function decode_st1_advsimd_sngl_aarch64_instrs_memory_vector_single_post_inc (Rt, Rn, size, S, opcode, Rm, R, L, Q) = {
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let wback : bool = true;
    let nontemporal : bool = false;
    let tagchecked : bool = wback | n != 31;
    let 'init_scale = UInt(opcode[2 .. 1]);
    scale : int = init_scale;
    let 'selem = UInt([opcode[0]] @ R) + 1;
    replicate : bool = false;
    index : int = undefined;
    match scale {
      3 => {
          if L == 0b0 | S == 0b1 then {
              throw(Error_Undefined())
          };
          scale = UInt(size);
          replicate = true
      },
      0 => {
          index = UInt((Q @ S) @ size)
      },
      1 => {
          if [size[0]] == 0b1 then {
              throw(Error_Undefined())
          };
          index = UInt((Q @ S) @ [size[1]])
      },
      2 => {
          if [size[1]] == 0b1 then {
              throw(Error_Undefined())
          };
          if [size[0]] == 0b0 then {
              index = UInt(Q @ S)
          } else {
              if S == 0b1 then {
                  throw(Error_Undefined())
              };
              index = UInt(Q);
              scale = 3
          }
      },
      _ => ()
    };
    let 'scale = scale;
    let 'index = index;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'esize = (8 << scale);
    assert(constraint('esize in {8, 16, 32, 64}));
    execute_aarch64_instrs_memory_vector_single_no_wb(datasize, esize, index, m, memop, n, nontemporal, replicate, selem, t, tagchecked, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitone, bitzero, bitzero, _, _, _, _, _, _, _, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 501) = {
    SEE = 501;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 10, 2);
    let S = Slice(__opcode, 12, 1);
    let opcode = Slice(__opcode, 13, 3);
    let Rm = Slice(__opcode, 16, 5);
    let R = Slice(__opcode, 21, 1);
    let L = Slice(__opcode, 22, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_st1_advsimd_sngl_aarch64_instrs_memory_vector_single_post_inc(Rt, Rn, size, S, opcode, Rm, R, L, Q)
}

val decode_st2_advsimd_sngl_aarch64_instrs_memory_vector_single_no_wb : (bits(5), bits(5), bits(2), bits(1), bits(3), bits(1), bits(1), bits(1), bits(1)) -> unit

function decode_st2_advsimd_sngl_aarch64_instrs_memory_vector_single_no_wb (Rt, Rn, size, S, opcode, o2, R, L, Q) = {
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 'm = __UNKNOWN_integer();
    let wback : bool = false;
    let nontemporal : bool = false;
    let tagchecked : bool = wback | n != 31;
    let 'init_scale = UInt(opcode[2 .. 1]);
    scale : int = init_scale;
    let 'selem = UInt([opcode[0]] @ R) + 1;
    replicate : bool = false;
    index : int = undefined;
    match scale {
      3 => {
          if L == 0b0 | S == 0b1 then {
              throw(Error_Undefined())
          };
          scale = UInt(size);
          replicate = true
      },
      0 => {
          index = UInt((Q @ S) @ size)
      },
      1 => {
          if [size[0]] == 0b1 then {
              throw(Error_Undefined())
          };
          index = UInt((Q @ S) @ [size[1]])
      },
      2 => {
          if [size[1]] == 0b1 then {
              throw(Error_Undefined())
          };
          if [size[0]] == 0b0 then {
              index = UInt(Q @ S)
          } else {
              if S == 0b1 then {
                  throw(Error_Undefined())
              };
              index = UInt(Q);
              scale = 3
          }
      },
      _ => ()
    };
    let 'scale = scale;
    let 'index = index;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'esize = (8 << scale);
    assert(constraint('esize in {8, 16, 32, 64}));
    execute_aarch64_instrs_memory_vector_single_no_wb(datasize, esize, index, m, memop, n, nontemporal, replicate, selem, t, tagchecked, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 502) = {
    SEE = 502;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 10, 2);
    let S = Slice(__opcode, 12, 1);
    let opcode = Slice(__opcode, 13, 3);
    let o2 = Slice(__opcode, 16, 1);
    let R = Slice(__opcode, 21, 1);
    let L = Slice(__opcode, 22, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_st2_advsimd_sngl_aarch64_instrs_memory_vector_single_no_wb(Rt, Rn, size, S, opcode, o2, R, L, Q)
}

val decode_st2_advsimd_sngl_aarch64_instrs_memory_vector_single_post_inc : (bits(5), bits(5), bits(2), bits(1), bits(3), bits(5), bits(1), bits(1), bits(1)) -> unit

function decode_st2_advsimd_sngl_aarch64_instrs_memory_vector_single_post_inc (Rt, Rn, size, S, opcode, Rm, R, L, Q) = {
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let wback : bool = true;
    let nontemporal : bool = false;
    let tagchecked : bool = wback | n != 31;
    let 'init_scale = UInt(opcode[2 .. 1]);
    scale : int = init_scale;
    let 'selem = UInt([opcode[0]] @ R) + 1;
    replicate : bool = false;
    index : int = undefined;
    match scale {
      3 => {
          if L == 0b0 | S == 0b1 then {
              throw(Error_Undefined())
          };
          scale = UInt(size);
          replicate = true
      },
      0 => {
          index = UInt((Q @ S) @ size)
      },
      1 => {
          if [size[0]] == 0b1 then {
              throw(Error_Undefined())
          };
          index = UInt((Q @ S) @ [size[1]])
      },
      2 => {
          if [size[1]] == 0b1 then {
              throw(Error_Undefined())
          };
          if [size[0]] == 0b0 then {
              index = UInt(Q @ S)
          } else {
              if S == 0b1 then {
                  throw(Error_Undefined())
              };
              index = UInt(Q);
              scale = 3
          }
      },
      _ => ()
    };
    let 'scale = scale;
    let 'index = index;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'esize = (8 << scale);
    assert(constraint('esize in {8, 16, 32, 64}));
    execute_aarch64_instrs_memory_vector_single_no_wb(datasize, esize, index, m, memop, n, nontemporal, replicate, selem, t, tagchecked, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitone, bitzero, bitone, _, _, _, _, _, _, _, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 503) = {
    SEE = 503;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 10, 2);
    let S = Slice(__opcode, 12, 1);
    let opcode = Slice(__opcode, 13, 3);
    let Rm = Slice(__opcode, 16, 5);
    let R = Slice(__opcode, 21, 1);
    let L = Slice(__opcode, 22, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_st2_advsimd_sngl_aarch64_instrs_memory_vector_single_post_inc(Rt, Rn, size, S, opcode, Rm, R, L, Q)
}

val decode_st3_advsimd_sngl_aarch64_instrs_memory_vector_single_no_wb : (bits(5), bits(5), bits(2), bits(1), bits(3), bits(1), bits(1), bits(1), bits(1)) -> unit

function decode_st3_advsimd_sngl_aarch64_instrs_memory_vector_single_no_wb (Rt, Rn, size, S, opcode, o2, R, L, Q) = {
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 'm = __UNKNOWN_integer();
    let wback : bool = false;
    let nontemporal : bool = false;
    let tagchecked : bool = wback | n != 31;
    let 'init_scale = UInt(opcode[2 .. 1]);
    scale : int = init_scale;
    let 'selem = UInt([opcode[0]] @ R) + 1;
    replicate : bool = false;
    index : int = undefined;
    match scale {
      3 => {
          if L == 0b0 | S == 0b1 then {
              throw(Error_Undefined())
          };
          scale = UInt(size);
          replicate = true
      },
      0 => {
          index = UInt((Q @ S) @ size)
      },
      1 => {
          if [size[0]] == 0b1 then {
              throw(Error_Undefined())
          };
          index = UInt((Q @ S) @ [size[1]])
      },
      2 => {
          if [size[1]] == 0b1 then {
              throw(Error_Undefined())
          };
          if [size[0]] == 0b0 then {
              index = UInt(Q @ S)
          } else {
              if S == 0b1 then {
                  throw(Error_Undefined())
              };
              index = UInt(Q);
              scale = 3
          }
      },
      _ => ()
    };
    let 'scale = scale;
    let 'index = index;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'esize = (8 << scale);
    assert(constraint('esize in {8, 16, 32, 64}));
    execute_aarch64_instrs_memory_vector_single_no_wb(datasize, esize, index, m, memop, n, nontemporal, replicate, selem, t, tagchecked, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 504) = {
    SEE = 504;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 10, 2);
    let S = Slice(__opcode, 12, 1);
    let opcode = Slice(__opcode, 13, 3);
    let o2 = Slice(__opcode, 16, 1);
    let R = Slice(__opcode, 21, 1);
    let L = Slice(__opcode, 22, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_st3_advsimd_sngl_aarch64_instrs_memory_vector_single_no_wb(Rt, Rn, size, S, opcode, o2, R, L, Q)
}

val decode_st3_advsimd_sngl_aarch64_instrs_memory_vector_single_post_inc : (bits(5), bits(5), bits(2), bits(1), bits(3), bits(5), bits(1), bits(1), bits(1)) -> unit

function decode_st3_advsimd_sngl_aarch64_instrs_memory_vector_single_post_inc (Rt, Rn, size, S, opcode, Rm, R, L, Q) = {
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let wback : bool = true;
    let nontemporal : bool = false;
    let tagchecked : bool = wback | n != 31;
    let 'init_scale = UInt(opcode[2 .. 1]);
    scale : int = init_scale;
    let 'selem = UInt([opcode[0]] @ R) + 1;
    replicate : bool = false;
    index : int = undefined;
    match scale {
      3 => {
          if L == 0b0 | S == 0b1 then {
              throw(Error_Undefined())
          };
          scale = UInt(size);
          replicate = true
      },
      0 => {
          index = UInt((Q @ S) @ size)
      },
      1 => {
          if [size[0]] == 0b1 then {
              throw(Error_Undefined())
          };
          index = UInt((Q @ S) @ [size[1]])
      },
      2 => {
          if [size[1]] == 0b1 then {
              throw(Error_Undefined())
          };
          if [size[0]] == 0b0 then {
              index = UInt(Q @ S)
          } else {
              if S == 0b1 then {
                  throw(Error_Undefined())
              };
              index = UInt(Q);
              scale = 3
          }
      },
      _ => ()
    };
    let 'scale = scale;
    let 'index = index;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'esize = (8 << scale);
    assert(constraint('esize in {8, 16, 32, 64}));
    execute_aarch64_instrs_memory_vector_single_no_wb(datasize, esize, index, m, memop, n, nontemporal, replicate, selem, t, tagchecked, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitone, bitzero, bitzero, _, _, _, _, _, _, _, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 505) = {
    SEE = 505;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 10, 2);
    let S = Slice(__opcode, 12, 1);
    let opcode = Slice(__opcode, 13, 3);
    let Rm = Slice(__opcode, 16, 5);
    let R = Slice(__opcode, 21, 1);
    let L = Slice(__opcode, 22, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_st3_advsimd_sngl_aarch64_instrs_memory_vector_single_post_inc(Rt, Rn, size, S, opcode, Rm, R, L, Q)
}

val decode_st4_advsimd_sngl_aarch64_instrs_memory_vector_single_no_wb : (bits(5), bits(5), bits(2), bits(1), bits(3), bits(1), bits(1), bits(1), bits(1)) -> unit

function decode_st4_advsimd_sngl_aarch64_instrs_memory_vector_single_no_wb (Rt, Rn, size, S, opcode, o2, R, L, Q) = {
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 'm = __UNKNOWN_integer();
    let wback : bool = false;
    let nontemporal : bool = false;
    let tagchecked : bool = wback | n != 31;
    let 'init_scale = UInt(opcode[2 .. 1]);
    scale : int = init_scale;
    let 'selem = UInt([opcode[0]] @ R) + 1;
    replicate : bool = false;
    index : int = undefined;
    match scale {
      3 => {
          if L == 0b0 | S == 0b1 then {
              throw(Error_Undefined())
          };
          scale = UInt(size);
          replicate = true
      },
      0 => {
          index = UInt((Q @ S) @ size)
      },
      1 => {
          if [size[0]] == 0b1 then {
              throw(Error_Undefined())
          };
          index = UInt((Q @ S) @ [size[1]])
      },
      2 => {
          if [size[1]] == 0b1 then {
              throw(Error_Undefined())
          };
          if [size[0]] == 0b0 then {
              index = UInt(Q @ S)
          } else {
              if S == 0b1 then {
                  throw(Error_Undefined())
              };
              index = UInt(Q);
              scale = 3
          }
      },
      _ => ()
    };
    let 'scale = scale;
    let 'index = index;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'esize = (8 << scale);
    assert(constraint('esize in {8, 16, 32, 64}));
    execute_aarch64_instrs_memory_vector_single_no_wb(datasize, esize, index, m, memop, n, nontemporal, replicate, selem, t, tagchecked, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 506) = {
    SEE = 506;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 10, 2);
    let S = Slice(__opcode, 12, 1);
    let opcode = Slice(__opcode, 13, 3);
    let o2 = Slice(__opcode, 16, 1);
    let R = Slice(__opcode, 21, 1);
    let L = Slice(__opcode, 22, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_st4_advsimd_sngl_aarch64_instrs_memory_vector_single_no_wb(Rt, Rn, size, S, opcode, o2, R, L, Q)
}

val decode_st4_advsimd_sngl_aarch64_instrs_memory_vector_single_post_inc : (bits(5), bits(5), bits(2), bits(1), bits(3), bits(5), bits(1), bits(1), bits(1)) -> unit

function decode_st4_advsimd_sngl_aarch64_instrs_memory_vector_single_post_inc (Rt, Rn, size, S, opcode, Rm, R, L, Q) = {
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let wback : bool = true;
    let nontemporal : bool = false;
    let tagchecked : bool = wback | n != 31;
    let 'init_scale = UInt(opcode[2 .. 1]);
    scale : int = init_scale;
    let 'selem = UInt([opcode[0]] @ R) + 1;
    replicate : bool = false;
    index : int = undefined;
    match scale {
      3 => {
          if L == 0b0 | S == 0b1 then {
              throw(Error_Undefined())
          };
          scale = UInt(size);
          replicate = true
      },
      0 => {
          index = UInt((Q @ S) @ size)
      },
      1 => {
          if [size[0]] == 0b1 then {
              throw(Error_Undefined())
          };
          index = UInt((Q @ S) @ [size[1]])
      },
      2 => {
          if [size[1]] == 0b1 then {
              throw(Error_Undefined())
          };
          if [size[0]] == 0b0 then {
              index = UInt(Q @ S)
          } else {
              if S == 0b1 then {
                  throw(Error_Undefined())
              };
              index = UInt(Q);
              scale = 3
          }
      },
      _ => ()
    };
    let 'scale = scale;
    let 'index = index;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'esize = (8 << scale);
    assert(constraint('esize in {8, 16, 32, 64}));
    execute_aarch64_instrs_memory_vector_single_no_wb(datasize, esize, index, m, memop, n, nontemporal, replicate, selem, t, tagchecked, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitone, bitzero, bitone, _, _, _, _, _, _, _, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 507) = {
    SEE = 507;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 10, 2);
    let S = Slice(__opcode, 12, 1);
    let opcode = Slice(__opcode, 13, 3);
    let Rm = Slice(__opcode, 16, 5);
    let R = Slice(__opcode, 21, 1);
    let L = Slice(__opcode, 22, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_st4_advsimd_sngl_aarch64_instrs_memory_vector_single_post_inc(Rt, Rn, size, S, opcode, Rm, R, L, Q)
}

val execute_aarch64_instrs_memory_vector_multiple_no_wb : forall 'datasize 'elements 'esize 'm 'n ('nontemporal : Bool) 'rpt 'selem 't ('tagchecked : Bool) ('wback : Bool),
  (0 <= 't & 't <= 31 & 'selem in {1, 2, 3, 4} & 'rpt in {1, 2, 3, 4} & 0 <= 'n & 'n <= 31 & 'esize in {8, 16, 32, 64} & 'datasize in {64, 128}).
  (int('datasize), int('elements), int('esize), int('m), MemOp, int('n), bool('nontemporal), int('rpt), int('selem), int('t), bool('tagchecked), bool('wback)) -> unit

function execute_aarch64_instrs_memory_vector_multiple_no_wb (datasize, elements, esize, m, memop, n, nontemporal, rpt, selem, t, tagchecked, wback) = {
    CheckFPAdvSIMDEnabled64();
    address : bits(64) = undefined;
    rval : bits('datasize) = undefined;
    tt : int = undefined;
    let 'ebytes = DIV(esize, 8);
    let accdesc : AccessDescriptor = CreateAccDescASIMD(memop, nontemporal, tagchecked);
    if n == 31 then {
        CheckSPAlignment();
        address = SP_read()
    } else {
        address = X_read(n, 64)
    };
    offs : bits(64) = Zeros(64);
    foreach (r from 0 to (rpt - 1) by 1 in inc) {
        foreach (e from 0 to (elements - 1) by 1 in inc) {
            tt = MOD(t + r, 32);
            foreach (s from 0 to (selem - 1) by 1 in inc) {
                let 'tt = tt in
                  {
                      rval = V_read(tt, datasize)
                  };
                let 'tt = tt in
                  {
                      if memop == MemOp_LOAD then {
                          rval = Elem_set(rval, e, esize, Mem_read(address + offs, ebytes, accdesc));
                          V_set(tt, datasize) = rval
                      } else {
                          Mem_set(address + offs, ebytes, accdesc) = Elem_read(rval, e, esize)
                      }
                  };
                offs = offs + ebytes;
                tt = MOD(tt + 1, 32)
            }
        }
    };
    if SPESampleInFlight then {
        SPESampleSIMDFPLoadStore()
    };
    if wback then {
        if m != 31 then {
            offs = X_read(m, 64)
        };
        if n == 31 then {
            SP_set() = address + offs
        } else {
            X_set(n, 64) = address + offs
        }
    };
    ()
}

val decode_ld1_advsimd_mult_aarch64_instrs_memory_vector_multiple_no_wb : (bits(5), bits(5), bits(2), bits(4), bits(1), bits(1)) -> unit

function decode_ld1_advsimd_mult_aarch64_instrs_memory_vector_multiple_no_wb (Rt, Rn, size, opcode, L, Q) = {
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 'm = __UNKNOWN_integer();
    let wback : bool = false;
    let nontemporal : bool = false;
    let tagchecked : bool = wback | n != 31;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'esize = (8 << UInt(size));
    let 'elements = DIV(datasize, esize);
    rpt : {1, 2, 3, 4} = 1;
    selem : {1, 2, 3, 4} = 1;
    match opcode {
      0b0000 => {
          rpt = 1;
          selem = 4
      },
      0b0010 => {
          rpt = 4;
          selem = 1
      },
      0b0100 => {
          rpt = 1;
          selem = 3
      },
      0b0110 => {
          rpt = 3;
          selem = 1
      },
      0b0111 => {
          rpt = 1;
          selem = 1
      },
      0b1000 => {
          rpt = 1;
          selem = 2
      },
      0b1010 => {
          rpt = 2;
          selem = 1
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let 'selem = selem;
    let 'rpt = rpt;
    if (size @ Q) == 0b110 & selem != 1 then {
        throw(Error_Undefined())
    };
    execute_aarch64_instrs_memory_vector_multiple_no_wb(datasize, elements, esize, m, memop, n, nontemporal, rpt, selem, t, tagchecked, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 508) = {
    SEE = 508;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 10, 2);
    let opcode = Slice(__opcode, 12, 4);
    let L = Slice(__opcode, 22, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_ld1_advsimd_mult_aarch64_instrs_memory_vector_multiple_no_wb(Rt, Rn, size, opcode, L, Q)
}

val decode_ld1_advsimd_mult_aarch64_instrs_memory_vector_multiple_post_inc : (bits(5), bits(5), bits(2), bits(4), bits(5), bits(1), bits(1)) -> unit

function decode_ld1_advsimd_mult_aarch64_instrs_memory_vector_multiple_post_inc (Rt, Rn, size, opcode, Rm, L, Q) = {
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let wback : bool = true;
    let nontemporal : bool = false;
    let tagchecked : bool = wback | n != 31;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'esize = (8 << UInt(size));
    let 'elements = DIV(datasize, esize);
    rpt : {1, 2, 3, 4} = 1;
    selem : {1, 2, 3, 4} = 1;
    match opcode {
      0b0000 => {
          rpt = 1;
          selem = 4
      },
      0b0010 => {
          rpt = 4;
          selem = 1
      },
      0b0100 => {
          rpt = 1;
          selem = 3
      },
      0b0110 => {
          rpt = 3;
          selem = 1
      },
      0b0111 => {
          rpt = 1;
          selem = 1
      },
      0b1000 => {
          rpt = 1;
          selem = 2
      },
      0b1010 => {
          rpt = 2;
          selem = 1
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let 'selem = selem;
    let 'rpt = rpt;
    if (size @ Q) == 0b110 & selem != 1 then {
        throw(Error_Undefined())
    };
    execute_aarch64_instrs_memory_vector_multiple_no_wb(datasize, elements, esize, m, memop, n, nontemporal, rpt, selem, t, tagchecked, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitone, bitone, bitzero, _, _, _, _, _, _, _, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 509) = {
    SEE = 509;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 10, 2);
    let opcode = Slice(__opcode, 12, 4);
    let Rm = Slice(__opcode, 16, 5);
    let L = Slice(__opcode, 22, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_ld1_advsimd_mult_aarch64_instrs_memory_vector_multiple_post_inc(Rt, Rn, size, opcode, Rm, L, Q)
}

val decode_ld2_advsimd_mult_aarch64_instrs_memory_vector_multiple_no_wb : (bits(5), bits(5), bits(2), bits(4), bits(1), bits(1)) -> unit

function decode_ld2_advsimd_mult_aarch64_instrs_memory_vector_multiple_no_wb (Rt, Rn, size, opcode, L, Q) = {
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 'm = __UNKNOWN_integer();
    let wback : bool = false;
    let nontemporal : bool = false;
    let tagchecked : bool = wback | n != 31;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'esize = (8 << UInt(size));
    let 'elements = DIV(datasize, esize);
    rpt : {1, 2, 3, 4} = 1;
    selem : {1, 2, 3, 4} = 1;
    match opcode {
      0b0000 => {
          rpt = 1;
          selem = 4
      },
      0b0010 => {
          rpt = 4;
          selem = 1
      },
      0b0100 => {
          rpt = 1;
          selem = 3
      },
      0b0110 => {
          rpt = 3;
          selem = 1
      },
      0b0111 => {
          rpt = 1;
          selem = 1
      },
      0b1000 => {
          rpt = 1;
          selem = 2
      },
      0b1010 => {
          rpt = 2;
          selem = 1
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let 'selem = selem;
    let 'rpt = rpt;
    if (size @ Q) == 0b110 & selem != 1 then {
        throw(Error_Undefined())
    };
    execute_aarch64_instrs_memory_vector_multiple_no_wb(datasize, elements, esize, m, memop, n, nontemporal, rpt, selem, t, tagchecked, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 510) = {
    SEE = 510;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 10, 2);
    let opcode = Slice(__opcode, 12, 4);
    let L = Slice(__opcode, 22, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_ld2_advsimd_mult_aarch64_instrs_memory_vector_multiple_no_wb(Rt, Rn, size, opcode, L, Q)
}

val decode_ld2_advsimd_mult_aarch64_instrs_memory_vector_multiple_post_inc : (bits(5), bits(5), bits(2), bits(4), bits(5), bits(1), bits(1)) -> unit

function decode_ld2_advsimd_mult_aarch64_instrs_memory_vector_multiple_post_inc (Rt, Rn, size, opcode, Rm, L, Q) = {
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let wback : bool = true;
    let nontemporal : bool = false;
    let tagchecked : bool = wback | n != 31;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'esize = (8 << UInt(size));
    let 'elements = DIV(datasize, esize);
    rpt : {1, 2, 3, 4} = 1;
    selem : {1, 2, 3, 4} = 1;
    match opcode {
      0b0000 => {
          rpt = 1;
          selem = 4
      },
      0b0010 => {
          rpt = 4;
          selem = 1
      },
      0b0100 => {
          rpt = 1;
          selem = 3
      },
      0b0110 => {
          rpt = 3;
          selem = 1
      },
      0b0111 => {
          rpt = 1;
          selem = 1
      },
      0b1000 => {
          rpt = 1;
          selem = 2
      },
      0b1010 => {
          rpt = 2;
          selem = 1
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let 'selem = selem;
    let 'rpt = rpt;
    if (size @ Q) == 0b110 & selem != 1 then {
        throw(Error_Undefined())
    };
    execute_aarch64_instrs_memory_vector_multiple_no_wb(datasize, elements, esize, m, memop, n, nontemporal, rpt, selem, t, tagchecked, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitone, bitone, bitzero, _, _, _, _, _, bitone, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 511) = {
    SEE = 511;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 10, 2);
    let opcode = Slice(__opcode, 12, 4);
    let Rm = Slice(__opcode, 16, 5);
    let L = Slice(__opcode, 22, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_ld2_advsimd_mult_aarch64_instrs_memory_vector_multiple_post_inc(Rt, Rn, size, opcode, Rm, L, Q)
}

val decode_ld3_advsimd_mult_aarch64_instrs_memory_vector_multiple_no_wb : (bits(5), bits(5), bits(2), bits(4), bits(1), bits(1)) -> unit

function decode_ld3_advsimd_mult_aarch64_instrs_memory_vector_multiple_no_wb (Rt, Rn, size, opcode, L, Q) = {
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 'm = __UNKNOWN_integer();
    let wback : bool = false;
    let nontemporal : bool = false;
    let tagchecked : bool = wback | n != 31;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'esize = (8 << UInt(size));
    let 'elements = DIV(datasize, esize);
    rpt : {1, 2, 3, 4} = 1;
    selem : {1, 2, 3, 4} = 1;
    match opcode {
      0b0000 => {
          rpt = 1;
          selem = 4
      },
      0b0010 => {
          rpt = 4;
          selem = 1
      },
      0b0100 => {
          rpt = 1;
          selem = 3
      },
      0b0110 => {
          rpt = 3;
          selem = 1
      },
      0b0111 => {
          rpt = 1;
          selem = 1
      },
      0b1000 => {
          rpt = 1;
          selem = 2
      },
      0b1010 => {
          rpt = 2;
          selem = 1
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let 'selem = selem;
    let 'rpt = rpt;
    if (size @ Q) == 0b110 & selem != 1 then {
        throw(Error_Undefined())
    };
    execute_aarch64_instrs_memory_vector_multiple_no_wb(datasize, elements, esize, m, memop, n, nontemporal, rpt, selem, t, tagchecked, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 512) = {
    SEE = 512;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 10, 2);
    let opcode = Slice(__opcode, 12, 4);
    let L = Slice(__opcode, 22, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_ld3_advsimd_mult_aarch64_instrs_memory_vector_multiple_no_wb(Rt, Rn, size, opcode, L, Q)
}

val decode_ld3_advsimd_mult_aarch64_instrs_memory_vector_multiple_post_inc : (bits(5), bits(5), bits(2), bits(4), bits(5), bits(1), bits(1)) -> unit

function decode_ld3_advsimd_mult_aarch64_instrs_memory_vector_multiple_post_inc (Rt, Rn, size, opcode, Rm, L, Q) = {
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let wback : bool = true;
    let nontemporal : bool = false;
    let tagchecked : bool = wback | n != 31;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'esize = (8 << UInt(size));
    let 'elements = DIV(datasize, esize);
    rpt : {1, 2, 3, 4} = 1;
    selem : {1, 2, 3, 4} = 1;
    match opcode {
      0b0000 => {
          rpt = 1;
          selem = 4
      },
      0b0010 => {
          rpt = 4;
          selem = 1
      },
      0b0100 => {
          rpt = 1;
          selem = 3
      },
      0b0110 => {
          rpt = 3;
          selem = 1
      },
      0b0111 => {
          rpt = 1;
          selem = 1
      },
      0b1000 => {
          rpt = 1;
          selem = 2
      },
      0b1010 => {
          rpt = 2;
          selem = 1
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let 'selem = selem;
    let 'rpt = rpt;
    if (size @ Q) == 0b110 & selem != 1 then {
        throw(Error_Undefined())
    };
    execute_aarch64_instrs_memory_vector_multiple_no_wb(datasize, elements, esize, m, memop, n, nontemporal, rpt, selem, t, tagchecked, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitone, bitone, bitzero, _, _, _, _, _, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 513) = {
    SEE = 513;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 10, 2);
    let opcode = Slice(__opcode, 12, 4);
    let Rm = Slice(__opcode, 16, 5);
    let L = Slice(__opcode, 22, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_ld3_advsimd_mult_aarch64_instrs_memory_vector_multiple_post_inc(Rt, Rn, size, opcode, Rm, L, Q)
}

val decode_ld4_advsimd_mult_aarch64_instrs_memory_vector_multiple_no_wb : (bits(5), bits(5), bits(2), bits(4), bits(1), bits(1)) -> unit

function decode_ld4_advsimd_mult_aarch64_instrs_memory_vector_multiple_no_wb (Rt, Rn, size, opcode, L, Q) = {
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 'm = __UNKNOWN_integer();
    let wback : bool = false;
    let nontemporal : bool = false;
    let tagchecked : bool = wback | n != 31;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'esize = (8 << UInt(size));
    let 'elements = DIV(datasize, esize);
    rpt : {1, 2, 3, 4} = 1;
    selem : {1, 2, 3, 4} = 1;
    match opcode {
      0b0000 => {
          rpt = 1;
          selem = 4
      },
      0b0010 => {
          rpt = 4;
          selem = 1
      },
      0b0100 => {
          rpt = 1;
          selem = 3
      },
      0b0110 => {
          rpt = 3;
          selem = 1
      },
      0b0111 => {
          rpt = 1;
          selem = 1
      },
      0b1000 => {
          rpt = 1;
          selem = 2
      },
      0b1010 => {
          rpt = 2;
          selem = 1
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let 'selem = selem;
    let 'rpt = rpt;
    if (size @ Q) == 0b110 & selem != 1 then {
        throw(Error_Undefined())
    };
    execute_aarch64_instrs_memory_vector_multiple_no_wb(datasize, elements, esize, m, memop, n, nontemporal, rpt, selem, t, tagchecked, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 514) = {
    SEE = 514;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 10, 2);
    let opcode = Slice(__opcode, 12, 4);
    let L = Slice(__opcode, 22, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_ld4_advsimd_mult_aarch64_instrs_memory_vector_multiple_no_wb(Rt, Rn, size, opcode, L, Q)
}

val decode_ld4_advsimd_mult_aarch64_instrs_memory_vector_multiple_post_inc : (bits(5), bits(5), bits(2), bits(4), bits(5), bits(1), bits(1)) -> unit

function decode_ld4_advsimd_mult_aarch64_instrs_memory_vector_multiple_post_inc (Rt, Rn, size, opcode, Rm, L, Q) = {
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let wback : bool = true;
    let nontemporal : bool = false;
    let tagchecked : bool = wback | n != 31;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'esize = (8 << UInt(size));
    let 'elements = DIV(datasize, esize);
    rpt : {1, 2, 3, 4} = 1;
    selem : {1, 2, 3, 4} = 1;
    match opcode {
      0b0000 => {
          rpt = 1;
          selem = 4
      },
      0b0010 => {
          rpt = 4;
          selem = 1
      },
      0b0100 => {
          rpt = 1;
          selem = 3
      },
      0b0110 => {
          rpt = 3;
          selem = 1
      },
      0b0111 => {
          rpt = 1;
          selem = 1
      },
      0b1000 => {
          rpt = 1;
          selem = 2
      },
      0b1010 => {
          rpt = 2;
          selem = 1
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let 'selem = selem;
    let 'rpt = rpt;
    if (size @ Q) == 0b110 & selem != 1 then {
        throw(Error_Undefined())
    };
    execute_aarch64_instrs_memory_vector_multiple_no_wb(datasize, elements, esize, m, memop, n, nontemporal, rpt, selem, t, tagchecked, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitone, bitone, bitzero, _, _, _, _, _, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 515) = {
    SEE = 515;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 10, 2);
    let opcode = Slice(__opcode, 12, 4);
    let Rm = Slice(__opcode, 16, 5);
    let L = Slice(__opcode, 22, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_ld4_advsimd_mult_aarch64_instrs_memory_vector_multiple_post_inc(Rt, Rn, size, opcode, Rm, L, Q)
}

val decode_st1_advsimd_mult_aarch64_instrs_memory_vector_multiple_no_wb : (bits(5), bits(5), bits(2), bits(4), bits(1), bits(1)) -> unit

function decode_st1_advsimd_mult_aarch64_instrs_memory_vector_multiple_no_wb (Rt, Rn, size, opcode, L, Q) = {
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 'm = __UNKNOWN_integer();
    let wback : bool = false;
    let nontemporal : bool = false;
    let tagchecked : bool = wback | n != 31;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'esize = (8 << UInt(size));
    let 'elements = DIV(datasize, esize);
    rpt : {1, 2, 3, 4} = 1;
    selem : {1, 2, 3, 4} = 1;
    match opcode {
      0b0000 => {
          rpt = 1;
          selem = 4
      },
      0b0010 => {
          rpt = 4;
          selem = 1
      },
      0b0100 => {
          rpt = 1;
          selem = 3
      },
      0b0110 => {
          rpt = 3;
          selem = 1
      },
      0b0111 => {
          rpt = 1;
          selem = 1
      },
      0b1000 => {
          rpt = 1;
          selem = 2
      },
      0b1010 => {
          rpt = 2;
          selem = 1
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let 'selem = selem;
    let 'rpt = rpt;
    if (size @ Q) == 0b110 & selem != 1 then {
        throw(Error_Undefined())
    };
    execute_aarch64_instrs_memory_vector_multiple_no_wb(datasize, elements, esize, m, memop, n, nontemporal, rpt, selem, t, tagchecked, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 516) = {
    SEE = 516;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 10, 2);
    let opcode = Slice(__opcode, 12, 4);
    let L = Slice(__opcode, 22, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_st1_advsimd_mult_aarch64_instrs_memory_vector_multiple_no_wb(Rt, Rn, size, opcode, L, Q)
}

val decode_st1_advsimd_mult_aarch64_instrs_memory_vector_multiple_post_inc : (bits(5), bits(5), bits(2), bits(4), bits(5), bits(1), bits(1)) -> unit

function decode_st1_advsimd_mult_aarch64_instrs_memory_vector_multiple_post_inc (Rt, Rn, size, opcode, Rm, L, Q) = {
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let wback : bool = true;
    let nontemporal : bool = false;
    let tagchecked : bool = wback | n != 31;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'esize = (8 << UInt(size));
    let 'elements = DIV(datasize, esize);
    rpt : {1, 2, 3, 4} = 1;
    selem : {1, 2, 3, 4} = 1;
    match opcode {
      0b0000 => {
          rpt = 1;
          selem = 4
      },
      0b0010 => {
          rpt = 4;
          selem = 1
      },
      0b0100 => {
          rpt = 1;
          selem = 3
      },
      0b0110 => {
          rpt = 3;
          selem = 1
      },
      0b0111 => {
          rpt = 1;
          selem = 1
      },
      0b1000 => {
          rpt = 1;
          selem = 2
      },
      0b1010 => {
          rpt = 2;
          selem = 1
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let 'selem = selem;
    let 'rpt = rpt;
    if (size @ Q) == 0b110 & selem != 1 then {
        throw(Error_Undefined())
    };
    execute_aarch64_instrs_memory_vector_multiple_no_wb(datasize, elements, esize, m, memop, n, nontemporal, rpt, selem, t, tagchecked, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, _, _, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 517) = {
    SEE = 517;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 10, 2);
    let opcode = Slice(__opcode, 12, 4);
    let Rm = Slice(__opcode, 16, 5);
    let L = Slice(__opcode, 22, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_st1_advsimd_mult_aarch64_instrs_memory_vector_multiple_post_inc(Rt, Rn, size, opcode, Rm, L, Q)
}

val decode_st2_advsimd_mult_aarch64_instrs_memory_vector_multiple_no_wb : (bits(5), bits(5), bits(2), bits(4), bits(1), bits(1)) -> unit

function decode_st2_advsimd_mult_aarch64_instrs_memory_vector_multiple_no_wb (Rt, Rn, size, opcode, L, Q) = {
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 'm = __UNKNOWN_integer();
    let wback : bool = false;
    let nontemporal : bool = false;
    let tagchecked : bool = wback | n != 31;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'esize = (8 << UInt(size));
    let 'elements = DIV(datasize, esize);
    rpt : {1, 2, 3, 4} = 1;
    selem : {1, 2, 3, 4} = 1;
    match opcode {
      0b0000 => {
          rpt = 1;
          selem = 4
      },
      0b0010 => {
          rpt = 4;
          selem = 1
      },
      0b0100 => {
          rpt = 1;
          selem = 3
      },
      0b0110 => {
          rpt = 3;
          selem = 1
      },
      0b0111 => {
          rpt = 1;
          selem = 1
      },
      0b1000 => {
          rpt = 1;
          selem = 2
      },
      0b1010 => {
          rpt = 2;
          selem = 1
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let 'selem = selem;
    let 'rpt = rpt;
    if (size @ Q) == 0b110 & selem != 1 then {
        throw(Error_Undefined())
    };
    execute_aarch64_instrs_memory_vector_multiple_no_wb(datasize, elements, esize, m, memop, n, nontemporal, rpt, selem, t, tagchecked, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 518) = {
    SEE = 518;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 10, 2);
    let opcode = Slice(__opcode, 12, 4);
    let L = Slice(__opcode, 22, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_st2_advsimd_mult_aarch64_instrs_memory_vector_multiple_no_wb(Rt, Rn, size, opcode, L, Q)
}

val decode_st2_advsimd_mult_aarch64_instrs_memory_vector_multiple_post_inc : (bits(5), bits(5), bits(2), bits(4), bits(5), bits(1), bits(1)) -> unit

function decode_st2_advsimd_mult_aarch64_instrs_memory_vector_multiple_post_inc (Rt, Rn, size, opcode, Rm, L, Q) = {
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let wback : bool = true;
    let nontemporal : bool = false;
    let tagchecked : bool = wback | n != 31;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'esize = (8 << UInt(size));
    let 'elements = DIV(datasize, esize);
    rpt : {1, 2, 3, 4} = 1;
    selem : {1, 2, 3, 4} = 1;
    match opcode {
      0b0000 => {
          rpt = 1;
          selem = 4
      },
      0b0010 => {
          rpt = 4;
          selem = 1
      },
      0b0100 => {
          rpt = 1;
          selem = 3
      },
      0b0110 => {
          rpt = 3;
          selem = 1
      },
      0b0111 => {
          rpt = 1;
          selem = 1
      },
      0b1000 => {
          rpt = 1;
          selem = 2
      },
      0b1010 => {
          rpt = 2;
          selem = 1
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let 'selem = selem;
    let 'rpt = rpt;
    if (size @ Q) == 0b110 & selem != 1 then {
        throw(Error_Undefined())
    };
    execute_aarch64_instrs_memory_vector_multiple_no_wb(datasize, elements, esize, m, memop, n, nontemporal, rpt, selem, t, tagchecked, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, bitone, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 519) = {
    SEE = 519;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 10, 2);
    let opcode = Slice(__opcode, 12, 4);
    let Rm = Slice(__opcode, 16, 5);
    let L = Slice(__opcode, 22, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_st2_advsimd_mult_aarch64_instrs_memory_vector_multiple_post_inc(Rt, Rn, size, opcode, Rm, L, Q)
}

val decode_st3_advsimd_mult_aarch64_instrs_memory_vector_multiple_no_wb : (bits(5), bits(5), bits(2), bits(4), bits(1), bits(1)) -> unit

function decode_st3_advsimd_mult_aarch64_instrs_memory_vector_multiple_no_wb (Rt, Rn, size, opcode, L, Q) = {
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 'm = __UNKNOWN_integer();
    let wback : bool = false;
    let nontemporal : bool = false;
    let tagchecked : bool = wback | n != 31;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'esize = (8 << UInt(size));
    let 'elements = DIV(datasize, esize);
    rpt : {1, 2, 3, 4} = 1;
    selem : {1, 2, 3, 4} = 1;
    match opcode {
      0b0000 => {
          rpt = 1;
          selem = 4
      },
      0b0010 => {
          rpt = 4;
          selem = 1
      },
      0b0100 => {
          rpt = 1;
          selem = 3
      },
      0b0110 => {
          rpt = 3;
          selem = 1
      },
      0b0111 => {
          rpt = 1;
          selem = 1
      },
      0b1000 => {
          rpt = 1;
          selem = 2
      },
      0b1010 => {
          rpt = 2;
          selem = 1
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let 'selem = selem;
    let 'rpt = rpt;
    if (size @ Q) == 0b110 & selem != 1 then {
        throw(Error_Undefined())
    };
    execute_aarch64_instrs_memory_vector_multiple_no_wb(datasize, elements, esize, m, memop, n, nontemporal, rpt, selem, t, tagchecked, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 520) = {
    SEE = 520;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 10, 2);
    let opcode = Slice(__opcode, 12, 4);
    let L = Slice(__opcode, 22, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_st3_advsimd_mult_aarch64_instrs_memory_vector_multiple_no_wb(Rt, Rn, size, opcode, L, Q)
}

val decode_st3_advsimd_mult_aarch64_instrs_memory_vector_multiple_post_inc : (bits(5), bits(5), bits(2), bits(4), bits(5), bits(1), bits(1)) -> unit

function decode_st3_advsimd_mult_aarch64_instrs_memory_vector_multiple_post_inc (Rt, Rn, size, opcode, Rm, L, Q) = {
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let wback : bool = true;
    let nontemporal : bool = false;
    let tagchecked : bool = wback | n != 31;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'esize = (8 << UInt(size));
    let 'elements = DIV(datasize, esize);
    rpt : {1, 2, 3, 4} = 1;
    selem : {1, 2, 3, 4} = 1;
    match opcode {
      0b0000 => {
          rpt = 1;
          selem = 4
      },
      0b0010 => {
          rpt = 4;
          selem = 1
      },
      0b0100 => {
          rpt = 1;
          selem = 3
      },
      0b0110 => {
          rpt = 3;
          selem = 1
      },
      0b0111 => {
          rpt = 1;
          selem = 1
      },
      0b1000 => {
          rpt = 1;
          selem = 2
      },
      0b1010 => {
          rpt = 2;
          selem = 1
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let 'selem = selem;
    let 'rpt = rpt;
    if (size @ Q) == 0b110 & selem != 1 then {
        throw(Error_Undefined())
    };
    execute_aarch64_instrs_memory_vector_multiple_no_wb(datasize, elements, esize, m, memop, n, nontemporal, rpt, selem, t, tagchecked, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 521) = {
    SEE = 521;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 10, 2);
    let opcode = Slice(__opcode, 12, 4);
    let Rm = Slice(__opcode, 16, 5);
    let L = Slice(__opcode, 22, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_st3_advsimd_mult_aarch64_instrs_memory_vector_multiple_post_inc(Rt, Rn, size, opcode, Rm, L, Q)
}

val decode_st4_advsimd_mult_aarch64_instrs_memory_vector_multiple_no_wb : (bits(5), bits(5), bits(2), bits(4), bits(1), bits(1)) -> unit

function decode_st4_advsimd_mult_aarch64_instrs_memory_vector_multiple_no_wb (Rt, Rn, size, opcode, L, Q) = {
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 'm = __UNKNOWN_integer();
    let wback : bool = false;
    let nontemporal : bool = false;
    let tagchecked : bool = wback | n != 31;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'esize = (8 << UInt(size));
    let 'elements = DIV(datasize, esize);
    rpt : {1, 2, 3, 4} = 1;
    selem : {1, 2, 3, 4} = 1;
    match opcode {
      0b0000 => {
          rpt = 1;
          selem = 4
      },
      0b0010 => {
          rpt = 4;
          selem = 1
      },
      0b0100 => {
          rpt = 1;
          selem = 3
      },
      0b0110 => {
          rpt = 3;
          selem = 1
      },
      0b0111 => {
          rpt = 1;
          selem = 1
      },
      0b1000 => {
          rpt = 1;
          selem = 2
      },
      0b1010 => {
          rpt = 2;
          selem = 1
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let 'selem = selem;
    let 'rpt = rpt;
    if (size @ Q) == 0b110 & selem != 1 then {
        throw(Error_Undefined())
    };
    execute_aarch64_instrs_memory_vector_multiple_no_wb(datasize, elements, esize, m, memop, n, nontemporal, rpt, selem, t, tagchecked, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 522) = {
    SEE = 522;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 10, 2);
    let opcode = Slice(__opcode, 12, 4);
    let L = Slice(__opcode, 22, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_st4_advsimd_mult_aarch64_instrs_memory_vector_multiple_no_wb(Rt, Rn, size, opcode, L, Q)
}

val decode_st4_advsimd_mult_aarch64_instrs_memory_vector_multiple_post_inc : (bits(5), bits(5), bits(2), bits(4), bits(5), bits(1), bits(1)) -> unit

function decode_st4_advsimd_mult_aarch64_instrs_memory_vector_multiple_post_inc (Rt, Rn, size, opcode, Rm, L, Q) = {
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let wback : bool = true;
    let nontemporal : bool = false;
    let tagchecked : bool = wback | n != 31;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'esize = (8 << UInt(size));
    let 'elements = DIV(datasize, esize);
    rpt : {1, 2, 3, 4} = 1;
    selem : {1, 2, 3, 4} = 1;
    match opcode {
      0b0000 => {
          rpt = 1;
          selem = 4
      },
      0b0010 => {
          rpt = 4;
          selem = 1
      },
      0b0100 => {
          rpt = 1;
          selem = 3
      },
      0b0110 => {
          rpt = 3;
          selem = 1
      },
      0b0111 => {
          rpt = 1;
          selem = 1
      },
      0b1000 => {
          rpt = 1;
          selem = 2
      },
      0b1010 => {
          rpt = 2;
          selem = 1
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let 'selem = selem;
    let 'rpt = rpt;
    if (size @ Q) == 0b110 & selem != 1 then {
        throw(Error_Undefined())
    };
    execute_aarch64_instrs_memory_vector_multiple_no_wb(datasize, elements, esize, m, memop, n, nontemporal, rpt, selem, t, tagchecked, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 523) = {
    SEE = 523;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 10, 2);
    let opcode = Slice(__opcode, 12, 4);
    let Rm = Slice(__opcode, 16, 5);
    let L = Slice(__opcode, 22, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_st4_advsimd_mult_aarch64_instrs_memory_vector_multiple_post_inc(Rt, Rn, size, opcode, Rm, L, Q)
}

val execute_aarch64_instrs_memory_atomicops_ld_acc : forall 'n 't ('tagchecked : Bool),
  (0 <= 't & 't <= 31 & 0 <= 'n & 'n <= 31).
  (bits(2), MemOp, int('n), int('t), bool('tagchecked)) -> unit

function execute_aarch64_instrs_memory_atomicops_ld_acc (lst, memop, n, t, tagchecked) = {
    CheckLDST64BEnabled();
    address : bits(64) = undefined;
    value_name : bits(64) = undefined;
    let accdesc : AccessDescriptor = CreateAccDescLS64(memop, tagchecked);
    if n == 31 then {
        CheckSPAlignment();
        address = SP_read()
    } else {
        address = X_read(n, 64)
    };
    SetLoadStoreType(lst);
    AArch64_SetLSInstructionSyndrome(64, false, t, true, false);
    let data : bits(512) = MemLoad64B(address, accdesc);
    foreach (i from 0 to 7 by 1 in inc) {
        value_name = data[63 + 64 * i .. 64 * i];
        if BigEndian(accdesc.acctype) then {
            value_name = BigEndianReverse(value_name)
        };
        X_set(t + i, 64) = value_name
    };
    if SPESampleInFlight then {
        SPESampleGeneralPurposeLoadStore()
    };
    ()
}

val decode_ld64b_aarch64_instrs_memory_atomicops_ld_acc : (bits(5), bits(5)) -> unit

function decode_ld64b_aarch64_instrs_memory_atomicops_ld_acc (Rt, Rn) = {
    if not_bool(HaveFeatLS64()) then {
        throw(Error_Undefined())
    };
    if Rt[4 .. 3] == 0b11 | [Rt[0]] == 0b1 then {
        throw(Error_Undefined())
    };
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let memop : MemOp = MemOp_LOAD;
    let tagchecked : bool = n != 31;
    let lst : bits(2) = lst_64b;
    execute_aarch64_instrs_memory_atomicops_ld_acc(lst, memop, n, t, tagchecked)
}

function clause __DecodeA64_LoadStore ((pc, ([bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 524) = {
    SEE = 524;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    decode_ld64b_aarch64_instrs_memory_atomicops_ld_acc(Rt, Rn)
}

val execute_aarch64_instrs_memory_atomicops_ld : forall ('acquire : Bool) 'datasize ('is_load : Bool) 'n 'regsize ('release : Bool) 's 't ('tagchecked : Bool),
  (0 <= 't & 't <= 31 & 0 <= 's & 's <= 31 & 'regsize in {32, 64} & 0 <= 'n & 'n <= 31 & 'datasize in {8, 16, 32, 64}).
  (bool('acquire), int('datasize), bool('is_load), int('n), MemAtomicOp, int('regsize), bool('release), int('s), int('t), bool('tagchecked)) -> unit

function execute_aarch64_instrs_memory_atomicops_ld (acquire, datasize, is_load, n, op, regsize, release, s, t, tagchecked) = {
    address : bits(64) = undefined;
    let accdesc : AccessDescriptor = CreateAccDescAtomicOp(op, acquire, release, tagchecked);
    let value_name : bits('datasize) = X_read(s, datasize);
    if n == 31 then {
        CheckSPAlignment();
        address = SP_read()
    } else {
        address = X_read(n, 64)
    };
    let comparevalue : bits('datasize) = __UNKNOWN_bits(datasize);
    let data : bits('datasize) = MemAtomic(address, comparevalue, value_name, accdesc);
    if t != 31 then {
        assert(constraint(('datasize >= 0 & 'regsize >= 'datasize)));
        X_set(t, regsize) = ZeroExtend(data, regsize)
    };
    if SPESampleInFlight then {
        let ar : bits(1) = if acquire | release then 0b1 else 0b0;
        let excl : bits(1) = 0b0;
        let at : bits(1) = 0b1;
        SPESampleExtendedLoadStore(ar, excl, at, is_load)
    };
    ()
}

val decode_ldadd_aarch64_instrs_memory_atomicops_ld : (bits(5), bits(5), bits(3), bits(5), bits(1), bits(1), bits(2)) -> unit

function decode_ldadd_aarch64_instrs_memory_atomicops_ld (Rt, Rn, opc, Rs, R, A, size) = {
    if not_bool(HaveAtomicExt()) then {
        throw(Error_Undefined())
    };
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 's = UInt(Rs);
    let 'datasize = (8 << UInt(size));
    let 'regsize = if datasize == 64 then 64 else 32;
    let acquire : bool = A == 0b1 & Rt != 0b11111;
    let is_load : bool = Rt != 0b11111;
    let release : bool = R == 0b1;
    op : MemAtomicOp = undefined;
    match opc {
      0b000 => {
          op = MemAtomicOp_ADD
      },
      0b001 => {
          op = MemAtomicOp_BIC
      },
      0b010 => {
          op = MemAtomicOp_EOR
      },
      0b011 => {
          op = MemAtomicOp_ORR
      },
      0b100 => {
          op = MemAtomicOp_SMAX
      },
      0b101 => {
          op = MemAtomicOp_SMIN
      },
      0b110 => {
          op = MemAtomicOp_UMAX
      },
      0b111 => {
          op = MemAtomicOp_UMIN
      }
    };
    let op = op;
    let tagchecked : bool = n != 31;
    execute_aarch64_instrs_memory_atomicops_ld(acquire, datasize, is_load, n, op, regsize, release, s, t, tagchecked)
}

function clause __DecodeA64_LoadStore ((pc, ([bitone, _, bitone, bitone, bitone, bitzero, bitzero, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 525) = {
    SEE = 525;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let opc = Slice(__opcode, 12, 3);
    let Rs = Slice(__opcode, 16, 5);
    let R = Slice(__opcode, 22, 1);
    let A = Slice(__opcode, 23, 1);
    let size = Slice(__opcode, 30, 2);
    decode_ldadd_aarch64_instrs_memory_atomicops_ld(Rt, Rn, opc, Rs, R, A, size)
}

val decode_ldaddb_aarch64_instrs_memory_atomicops_ld : (bits(5), bits(5), bits(3), bits(5), bits(1), bits(1), bits(2)) -> unit

function decode_ldaddb_aarch64_instrs_memory_atomicops_ld (Rt, Rn, opc, Rs, R, A, size) = {
    if not_bool(HaveAtomicExt()) then {
        throw(Error_Undefined())
    };
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 's = UInt(Rs);
    let 'datasize = (8 << UInt(size));
    let 'regsize = if datasize == 64 then 64 else 32;
    let acquire : bool = A == 0b1 & Rt != 0b11111;
    let is_load : bool = Rt != 0b11111;
    let release : bool = R == 0b1;
    op : MemAtomicOp = undefined;
    match opc {
      0b000 => {
          op = MemAtomicOp_ADD
      },
      0b001 => {
          op = MemAtomicOp_BIC
      },
      0b010 => {
          op = MemAtomicOp_EOR
      },
      0b011 => {
          op = MemAtomicOp_ORR
      },
      0b100 => {
          op = MemAtomicOp_SMAX
      },
      0b101 => {
          op = MemAtomicOp_SMIN
      },
      0b110 => {
          op = MemAtomicOp_UMAX
      },
      0b111 => {
          op = MemAtomicOp_UMIN
      }
    };
    let op = op;
    let tagchecked : bool = n != 31;
    execute_aarch64_instrs_memory_atomicops_ld(acquire, datasize, is_load, n, op, regsize, release, s, t, tagchecked)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 526) = {
    SEE = 526;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let opc = Slice(__opcode, 12, 3);
    let Rs = Slice(__opcode, 16, 5);
    let R = Slice(__opcode, 22, 1);
    let A = Slice(__opcode, 23, 1);
    let size = Slice(__opcode, 30, 2);
    decode_ldaddb_aarch64_instrs_memory_atomicops_ld(Rt, Rn, opc, Rs, R, A, size)
}

val decode_ldaddh_aarch64_instrs_memory_atomicops_ld : (bits(5), bits(5), bits(3), bits(5), bits(1), bits(1), bits(2)) -> unit

function decode_ldaddh_aarch64_instrs_memory_atomicops_ld (Rt, Rn, opc, Rs, R, A, size) = {
    if not_bool(HaveAtomicExt()) then {
        throw(Error_Undefined())
    };
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 's = UInt(Rs);
    let 'datasize = (8 << UInt(size));
    let 'regsize = if datasize == 64 then 64 else 32;
    let acquire : bool = A == 0b1 & Rt != 0b11111;
    let is_load : bool = Rt != 0b11111;
    let release : bool = R == 0b1;
    op : MemAtomicOp = undefined;
    match opc {
      0b000 => {
          op = MemAtomicOp_ADD
      },
      0b001 => {
          op = MemAtomicOp_BIC
      },
      0b010 => {
          op = MemAtomicOp_EOR
      },
      0b011 => {
          op = MemAtomicOp_ORR
      },
      0b100 => {
          op = MemAtomicOp_SMAX
      },
      0b101 => {
          op = MemAtomicOp_SMIN
      },
      0b110 => {
          op = MemAtomicOp_UMAX
      },
      0b111 => {
          op = MemAtomicOp_UMIN
      }
    };
    let op = op;
    let tagchecked : bool = n != 31;
    execute_aarch64_instrs_memory_atomicops_ld(acquire, datasize, is_load, n, op, regsize, release, s, t, tagchecked)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 527) = {
    SEE = 527;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let opc = Slice(__opcode, 12, 3);
    let Rs = Slice(__opcode, 16, 5);
    let R = Slice(__opcode, 22, 1);
    let A = Slice(__opcode, 23, 1);
    let size = Slice(__opcode, 30, 2);
    decode_ldaddh_aarch64_instrs_memory_atomicops_ld(Rt, Rn, opc, Rs, R, A, size)
}

val decode_ldclr_aarch64_instrs_memory_atomicops_ld : (bits(5), bits(5), bits(3), bits(5), bits(1), bits(1), bits(2)) -> unit

function decode_ldclr_aarch64_instrs_memory_atomicops_ld (Rt, Rn, opc, Rs, R, A, size) = {
    if not_bool(HaveAtomicExt()) then {
        throw(Error_Undefined())
    };
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 's = UInt(Rs);
    let 'datasize = (8 << UInt(size));
    let 'regsize = if datasize == 64 then 64 else 32;
    let acquire : bool = A == 0b1 & Rt != 0b11111;
    let is_load : bool = Rt != 0b11111;
    let release : bool = R == 0b1;
    op : MemAtomicOp = undefined;
    match opc {
      0b000 => {
          op = MemAtomicOp_ADD
      },
      0b001 => {
          op = MemAtomicOp_BIC
      },
      0b010 => {
          op = MemAtomicOp_EOR
      },
      0b011 => {
          op = MemAtomicOp_ORR
      },
      0b100 => {
          op = MemAtomicOp_SMAX
      },
      0b101 => {
          op = MemAtomicOp_SMIN
      },
      0b110 => {
          op = MemAtomicOp_UMAX
      },
      0b111 => {
          op = MemAtomicOp_UMIN
      }
    };
    let op = op;
    let tagchecked : bool = n != 31;
    execute_aarch64_instrs_memory_atomicops_ld(acquire, datasize, is_load, n, op, regsize, release, s, t, tagchecked)
}

function clause __DecodeA64_LoadStore ((pc, ([bitone, _, bitone, bitone, bitone, bitzero, bitzero, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 528) = {
    SEE = 528;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let opc = Slice(__opcode, 12, 3);
    let Rs = Slice(__opcode, 16, 5);
    let R = Slice(__opcode, 22, 1);
    let A = Slice(__opcode, 23, 1);
    let size = Slice(__opcode, 30, 2);
    decode_ldclr_aarch64_instrs_memory_atomicops_ld(Rt, Rn, opc, Rs, R, A, size)
}

val decode_ldclrb_aarch64_instrs_memory_atomicops_ld : (bits(5), bits(5), bits(3), bits(5), bits(1), bits(1), bits(2)) -> unit

function decode_ldclrb_aarch64_instrs_memory_atomicops_ld (Rt, Rn, opc, Rs, R, A, size) = {
    if not_bool(HaveAtomicExt()) then {
        throw(Error_Undefined())
    };
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 's = UInt(Rs);
    let 'datasize = (8 << UInt(size));
    let 'regsize = if datasize == 64 then 64 else 32;
    let acquire : bool = A == 0b1 & Rt != 0b11111;
    let is_load : bool = Rt != 0b11111;
    let release : bool = R == 0b1;
    op : MemAtomicOp = undefined;
    match opc {
      0b000 => {
          op = MemAtomicOp_ADD
      },
      0b001 => {
          op = MemAtomicOp_BIC
      },
      0b010 => {
          op = MemAtomicOp_EOR
      },
      0b011 => {
          op = MemAtomicOp_ORR
      },
      0b100 => {
          op = MemAtomicOp_SMAX
      },
      0b101 => {
          op = MemAtomicOp_SMIN
      },
      0b110 => {
          op = MemAtomicOp_UMAX
      },
      0b111 => {
          op = MemAtomicOp_UMIN
      }
    };
    let op = op;
    let tagchecked : bool = n != 31;
    execute_aarch64_instrs_memory_atomicops_ld(acquire, datasize, is_load, n, op, regsize, release, s, t, tagchecked)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 529) = {
    SEE = 529;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let opc = Slice(__opcode, 12, 3);
    let Rs = Slice(__opcode, 16, 5);
    let R = Slice(__opcode, 22, 1);
    let A = Slice(__opcode, 23, 1);
    let size = Slice(__opcode, 30, 2);
    decode_ldclrb_aarch64_instrs_memory_atomicops_ld(Rt, Rn, opc, Rs, R, A, size)
}

val decode_ldclrh_aarch64_instrs_memory_atomicops_ld : (bits(5), bits(5), bits(3), bits(5), bits(1), bits(1), bits(2)) -> unit

function decode_ldclrh_aarch64_instrs_memory_atomicops_ld (Rt, Rn, opc, Rs, R, A, size) = {
    if not_bool(HaveAtomicExt()) then {
        throw(Error_Undefined())
    };
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 's = UInt(Rs);
    let 'datasize = (8 << UInt(size));
    let 'regsize = if datasize == 64 then 64 else 32;
    let acquire : bool = A == 0b1 & Rt != 0b11111;
    let is_load : bool = Rt != 0b11111;
    let release : bool = R == 0b1;
    op : MemAtomicOp = undefined;
    match opc {
      0b000 => {
          op = MemAtomicOp_ADD
      },
      0b001 => {
          op = MemAtomicOp_BIC
      },
      0b010 => {
          op = MemAtomicOp_EOR
      },
      0b011 => {
          op = MemAtomicOp_ORR
      },
      0b100 => {
          op = MemAtomicOp_SMAX
      },
      0b101 => {
          op = MemAtomicOp_SMIN
      },
      0b110 => {
          op = MemAtomicOp_UMAX
      },
      0b111 => {
          op = MemAtomicOp_UMIN
      }
    };
    let op = op;
    let tagchecked : bool = n != 31;
    execute_aarch64_instrs_memory_atomicops_ld(acquire, datasize, is_load, n, op, regsize, release, s, t, tagchecked)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 530) = {
    SEE = 530;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let opc = Slice(__opcode, 12, 3);
    let Rs = Slice(__opcode, 16, 5);
    let R = Slice(__opcode, 22, 1);
    let A = Slice(__opcode, 23, 1);
    let size = Slice(__opcode, 30, 2);
    decode_ldclrh_aarch64_instrs_memory_atomicops_ld(Rt, Rn, opc, Rs, R, A, size)
}

val decode_ldeor_aarch64_instrs_memory_atomicops_ld : (bits(5), bits(5), bits(3), bits(5), bits(1), bits(1), bits(2)) -> unit

function decode_ldeor_aarch64_instrs_memory_atomicops_ld (Rt, Rn, opc, Rs, R, A, size) = {
    if not_bool(HaveAtomicExt()) then {
        throw(Error_Undefined())
    };
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 's = UInt(Rs);
    let 'datasize = (8 << UInt(size));
    let 'regsize = if datasize == 64 then 64 else 32;
    let acquire : bool = A == 0b1 & Rt != 0b11111;
    let is_load : bool = Rt != 0b11111;
    let release : bool = R == 0b1;
    op : MemAtomicOp = undefined;
    match opc {
      0b000 => {
          op = MemAtomicOp_ADD
      },
      0b001 => {
          op = MemAtomicOp_BIC
      },
      0b010 => {
          op = MemAtomicOp_EOR
      },
      0b011 => {
          op = MemAtomicOp_ORR
      },
      0b100 => {
          op = MemAtomicOp_SMAX
      },
      0b101 => {
          op = MemAtomicOp_SMIN
      },
      0b110 => {
          op = MemAtomicOp_UMAX
      },
      0b111 => {
          op = MemAtomicOp_UMIN
      }
    };
    let op = op;
    let tagchecked : bool = n != 31;
    execute_aarch64_instrs_memory_atomicops_ld(acquire, datasize, is_load, n, op, regsize, release, s, t, tagchecked)
}

function clause __DecodeA64_LoadStore ((pc, ([bitone, _, bitone, bitone, bitone, bitzero, bitzero, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 531) = {
    SEE = 531;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let opc = Slice(__opcode, 12, 3);
    let Rs = Slice(__opcode, 16, 5);
    let R = Slice(__opcode, 22, 1);
    let A = Slice(__opcode, 23, 1);
    let size = Slice(__opcode, 30, 2);
    decode_ldeor_aarch64_instrs_memory_atomicops_ld(Rt, Rn, opc, Rs, R, A, size)
}

val decode_ldeorb_aarch64_instrs_memory_atomicops_ld : (bits(5), bits(5), bits(3), bits(5), bits(1), bits(1), bits(2)) -> unit

function decode_ldeorb_aarch64_instrs_memory_atomicops_ld (Rt, Rn, opc, Rs, R, A, size) = {
    if not_bool(HaveAtomicExt()) then {
        throw(Error_Undefined())
    };
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 's = UInt(Rs);
    let 'datasize = (8 << UInt(size));
    let 'regsize = if datasize == 64 then 64 else 32;
    let acquire : bool = A == 0b1 & Rt != 0b11111;
    let is_load : bool = Rt != 0b11111;
    let release : bool = R == 0b1;
    op : MemAtomicOp = undefined;
    match opc {
      0b000 => {
          op = MemAtomicOp_ADD
      },
      0b001 => {
          op = MemAtomicOp_BIC
      },
      0b010 => {
          op = MemAtomicOp_EOR
      },
      0b011 => {
          op = MemAtomicOp_ORR
      },
      0b100 => {
          op = MemAtomicOp_SMAX
      },
      0b101 => {
          op = MemAtomicOp_SMIN
      },
      0b110 => {
          op = MemAtomicOp_UMAX
      },
      0b111 => {
          op = MemAtomicOp_UMIN
      }
    };
    let op = op;
    let tagchecked : bool = n != 31;
    execute_aarch64_instrs_memory_atomicops_ld(acquire, datasize, is_load, n, op, regsize, release, s, t, tagchecked)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 532) = {
    SEE = 532;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let opc = Slice(__opcode, 12, 3);
    let Rs = Slice(__opcode, 16, 5);
    let R = Slice(__opcode, 22, 1);
    let A = Slice(__opcode, 23, 1);
    let size = Slice(__opcode, 30, 2);
    decode_ldeorb_aarch64_instrs_memory_atomicops_ld(Rt, Rn, opc, Rs, R, A, size)
}

val decode_ldeorh_aarch64_instrs_memory_atomicops_ld : (bits(5), bits(5), bits(3), bits(5), bits(1), bits(1), bits(2)) -> unit

function decode_ldeorh_aarch64_instrs_memory_atomicops_ld (Rt, Rn, opc, Rs, R, A, size) = {
    if not_bool(HaveAtomicExt()) then {
        throw(Error_Undefined())
    };
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 's = UInt(Rs);
    let 'datasize = (8 << UInt(size));
    let 'regsize = if datasize == 64 then 64 else 32;
    let acquire : bool = A == 0b1 & Rt != 0b11111;
    let is_load : bool = Rt != 0b11111;
    let release : bool = R == 0b1;
    op : MemAtomicOp = undefined;
    match opc {
      0b000 => {
          op = MemAtomicOp_ADD
      },
      0b001 => {
          op = MemAtomicOp_BIC
      },
      0b010 => {
          op = MemAtomicOp_EOR
      },
      0b011 => {
          op = MemAtomicOp_ORR
      },
      0b100 => {
          op = MemAtomicOp_SMAX
      },
      0b101 => {
          op = MemAtomicOp_SMIN
      },
      0b110 => {
          op = MemAtomicOp_UMAX
      },
      0b111 => {
          op = MemAtomicOp_UMIN
      }
    };
    let op = op;
    let tagchecked : bool = n != 31;
    execute_aarch64_instrs_memory_atomicops_ld(acquire, datasize, is_load, n, op, regsize, release, s, t, tagchecked)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 533) = {
    SEE = 533;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let opc = Slice(__opcode, 12, 3);
    let Rs = Slice(__opcode, 16, 5);
    let R = Slice(__opcode, 22, 1);
    let A = Slice(__opcode, 23, 1);
    let size = Slice(__opcode, 30, 2);
    decode_ldeorh_aarch64_instrs_memory_atomicops_ld(Rt, Rn, opc, Rs, R, A, size)
}

val decode_ldset_aarch64_instrs_memory_atomicops_ld : (bits(5), bits(5), bits(3), bits(5), bits(1), bits(1), bits(2)) -> unit

function decode_ldset_aarch64_instrs_memory_atomicops_ld (Rt, Rn, opc, Rs, R, A, size) = {
    if not_bool(HaveAtomicExt()) then {
        throw(Error_Undefined())
    };
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 's = UInt(Rs);
    let 'datasize = (8 << UInt(size));
    let 'regsize = if datasize == 64 then 64 else 32;
    let acquire : bool = A == 0b1 & Rt != 0b11111;
    let is_load : bool = Rt != 0b11111;
    let release : bool = R == 0b1;
    op : MemAtomicOp = undefined;
    match opc {
      0b000 => {
          op = MemAtomicOp_ADD
      },
      0b001 => {
          op = MemAtomicOp_BIC
      },
      0b010 => {
          op = MemAtomicOp_EOR
      },
      0b011 => {
          op = MemAtomicOp_ORR
      },
      0b100 => {
          op = MemAtomicOp_SMAX
      },
      0b101 => {
          op = MemAtomicOp_SMIN
      },
      0b110 => {
          op = MemAtomicOp_UMAX
      },
      0b111 => {
          op = MemAtomicOp_UMIN
      }
    };
    let op = op;
    let tagchecked : bool = n != 31;
    execute_aarch64_instrs_memory_atomicops_ld(acquire, datasize, is_load, n, op, regsize, release, s, t, tagchecked)
}

function clause __DecodeA64_LoadStore ((pc, ([bitone, _, bitone, bitone, bitone, bitzero, bitzero, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitzero, bitone, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 534) = {
    SEE = 534;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let opc = Slice(__opcode, 12, 3);
    let Rs = Slice(__opcode, 16, 5);
    let R = Slice(__opcode, 22, 1);
    let A = Slice(__opcode, 23, 1);
    let size = Slice(__opcode, 30, 2);
    decode_ldset_aarch64_instrs_memory_atomicops_ld(Rt, Rn, opc, Rs, R, A, size)
}

val decode_ldsetb_aarch64_instrs_memory_atomicops_ld : (bits(5), bits(5), bits(3), bits(5), bits(1), bits(1), bits(2)) -> unit

function decode_ldsetb_aarch64_instrs_memory_atomicops_ld (Rt, Rn, opc, Rs, R, A, size) = {
    if not_bool(HaveAtomicExt()) then {
        throw(Error_Undefined())
    };
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 's = UInt(Rs);
    let 'datasize = (8 << UInt(size));
    let 'regsize = if datasize == 64 then 64 else 32;
    let acquire : bool = A == 0b1 & Rt != 0b11111;
    let is_load : bool = Rt != 0b11111;
    let release : bool = R == 0b1;
    op : MemAtomicOp = undefined;
    match opc {
      0b000 => {
          op = MemAtomicOp_ADD
      },
      0b001 => {
          op = MemAtomicOp_BIC
      },
      0b010 => {
          op = MemAtomicOp_EOR
      },
      0b011 => {
          op = MemAtomicOp_ORR
      },
      0b100 => {
          op = MemAtomicOp_SMAX
      },
      0b101 => {
          op = MemAtomicOp_SMIN
      },
      0b110 => {
          op = MemAtomicOp_UMAX
      },
      0b111 => {
          op = MemAtomicOp_UMIN
      }
    };
    let op = op;
    let tagchecked : bool = n != 31;
    execute_aarch64_instrs_memory_atomicops_ld(acquire, datasize, is_load, n, op, regsize, release, s, t, tagchecked)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitzero, bitone, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 535) = {
    SEE = 535;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let opc = Slice(__opcode, 12, 3);
    let Rs = Slice(__opcode, 16, 5);
    let R = Slice(__opcode, 22, 1);
    let A = Slice(__opcode, 23, 1);
    let size = Slice(__opcode, 30, 2);
    decode_ldsetb_aarch64_instrs_memory_atomicops_ld(Rt, Rn, opc, Rs, R, A, size)
}

val decode_ldseth_aarch64_instrs_memory_atomicops_ld : (bits(5), bits(5), bits(3), bits(5), bits(1), bits(1), bits(2)) -> unit

function decode_ldseth_aarch64_instrs_memory_atomicops_ld (Rt, Rn, opc, Rs, R, A, size) = {
    if not_bool(HaveAtomicExt()) then {
        throw(Error_Undefined())
    };
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 's = UInt(Rs);
    let 'datasize = (8 << UInt(size));
    let 'regsize = if datasize == 64 then 64 else 32;
    let acquire : bool = A == 0b1 & Rt != 0b11111;
    let is_load : bool = Rt != 0b11111;
    let release : bool = R == 0b1;
    op : MemAtomicOp = undefined;
    match opc {
      0b000 => {
          op = MemAtomicOp_ADD
      },
      0b001 => {
          op = MemAtomicOp_BIC
      },
      0b010 => {
          op = MemAtomicOp_EOR
      },
      0b011 => {
          op = MemAtomicOp_ORR
      },
      0b100 => {
          op = MemAtomicOp_SMAX
      },
      0b101 => {
          op = MemAtomicOp_SMIN
      },
      0b110 => {
          op = MemAtomicOp_UMAX
      },
      0b111 => {
          op = MemAtomicOp_UMIN
      }
    };
    let op = op;
    let tagchecked : bool = n != 31;
    execute_aarch64_instrs_memory_atomicops_ld(acquire, datasize, is_load, n, op, regsize, release, s, t, tagchecked)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitzero, bitone, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 536) = {
    SEE = 536;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let opc = Slice(__opcode, 12, 3);
    let Rs = Slice(__opcode, 16, 5);
    let R = Slice(__opcode, 22, 1);
    let A = Slice(__opcode, 23, 1);
    let size = Slice(__opcode, 30, 2);
    decode_ldseth_aarch64_instrs_memory_atomicops_ld(Rt, Rn, opc, Rs, R, A, size)
}

val decode_ldsmax_aarch64_instrs_memory_atomicops_ld : (bits(5), bits(5), bits(3), bits(5), bits(1), bits(1), bits(2)) -> unit

function decode_ldsmax_aarch64_instrs_memory_atomicops_ld (Rt, Rn, opc, Rs, R, A, size) = {
    if not_bool(HaveAtomicExt()) then {
        throw(Error_Undefined())
    };
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 's = UInt(Rs);
    let 'datasize = (8 << UInt(size));
    let 'regsize = if datasize == 64 then 64 else 32;
    let acquire : bool = A == 0b1 & Rt != 0b11111;
    let is_load : bool = Rt != 0b11111;
    let release : bool = R == 0b1;
    op : MemAtomicOp = undefined;
    match opc {
      0b000 => {
          op = MemAtomicOp_ADD
      },
      0b001 => {
          op = MemAtomicOp_BIC
      },
      0b010 => {
          op = MemAtomicOp_EOR
      },
      0b011 => {
          op = MemAtomicOp_ORR
      },
      0b100 => {
          op = MemAtomicOp_SMAX
      },
      0b101 => {
          op = MemAtomicOp_SMIN
      },
      0b110 => {
          op = MemAtomicOp_UMAX
      },
      0b111 => {
          op = MemAtomicOp_UMIN
      }
    };
    let op = op;
    let tagchecked : bool = n != 31;
    execute_aarch64_instrs_memory_atomicops_ld(acquire, datasize, is_load, n, op, regsize, release, s, t, tagchecked)
}

function clause __DecodeA64_LoadStore ((pc, ([bitone, _, bitone, bitone, bitone, bitzero, bitzero, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 537) = {
    SEE = 537;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let opc = Slice(__opcode, 12, 3);
    let Rs = Slice(__opcode, 16, 5);
    let R = Slice(__opcode, 22, 1);
    let A = Slice(__opcode, 23, 1);
    let size = Slice(__opcode, 30, 2);
    decode_ldsmax_aarch64_instrs_memory_atomicops_ld(Rt, Rn, opc, Rs, R, A, size)
}

val decode_ldsmaxb_aarch64_instrs_memory_atomicops_ld : (bits(5), bits(5), bits(3), bits(5), bits(1), bits(1), bits(2)) -> unit

function decode_ldsmaxb_aarch64_instrs_memory_atomicops_ld (Rt, Rn, opc, Rs, R, A, size) = {
    if not_bool(HaveAtomicExt()) then {
        throw(Error_Undefined())
    };
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 's = UInt(Rs);
    let 'datasize = (8 << UInt(size));
    let 'regsize = if datasize == 64 then 64 else 32;
    let acquire : bool = A == 0b1 & Rt != 0b11111;
    let is_load : bool = Rt != 0b11111;
    let release : bool = R == 0b1;
    op : MemAtomicOp = undefined;
    match opc {
      0b000 => {
          op = MemAtomicOp_ADD
      },
      0b001 => {
          op = MemAtomicOp_BIC
      },
      0b010 => {
          op = MemAtomicOp_EOR
      },
      0b011 => {
          op = MemAtomicOp_ORR
      },
      0b100 => {
          op = MemAtomicOp_SMAX
      },
      0b101 => {
          op = MemAtomicOp_SMIN
      },
      0b110 => {
          op = MemAtomicOp_UMAX
      },
      0b111 => {
          op = MemAtomicOp_UMIN
      }
    };
    let op = op;
    let tagchecked : bool = n != 31;
    execute_aarch64_instrs_memory_atomicops_ld(acquire, datasize, is_load, n, op, regsize, release, s, t, tagchecked)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 538) = {
    SEE = 538;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let opc = Slice(__opcode, 12, 3);
    let Rs = Slice(__opcode, 16, 5);
    let R = Slice(__opcode, 22, 1);
    let A = Slice(__opcode, 23, 1);
    let size = Slice(__opcode, 30, 2);
    decode_ldsmaxb_aarch64_instrs_memory_atomicops_ld(Rt, Rn, opc, Rs, R, A, size)
}

val decode_ldsmaxh_aarch64_instrs_memory_atomicops_ld : (bits(5), bits(5), bits(3), bits(5), bits(1), bits(1), bits(2)) -> unit

function decode_ldsmaxh_aarch64_instrs_memory_atomicops_ld (Rt, Rn, opc, Rs, R, A, size) = {
    if not_bool(HaveAtomicExt()) then {
        throw(Error_Undefined())
    };
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 's = UInt(Rs);
    let 'datasize = (8 << UInt(size));
    let 'regsize = if datasize == 64 then 64 else 32;
    let acquire : bool = A == 0b1 & Rt != 0b11111;
    let is_load : bool = Rt != 0b11111;
    let release : bool = R == 0b1;
    op : MemAtomicOp = undefined;
    match opc {
      0b000 => {
          op = MemAtomicOp_ADD
      },
      0b001 => {
          op = MemAtomicOp_BIC
      },
      0b010 => {
          op = MemAtomicOp_EOR
      },
      0b011 => {
          op = MemAtomicOp_ORR
      },
      0b100 => {
          op = MemAtomicOp_SMAX
      },
      0b101 => {
          op = MemAtomicOp_SMIN
      },
      0b110 => {
          op = MemAtomicOp_UMAX
      },
      0b111 => {
          op = MemAtomicOp_UMIN
      }
    };
    let op = op;
    let tagchecked : bool = n != 31;
    execute_aarch64_instrs_memory_atomicops_ld(acquire, datasize, is_load, n, op, regsize, release, s, t, tagchecked)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 539) = {
    SEE = 539;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let opc = Slice(__opcode, 12, 3);
    let Rs = Slice(__opcode, 16, 5);
    let R = Slice(__opcode, 22, 1);
    let A = Slice(__opcode, 23, 1);
    let size = Slice(__opcode, 30, 2);
    decode_ldsmaxh_aarch64_instrs_memory_atomicops_ld(Rt, Rn, opc, Rs, R, A, size)
}

val decode_ldsmin_aarch64_instrs_memory_atomicops_ld : (bits(5), bits(5), bits(3), bits(5), bits(1), bits(1), bits(2)) -> unit

function decode_ldsmin_aarch64_instrs_memory_atomicops_ld (Rt, Rn, opc, Rs, R, A, size) = {
    if not_bool(HaveAtomicExt()) then {
        throw(Error_Undefined())
    };
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 's = UInt(Rs);
    let 'datasize = (8 << UInt(size));
    let 'regsize = if datasize == 64 then 64 else 32;
    let acquire : bool = A == 0b1 & Rt != 0b11111;
    let is_load : bool = Rt != 0b11111;
    let release : bool = R == 0b1;
    op : MemAtomicOp = undefined;
    match opc {
      0b000 => {
          op = MemAtomicOp_ADD
      },
      0b001 => {
          op = MemAtomicOp_BIC
      },
      0b010 => {
          op = MemAtomicOp_EOR
      },
      0b011 => {
          op = MemAtomicOp_ORR
      },
      0b100 => {
          op = MemAtomicOp_SMAX
      },
      0b101 => {
          op = MemAtomicOp_SMIN
      },
      0b110 => {
          op = MemAtomicOp_UMAX
      },
      0b111 => {
          op = MemAtomicOp_UMIN
      }
    };
    let op = op;
    let tagchecked : bool = n != 31;
    execute_aarch64_instrs_memory_atomicops_ld(acquire, datasize, is_load, n, op, regsize, release, s, t, tagchecked)
}

function clause __DecodeA64_LoadStore ((pc, ([bitone, _, bitone, bitone, bitone, bitzero, bitzero, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitone, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 540) = {
    SEE = 540;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let opc = Slice(__opcode, 12, 3);
    let Rs = Slice(__opcode, 16, 5);
    let R = Slice(__opcode, 22, 1);
    let A = Slice(__opcode, 23, 1);
    let size = Slice(__opcode, 30, 2);
    decode_ldsmin_aarch64_instrs_memory_atomicops_ld(Rt, Rn, opc, Rs, R, A, size)
}

val decode_ldsminb_aarch64_instrs_memory_atomicops_ld : (bits(5), bits(5), bits(3), bits(5), bits(1), bits(1), bits(2)) -> unit

function decode_ldsminb_aarch64_instrs_memory_atomicops_ld (Rt, Rn, opc, Rs, R, A, size) = {
    if not_bool(HaveAtomicExt()) then {
        throw(Error_Undefined())
    };
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 's = UInt(Rs);
    let 'datasize = (8 << UInt(size));
    let 'regsize = if datasize == 64 then 64 else 32;
    let acquire : bool = A == 0b1 & Rt != 0b11111;
    let is_load : bool = Rt != 0b11111;
    let release : bool = R == 0b1;
    op : MemAtomicOp = undefined;
    match opc {
      0b000 => {
          op = MemAtomicOp_ADD
      },
      0b001 => {
          op = MemAtomicOp_BIC
      },
      0b010 => {
          op = MemAtomicOp_EOR
      },
      0b011 => {
          op = MemAtomicOp_ORR
      },
      0b100 => {
          op = MemAtomicOp_SMAX
      },
      0b101 => {
          op = MemAtomicOp_SMIN
      },
      0b110 => {
          op = MemAtomicOp_UMAX
      },
      0b111 => {
          op = MemAtomicOp_UMIN
      }
    };
    let op = op;
    let tagchecked : bool = n != 31;
    execute_aarch64_instrs_memory_atomicops_ld(acquire, datasize, is_load, n, op, regsize, release, s, t, tagchecked)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitone, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 541) = {
    SEE = 541;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let opc = Slice(__opcode, 12, 3);
    let Rs = Slice(__opcode, 16, 5);
    let R = Slice(__opcode, 22, 1);
    let A = Slice(__opcode, 23, 1);
    let size = Slice(__opcode, 30, 2);
    decode_ldsminb_aarch64_instrs_memory_atomicops_ld(Rt, Rn, opc, Rs, R, A, size)
}

val decode_ldsminh_aarch64_instrs_memory_atomicops_ld : (bits(5), bits(5), bits(3), bits(5), bits(1), bits(1), bits(2)) -> unit

function decode_ldsminh_aarch64_instrs_memory_atomicops_ld (Rt, Rn, opc, Rs, R, A, size) = {
    if not_bool(HaveAtomicExt()) then {
        throw(Error_Undefined())
    };
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 's = UInt(Rs);
    let 'datasize = (8 << UInt(size));
    let 'regsize = if datasize == 64 then 64 else 32;
    let acquire : bool = A == 0b1 & Rt != 0b11111;
    let is_load : bool = Rt != 0b11111;
    let release : bool = R == 0b1;
    op : MemAtomicOp = undefined;
    match opc {
      0b000 => {
          op = MemAtomicOp_ADD
      },
      0b001 => {
          op = MemAtomicOp_BIC
      },
      0b010 => {
          op = MemAtomicOp_EOR
      },
      0b011 => {
          op = MemAtomicOp_ORR
      },
      0b100 => {
          op = MemAtomicOp_SMAX
      },
      0b101 => {
          op = MemAtomicOp_SMIN
      },
      0b110 => {
          op = MemAtomicOp_UMAX
      },
      0b111 => {
          op = MemAtomicOp_UMIN
      }
    };
    let op = op;
    let tagchecked : bool = n != 31;
    execute_aarch64_instrs_memory_atomicops_ld(acquire, datasize, is_load, n, op, regsize, release, s, t, tagchecked)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitone, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 542) = {
    SEE = 542;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let opc = Slice(__opcode, 12, 3);
    let Rs = Slice(__opcode, 16, 5);
    let R = Slice(__opcode, 22, 1);
    let A = Slice(__opcode, 23, 1);
    let size = Slice(__opcode, 30, 2);
    decode_ldsminh_aarch64_instrs_memory_atomicops_ld(Rt, Rn, opc, Rs, R, A, size)
}

val decode_ldumax_aarch64_instrs_memory_atomicops_ld : (bits(5), bits(5), bits(3), bits(5), bits(1), bits(1), bits(2)) -> unit

function decode_ldumax_aarch64_instrs_memory_atomicops_ld (Rt, Rn, opc, Rs, R, A, size) = {
    if not_bool(HaveAtomicExt()) then {
        throw(Error_Undefined())
    };
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 's = UInt(Rs);
    let 'datasize = (8 << UInt(size));
    let 'regsize = if datasize == 64 then 64 else 32;
    let acquire : bool = A == 0b1 & Rt != 0b11111;
    let is_load : bool = Rt != 0b11111;
    let release : bool = R == 0b1;
    op : MemAtomicOp = undefined;
    match opc {
      0b000 => {
          op = MemAtomicOp_ADD
      },
      0b001 => {
          op = MemAtomicOp_BIC
      },
      0b010 => {
          op = MemAtomicOp_EOR
      },
      0b011 => {
          op = MemAtomicOp_ORR
      },
      0b100 => {
          op = MemAtomicOp_SMAX
      },
      0b101 => {
          op = MemAtomicOp_SMIN
      },
      0b110 => {
          op = MemAtomicOp_UMAX
      },
      0b111 => {
          op = MemAtomicOp_UMIN
      }
    };
    let op = op;
    let tagchecked : bool = n != 31;
    execute_aarch64_instrs_memory_atomicops_ld(acquire, datasize, is_load, n, op, regsize, release, s, t, tagchecked)
}

function clause __DecodeA64_LoadStore ((pc, ([bitone, _, bitone, bitone, bitone, bitzero, bitzero, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitone, bitone, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 543) = {
    SEE = 543;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let opc = Slice(__opcode, 12, 3);
    let Rs = Slice(__opcode, 16, 5);
    let R = Slice(__opcode, 22, 1);
    let A = Slice(__opcode, 23, 1);
    let size = Slice(__opcode, 30, 2);
    decode_ldumax_aarch64_instrs_memory_atomicops_ld(Rt, Rn, opc, Rs, R, A, size)
}

val decode_ldumaxb_aarch64_instrs_memory_atomicops_ld : (bits(5), bits(5), bits(3), bits(5), bits(1), bits(1), bits(2)) -> unit

function decode_ldumaxb_aarch64_instrs_memory_atomicops_ld (Rt, Rn, opc, Rs, R, A, size) = {
    if not_bool(HaveAtomicExt()) then {
        throw(Error_Undefined())
    };
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 's = UInt(Rs);
    let 'datasize = (8 << UInt(size));
    let 'regsize = if datasize == 64 then 64 else 32;
    let acquire : bool = A == 0b1 & Rt != 0b11111;
    let is_load : bool = Rt != 0b11111;
    let release : bool = R == 0b1;
    op : MemAtomicOp = undefined;
    match opc {
      0b000 => {
          op = MemAtomicOp_ADD
      },
      0b001 => {
          op = MemAtomicOp_BIC
      },
      0b010 => {
          op = MemAtomicOp_EOR
      },
      0b011 => {
          op = MemAtomicOp_ORR
      },
      0b100 => {
          op = MemAtomicOp_SMAX
      },
      0b101 => {
          op = MemAtomicOp_SMIN
      },
      0b110 => {
          op = MemAtomicOp_UMAX
      },
      0b111 => {
          op = MemAtomicOp_UMIN
      }
    };
    let op = op;
    let tagchecked : bool = n != 31;
    execute_aarch64_instrs_memory_atomicops_ld(acquire, datasize, is_load, n, op, regsize, release, s, t, tagchecked)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitone, bitone, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 544) = {
    SEE = 544;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let opc = Slice(__opcode, 12, 3);
    let Rs = Slice(__opcode, 16, 5);
    let R = Slice(__opcode, 22, 1);
    let A = Slice(__opcode, 23, 1);
    let size = Slice(__opcode, 30, 2);
    decode_ldumaxb_aarch64_instrs_memory_atomicops_ld(Rt, Rn, opc, Rs, R, A, size)
}

val decode_ldumaxh_aarch64_instrs_memory_atomicops_ld : (bits(5), bits(5), bits(3), bits(5), bits(1), bits(1), bits(2)) -> unit

function decode_ldumaxh_aarch64_instrs_memory_atomicops_ld (Rt, Rn, opc, Rs, R, A, size) = {
    if not_bool(HaveAtomicExt()) then {
        throw(Error_Undefined())
    };
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 's = UInt(Rs);
    let 'datasize = (8 << UInt(size));
    let 'regsize = if datasize == 64 then 64 else 32;
    let acquire : bool = A == 0b1 & Rt != 0b11111;
    let is_load : bool = Rt != 0b11111;
    let release : bool = R == 0b1;
    op : MemAtomicOp = undefined;
    match opc {
      0b000 => {
          op = MemAtomicOp_ADD
      },
      0b001 => {
          op = MemAtomicOp_BIC
      },
      0b010 => {
          op = MemAtomicOp_EOR
      },
      0b011 => {
          op = MemAtomicOp_ORR
      },
      0b100 => {
          op = MemAtomicOp_SMAX
      },
      0b101 => {
          op = MemAtomicOp_SMIN
      },
      0b110 => {
          op = MemAtomicOp_UMAX
      },
      0b111 => {
          op = MemAtomicOp_UMIN
      }
    };
    let op = op;
    let tagchecked : bool = n != 31;
    execute_aarch64_instrs_memory_atomicops_ld(acquire, datasize, is_load, n, op, regsize, release, s, t, tagchecked)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitone, bitone, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 545) = {
    SEE = 545;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let opc = Slice(__opcode, 12, 3);
    let Rs = Slice(__opcode, 16, 5);
    let R = Slice(__opcode, 22, 1);
    let A = Slice(__opcode, 23, 1);
    let size = Slice(__opcode, 30, 2);
    decode_ldumaxh_aarch64_instrs_memory_atomicops_ld(Rt, Rn, opc, Rs, R, A, size)
}

val decode_ldumin_aarch64_instrs_memory_atomicops_ld : (bits(5), bits(5), bits(3), bits(5), bits(1), bits(1), bits(2)) -> unit

function decode_ldumin_aarch64_instrs_memory_atomicops_ld (Rt, Rn, opc, Rs, R, A, size) = {
    if not_bool(HaveAtomicExt()) then {
        throw(Error_Undefined())
    };
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 's = UInt(Rs);
    let 'datasize = (8 << UInt(size));
    let 'regsize = if datasize == 64 then 64 else 32;
    let acquire : bool = A == 0b1 & Rt != 0b11111;
    let is_load : bool = Rt != 0b11111;
    let release : bool = R == 0b1;
    op : MemAtomicOp = undefined;
    match opc {
      0b000 => {
          op = MemAtomicOp_ADD
      },
      0b001 => {
          op = MemAtomicOp_BIC
      },
      0b010 => {
          op = MemAtomicOp_EOR
      },
      0b011 => {
          op = MemAtomicOp_ORR
      },
      0b100 => {
          op = MemAtomicOp_SMAX
      },
      0b101 => {
          op = MemAtomicOp_SMIN
      },
      0b110 => {
          op = MemAtomicOp_UMAX
      },
      0b111 => {
          op = MemAtomicOp_UMIN
      }
    };
    let op = op;
    let tagchecked : bool = n != 31;
    execute_aarch64_instrs_memory_atomicops_ld(acquire, datasize, is_load, n, op, regsize, release, s, t, tagchecked)
}

function clause __DecodeA64_LoadStore ((pc, ([bitone, _, bitone, bitone, bitone, bitzero, bitzero, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitone, bitone, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 546) = {
    SEE = 546;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let opc = Slice(__opcode, 12, 3);
    let Rs = Slice(__opcode, 16, 5);
    let R = Slice(__opcode, 22, 1);
    let A = Slice(__opcode, 23, 1);
    let size = Slice(__opcode, 30, 2);
    decode_ldumin_aarch64_instrs_memory_atomicops_ld(Rt, Rn, opc, Rs, R, A, size)
}

val decode_lduminb_aarch64_instrs_memory_atomicops_ld : (bits(5), bits(5), bits(3), bits(5), bits(1), bits(1), bits(2)) -> unit

function decode_lduminb_aarch64_instrs_memory_atomicops_ld (Rt, Rn, opc, Rs, R, A, size) = {
    if not_bool(HaveAtomicExt()) then {
        throw(Error_Undefined())
    };
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 's = UInt(Rs);
    let 'datasize = (8 << UInt(size));
    let 'regsize = if datasize == 64 then 64 else 32;
    let acquire : bool = A == 0b1 & Rt != 0b11111;
    let is_load : bool = Rt != 0b11111;
    let release : bool = R == 0b1;
    op : MemAtomicOp = undefined;
    match opc {
      0b000 => {
          op = MemAtomicOp_ADD
      },
      0b001 => {
          op = MemAtomicOp_BIC
      },
      0b010 => {
          op = MemAtomicOp_EOR
      },
      0b011 => {
          op = MemAtomicOp_ORR
      },
      0b100 => {
          op = MemAtomicOp_SMAX
      },
      0b101 => {
          op = MemAtomicOp_SMIN
      },
      0b110 => {
          op = MemAtomicOp_UMAX
      },
      0b111 => {
          op = MemAtomicOp_UMIN
      }
    };
    let op = op;
    let tagchecked : bool = n != 31;
    execute_aarch64_instrs_memory_atomicops_ld(acquire, datasize, is_load, n, op, regsize, release, s, t, tagchecked)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitone, bitone, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 547) = {
    SEE = 547;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let opc = Slice(__opcode, 12, 3);
    let Rs = Slice(__opcode, 16, 5);
    let R = Slice(__opcode, 22, 1);
    let A = Slice(__opcode, 23, 1);
    let size = Slice(__opcode, 30, 2);
    decode_lduminb_aarch64_instrs_memory_atomicops_ld(Rt, Rn, opc, Rs, R, A, size)
}

val decode_lduminh_aarch64_instrs_memory_atomicops_ld : (bits(5), bits(5), bits(3), bits(5), bits(1), bits(1), bits(2)) -> unit

function decode_lduminh_aarch64_instrs_memory_atomicops_ld (Rt, Rn, opc, Rs, R, A, size) = {
    if not_bool(HaveAtomicExt()) then {
        throw(Error_Undefined())
    };
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 's = UInt(Rs);
    let 'datasize = (8 << UInt(size));
    let 'regsize = if datasize == 64 then 64 else 32;
    let acquire : bool = A == 0b1 & Rt != 0b11111;
    let is_load : bool = Rt != 0b11111;
    let release : bool = R == 0b1;
    op : MemAtomicOp = undefined;
    match opc {
      0b000 => {
          op = MemAtomicOp_ADD
      },
      0b001 => {
          op = MemAtomicOp_BIC
      },
      0b010 => {
          op = MemAtomicOp_EOR
      },
      0b011 => {
          op = MemAtomicOp_ORR
      },
      0b100 => {
          op = MemAtomicOp_SMAX
      },
      0b101 => {
          op = MemAtomicOp_SMIN
      },
      0b110 => {
          op = MemAtomicOp_UMAX
      },
      0b111 => {
          op = MemAtomicOp_UMIN
      }
    };
    let op = op;
    let tagchecked : bool = n != 31;
    execute_aarch64_instrs_memory_atomicops_ld(acquire, datasize, is_load, n, op, regsize, release, s, t, tagchecked)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitone, bitone, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 548) = {
    SEE = 548;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let opc = Slice(__opcode, 12, 3);
    let Rs = Slice(__opcode, 16, 5);
    let R = Slice(__opcode, 22, 1);
    let A = Slice(__opcode, 23, 1);
    let size = Slice(__opcode, 30, 2);
    decode_lduminh_aarch64_instrs_memory_atomicops_ld(Rt, Rn, opc, Rs, R, A, size)
}

val execute_aarch64_instrs_memory_vector_single_no_wb_ordered : forall 'datasize 'esize 'index 'm 'n ('replicate : Bool) 'selem 't ('tagchecked : Bool) ('wback : Bool),
  (0 <= 't & 't <= 31 & 'selem in {1, 2, 3, 4} & 0 <= 'n & 'n <= 31 & 'esize in {8, 16, 32, 64} & 'datasize in {64, 128}).
  (int('datasize), int('esize), int('index), int('m), MemOp, int('n), bool('replicate), int('selem), int('t), bool('tagchecked), bool('wback)) -> unit

function execute_aarch64_instrs_memory_vector_single_no_wb_ordered (datasize, esize, index, m, memop, n, replicate, selem, t__arg, tagchecked, wback) = {
    t : int = t__arg;
    CheckFPAdvSIMDEnabled64();
    address : bits(64) = undefined;
    rval : bits(128) = undefined;
    element : bits('esize) = undefined;
    let 'ebytes = DIV(esize, 8);
    let accdesc : AccessDescriptor = CreateAccDescASIMDAcqRel(memop, tagchecked);
    if n == 31 then {
        CheckSPAlignment();
        address = SP_read()
    } else {
        address = X_read(n, 64)
    };
    offs : bits(64) = Zeros(64);
    if replicate then {
        foreach (s from 0 to (selem - 1) by 1 in inc) {
            element = Mem_read(address + offs, ebytes, accdesc);
            V_set(t, datasize) = Replicate(element, DIV(datasize, esize));
            offs = offs + ebytes;
            t = MOD(t + 1, 32)
        }
    } else {
        foreach (s from 0 to (selem - 1) by 1 in inc) {
            rval = V_read(t, 128);
            if memop == MemOp_LOAD then {
                rval = Elem_set(rval, index, esize, Mem_read(address + offs, ebytes, accdesc));
                V_set(t, 128) = rval
            } else {
                Mem_set(address + offs, ebytes, accdesc) = Elem_read(rval, index, esize)
            };
            offs = offs + ebytes;
            t = MOD(t + 1, 32)
        }
    };
    if SPESampleInFlight then {
        SPESampleSIMDFPLoadStore()
    };
    if wback then {
        if m != 31 then {
            offs = X_read(m, 64)
        };
        if n == 31 then {
            SP_set() = address + offs
        } else {
            X_set(n, 64) = address + offs
        }
    };
    ()
}

val decode_ldap1_advsimd_sngl_aarch64_instrs_memory_vector_single_no_wb_ordered : (bits(5), bits(5), bits(2), bits(1), bits(3), bits(1), bits(1), bits(1)) -> unit

function decode_ldap1_advsimd_sngl_aarch64_instrs_memory_vector_single_no_wb_ordered (Rt, Rn, size, S, opcode, R, L, Q) = {
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 'm = __UNKNOWN_integer();
    let wback : bool = false;
    let nontemporal : bool = false;
    let tagchecked : bool = wback | n != 31;
    let 'init_scale = UInt(opcode[2 .. 1]);
    scale : int = init_scale;
    let 'selem = UInt([opcode[0]] @ R) + 1;
    replicate : bool = false;
    index : int = undefined;
    match scale {
      3 => {
          if L == 0b0 | S == 0b1 then {
              throw(Error_Undefined())
          };
          scale = UInt(size);
          replicate = true
      },
      0 => {
          index = UInt((Q @ S) @ size)
      },
      1 => {
          if [size[0]] == 0b1 then {
              throw(Error_Undefined())
          };
          index = UInt((Q @ S) @ [size[1]])
      },
      2 => {
          if [size[1]] == 0b1 then {
              throw(Error_Undefined())
          };
          if [size[0]] == 0b0 then {
              index = UInt(Q @ S)
          } else {
              if S == 0b1 then {
                  throw(Error_Undefined())
              };
              index = UInt(Q);
              scale = 3
          }
      },
      _ => ()
    };
    let 'scale = scale;
    let 'index = index;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'esize = (8 << scale);
    assert(constraint('esize in {8, 16, 32, 64}));
    execute_aarch64_instrs_memory_vector_single_no_wb_ordered(datasize, esize, index, m, memop, n, replicate, selem, t, tagchecked, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 549) = {
    SEE = 549;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 10, 2);
    let S = Slice(__opcode, 12, 1);
    let opcode = Slice(__opcode, 13, 3);
    let R = Slice(__opcode, 21, 1);
    let L = Slice(__opcode, 22, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_ldap1_advsimd_sngl_aarch64_instrs_memory_vector_single_no_wb_ordered(Rt, Rn, size, S, opcode, R, L, Q)
}

val decode_stl1_advsimd_sngl_aarch64_instrs_memory_vector_single_no_wb_ordered : (bits(5), bits(5), bits(2), bits(1), bits(3), bits(1), bits(1), bits(1)) -> unit

function decode_stl1_advsimd_sngl_aarch64_instrs_memory_vector_single_no_wb_ordered (Rt, Rn, size, S, opcode, R, L, Q) = {
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 'm = __UNKNOWN_integer();
    let wback : bool = false;
    let nontemporal : bool = false;
    let tagchecked : bool = wback | n != 31;
    let 'init_scale = UInt(opcode[2 .. 1]);
    scale : int = init_scale;
    let 'selem = UInt([opcode[0]] @ R) + 1;
    replicate : bool = false;
    index : int = undefined;
    match scale {
      3 => {
          if L == 0b0 | S == 0b1 then {
              throw(Error_Undefined())
          };
          scale = UInt(size);
          replicate = true
      },
      0 => {
          index = UInt((Q @ S) @ size)
      },
      1 => {
          if [size[0]] == 0b1 then {
              throw(Error_Undefined())
          };
          index = UInt((Q @ S) @ [size[1]])
      },
      2 => {
          if [size[1]] == 0b1 then {
              throw(Error_Undefined())
          };
          if [size[0]] == 0b0 then {
              index = UInt(Q @ S)
          } else {
              if S == 0b1 then {
                  throw(Error_Undefined())
              };
              index = UInt(Q);
              scale = 3
          }
      },
      _ => ()
    };
    let 'scale = scale;
    let 'index = index;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'esize = (8 << scale);
    assert(constraint('esize in {8, 16, 32, 64}));
    execute_aarch64_instrs_memory_vector_single_no_wb_ordered(datasize, esize, index, m, memop, n, replicate, selem, t, tagchecked, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 550) = {
    SEE = 550;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 10, 2);
    let S = Slice(__opcode, 12, 1);
    let opcode = Slice(__opcode, 13, 3);
    let R = Slice(__opcode, 21, 1);
    let L = Slice(__opcode, 22, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_stl1_advsimd_sngl_aarch64_instrs_memory_vector_single_no_wb_ordered(Rt, Rn, size, S, opcode, R, L, Q)
}

val execute_aarch64_instrs_memory_ordered_rcpc : forall 'datasize 'n 'offset 'regsize 't ('tagchecked : Bool) ('wb_unknown : Bool) ('wback : Bool),
  (0 <= 't & 't <= 31 & 'regsize in {32, 64} & 'offset in {0, 1, 2, 4, 8} & 0 <= 'n & 'n <= 31 & 'datasize in {8, 16, 32, 64}).
  (int('datasize), int('n), int('offset), int('regsize), int('t), bool('tagchecked), bool('wb_unknown), bool('wback)) -> unit

function execute_aarch64_instrs_memory_ordered_rcpc (datasize, n, offset, regsize, t, tagchecked, wb_unknown, wback) = {
    address : bits(64) = undefined;
    let 'dbytes = DIV(datasize, 8);
    let accdesc : AccessDescriptor = CreateAccDescLDAcqPC(tagchecked);
    if n == 31 then {
        CheckSPAlignment();
        address = SP_read()
    } else {
        address = X_read(n, 64)
    };
    let data : bits('datasize) = Mem_read(address, dbytes, accdesc);
    assert(constraint('regsize >= 'datasize));
    X_set(t, regsize) = ZeroExtend(data, regsize);
    if wback then {
        if wb_unknown then {
            address = __UNKNOWN_bits(64)
        } else {
            address = address + offset
        };
        if n == 31 then {
            SP_set() = address
        } else {
            X_set(n, 64) = address
        }
    };
    if SPESampleInFlight then {
        let ar : bits(1) = 0b1;
        let excl : bits(1) = 0b0;
        let at : bits(1) = 0b0;
        let is_load : bool = true;
        SPESampleExtendedLoadStore(ar, excl, at, is_load)
    };
    ()
}

val decode_ldapr_aarch64_instrs_memory_ordered_rcpc : (bits(5), bits(5), bits(5), bits(2)) -> unit

function decode_ldapr_aarch64_instrs_memory_ordered_rcpc (Rt, Rn, Rs, size) = {
    let wback : bool = false;
    let 'offset = 0;
    let wb_unknown : bool = false;
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 's = UInt(Rs);
    let 'elsize = (8 << UInt(size));
    let 'regsize = if elsize == 64 then 64 else 32;
    let 'datasize = elsize;
    let tagchecked : bool = n != 31;
    execute_aarch64_instrs_memory_ordered_rcpc(datasize, n, offset, regsize, t, tagchecked, wb_unknown, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([bitone, _, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 551) = {
    SEE = 551;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rs = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 30, 2);
    if ((([__opcode[16]] != 0b1 | [__opcode[17]] != 0b1) | [__opcode[18]] != 0b1) | [__opcode[19]] != 0b1) | [__opcode[20]] != 0b1 then {
        throw(Error_ConstrainedUnpredictable())
    } else {
        decode_ldapr_aarch64_instrs_memory_ordered_rcpc(Rt, Rn, Rs, size)
    }
}

val decode_ldapr_aarch64_instrs_memory_ordered_rcpc_writeback : (bits(5), bits(5), bits(2)) -> unit

function decode_ldapr_aarch64_instrs_memory_ordered_rcpc_writeback (Rt, Rn, size) = {
    wback : bool = true;
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 'regsize = if size == 0b11 then 64 else 32;
    let 'datasize = (8 << UInt(size));
    let 'offset = (1 << UInt(size));
    let tagchecked : bool = wback | n != 31;
    wb_unknown : bool = false;
    if (wback & n == t) & n != 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
        assert(c == Constraint_WBSUPPRESS | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_WBSUPPRESS => {
              wback = false
          },
          Constraint_UNKNOWN => {
              wb_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    execute_aarch64_instrs_memory_ordered_rcpc(datasize, n, offset, regsize, t, tagchecked, wb_unknown, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([bitone, _, bitzero, bitone, bitone, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 552) = {
    SEE = 552;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 30, 2);
    decode_ldapr_aarch64_instrs_memory_ordered_rcpc_writeback(Rt, Rn, size)
}

val decode_ldaprb_aarch64_instrs_memory_ordered_rcpc : (bits(5), bits(5), bits(5), bits(2)) -> unit

function decode_ldaprb_aarch64_instrs_memory_ordered_rcpc (Rt, Rn, Rs, size) = {
    let wback : bool = false;
    let 'offset = 0;
    let wb_unknown : bool = false;
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 's = UInt(Rs);
    let 'elsize = (8 << UInt(size));
    let 'regsize = if elsize == 64 then 64 else 32;
    let 'datasize = elsize;
    let tagchecked : bool = n != 31;
    execute_aarch64_instrs_memory_ordered_rcpc(datasize, n, offset, regsize, t, tagchecked, wb_unknown, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 553) = {
    SEE = 553;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rs = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 30, 2);
    if ((([__opcode[16]] != 0b1 | [__opcode[17]] != 0b1) | [__opcode[18]] != 0b1) | [__opcode[19]] != 0b1) | [__opcode[20]] != 0b1 then {
        throw(Error_ConstrainedUnpredictable())
    } else {
        decode_ldaprb_aarch64_instrs_memory_ordered_rcpc(Rt, Rn, Rs, size)
    }
}

val decode_ldaprh_aarch64_instrs_memory_ordered_rcpc : (bits(5), bits(5), bits(5), bits(2)) -> unit

function decode_ldaprh_aarch64_instrs_memory_ordered_rcpc (Rt, Rn, Rs, size) = {
    let wback : bool = false;
    let 'offset = 0;
    let wb_unknown : bool = false;
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 's = UInt(Rs);
    let 'elsize = (8 << UInt(size));
    let 'regsize = if elsize == 64 then 64 else 32;
    let 'datasize = elsize;
    let tagchecked : bool = n != 31;
    execute_aarch64_instrs_memory_ordered_rcpc(datasize, n, offset, regsize, t, tagchecked, wb_unknown, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 554) = {
    SEE = 554;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rs = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 30, 2);
    if ((([__opcode[16]] != 0b1 | [__opcode[17]] != 0b1) | [__opcode[18]] != 0b1) | [__opcode[19]] != 0b1) | [__opcode[20]] != 0b1 then {
        throw(Error_ConstrainedUnpredictable())
    } else {
        decode_ldaprh_aarch64_instrs_memory_ordered_rcpc(Rt, Rn, Rs, size)
    }
}

val execute_aarch64_instrs_memory_single_general_immediate_signed_offset_lda_stl : forall 'datasize ('is_signed : Bool) 'n ('postindex : Bool) 'regsize ('rt_unknown : Bool) 't ('tagchecked : Bool) ('wb_unknown : Bool) ('wback : Bool),
  (0 <= 't & 't <= 31 & 'regsize in {32, 64} & 0 <= 'n & 'n <= 31 & 'datasize in {8, 16, 32, 64}).
  (int('datasize), MemOp, int('n), bits(64), bool('postindex), int('regsize), bool('rt_unknown), bool('is_signed), int('t), bool('tagchecked), bool('wb_unknown), bool('wback)) -> unit

function execute_aarch64_instrs_memory_single_general_immediate_signed_offset_lda_stl (datasize, memop, n, offset, postindex, regsize, rt_unknown, is_signed, t, tagchecked, wb_unknown, wback) = {
    address : bits(64) = undefined;
    data : bits('datasize) = undefined;
    accdesc : AccessDescriptor = undefined;
    if memop == MemOp_LOAD then {
        accdesc = CreateAccDescLDAcqPC(tagchecked)
    } else if memop == MemOp_STORE then {
        accdesc = CreateAccDescAcqRel(memop, tagchecked)
    } else ();
    if n == 31 then {
        if memop != MemOp_PREFETCH then {
            CheckSPAlignment()
        };
        address = SP_read()
    } else {
        address = X_read(n, 64)
    };
    if not_bool(postindex) then {
        address = address + offset
    };
    match memop {
      MemOp_STORE => {
          if rt_unknown then {
              data = __UNKNOWN_bits(datasize)
          } else {
              data = X_read(t, datasize)
          };
          if not_bool(wback) then {
              AArch64_SetLSInstructionSyndrome(DIV(datasize, 8), false, t, regsize == 64, false)
          };
          Mem_set(address, DIV(datasize, 8), accdesc) = data
      },
      MemOp_LOAD => {
          if not_bool(wback) then {
              AArch64_SetLSInstructionSyndrome(DIV(datasize, 8), is_signed, t, regsize == 64, false)
          };
          let data : bits('datasize) = Mem_read(address, DIV(datasize, 8), accdesc);
          if is_signed then {
              assert(constraint(('datasize > 0 & 'regsize >= 'datasize)));
              X_set(t, regsize) = SignExtend(data, regsize)
          } else {
              assert(constraint(('datasize >= 0 & 'regsize >= 'datasize)));
              X_set(t, regsize) = ZeroExtend(data, regsize)
          }
      },
      MemOp_PREFETCH => {
          Prefetch(address, t[4 .. 0])
      }
    };
    if wback then {
        if wb_unknown then {
            address = __UNKNOWN_bits(64)
        } else if postindex then {
            address = address + offset
        } else ();
        if n == 31 then {
            SP_set() = address
        } else {
            X_set(n, 64) = address
        }
    };
    if SPESampleInFlight then {
        SPESampleGeneralPurposeLoadStore()
    };
    ()
}

val decode_ldapur_gen_aarch64_instrs_memory_single_general_immediate_signed_offset_lda_stl : (bits(5), bits(5), bits(9), bits(2), bits(2)) -> unit

function decode_ldapur_gen_aarch64_instrs_memory_single_general_immediate_signed_offset_lda_stl (Rt, Rn, imm9, opc, size) = {
    wback : bool = false;
    let postindex : bool = false;
    let 'scale = UInt(size);
    let offset : bits(64) = SignExtend(imm9, 64);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    memop : MemOp = undefined;
    is_signed : bool = undefined;
    regsize : {32, 64} = 32;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        is_signed = false
    } else {
        if size == 0b11 then {
            throw(Error_Undefined())
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            };
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            is_signed = true
        }
    };
    let 'regsize = regsize;
    let 'datasize = (8 << scale);
    let tagchecked : bool = memop != MemOp_PREFETCH & (wback | n != 31);
    wb_unknown : bool = false;
    rt_unknown : bool = false;
    c : Constraint = undefined;
    if ((memop == MemOp_LOAD & wback) & n == t) & n != 31 then {
        c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
        assert(c == Constraint_WBSUPPRESS | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_WBSUPPRESS => {
              wback = false
          },
          Constraint_UNKNOWN => {
              wb_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    if ((memop == MemOp_STORE & wback) & n == t) & n != 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
        assert(c == Constraint_NONE | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_NONE => {
              rt_unknown = false
          },
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    execute_aarch64_instrs_memory_single_general_immediate_signed_offset_lda_stl(datasize, memop, n, offset, postindex, regsize, rt_unknown, is_signed, t, tagchecked, wb_unknown, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([bitone, _, bitzero, bitone, bitone, bitzero, bitzero, bitone, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 555) = {
    SEE = 555;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm9 = Slice(__opcode, 12, 9);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_ldapur_gen_aarch64_instrs_memory_single_general_immediate_signed_offset_lda_stl(Rt, Rn, imm9, opc, size)
}

val decode_ldapurb_aarch64_instrs_memory_single_general_immediate_signed_offset_lda_stl : (bits(5), bits(5), bits(9), bits(2), bits(2)) -> unit

function decode_ldapurb_aarch64_instrs_memory_single_general_immediate_signed_offset_lda_stl (Rt, Rn, imm9, opc, size) = {
    wback : bool = false;
    let postindex : bool = false;
    let 'scale = UInt(size);
    let offset : bits(64) = SignExtend(imm9, 64);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    memop : MemOp = undefined;
    is_signed : bool = undefined;
    regsize : {32, 64} = 32;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        is_signed = false
    } else {
        if size == 0b11 then {
            throw(Error_Undefined())
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            };
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            is_signed = true
        }
    };
    let 'regsize = regsize;
    let 'datasize = (8 << scale);
    let tagchecked : bool = memop != MemOp_PREFETCH & (wback | n != 31);
    wb_unknown : bool = false;
    rt_unknown : bool = false;
    c : Constraint = undefined;
    if ((memop == MemOp_LOAD & wback) & n == t) & n != 31 then {
        c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
        assert(c == Constraint_WBSUPPRESS | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_WBSUPPRESS => {
              wback = false
          },
          Constraint_UNKNOWN => {
              wb_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    if ((memop == MemOp_STORE & wback) & n == t) & n != 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
        assert(c == Constraint_NONE | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_NONE => {
              rt_unknown = false
          },
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    execute_aarch64_instrs_memory_single_general_immediate_signed_offset_lda_stl(datasize, memop, n, offset, postindex, regsize, rt_unknown, is_signed, t, tagchecked, wb_unknown, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitone, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 556) = {
    SEE = 556;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm9 = Slice(__opcode, 12, 9);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_ldapurb_aarch64_instrs_memory_single_general_immediate_signed_offset_lda_stl(Rt, Rn, imm9, opc, size)
}

val decode_ldapurh_aarch64_instrs_memory_single_general_immediate_signed_offset_lda_stl : (bits(5), bits(5), bits(9), bits(2), bits(2)) -> unit

function decode_ldapurh_aarch64_instrs_memory_single_general_immediate_signed_offset_lda_stl (Rt, Rn, imm9, opc, size) = {
    wback : bool = false;
    let postindex : bool = false;
    let 'scale = UInt(size);
    let offset : bits(64) = SignExtend(imm9, 64);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    memop : MemOp = undefined;
    is_signed : bool = undefined;
    regsize : {32, 64} = 32;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        is_signed = false
    } else {
        if size == 0b11 then {
            throw(Error_Undefined())
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            };
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            is_signed = true
        }
    };
    let 'regsize = regsize;
    let 'datasize = (8 << scale);
    let tagchecked : bool = memop != MemOp_PREFETCH & (wback | n != 31);
    wb_unknown : bool = false;
    rt_unknown : bool = false;
    c : Constraint = undefined;
    if ((memop == MemOp_LOAD & wback) & n == t) & n != 31 then {
        c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
        assert(c == Constraint_WBSUPPRESS | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_WBSUPPRESS => {
              wback = false
          },
          Constraint_UNKNOWN => {
              wb_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    if ((memop == MemOp_STORE & wback) & n == t) & n != 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
        assert(c == Constraint_NONE | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_NONE => {
              rt_unknown = false
          },
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    execute_aarch64_instrs_memory_single_general_immediate_signed_offset_lda_stl(datasize, memop, n, offset, postindex, regsize, rt_unknown, is_signed, t, tagchecked, wb_unknown, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitone, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 557) = {
    SEE = 557;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm9 = Slice(__opcode, 12, 9);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_ldapurh_aarch64_instrs_memory_single_general_immediate_signed_offset_lda_stl(Rt, Rn, imm9, opc, size)
}

val decode_ldapursb_aarch64_instrs_memory_single_general_immediate_signed_offset_lda_stl : (bits(5), bits(5), bits(9), bits(2), bits(2)) -> unit

function decode_ldapursb_aarch64_instrs_memory_single_general_immediate_signed_offset_lda_stl (Rt, Rn, imm9, opc, size) = {
    wback : bool = false;
    let postindex : bool = false;
    let 'scale = UInt(size);
    let offset : bits(64) = SignExtend(imm9, 64);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    memop : MemOp = undefined;
    is_signed : bool = undefined;
    regsize : {32, 64} = 32;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        is_signed = false
    } else {
        if size == 0b11 then {
            throw(Error_Undefined())
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            };
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            is_signed = true
        }
    };
    let 'regsize = regsize;
    let 'datasize = (8 << scale);
    let tagchecked : bool = memop != MemOp_PREFETCH & (wback | n != 31);
    wb_unknown : bool = false;
    rt_unknown : bool = false;
    c : Constraint = undefined;
    if ((memop == MemOp_LOAD & wback) & n == t) & n != 31 then {
        c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
        assert(c == Constraint_WBSUPPRESS | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_WBSUPPRESS => {
              wback = false
          },
          Constraint_UNKNOWN => {
              wb_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    if ((memop == MemOp_STORE & wback) & n == t) & n != 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
        assert(c == Constraint_NONE | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_NONE => {
              rt_unknown = false
          },
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    execute_aarch64_instrs_memory_single_general_immediate_signed_offset_lda_stl(datasize, memop, n, offset, postindex, regsize, rt_unknown, is_signed, t, tagchecked, wb_unknown, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitone, bitone, _, bitzero, _, _, _, _, _, _, _, _, _, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 558) = {
    SEE = 558;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm9 = Slice(__opcode, 12, 9);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_ldapursb_aarch64_instrs_memory_single_general_immediate_signed_offset_lda_stl(Rt, Rn, imm9, opc, size)
}

val decode_ldapursh_aarch64_instrs_memory_single_general_immediate_signed_offset_lda_stl : (bits(5), bits(5), bits(9), bits(2), bits(2)) -> unit

function decode_ldapursh_aarch64_instrs_memory_single_general_immediate_signed_offset_lda_stl (Rt, Rn, imm9, opc, size) = {
    wback : bool = false;
    let postindex : bool = false;
    let 'scale = UInt(size);
    let offset : bits(64) = SignExtend(imm9, 64);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    memop : MemOp = undefined;
    is_signed : bool = undefined;
    regsize : {32, 64} = 32;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        is_signed = false
    } else {
        if size == 0b11 then {
            throw(Error_Undefined())
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            };
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            is_signed = true
        }
    };
    let 'regsize = regsize;
    let 'datasize = (8 << scale);
    let tagchecked : bool = memop != MemOp_PREFETCH & (wback | n != 31);
    wb_unknown : bool = false;
    rt_unknown : bool = false;
    c : Constraint = undefined;
    if ((memop == MemOp_LOAD & wback) & n == t) & n != 31 then {
        c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
        assert(c == Constraint_WBSUPPRESS | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_WBSUPPRESS => {
              wback = false
          },
          Constraint_UNKNOWN => {
              wb_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    if ((memop == MemOp_STORE & wback) & n == t) & n != 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
        assert(c == Constraint_NONE | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_NONE => {
              rt_unknown = false
          },
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    execute_aarch64_instrs_memory_single_general_immediate_signed_offset_lda_stl(datasize, memop, n, offset, postindex, regsize, rt_unknown, is_signed, t, tagchecked, wb_unknown, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitone, bitone, _, bitzero, _, _, _, _, _, _, _, _, _, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 559) = {
    SEE = 559;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm9 = Slice(__opcode, 12, 9);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_ldapursh_aarch64_instrs_memory_single_general_immediate_signed_offset_lda_stl(Rt, Rn, imm9, opc, size)
}

val decode_ldapursw_aarch64_instrs_memory_single_general_immediate_signed_offset_lda_stl : (bits(5), bits(5), bits(9), bits(2), bits(2)) -> unit

function decode_ldapursw_aarch64_instrs_memory_single_general_immediate_signed_offset_lda_stl (Rt, Rn, imm9, opc, size) = {
    wback : bool = false;
    let postindex : bool = false;
    let 'scale = UInt(size);
    let offset : bits(64) = SignExtend(imm9, 64);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    memop : MemOp = undefined;
    is_signed : bool = undefined;
    regsize : {32, 64} = 32;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        is_signed = false
    } else {
        if size == 0b11 then {
            throw(Error_Undefined())
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            };
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            is_signed = true
        }
    };
    let 'regsize = regsize;
    let 'datasize = (8 << scale);
    let tagchecked : bool = memop != MemOp_PREFETCH & (wback | n != 31);
    wb_unknown : bool = false;
    rt_unknown : bool = false;
    c : Constraint = undefined;
    if ((memop == MemOp_LOAD & wback) & n == t) & n != 31 then {
        c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
        assert(c == Constraint_WBSUPPRESS | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_WBSUPPRESS => {
              wback = false
          },
          Constraint_UNKNOWN => {
              wb_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    if ((memop == MemOp_STORE & wback) & n == t) & n != 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
        assert(c == Constraint_NONE | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_NONE => {
              rt_unknown = false
          },
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    execute_aarch64_instrs_memory_single_general_immediate_signed_offset_lda_stl(datasize, memop, n, offset, postindex, regsize, rt_unknown, is_signed, t, tagchecked, wb_unknown, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([bitone, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitone, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 560) = {
    SEE = 560;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm9 = Slice(__opcode, 12, 9);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_ldapursw_aarch64_instrs_memory_single_general_immediate_signed_offset_lda_stl(Rt, Rn, imm9, opc, size)
}

val decode_stlur_gen_aarch64_instrs_memory_single_general_immediate_signed_offset_lda_stl : (bits(5), bits(5), bits(9), bits(2), bits(2)) -> unit

function decode_stlur_gen_aarch64_instrs_memory_single_general_immediate_signed_offset_lda_stl (Rt, Rn, imm9, opc, size) = {
    wback : bool = false;
    let postindex : bool = false;
    let 'scale = UInt(size);
    let offset : bits(64) = SignExtend(imm9, 64);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    memop : MemOp = undefined;
    is_signed : bool = undefined;
    regsize : {32, 64} = 32;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        is_signed = false
    } else {
        if size == 0b11 then {
            throw(Error_Undefined())
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            };
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            is_signed = true
        }
    };
    let 'regsize = regsize;
    let 'datasize = (8 << scale);
    let tagchecked : bool = memop != MemOp_PREFETCH & (wback | n != 31);
    wb_unknown : bool = false;
    rt_unknown : bool = false;
    c : Constraint = undefined;
    if ((memop == MemOp_LOAD & wback) & n == t) & n != 31 then {
        c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
        assert(c == Constraint_WBSUPPRESS | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_WBSUPPRESS => {
              wback = false
          },
          Constraint_UNKNOWN => {
              wb_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    if ((memop == MemOp_STORE & wback) & n == t) & n != 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
        assert(c == Constraint_NONE | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_NONE => {
              rt_unknown = false
          },
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    execute_aarch64_instrs_memory_single_general_immediate_signed_offset_lda_stl(datasize, memop, n, offset, postindex, regsize, rt_unknown, is_signed, t, tagchecked, wb_unknown, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([bitone, _, bitzero, bitone, bitone, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 561) = {
    SEE = 561;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm9 = Slice(__opcode, 12, 9);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_stlur_gen_aarch64_instrs_memory_single_general_immediate_signed_offset_lda_stl(Rt, Rn, imm9, opc, size)
}

val decode_stlurb_aarch64_instrs_memory_single_general_immediate_signed_offset_lda_stl : (bits(5), bits(5), bits(9), bits(2), bits(2)) -> unit

function decode_stlurb_aarch64_instrs_memory_single_general_immediate_signed_offset_lda_stl (Rt, Rn, imm9, opc, size) = {
    wback : bool = false;
    let postindex : bool = false;
    let 'scale = UInt(size);
    let offset : bits(64) = SignExtend(imm9, 64);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    memop : MemOp = undefined;
    is_signed : bool = undefined;
    regsize : {32, 64} = 32;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        is_signed = false
    } else {
        if size == 0b11 then {
            throw(Error_Undefined())
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            };
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            is_signed = true
        }
    };
    let 'regsize = regsize;
    let 'datasize = (8 << scale);
    let tagchecked : bool = memop != MemOp_PREFETCH & (wback | n != 31);
    wb_unknown : bool = false;
    rt_unknown : bool = false;
    c : Constraint = undefined;
    if ((memop == MemOp_LOAD & wback) & n == t) & n != 31 then {
        c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
        assert(c == Constraint_WBSUPPRESS | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_WBSUPPRESS => {
              wback = false
          },
          Constraint_UNKNOWN => {
              wb_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    if ((memop == MemOp_STORE & wback) & n == t) & n != 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
        assert(c == Constraint_NONE | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_NONE => {
              rt_unknown = false
          },
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    execute_aarch64_instrs_memory_single_general_immediate_signed_offset_lda_stl(datasize, memop, n, offset, postindex, regsize, rt_unknown, is_signed, t, tagchecked, wb_unknown, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 562) = {
    SEE = 562;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm9 = Slice(__opcode, 12, 9);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_stlurb_aarch64_instrs_memory_single_general_immediate_signed_offset_lda_stl(Rt, Rn, imm9, opc, size)
}

val decode_stlurh_aarch64_instrs_memory_single_general_immediate_signed_offset_lda_stl : (bits(5), bits(5), bits(9), bits(2), bits(2)) -> unit

function decode_stlurh_aarch64_instrs_memory_single_general_immediate_signed_offset_lda_stl (Rt, Rn, imm9, opc, size) = {
    wback : bool = false;
    let postindex : bool = false;
    let 'scale = UInt(size);
    let offset : bits(64) = SignExtend(imm9, 64);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    memop : MemOp = undefined;
    is_signed : bool = undefined;
    regsize : {32, 64} = 32;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        is_signed = false
    } else {
        if size == 0b11 then {
            throw(Error_Undefined())
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            };
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            is_signed = true
        }
    };
    let 'regsize = regsize;
    let 'datasize = (8 << scale);
    let tagchecked : bool = memop != MemOp_PREFETCH & (wback | n != 31);
    wb_unknown : bool = false;
    rt_unknown : bool = false;
    c : Constraint = undefined;
    if ((memop == MemOp_LOAD & wback) & n == t) & n != 31 then {
        c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
        assert(c == Constraint_WBSUPPRESS | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_WBSUPPRESS => {
              wback = false
          },
          Constraint_UNKNOWN => {
              wb_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    if ((memop == MemOp_STORE & wback) & n == t) & n != 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
        assert(c == Constraint_NONE | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_NONE => {
              rt_unknown = false
          },
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    execute_aarch64_instrs_memory_single_general_immediate_signed_offset_lda_stl(datasize, memop, n, offset, postindex, regsize, rt_unknown, is_signed, t, tagchecked, wb_unknown, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 563) = {
    SEE = 563;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm9 = Slice(__opcode, 12, 9);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_stlurh_aarch64_instrs_memory_single_general_immediate_signed_offset_lda_stl(Rt, Rn, imm9, opc, size)
}

val execute_aarch64_instrs_memory_single_simdfp_immediate_signed_offset_ordered : forall 'datasize 'n ('postindex : Bool) 't ('tagchecked : Bool) ('wback : Bool),
  (0 <= 't & 't <= 31 & 0 <= 'n & 'n <= 31 & 'datasize in {8, 16, 32, 64, 128, 256, 512, 1024}).
  (int('datasize), MemOp, int('n), bits(64), bool('postindex), int('t), bool('tagchecked), bool('wback)) -> unit

function execute_aarch64_instrs_memory_single_simdfp_immediate_signed_offset_ordered (datasize, memop, n, offset, postindex, t, tagchecked, wback) = {
    CheckFPAdvSIMDEnabled64();
    address : bits(64) = undefined;
    data : bits('datasize) = undefined;
    let accdesc : AccessDescriptor = CreateAccDescASIMDAcqRel(memop, tagchecked);
    if n == 31 then {
        CheckSPAlignment();
        address = SP_read()
    } else {
        address = X_read(n, 64)
    };
    if not_bool(postindex) then {
        address = address + offset
    };
    match memop {
      MemOp_STORE => {
          assert(constraint('datasize in {8, 16, 32, 64, 128}));
          let data : bits('datasize) = V_read(t, datasize);
          Mem_set(address, DIV(datasize, 8), accdesc) = data
      },
      MemOp_LOAD => {
          let data : bits('datasize) = Mem_read(address, DIV(datasize, 8), accdesc);
          assert(constraint('datasize in {8, 16, 32, 64, 128}));
          V_set(t, datasize) = data
      },
      _ => ()
    };
    if wback then {
        if postindex then {
            address = address + offset
        };
        if n == 31 then {
            SP_set() = address
        } else {
            X_set(n, 64) = address
        }
    };
    if SPESampleInFlight then {
        SPESampleSIMDFPLoadStore()
    };
    ()
}

val decode_ldapur_fpsimd_aarch64_instrs_memory_single_simdfp_immediate_signed_offset_ordered : (bits(5), bits(5), bits(9), bits(2), bits(2)) -> unit

function decode_ldapur_fpsimd_aarch64_instrs_memory_single_simdfp_immediate_signed_offset_ordered (Rt, Rn, imm9, opc, size) = {
    let wback : bool = false;
    let postindex : bool = false;
    let 'scale = UInt([opc[1]] @ size);
    if scale > 4 then {
        throw(Error_Undefined())
    };
    let offset : bits(64) = SignExtend(imm9, 64);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let nontemporal : bool = false;
    let memop : MemOp = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'datasize = (8 << scale);
    let tagchecked : bool = memop != MemOp_PREFETCH & (wback | n != 31);
    assert(constraint('datasize in {8, 16, 32, 64, 128, 256, 512, 1024}));
    execute_aarch64_instrs_memory_single_simdfp_immediate_signed_offset_ordered(datasize, memop, n, offset, postindex, t, tagchecked, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([_, _, bitzero, bitone, bitone, bitone, bitzero, bitone, _, bitone, bitzero, _, _, _, _, _, _, _, _, _, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 564) = {
    SEE = 564;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm9 = Slice(__opcode, 12, 9);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_ldapur_fpsimd_aarch64_instrs_memory_single_simdfp_immediate_signed_offset_ordered(Rt, Rn, imm9, opc, size)
}

val decode_stlur_fpsimd_aarch64_instrs_memory_single_simdfp_immediate_signed_offset_ordered : (bits(5), bits(5), bits(9), bits(2), bits(2)) -> unit

function decode_stlur_fpsimd_aarch64_instrs_memory_single_simdfp_immediate_signed_offset_ordered (Rt, Rn, imm9, opc, size) = {
    let wback : bool = false;
    let postindex : bool = false;
    let 'scale = UInt([opc[1]] @ size);
    if scale > 4 then {
        throw(Error_Undefined())
    };
    let offset : bits(64) = SignExtend(imm9, 64);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let nontemporal : bool = false;
    let memop : MemOp = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'datasize = (8 << scale);
    let tagchecked : bool = memop != MemOp_PREFETCH & (wback | n != 31);
    assert(constraint('datasize in {8, 16, 32, 64, 128, 256, 512, 1024}));
    execute_aarch64_instrs_memory_single_simdfp_immediate_signed_offset_ordered(datasize, memop, n, offset, postindex, t, tagchecked, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([_, _, bitzero, bitone, bitone, bitone, bitzero, bitone, _, bitzero, bitzero, _, _, _, _, _, _, _, _, _, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 565) = {
    SEE = 565;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm9 = Slice(__opcode, 12, 9);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_stlur_fpsimd_aarch64_instrs_memory_single_simdfp_immediate_signed_offset_ordered(Rt, Rn, imm9, opc, size)
}

val execute_aarch64_instrs_memory_ordered : forall 'datasize ('limitedordered : Bool) 'n 'offset 'regsize ('rt_unknown : Bool) 't ('tagchecked : Bool) ('wback : Bool),
  (0 <= 't & 't <= 31 & 'regsize in {32, 64} & 0 <= 'n & 'n <= 31 & 'datasize in {8, 16, 32, 64}).
  (int('datasize), bool('limitedordered), MemOp, int('n), int('offset), int('regsize), bool('rt_unknown), int('t), bool('tagchecked), bool('wback)) -> unit

function execute_aarch64_instrs_memory_ordered (datasize, limitedordered, memop, n, offset, regsize, rt_unknown, t, tagchecked, wback) = {
    address : bits(64) = undefined;
    data : bits('datasize) = undefined;
    let 'dbytes = DIV(datasize, 8);
    accdesc : AccessDescriptor = undefined;
    if limitedordered then {
        accdesc = CreateAccDescLOR(memop, tagchecked)
    } else {
        accdesc = CreateAccDescAcqRel(memop, tagchecked)
    };
    if n == 31 then {
        CheckSPAlignment();
        address = SP_read()
    } else {
        address = X_read(n, 64)
    };
    match memop {
      MemOp_STORE => {
          let address : bits(64) = address + offset;
          if rt_unknown then {
              data = __UNKNOWN_bits(datasize)
          } else {
              data = X_read(t, datasize)
          };
          AArch64_SetLSInstructionSyndrome(dbytes, false, t, regsize == 64, true);
          Mem_set(address, dbytes, accdesc) = data;
          if wback then {
              if n == 31 then {
                  SP_set() = address
              } else {
                  X_set(n, 64) = address
              }
          };
          ()
      },
      MemOp_LOAD => {
          AArch64_SetLSInstructionSyndrome(dbytes, false, t, regsize == 64, true);
          let data : bits('datasize) = Mem_read(address, dbytes, accdesc);
          assert(constraint(('datasize >= 0 & 'regsize >= 'datasize)));
          X_set(t, regsize) = ZeroExtend(data, regsize)
      },
      _ => ()
    };
    if SPESampleInFlight then {
        let ar : bits(1) = 0b1;
        let excl : bits(1) = 0b0;
        let at : bits(1) = 0b0;
        let is_load : bool = memop == MemOp_LOAD;
        SPESampleExtendedLoadStore(ar, excl, at, is_load)
    };
    ()
}

val decode_ldar_aarch64_instrs_memory_ordered : (bits(5), bits(5), bits(5), bits(1), bits(5), bits(1), bits(2)) -> unit

function decode_ldar_aarch64_instrs_memory_ordered (Rt, Rn, Rt2, o0, Rs, L, size) = {
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 't2 = UInt(Rt2);
    let 's = UInt(Rs);
    let wback : bool = false;
    let 'offset = 0;
    let rt_unknown : bool = false;
    let limitedordered : bool = o0 == 0b0;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'elsize = (8 << UInt(size));
    let 'regsize = if elsize == 64 then 64 else 32;
    let 'datasize = elsize;
    let tagchecked : bool = n != 31;
    execute_aarch64_instrs_memory_ordered(datasize, limitedordered, memop, n, offset, regsize, rt_unknown, t, tagchecked, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([bitone, _, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 566) = {
    SEE = 566;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rt2 = Slice(__opcode, 10, 5);
    let o0 = Slice(__opcode, 15, 1);
    let Rs = Slice(__opcode, 16, 5);
    let L = Slice(__opcode, 22, 1);
    let size = Slice(__opcode, 30, 2);
    if (((((((([__opcode[10]] != 0b1 | [__opcode[11]] != 0b1) | [__opcode[12]] != 0b1) | [__opcode[13]] != 0b1) | [__opcode[14]] != 0b1) | [__opcode[16]] != 0b1) | [__opcode[17]] != 0b1) | [__opcode[18]] != 0b1) | [__opcode[19]] != 0b1) | [__opcode[20]] != 0b1 then {
        throw(Error_ConstrainedUnpredictable())
    } else {
        decode_ldar_aarch64_instrs_memory_ordered(Rt, Rn, Rt2, o0, Rs, L, size)
    }
}

val decode_ldarb_aarch64_instrs_memory_ordered : (bits(5), bits(5), bits(5), bits(1), bits(5), bits(1), bits(2)) -> unit

function decode_ldarb_aarch64_instrs_memory_ordered (Rt, Rn, Rt2, o0, Rs, L, size) = {
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 't2 = UInt(Rt2);
    let 's = UInt(Rs);
    let wback : bool = false;
    let 'offset = 0;
    let rt_unknown : bool = false;
    let limitedordered : bool = o0 == 0b0;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'elsize = (8 << UInt(size));
    let 'regsize = if elsize == 64 then 64 else 32;
    let 'datasize = elsize;
    let tagchecked : bool = n != 31;
    execute_aarch64_instrs_memory_ordered(datasize, limitedordered, memop, n, offset, regsize, rt_unknown, t, tagchecked, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 567) = {
    SEE = 567;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rt2 = Slice(__opcode, 10, 5);
    let o0 = Slice(__opcode, 15, 1);
    let Rs = Slice(__opcode, 16, 5);
    let L = Slice(__opcode, 22, 1);
    let size = Slice(__opcode, 30, 2);
    if (((((((([__opcode[10]] != 0b1 | [__opcode[11]] != 0b1) | [__opcode[12]] != 0b1) | [__opcode[13]] != 0b1) | [__opcode[14]] != 0b1) | [__opcode[16]] != 0b1) | [__opcode[17]] != 0b1) | [__opcode[18]] != 0b1) | [__opcode[19]] != 0b1) | [__opcode[20]] != 0b1 then {
        throw(Error_ConstrainedUnpredictable())
    } else {
        decode_ldarb_aarch64_instrs_memory_ordered(Rt, Rn, Rt2, o0, Rs, L, size)
    }
}

val decode_ldarh_aarch64_instrs_memory_ordered : (bits(5), bits(5), bits(5), bits(1), bits(5), bits(1), bits(2)) -> unit

function decode_ldarh_aarch64_instrs_memory_ordered (Rt, Rn, Rt2, o0, Rs, L, size) = {
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 't2 = UInt(Rt2);
    let 's = UInt(Rs);
    let wback : bool = false;
    let 'offset = 0;
    let rt_unknown : bool = false;
    let limitedordered : bool = o0 == 0b0;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'elsize = (8 << UInt(size));
    let 'regsize = if elsize == 64 then 64 else 32;
    let 'datasize = elsize;
    let tagchecked : bool = n != 31;
    execute_aarch64_instrs_memory_ordered(datasize, limitedordered, memop, n, offset, regsize, rt_unknown, t, tagchecked, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, bitone, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 568) = {
    SEE = 568;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rt2 = Slice(__opcode, 10, 5);
    let o0 = Slice(__opcode, 15, 1);
    let Rs = Slice(__opcode, 16, 5);
    let L = Slice(__opcode, 22, 1);
    let size = Slice(__opcode, 30, 2);
    if (((((((([__opcode[10]] != 0b1 | [__opcode[11]] != 0b1) | [__opcode[12]] != 0b1) | [__opcode[13]] != 0b1) | [__opcode[14]] != 0b1) | [__opcode[16]] != 0b1) | [__opcode[17]] != 0b1) | [__opcode[18]] != 0b1) | [__opcode[19]] != 0b1) | [__opcode[20]] != 0b1 then {
        throw(Error_ConstrainedUnpredictable())
    } else {
        decode_ldarh_aarch64_instrs_memory_ordered(Rt, Rn, Rt2, o0, Rs, L, size)
    }
}

val decode_ldlar_aarch64_instrs_memory_ordered : (bits(5), bits(5), bits(5), bits(1), bits(5), bits(1), bits(2)) -> unit

function decode_ldlar_aarch64_instrs_memory_ordered (Rt, Rn, Rt2, o0, Rs, L, size) = {
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 't2 = UInt(Rt2);
    let 's = UInt(Rs);
    let wback : bool = false;
    let 'offset = 0;
    let rt_unknown : bool = false;
    let limitedordered : bool = o0 == 0b0;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'elsize = (8 << UInt(size));
    let 'regsize = if elsize == 64 then 64 else 32;
    let 'datasize = elsize;
    let tagchecked : bool = n != 31;
    execute_aarch64_instrs_memory_ordered(datasize, limitedordered, memop, n, offset, regsize, rt_unknown, t, tagchecked, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([bitone, _, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 569) = {
    SEE = 569;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rt2 = Slice(__opcode, 10, 5);
    let o0 = Slice(__opcode, 15, 1);
    let Rs = Slice(__opcode, 16, 5);
    let L = Slice(__opcode, 22, 1);
    let size = Slice(__opcode, 30, 2);
    if (((((((([__opcode[10]] != 0b1 | [__opcode[11]] != 0b1) | [__opcode[12]] != 0b1) | [__opcode[13]] != 0b1) | [__opcode[14]] != 0b1) | [__opcode[16]] != 0b1) | [__opcode[17]] != 0b1) | [__opcode[18]] != 0b1) | [__opcode[19]] != 0b1) | [__opcode[20]] != 0b1 then {
        throw(Error_ConstrainedUnpredictable())
    } else {
        decode_ldlar_aarch64_instrs_memory_ordered(Rt, Rn, Rt2, o0, Rs, L, size)
    }
}

val decode_ldlarb_aarch64_instrs_memory_ordered : (bits(5), bits(5), bits(5), bits(1), bits(5), bits(1), bits(2)) -> unit

function decode_ldlarb_aarch64_instrs_memory_ordered (Rt, Rn, Rt2, o0, Rs, L, size) = {
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 't2 = UInt(Rt2);
    let 's = UInt(Rs);
    let wback : bool = false;
    let 'offset = 0;
    let rt_unknown : bool = false;
    let limitedordered : bool = o0 == 0b0;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'elsize = (8 << UInt(size));
    let 'regsize = if elsize == 64 then 64 else 32;
    let 'datasize = elsize;
    let tagchecked : bool = n != 31;
    execute_aarch64_instrs_memory_ordered(datasize, limitedordered, memop, n, offset, regsize, rt_unknown, t, tagchecked, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 570) = {
    SEE = 570;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rt2 = Slice(__opcode, 10, 5);
    let o0 = Slice(__opcode, 15, 1);
    let Rs = Slice(__opcode, 16, 5);
    let L = Slice(__opcode, 22, 1);
    let size = Slice(__opcode, 30, 2);
    if (((((((([__opcode[10]] != 0b1 | [__opcode[11]] != 0b1) | [__opcode[12]] != 0b1) | [__opcode[13]] != 0b1) | [__opcode[14]] != 0b1) | [__opcode[16]] != 0b1) | [__opcode[17]] != 0b1) | [__opcode[18]] != 0b1) | [__opcode[19]] != 0b1) | [__opcode[20]] != 0b1 then {
        throw(Error_ConstrainedUnpredictable())
    } else {
        decode_ldlarb_aarch64_instrs_memory_ordered(Rt, Rn, Rt2, o0, Rs, L, size)
    }
}

val decode_ldlarh_aarch64_instrs_memory_ordered : (bits(5), bits(5), bits(5), bits(1), bits(5), bits(1), bits(2)) -> unit

function decode_ldlarh_aarch64_instrs_memory_ordered (Rt, Rn, Rt2, o0, Rs, L, size) = {
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 't2 = UInt(Rt2);
    let 's = UInt(Rs);
    let wback : bool = false;
    let 'offset = 0;
    let rt_unknown : bool = false;
    let limitedordered : bool = o0 == 0b0;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'elsize = (8 << UInt(size));
    let 'regsize = if elsize == 64 then 64 else 32;
    let 'datasize = elsize;
    let tagchecked : bool = n != 31;
    execute_aarch64_instrs_memory_ordered(datasize, limitedordered, memop, n, offset, regsize, rt_unknown, t, tagchecked, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, bitone, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 571) = {
    SEE = 571;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rt2 = Slice(__opcode, 10, 5);
    let o0 = Slice(__opcode, 15, 1);
    let Rs = Slice(__opcode, 16, 5);
    let L = Slice(__opcode, 22, 1);
    let size = Slice(__opcode, 30, 2);
    if (((((((([__opcode[10]] != 0b1 | [__opcode[11]] != 0b1) | [__opcode[12]] != 0b1) | [__opcode[13]] != 0b1) | [__opcode[14]] != 0b1) | [__opcode[16]] != 0b1) | [__opcode[17]] != 0b1) | [__opcode[18]] != 0b1) | [__opcode[19]] != 0b1) | [__opcode[20]] != 0b1 then {
        throw(Error_ConstrainedUnpredictable())
    } else {
        decode_ldlarh_aarch64_instrs_memory_ordered(Rt, Rn, Rt2, o0, Rs, L, size)
    }
}

val decode_stllr_aarch64_instrs_memory_ordered : (bits(5), bits(5), bits(5), bits(1), bits(5), bits(1), bits(2)) -> unit

function decode_stllr_aarch64_instrs_memory_ordered (Rt, Rn, Rt2, o0, Rs, L, size) = {
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 't2 = UInt(Rt2);
    let 's = UInt(Rs);
    let wback : bool = false;
    let 'offset = 0;
    let rt_unknown : bool = false;
    let limitedordered : bool = o0 == 0b0;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'elsize = (8 << UInt(size));
    let 'regsize = if elsize == 64 then 64 else 32;
    let 'datasize = elsize;
    let tagchecked : bool = n != 31;
    execute_aarch64_instrs_memory_ordered(datasize, limitedordered, memop, n, offset, regsize, rt_unknown, t, tagchecked, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([bitone, _, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 572) = {
    SEE = 572;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rt2 = Slice(__opcode, 10, 5);
    let o0 = Slice(__opcode, 15, 1);
    let Rs = Slice(__opcode, 16, 5);
    let L = Slice(__opcode, 22, 1);
    let size = Slice(__opcode, 30, 2);
    if (((((((([__opcode[10]] != 0b1 | [__opcode[11]] != 0b1) | [__opcode[12]] != 0b1) | [__opcode[13]] != 0b1) | [__opcode[14]] != 0b1) | [__opcode[16]] != 0b1) | [__opcode[17]] != 0b1) | [__opcode[18]] != 0b1) | [__opcode[19]] != 0b1) | [__opcode[20]] != 0b1 then {
        throw(Error_ConstrainedUnpredictable())
    } else {
        decode_stllr_aarch64_instrs_memory_ordered(Rt, Rn, Rt2, o0, Rs, L, size)
    }
}

val decode_stllrb_aarch64_instrs_memory_ordered : (bits(5), bits(5), bits(5), bits(1), bits(5), bits(1), bits(2)) -> unit

function decode_stllrb_aarch64_instrs_memory_ordered (Rt, Rn, Rt2, o0, Rs, L, size) = {
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 't2 = UInt(Rt2);
    let 's = UInt(Rs);
    let wback : bool = false;
    let 'offset = 0;
    let rt_unknown : bool = false;
    let limitedordered : bool = o0 == 0b0;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'elsize = (8 << UInt(size));
    let 'regsize = if elsize == 64 then 64 else 32;
    let 'datasize = elsize;
    let tagchecked : bool = n != 31;
    execute_aarch64_instrs_memory_ordered(datasize, limitedordered, memop, n, offset, regsize, rt_unknown, t, tagchecked, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 573) = {
    SEE = 573;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rt2 = Slice(__opcode, 10, 5);
    let o0 = Slice(__opcode, 15, 1);
    let Rs = Slice(__opcode, 16, 5);
    let L = Slice(__opcode, 22, 1);
    let size = Slice(__opcode, 30, 2);
    if (((((((([__opcode[10]] != 0b1 | [__opcode[11]] != 0b1) | [__opcode[12]] != 0b1) | [__opcode[13]] != 0b1) | [__opcode[14]] != 0b1) | [__opcode[16]] != 0b1) | [__opcode[17]] != 0b1) | [__opcode[18]] != 0b1) | [__opcode[19]] != 0b1) | [__opcode[20]] != 0b1 then {
        throw(Error_ConstrainedUnpredictable())
    } else {
        decode_stllrb_aarch64_instrs_memory_ordered(Rt, Rn, Rt2, o0, Rs, L, size)
    }
}

val decode_stllrh_aarch64_instrs_memory_ordered : (bits(5), bits(5), bits(5), bits(1), bits(5), bits(1), bits(2)) -> unit

function decode_stllrh_aarch64_instrs_memory_ordered (Rt, Rn, Rt2, o0, Rs, L, size) = {
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 't2 = UInt(Rt2);
    let 's = UInt(Rs);
    let wback : bool = false;
    let 'offset = 0;
    let rt_unknown : bool = false;
    let limitedordered : bool = o0 == 0b0;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'elsize = (8 << UInt(size));
    let 'regsize = if elsize == 64 then 64 else 32;
    let 'datasize = elsize;
    let tagchecked : bool = n != 31;
    execute_aarch64_instrs_memory_ordered(datasize, limitedordered, memop, n, offset, regsize, rt_unknown, t, tagchecked, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, bitone, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 574) = {
    SEE = 574;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rt2 = Slice(__opcode, 10, 5);
    let o0 = Slice(__opcode, 15, 1);
    let Rs = Slice(__opcode, 16, 5);
    let L = Slice(__opcode, 22, 1);
    let size = Slice(__opcode, 30, 2);
    if (((((((([__opcode[10]] != 0b1 | [__opcode[11]] != 0b1) | [__opcode[12]] != 0b1) | [__opcode[13]] != 0b1) | [__opcode[14]] != 0b1) | [__opcode[16]] != 0b1) | [__opcode[17]] != 0b1) | [__opcode[18]] != 0b1) | [__opcode[19]] != 0b1) | [__opcode[20]] != 0b1 then {
        throw(Error_ConstrainedUnpredictable())
    } else {
        decode_stllrh_aarch64_instrs_memory_ordered(Rt, Rn, Rt2, o0, Rs, L, size)
    }
}

val decode_stlr_aarch64_instrs_memory_ordered : (bits(5), bits(5), bits(5), bits(1), bits(5), bits(1), bits(2)) -> unit

function decode_stlr_aarch64_instrs_memory_ordered (Rt, Rn, Rt2, o0, Rs, L, size) = {
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 't2 = UInt(Rt2);
    let 's = UInt(Rs);
    let wback : bool = false;
    let 'offset = 0;
    let rt_unknown : bool = false;
    let limitedordered : bool = o0 == 0b0;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'elsize = (8 << UInt(size));
    let 'regsize = if elsize == 64 then 64 else 32;
    let 'datasize = elsize;
    let tagchecked : bool = n != 31;
    execute_aarch64_instrs_memory_ordered(datasize, limitedordered, memop, n, offset, regsize, rt_unknown, t, tagchecked, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([bitone, _, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 575) = {
    SEE = 575;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rt2 = Slice(__opcode, 10, 5);
    let o0 = Slice(__opcode, 15, 1);
    let Rs = Slice(__opcode, 16, 5);
    let L = Slice(__opcode, 22, 1);
    let size = Slice(__opcode, 30, 2);
    if (((((((([__opcode[10]] != 0b1 | [__opcode[11]] != 0b1) | [__opcode[12]] != 0b1) | [__opcode[13]] != 0b1) | [__opcode[14]] != 0b1) | [__opcode[16]] != 0b1) | [__opcode[17]] != 0b1) | [__opcode[18]] != 0b1) | [__opcode[19]] != 0b1) | [__opcode[20]] != 0b1 then {
        throw(Error_ConstrainedUnpredictable())
    } else {
        decode_stlr_aarch64_instrs_memory_ordered(Rt, Rn, Rt2, o0, Rs, L, size)
    }
}

val decode_stlr_aarch64_instrs_memory_ordered_writeback : (bits(5), bits(5), bits(2)) -> unit

function decode_stlr_aarch64_instrs_memory_ordered_writeback (Rt, Rn, size) = {
    let wback : bool = true;
    let memop : MemOp = MemOp_STORE;
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let limitedordered : bool = false;
    let 'regsize = if size == 0b11 then 64 else 32;
    let 'datasize = (8 << UInt(size));
    let 'offset = negate(1) * (1 << UInt(size));
    let tagchecked : bool = wback | n != 31;
    rt_unknown : bool = false;
    if (wback & n == t) & n != 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
        assert(c == Constraint_NONE | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_NONE => {
              rt_unknown = false
          },
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    execute_aarch64_instrs_memory_ordered(datasize, limitedordered, memop, n, offset, regsize, rt_unknown, t, tagchecked, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([bitone, _, bitzero, bitone, bitone, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 576) = {
    SEE = 576;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 30, 2);
    decode_stlr_aarch64_instrs_memory_ordered_writeback(Rt, Rn, size)
}

val decode_stlrb_aarch64_instrs_memory_ordered : (bits(5), bits(5), bits(5), bits(1), bits(5), bits(1), bits(2)) -> unit

function decode_stlrb_aarch64_instrs_memory_ordered (Rt, Rn, Rt2, o0, Rs, L, size) = {
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 't2 = UInt(Rt2);
    let 's = UInt(Rs);
    let wback : bool = false;
    let 'offset = 0;
    let rt_unknown : bool = false;
    let limitedordered : bool = o0 == 0b0;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'elsize = (8 << UInt(size));
    let 'regsize = if elsize == 64 then 64 else 32;
    let 'datasize = elsize;
    let tagchecked : bool = n != 31;
    execute_aarch64_instrs_memory_ordered(datasize, limitedordered, memop, n, offset, regsize, rt_unknown, t, tagchecked, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 577) = {
    SEE = 577;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rt2 = Slice(__opcode, 10, 5);
    let o0 = Slice(__opcode, 15, 1);
    let Rs = Slice(__opcode, 16, 5);
    let L = Slice(__opcode, 22, 1);
    let size = Slice(__opcode, 30, 2);
    if (((((((([__opcode[10]] != 0b1 | [__opcode[11]] != 0b1) | [__opcode[12]] != 0b1) | [__opcode[13]] != 0b1) | [__opcode[14]] != 0b1) | [__opcode[16]] != 0b1) | [__opcode[17]] != 0b1) | [__opcode[18]] != 0b1) | [__opcode[19]] != 0b1) | [__opcode[20]] != 0b1 then {
        throw(Error_ConstrainedUnpredictable())
    } else {
        decode_stlrb_aarch64_instrs_memory_ordered(Rt, Rn, Rt2, o0, Rs, L, size)
    }
}

val decode_stlrh_aarch64_instrs_memory_ordered : (bits(5), bits(5), bits(5), bits(1), bits(5), bits(1), bits(2)) -> unit

function decode_stlrh_aarch64_instrs_memory_ordered (Rt, Rn, Rt2, o0, Rs, L, size) = {
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 't2 = UInt(Rt2);
    let 's = UInt(Rs);
    let wback : bool = false;
    let 'offset = 0;
    let rt_unknown : bool = false;
    let limitedordered : bool = o0 == 0b0;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'elsize = (8 << UInt(size));
    let 'regsize = if elsize == 64 then 64 else 32;
    let 'datasize = elsize;
    let tagchecked : bool = n != 31;
    execute_aarch64_instrs_memory_ordered(datasize, limitedordered, memop, n, offset, regsize, rt_unknown, t, tagchecked, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, bitone, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 578) = {
    SEE = 578;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rt2 = Slice(__opcode, 10, 5);
    let o0 = Slice(__opcode, 15, 1);
    let Rs = Slice(__opcode, 16, 5);
    let L = Slice(__opcode, 22, 1);
    let size = Slice(__opcode, 30, 2);
    if (((((((([__opcode[10]] != 0b1 | [__opcode[11]] != 0b1) | [__opcode[12]] != 0b1) | [__opcode[13]] != 0b1) | [__opcode[14]] != 0b1) | [__opcode[16]] != 0b1) | [__opcode[17]] != 0b1) | [__opcode[18]] != 0b1) | [__opcode[19]] != 0b1) | [__opcode[20]] != 0b1 then {
        throw(Error_ConstrainedUnpredictable())
    } else {
        decode_stlrh_aarch64_instrs_memory_ordered(Rt, Rn, Rt2, o0, Rs, L, size)
    }
}

val execute_aarch64_instrs_memory_exclusive_pair : forall ('acqrel : Bool) 'datasize 'elsize 'n ('pair : Bool) 'regsize ('rn_unknown : Bool) ('rt_unknown : Bool) 's 't 't2 ('tagchecked : Bool),
  (0 <= 't2 & 't2 <= 31 & 0 <= 't & 't <= 31 & 0 <= 's & 's <= 31 & 'regsize in {32, 64} & 0 <= 'n & 'n <= 31 & 'elsize in {32, 64} & 'datasize in {32, 64, 128}).
  (bool('acqrel), int('datasize), int('elsize), MemOp, int('n), bool('pair), int('regsize), bool('rn_unknown), bool('rt_unknown), int('s), int('t), int('t2), bool('tagchecked)) -> unit

function execute_aarch64_instrs_memory_exclusive_pair (acqrel, datasize, elsize, memop, n, pair, regsize, rn_unknown, rt_unknown, s, t, t2, tagchecked) = {
    address : bits(64) = undefined;
    data : bits('datasize) = undefined;
    let 'dbytes = DIV(datasize, 8);
    let accdesc : AccessDescriptor = CreateAccDescExLDST(memop, acqrel, tagchecked);
    if n == 31 then {
        CheckSPAlignment();
        address = SP_read()
    } else if rn_unknown then {
        address = __UNKNOWN_bits(64)
    } else {
        address = X_read(n, 64)
    };
    match memop {
      MemOp_STORE => {
          if rt_unknown then {
              data = __UNKNOWN_bits(datasize)
          } else if pair then {
              let el1 : bits(div('datasize, 2)) = X_read(t, DIV(datasize, 2));
              let el2 : bits(div('datasize, 2)) = X_read(t2, DIV(datasize, 2));
              data = if BigEndian(accdesc.acctype) then el1 @ el2 else el2 @ el1
          } else {
              assert(constraint('datasize in {8, 16, 32, 64}));
              data = X_read(t, datasize)
          };
          status : bits(1) = 0b1;
          if AArch64_ExclusiveMonitorsPass(address, dbytes) then {
              Mem_set(address, dbytes, accdesc) = data;
              status = ExclusiveMonitorsStatus()
          } else if SPESampleInFlight then {
              SPESetDataVirtualAddress(address)
          } else ();
          X_set(s, 32) = ZeroExtend(status, 32)
      },
      MemOp_LOAD => {
          AArch64_SetExclusiveMonitors(address, dbytes);
          if pair then {
              if rt_unknown then {
                  assert(constraint('datasize in {32, 64}));
                  X_set(t, datasize) = __UNKNOWN_bits(datasize)
              } else if elsize == 32 then {
                  let data : bits('datasize) = Mem_read(address, dbytes, accdesc);
                  if BigEndian(accdesc.acctype) then {
                      assert(constraint((0 <= 'elsize & 'elsize <= 'datasize - 1 & 'datasize - 1 < 'datasize)));
                      assert(constraint(('datasize - 'elsize == 32 | 'datasize - 'elsize == 64)));
                      X_set(t, datasize - elsize) = data[datasize - 1 .. elsize];
                      X_set(t2, elsize) = data[elsize - 1 .. 0]
                  } else {
                      X_set(t, elsize) = data[elsize - 1 .. 0];
                      assert(constraint((0 <= 'elsize & 'elsize <= 'datasize - 1 & 'datasize - 1 < 'datasize)));
                      assert(constraint(('datasize - 'elsize == 32 | 'datasize - 'elsize == 64)));
                      X_set(t2, datasize - elsize) = data[datasize - 1 .. elsize]
                  }
              } else {
                  if not_bool(IsAligned__1(address, dbytes)) then {
                      AArch64_Abort(address, AlignmentFault(accdesc))
                  };
                  X_set(t, 64) = Mem_read(address + 0, 8, accdesc);
                  X_set(t2, 64) = Mem_read(address + 8, 8, accdesc)
              }
          } else {
              let data : bits('datasize) = Mem_read(address, dbytes, accdesc);
              assert(constraint(('datasize >= 0 & 'regsize >= 'datasize)));
              X_set(t, regsize) = ZeroExtend(data, regsize)
          }
      },
      _ => ()
    };
    if SPESampleInFlight then {
        let ar : bits(1) = if acqrel then 0b1 else 0b0;
        let excl : bits(1) = 0b1;
        let at : bits(1) = 0b0;
        let is_load : bool = memop == MemOp_LOAD;
        SPESampleExtendedLoadStore(ar, excl, at, is_load)
    };
    ()
}

val decode_ldaxp_aarch64_instrs_memory_exclusive_pair : (bits(5), bits(5), bits(5), bits(1), bits(5), bits(1), bits(1)) -> unit

function decode_ldaxp_aarch64_instrs_memory_exclusive_pair (Rt, Rn, Rt2, o0, Rs, L, sz) = {
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 't2 = UInt(Rt2);
    let 's = UInt(Rs);
    let acqrel : bool = o0 == 0b1;
    let pair : bool = true;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'elsize = (32 << UInt(sz));
    let 'regsize = if elsize == 64 then 64 else 32;
    let 'datasize = if pair then elsize * 2 else elsize;
    let tagchecked : bool = n != 31;
    rt_unknown : bool = false;
    rn_unknown : bool = false;
    if (memop == MemOp_LOAD & pair) & t == t2 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);
        assert(c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    if memop == MemOp_STORE then {
        if s == t | pair & s == t2 then {
            let c : Constraint = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);
            assert(c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
            match c {
              Constraint_UNKNOWN => {
                  rt_unknown = true
              },
              Constraint_UNDEF => {
                  throw(Error_Undefined())
              },
              Constraint_NOP => {
                  EndOfInstruction()
              },
              _ => ()
            }
        };
        if s == n & n != 31 then {
            let c : Constraint = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);
            assert(c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
            match c {
              Constraint_UNKNOWN => {
                  rn_unknown = true
              },
              Constraint_UNDEF => {
                  throw(Error_Undefined())
              },
              Constraint_NOP => {
                  EndOfInstruction()
              },
              _ => ()
            }
        };
        ()
    };
    execute_aarch64_instrs_memory_exclusive_pair(acqrel, datasize, elsize, memop, n, pair, regsize, rn_unknown, rt_unknown, s, t, t2, tagchecked)
}

function clause __DecodeA64_LoadStore ((pc, ([bitone, _, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 579) = {
    SEE = 579;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rt2 = Slice(__opcode, 10, 5);
    let o0 = Slice(__opcode, 15, 1);
    let Rs = Slice(__opcode, 16, 5);
    let L = Slice(__opcode, 22, 1);
    let sz = Slice(__opcode, 30, 1);
    if ((([__opcode[16]] != 0b1 | [__opcode[17]] != 0b1) | [__opcode[18]] != 0b1) | [__opcode[19]] != 0b1) | [__opcode[20]] != 0b1 then {
        throw(Error_ConstrainedUnpredictable())
    } else {
        decode_ldaxp_aarch64_instrs_memory_exclusive_pair(Rt, Rn, Rt2, o0, Rs, L, sz)
    }
}

val decode_ldxp_aarch64_instrs_memory_exclusive_pair : (bits(5), bits(5), bits(5), bits(1), bits(5), bits(1), bits(1)) -> unit

function decode_ldxp_aarch64_instrs_memory_exclusive_pair (Rt, Rn, Rt2, o0, Rs, L, sz) = {
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 't2 = UInt(Rt2);
    let 's = UInt(Rs);
    let acqrel : bool = o0 == 0b1;
    let pair : bool = true;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'elsize = (32 << UInt(sz));
    let 'regsize = if elsize == 64 then 64 else 32;
    let 'datasize = if pair then elsize * 2 else elsize;
    let tagchecked : bool = n != 31;
    rt_unknown : bool = false;
    rn_unknown : bool = false;
    if (memop == MemOp_LOAD & pair) & t == t2 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);
        assert(c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    if memop == MemOp_STORE then {
        if s == t | pair & s == t2 then {
            let c : Constraint = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);
            assert(c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
            match c {
              Constraint_UNKNOWN => {
                  rt_unknown = true
              },
              Constraint_UNDEF => {
                  throw(Error_Undefined())
              },
              Constraint_NOP => {
                  EndOfInstruction()
              },
              _ => ()
            }
        };
        if s == n & n != 31 then {
            let c : Constraint = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);
            assert(c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
            match c {
              Constraint_UNKNOWN => {
                  rn_unknown = true
              },
              Constraint_UNDEF => {
                  throw(Error_Undefined())
              },
              Constraint_NOP => {
                  EndOfInstruction()
              },
              _ => ()
            }
        };
        ()
    };
    execute_aarch64_instrs_memory_exclusive_pair(acqrel, datasize, elsize, memop, n, pair, regsize, rn_unknown, rt_unknown, s, t, t2, tagchecked)
}

function clause __DecodeA64_LoadStore ((pc, ([bitone, _, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 580) = {
    SEE = 580;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rt2 = Slice(__opcode, 10, 5);
    let o0 = Slice(__opcode, 15, 1);
    let Rs = Slice(__opcode, 16, 5);
    let L = Slice(__opcode, 22, 1);
    let sz = Slice(__opcode, 30, 1);
    if ((([__opcode[16]] != 0b1 | [__opcode[17]] != 0b1) | [__opcode[18]] != 0b1) | [__opcode[19]] != 0b1) | [__opcode[20]] != 0b1 then {
        throw(Error_ConstrainedUnpredictable())
    } else {
        decode_ldxp_aarch64_instrs_memory_exclusive_pair(Rt, Rn, Rt2, o0, Rs, L, sz)
    }
}

val decode_stlxp_aarch64_instrs_memory_exclusive_pair : (bits(5), bits(5), bits(5), bits(1), bits(5), bits(1), bits(1)) -> unit

function decode_stlxp_aarch64_instrs_memory_exclusive_pair (Rt, Rn, Rt2, o0, Rs, L, sz) = {
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 't2 = UInt(Rt2);
    let 's = UInt(Rs);
    let acqrel : bool = o0 == 0b1;
    let pair : bool = true;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'elsize = (32 << UInt(sz));
    let 'regsize = if elsize == 64 then 64 else 32;
    let 'datasize = if pair then elsize * 2 else elsize;
    let tagchecked : bool = n != 31;
    rt_unknown : bool = false;
    rn_unknown : bool = false;
    if (memop == MemOp_LOAD & pair) & t == t2 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);
        assert(c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    if memop == MemOp_STORE then {
        if s == t | pair & s == t2 then {
            let c : Constraint = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);
            assert(c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
            match c {
              Constraint_UNKNOWN => {
                  rt_unknown = true
              },
              Constraint_UNDEF => {
                  throw(Error_Undefined())
              },
              Constraint_NOP => {
                  EndOfInstruction()
              },
              _ => ()
            }
        };
        if s == n & n != 31 then {
            let c : Constraint = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);
            assert(c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
            match c {
              Constraint_UNKNOWN => {
                  rn_unknown = true
              },
              Constraint_UNDEF => {
                  throw(Error_Undefined())
              },
              Constraint_NOP => {
                  EndOfInstruction()
              },
              _ => ()
            }
        };
        ()
    };
    execute_aarch64_instrs_memory_exclusive_pair(acqrel, datasize, elsize, memop, n, pair, regsize, rn_unknown, rt_unknown, s, t, t2, tagchecked)
}

function clause __DecodeA64_LoadStore ((pc, ([bitone, _, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, _, _, _, _, _, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 581) = {
    SEE = 581;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rt2 = Slice(__opcode, 10, 5);
    let o0 = Slice(__opcode, 15, 1);
    let Rs = Slice(__opcode, 16, 5);
    let L = Slice(__opcode, 22, 1);
    let sz = Slice(__opcode, 30, 1);
    decode_stlxp_aarch64_instrs_memory_exclusive_pair(Rt, Rn, Rt2, o0, Rs, L, sz)
}

val decode_stxp_aarch64_instrs_memory_exclusive_pair : (bits(5), bits(5), bits(5), bits(1), bits(5), bits(1), bits(1)) -> unit

function decode_stxp_aarch64_instrs_memory_exclusive_pair (Rt, Rn, Rt2, o0, Rs, L, sz) = {
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 't2 = UInt(Rt2);
    let 's = UInt(Rs);
    let acqrel : bool = o0 == 0b1;
    let pair : bool = true;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'elsize = (32 << UInt(sz));
    let 'regsize = if elsize == 64 then 64 else 32;
    let 'datasize = if pair then elsize * 2 else elsize;
    let tagchecked : bool = n != 31;
    rt_unknown : bool = false;
    rn_unknown : bool = false;
    if (memop == MemOp_LOAD & pair) & t == t2 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);
        assert(c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    if memop == MemOp_STORE then {
        if s == t | pair & s == t2 then {
            let c : Constraint = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);
            assert(c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
            match c {
              Constraint_UNKNOWN => {
                  rt_unknown = true
              },
              Constraint_UNDEF => {
                  throw(Error_Undefined())
              },
              Constraint_NOP => {
                  EndOfInstruction()
              },
              _ => ()
            }
        };
        if s == n & n != 31 then {
            let c : Constraint = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);
            assert(c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
            match c {
              Constraint_UNKNOWN => {
                  rn_unknown = true
              },
              Constraint_UNDEF => {
                  throw(Error_Undefined())
              },
              Constraint_NOP => {
                  EndOfInstruction()
              },
              _ => ()
            }
        };
        ()
    };
    execute_aarch64_instrs_memory_exclusive_pair(acqrel, datasize, elsize, memop, n, pair, regsize, rn_unknown, rt_unknown, s, t, t2, tagchecked)
}

function clause __DecodeA64_LoadStore ((pc, ([bitone, _, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, _, _, _, _, _, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 582) = {
    SEE = 582;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rt2 = Slice(__opcode, 10, 5);
    let o0 = Slice(__opcode, 15, 1);
    let Rs = Slice(__opcode, 16, 5);
    let L = Slice(__opcode, 22, 1);
    let sz = Slice(__opcode, 30, 1);
    decode_stxp_aarch64_instrs_memory_exclusive_pair(Rt, Rn, Rt2, o0, Rs, L, sz)
}

val execute_aarch64_instrs_memory_exclusive_single : forall ('acqrel : Bool) 'datasize 'elsize 'n ('pair : Bool) 'regsize ('rn_unknown : Bool) ('rt_unknown : Bool) 's 't 't2 ('tagchecked : Bool),
  (0 <= 't2 & 't2 <= 31 & 0 <= 't & 't <= 31 & 0 <= 's & 's <= 31 & 'regsize in {32, 64} & 0 <= 'n & 'n <= 31 & 'elsize in {8, 16, 32, 64} & 'datasize in {8, 16, 32, 64, 128}).
  (bool('acqrel), int('datasize), int('elsize), MemOp, int('n), bool('pair), int('regsize), bool('rn_unknown), bool('rt_unknown), int('s), int('t), int('t2), bool('tagchecked)) -> unit

function execute_aarch64_instrs_memory_exclusive_single (acqrel, datasize, elsize, memop, n, pair, regsize, rn_unknown, rt_unknown, s, t, t2, tagchecked) = {
    address : bits(64) = undefined;
    data : bits('datasize) = undefined;
    let 'dbytes = DIV(datasize, 8);
    let accdesc : AccessDescriptor = CreateAccDescExLDST(memop, acqrel, tagchecked);
    if n == 31 then {
        CheckSPAlignment();
        address = SP_read()
    } else if rn_unknown then {
        address = __UNKNOWN_bits(64)
    } else {
        address = X_read(n, 64)
    };
    match memop {
      MemOp_STORE => {
          if rt_unknown then {
              data = __UNKNOWN_bits(datasize)
          } else if pair then {
              assert(constraint((div('datasize, 2) == 8 | div('datasize, 2) == 16 | div('datasize, 2) == 32 | div('datasize, 2) == 64)));
              let el1 : bits(div('datasize, 2)) = X_read(t, DIV(datasize, 2));
              let el2 : bits(div('datasize, 2)) = X_read(t2, DIV(datasize, 2));
              data = if BigEndian(accdesc.acctype) then el1 @ el2 else el2 @ el1
          } else {
              assert(constraint('datasize in {8, 16, 32, 64}));
              data = X_read(t, datasize)
          };
          status : bits(1) = 0b1;
          if AArch64_ExclusiveMonitorsPass(address, dbytes) then {
              Mem_set(address, dbytes, accdesc) = data;
              status = ExclusiveMonitorsStatus()
          } else if SPESampleInFlight then {
              SPESetDataVirtualAddress(address)
          } else ();
          X_set(s, 32) = ZeroExtend(status, 32)
      },
      MemOp_LOAD => {
          AArch64_SetExclusiveMonitors(address, dbytes);
          if pair then {
              if rt_unknown then {
                  assert(constraint('datasize in {32, 64}));
                  X_set(t, datasize) = __UNKNOWN_bits(datasize)
              } else if elsize == 32 then {
                  let data : bits('datasize) = Mem_read(address, dbytes, accdesc);
                  if BigEndian(accdesc.acctype) then {
                      assert(constraint((0 <= 'elsize & 'elsize <= 'datasize - 1 & 'datasize - 1 < 'datasize)));
                      assert(constraint(('datasize - 'elsize == 32 | 'datasize - 'elsize == 64)));
                      X_set(t, datasize - elsize) = data[datasize - 1 .. elsize];
                      X_set(t2, elsize) = data[elsize - 1 .. 0]
                  } else {
                      assert(constraint((0 <= 'elsize - 1 & 'elsize - 1 < 'datasize)));
                      X_set(t, elsize) = data[elsize - 1 .. 0];
                      assert(constraint((0 <= 'elsize & 'elsize <= 'datasize - 1 & 'datasize - 1 < 'datasize)));
                      assert(constraint(('datasize - 'elsize == 32 | 'datasize - 'elsize == 64)));
                      X_set(t2, datasize - elsize) = data[datasize - 1 .. elsize]
                  }
              } else {
                  if not_bool(IsAligned__1(address, dbytes)) then {
                      AArch64_Abort(address, AlignmentFault(accdesc))
                  };
                  X_set(t, 64) = Mem_read(address + 0, 8, accdesc);
                  X_set(t2, 64) = Mem_read(address + 8, 8, accdesc)
              }
          } else {
              let data : bits('datasize) = Mem_read(address, dbytes, accdesc);
              assert(constraint(('datasize >= 0 & 'regsize >= 'datasize)));
              X_set(t, regsize) = ZeroExtend(data, regsize)
          }
      },
      _ => ()
    };
    if SPESampleInFlight then {
        let ar : bits(1) = if acqrel then 0b1 else 0b0;
        let excl : bits(1) = 0b1;
        let at : bits(1) = 0b0;
        let is_load : bool = memop == MemOp_LOAD;
        SPESampleExtendedLoadStore(ar, excl, at, is_load)
    };
    ()
}

val decode_ldaxr_aarch64_instrs_memory_exclusive_single : (bits(5), bits(5), bits(5), bits(1), bits(5), bits(1), bits(2)) -> unit

function decode_ldaxr_aarch64_instrs_memory_exclusive_single (Rt, Rn, Rt2, o0, Rs, L, size) = {
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 't2 = UInt(Rt2);
    let 's = UInt(Rs);
    let acqrel : bool = o0 == 0b1;
    let pair : bool = false;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'elsize = (8 << UInt(size));
    let 'regsize = if elsize == 64 then 64 else 32;
    let 'datasize = if pair then elsize * 2 else elsize;
    let tagchecked : bool = n != 31;
    rt_unknown : bool = false;
    rn_unknown : bool = false;
    if (memop == MemOp_LOAD & pair) & t == t2 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);
        assert(c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    if memop == MemOp_STORE then {
        if s == t | pair & s == t2 then {
            let c : Constraint = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);
            assert(c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
            match c {
              Constraint_UNKNOWN => {
                  rt_unknown = true
              },
              Constraint_UNDEF => {
                  throw(Error_Undefined())
              },
              Constraint_NOP => {
                  EndOfInstruction()
              },
              _ => ()
            }
        };
        if s == n & n != 31 then {
            let c : Constraint = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);
            assert(c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
            match c {
              Constraint_UNKNOWN => {
                  rn_unknown = true
              },
              Constraint_UNDEF => {
                  throw(Error_Undefined())
              },
              Constraint_NOP => {
                  EndOfInstruction()
              },
              _ => ()
            }
        };
        ()
    };
    execute_aarch64_instrs_memory_exclusive_single(acqrel, datasize, elsize, memop, n, pair, regsize, rn_unknown, rt_unknown, s, t, t2, tagchecked)
}

function clause __DecodeA64_LoadStore ((pc, ([bitone, _, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 583) = {
    SEE = 583;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rt2 = Slice(__opcode, 10, 5);
    let o0 = Slice(__opcode, 15, 1);
    let Rs = Slice(__opcode, 16, 5);
    let L = Slice(__opcode, 22, 1);
    let size = Slice(__opcode, 30, 2);
    if (((((((([__opcode[10]] != 0b1 | [__opcode[11]] != 0b1) | [__opcode[12]] != 0b1) | [__opcode[13]] != 0b1) | [__opcode[14]] != 0b1) | [__opcode[16]] != 0b1) | [__opcode[17]] != 0b1) | [__opcode[18]] != 0b1) | [__opcode[19]] != 0b1) | [__opcode[20]] != 0b1 then {
        throw(Error_ConstrainedUnpredictable())
    } else {
        decode_ldaxr_aarch64_instrs_memory_exclusive_single(Rt, Rn, Rt2, o0, Rs, L, size)
    }
}

val decode_ldaxrb_aarch64_instrs_memory_exclusive_single : (bits(5), bits(5), bits(5), bits(1), bits(5), bits(1), bits(2)) -> unit

function decode_ldaxrb_aarch64_instrs_memory_exclusive_single (Rt, Rn, Rt2, o0, Rs, L, size) = {
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 't2 = UInt(Rt2);
    let 's = UInt(Rs);
    let acqrel : bool = o0 == 0b1;
    let pair : bool = false;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'elsize = (8 << UInt(size));
    let 'regsize = if elsize == 64 then 64 else 32;
    let 'datasize = if pair then elsize * 2 else elsize;
    let tagchecked : bool = n != 31;
    rt_unknown : bool = false;
    rn_unknown : bool = false;
    if (memop == MemOp_LOAD & pair) & t == t2 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);
        assert(c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    if memop == MemOp_STORE then {
        if s == t | pair & s == t2 then {
            let c : Constraint = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);
            assert(c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
            match c {
              Constraint_UNKNOWN => {
                  rt_unknown = true
              },
              Constraint_UNDEF => {
                  throw(Error_Undefined())
              },
              Constraint_NOP => {
                  EndOfInstruction()
              },
              _ => ()
            }
        };
        if s == n & n != 31 then {
            let c : Constraint = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);
            assert(c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
            match c {
              Constraint_UNKNOWN => {
                  rn_unknown = true
              },
              Constraint_UNDEF => {
                  throw(Error_Undefined())
              },
              Constraint_NOP => {
                  EndOfInstruction()
              },
              _ => ()
            }
        };
        ()
    };
    execute_aarch64_instrs_memory_exclusive_single(acqrel, datasize, elsize, memop, n, pair, regsize, rn_unknown, rt_unknown, s, t, t2, tagchecked)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 584) = {
    SEE = 584;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rt2 = Slice(__opcode, 10, 5);
    let o0 = Slice(__opcode, 15, 1);
    let Rs = Slice(__opcode, 16, 5);
    let L = Slice(__opcode, 22, 1);
    let size = Slice(__opcode, 30, 2);
    if (((((((([__opcode[10]] != 0b1 | [__opcode[11]] != 0b1) | [__opcode[12]] != 0b1) | [__opcode[13]] != 0b1) | [__opcode[14]] != 0b1) | [__opcode[16]] != 0b1) | [__opcode[17]] != 0b1) | [__opcode[18]] != 0b1) | [__opcode[19]] != 0b1) | [__opcode[20]] != 0b1 then {
        throw(Error_ConstrainedUnpredictable())
    } else {
        decode_ldaxrb_aarch64_instrs_memory_exclusive_single(Rt, Rn, Rt2, o0, Rs, L, size)
    }
}

val decode_ldaxrh_aarch64_instrs_memory_exclusive_single : (bits(5), bits(5), bits(5), bits(1), bits(5), bits(1), bits(2)) -> unit

function decode_ldaxrh_aarch64_instrs_memory_exclusive_single (Rt, Rn, Rt2, o0, Rs, L, size) = {
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 't2 = UInt(Rt2);
    let 's = UInt(Rs);
    let acqrel : bool = o0 == 0b1;
    let pair : bool = false;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'elsize = (8 << UInt(size));
    let 'regsize = if elsize == 64 then 64 else 32;
    let 'datasize = if pair then elsize * 2 else elsize;
    let tagchecked : bool = n != 31;
    rt_unknown : bool = false;
    rn_unknown : bool = false;
    if (memop == MemOp_LOAD & pair) & t == t2 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);
        assert(c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    if memop == MemOp_STORE then {
        if s == t | pair & s == t2 then {
            let c : Constraint = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);
            assert(c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
            match c {
              Constraint_UNKNOWN => {
                  rt_unknown = true
              },
              Constraint_UNDEF => {
                  throw(Error_Undefined())
              },
              Constraint_NOP => {
                  EndOfInstruction()
              },
              _ => ()
            }
        };
        if s == n & n != 31 then {
            let c : Constraint = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);
            assert(c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
            match c {
              Constraint_UNKNOWN => {
                  rn_unknown = true
              },
              Constraint_UNDEF => {
                  throw(Error_Undefined())
              },
              Constraint_NOP => {
                  EndOfInstruction()
              },
              _ => ()
            }
        };
        ()
    };
    execute_aarch64_instrs_memory_exclusive_single(acqrel, datasize, elsize, memop, n, pair, regsize, rn_unknown, rt_unknown, s, t, t2, tagchecked)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, bitone, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 585) = {
    SEE = 585;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rt2 = Slice(__opcode, 10, 5);
    let o0 = Slice(__opcode, 15, 1);
    let Rs = Slice(__opcode, 16, 5);
    let L = Slice(__opcode, 22, 1);
    let size = Slice(__opcode, 30, 2);
    if (((((((([__opcode[10]] != 0b1 | [__opcode[11]] != 0b1) | [__opcode[12]] != 0b1) | [__opcode[13]] != 0b1) | [__opcode[14]] != 0b1) | [__opcode[16]] != 0b1) | [__opcode[17]] != 0b1) | [__opcode[18]] != 0b1) | [__opcode[19]] != 0b1) | [__opcode[20]] != 0b1 then {
        throw(Error_ConstrainedUnpredictable())
    } else {
        decode_ldaxrh_aarch64_instrs_memory_exclusive_single(Rt, Rn, Rt2, o0, Rs, L, size)
    }
}

val decode_ldxr_aarch64_instrs_memory_exclusive_single : (bits(5), bits(5), bits(5), bits(1), bits(5), bits(1), bits(2)) -> unit

function decode_ldxr_aarch64_instrs_memory_exclusive_single (Rt, Rn, Rt2, o0, Rs, L, size) = {
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 't2 = UInt(Rt2);
    let 's = UInt(Rs);
    let acqrel : bool = o0 == 0b1;
    let pair : bool = false;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'elsize = (8 << UInt(size));
    let 'regsize = if elsize == 64 then 64 else 32;
    let 'datasize = if pair then elsize * 2 else elsize;
    let tagchecked : bool = n != 31;
    rt_unknown : bool = false;
    rn_unknown : bool = false;
    if (memop == MemOp_LOAD & pair) & t == t2 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);
        assert(c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    if memop == MemOp_STORE then {
        if s == t | pair & s == t2 then {
            let c : Constraint = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);
            assert(c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
            match c {
              Constraint_UNKNOWN => {
                  rt_unknown = true
              },
              Constraint_UNDEF => {
                  throw(Error_Undefined())
              },
              Constraint_NOP => {
                  EndOfInstruction()
              },
              _ => ()
            }
        };
        if s == n & n != 31 then {
            let c : Constraint = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);
            assert(c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
            match c {
              Constraint_UNKNOWN => {
                  rn_unknown = true
              },
              Constraint_UNDEF => {
                  throw(Error_Undefined())
              },
              Constraint_NOP => {
                  EndOfInstruction()
              },
              _ => ()
            }
        };
        ()
    };
    execute_aarch64_instrs_memory_exclusive_single(acqrel, datasize, elsize, memop, n, pair, regsize, rn_unknown, rt_unknown, s, t, t2, tagchecked)
}

function clause __DecodeA64_LoadStore ((pc, ([bitone, _, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 586) = {
    SEE = 586;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rt2 = Slice(__opcode, 10, 5);
    let o0 = Slice(__opcode, 15, 1);
    let Rs = Slice(__opcode, 16, 5);
    let L = Slice(__opcode, 22, 1);
    let size = Slice(__opcode, 30, 2);
    if (((((((([__opcode[10]] != 0b1 | [__opcode[11]] != 0b1) | [__opcode[12]] != 0b1) | [__opcode[13]] != 0b1) | [__opcode[14]] != 0b1) | [__opcode[16]] != 0b1) | [__opcode[17]] != 0b1) | [__opcode[18]] != 0b1) | [__opcode[19]] != 0b1) | [__opcode[20]] != 0b1 then {
        throw(Error_ConstrainedUnpredictable())
    } else {
        decode_ldxr_aarch64_instrs_memory_exclusive_single(Rt, Rn, Rt2, o0, Rs, L, size)
    }
}

val decode_ldxrb_aarch64_instrs_memory_exclusive_single : (bits(5), bits(5), bits(5), bits(1), bits(5), bits(1), bits(2)) -> unit

function decode_ldxrb_aarch64_instrs_memory_exclusive_single (Rt, Rn, Rt2, o0, Rs, L, size) = {
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 't2 = UInt(Rt2);
    let 's = UInt(Rs);
    let acqrel : bool = o0 == 0b1;
    let pair : bool = false;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'elsize = (8 << UInt(size));
    let 'regsize = if elsize == 64 then 64 else 32;
    let 'datasize = if pair then elsize * 2 else elsize;
    let tagchecked : bool = n != 31;
    rt_unknown : bool = false;
    rn_unknown : bool = false;
    if (memop == MemOp_LOAD & pair) & t == t2 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);
        assert(c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    if memop == MemOp_STORE then {
        if s == t | pair & s == t2 then {
            let c : Constraint = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);
            assert(c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
            match c {
              Constraint_UNKNOWN => {
                  rt_unknown = true
              },
              Constraint_UNDEF => {
                  throw(Error_Undefined())
              },
              Constraint_NOP => {
                  EndOfInstruction()
              },
              _ => ()
            }
        };
        if s == n & n != 31 then {
            let c : Constraint = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);
            assert(c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
            match c {
              Constraint_UNKNOWN => {
                  rn_unknown = true
              },
              Constraint_UNDEF => {
                  throw(Error_Undefined())
              },
              Constraint_NOP => {
                  EndOfInstruction()
              },
              _ => ()
            }
        };
        ()
    };
    execute_aarch64_instrs_memory_exclusive_single(acqrel, datasize, elsize, memop, n, pair, regsize, rn_unknown, rt_unknown, s, t, t2, tagchecked)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 587) = {
    SEE = 587;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rt2 = Slice(__opcode, 10, 5);
    let o0 = Slice(__opcode, 15, 1);
    let Rs = Slice(__opcode, 16, 5);
    let L = Slice(__opcode, 22, 1);
    let size = Slice(__opcode, 30, 2);
    if (((((((([__opcode[10]] != 0b1 | [__opcode[11]] != 0b1) | [__opcode[12]] != 0b1) | [__opcode[13]] != 0b1) | [__opcode[14]] != 0b1) | [__opcode[16]] != 0b1) | [__opcode[17]] != 0b1) | [__opcode[18]] != 0b1) | [__opcode[19]] != 0b1) | [__opcode[20]] != 0b1 then {
        throw(Error_ConstrainedUnpredictable())
    } else {
        decode_ldxrb_aarch64_instrs_memory_exclusive_single(Rt, Rn, Rt2, o0, Rs, L, size)
    }
}

val decode_ldxrh_aarch64_instrs_memory_exclusive_single : (bits(5), bits(5), bits(5), bits(1), bits(5), bits(1), bits(2)) -> unit

function decode_ldxrh_aarch64_instrs_memory_exclusive_single (Rt, Rn, Rt2, o0, Rs, L, size) = {
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 't2 = UInt(Rt2);
    let 's = UInt(Rs);
    let acqrel : bool = o0 == 0b1;
    let pair : bool = false;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'elsize = (8 << UInt(size));
    let 'regsize = if elsize == 64 then 64 else 32;
    let 'datasize = if pair then elsize * 2 else elsize;
    let tagchecked : bool = n != 31;
    rt_unknown : bool = false;
    rn_unknown : bool = false;
    if (memop == MemOp_LOAD & pair) & t == t2 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);
        assert(c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    if memop == MemOp_STORE then {
        if s == t | pair & s == t2 then {
            let c : Constraint = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);
            assert(c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
            match c {
              Constraint_UNKNOWN => {
                  rt_unknown = true
              },
              Constraint_UNDEF => {
                  throw(Error_Undefined())
              },
              Constraint_NOP => {
                  EndOfInstruction()
              },
              _ => ()
            }
        };
        if s == n & n != 31 then {
            let c : Constraint = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);
            assert(c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
            match c {
              Constraint_UNKNOWN => {
                  rn_unknown = true
              },
              Constraint_UNDEF => {
                  throw(Error_Undefined())
              },
              Constraint_NOP => {
                  EndOfInstruction()
              },
              _ => ()
            }
        };
        ()
    };
    execute_aarch64_instrs_memory_exclusive_single(acqrel, datasize, elsize, memop, n, pair, regsize, rn_unknown, rt_unknown, s, t, t2, tagchecked)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, bitone, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 588) = {
    SEE = 588;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rt2 = Slice(__opcode, 10, 5);
    let o0 = Slice(__opcode, 15, 1);
    let Rs = Slice(__opcode, 16, 5);
    let L = Slice(__opcode, 22, 1);
    let size = Slice(__opcode, 30, 2);
    if (((((((([__opcode[10]] != 0b1 | [__opcode[11]] != 0b1) | [__opcode[12]] != 0b1) | [__opcode[13]] != 0b1) | [__opcode[14]] != 0b1) | [__opcode[16]] != 0b1) | [__opcode[17]] != 0b1) | [__opcode[18]] != 0b1) | [__opcode[19]] != 0b1) | [__opcode[20]] != 0b1 then {
        throw(Error_ConstrainedUnpredictable())
    } else {
        decode_ldxrh_aarch64_instrs_memory_exclusive_single(Rt, Rn, Rt2, o0, Rs, L, size)
    }
}

val decode_stlxr_aarch64_instrs_memory_exclusive_single : (bits(5), bits(5), bits(5), bits(1), bits(5), bits(1), bits(2)) -> unit

function decode_stlxr_aarch64_instrs_memory_exclusive_single (Rt, Rn, Rt2, o0, Rs, L, size) = {
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 't2 = UInt(Rt2);
    let 's = UInt(Rs);
    let acqrel : bool = o0 == 0b1;
    let pair : bool = false;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'elsize = (8 << UInt(size));
    let 'regsize = if elsize == 64 then 64 else 32;
    let 'datasize = if pair then elsize * 2 else elsize;
    let tagchecked : bool = n != 31;
    rt_unknown : bool = false;
    rn_unknown : bool = false;
    if (memop == MemOp_LOAD & pair) & t == t2 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);
        assert(c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    if memop == MemOp_STORE then {
        if s == t | pair & s == t2 then {
            let c : Constraint = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);
            assert(c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
            match c {
              Constraint_UNKNOWN => {
                  rt_unknown = true
              },
              Constraint_UNDEF => {
                  throw(Error_Undefined())
              },
              Constraint_NOP => {
                  EndOfInstruction()
              },
              _ => ()
            }
        };
        if s == n & n != 31 then {
            let c : Constraint = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);
            assert(c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
            match c {
              Constraint_UNKNOWN => {
                  rn_unknown = true
              },
              Constraint_UNDEF => {
                  throw(Error_Undefined())
              },
              Constraint_NOP => {
                  EndOfInstruction()
              },
              _ => ()
            }
        };
        ()
    };
    execute_aarch64_instrs_memory_exclusive_single(acqrel, datasize, elsize, memop, n, pair, regsize, rn_unknown, rt_unknown, s, t, t2, tagchecked)
}

function clause __DecodeA64_LoadStore ((pc, ([bitone, _, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, bitone, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 589) = {
    SEE = 589;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rt2 = Slice(__opcode, 10, 5);
    let o0 = Slice(__opcode, 15, 1);
    let Rs = Slice(__opcode, 16, 5);
    let L = Slice(__opcode, 22, 1);
    let size = Slice(__opcode, 30, 2);
    if ((([__opcode[10]] != 0b1 | [__opcode[11]] != 0b1) | [__opcode[12]] != 0b1) | [__opcode[13]] != 0b1) | [__opcode[14]] != 0b1 then {
        throw(Error_ConstrainedUnpredictable())
    } else {
        decode_stlxr_aarch64_instrs_memory_exclusive_single(Rt, Rn, Rt2, o0, Rs, L, size)
    }
}

val decode_stlxrb_aarch64_instrs_memory_exclusive_single : (bits(5), bits(5), bits(5), bits(1), bits(5), bits(1), bits(2)) -> unit

function decode_stlxrb_aarch64_instrs_memory_exclusive_single (Rt, Rn, Rt2, o0, Rs, L, size) = {
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 't2 = UInt(Rt2);
    let 's = UInt(Rs);
    let acqrel : bool = o0 == 0b1;
    let pair : bool = false;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'elsize = (8 << UInt(size));
    let 'regsize = if elsize == 64 then 64 else 32;
    let 'datasize = if pair then elsize * 2 else elsize;
    let tagchecked : bool = n != 31;
    rt_unknown : bool = false;
    rn_unknown : bool = false;
    if (memop == MemOp_LOAD & pair) & t == t2 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);
        assert(c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    if memop == MemOp_STORE then {
        if s == t | pair & s == t2 then {
            let c : Constraint = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);
            assert(c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
            match c {
              Constraint_UNKNOWN => {
                  rt_unknown = true
              },
              Constraint_UNDEF => {
                  throw(Error_Undefined())
              },
              Constraint_NOP => {
                  EndOfInstruction()
              },
              _ => ()
            }
        };
        if s == n & n != 31 then {
            let c : Constraint = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);
            assert(c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
            match c {
              Constraint_UNKNOWN => {
                  rn_unknown = true
              },
              Constraint_UNDEF => {
                  throw(Error_Undefined())
              },
              Constraint_NOP => {
                  EndOfInstruction()
              },
              _ => ()
            }
        };
        ()
    };
    execute_aarch64_instrs_memory_exclusive_single(acqrel, datasize, elsize, memop, n, pair, regsize, rn_unknown, rt_unknown, s, t, t2, tagchecked)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, bitone, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 590) = {
    SEE = 590;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rt2 = Slice(__opcode, 10, 5);
    let o0 = Slice(__opcode, 15, 1);
    let Rs = Slice(__opcode, 16, 5);
    let L = Slice(__opcode, 22, 1);
    let size = Slice(__opcode, 30, 2);
    if ((([__opcode[10]] != 0b1 | [__opcode[11]] != 0b1) | [__opcode[12]] != 0b1) | [__opcode[13]] != 0b1) | [__opcode[14]] != 0b1 then {
        throw(Error_ConstrainedUnpredictable())
    } else {
        decode_stlxrb_aarch64_instrs_memory_exclusive_single(Rt, Rn, Rt2, o0, Rs, L, size)
    }
}

val decode_stlxrh_aarch64_instrs_memory_exclusive_single : (bits(5), bits(5), bits(5), bits(1), bits(5), bits(1), bits(2)) -> unit

function decode_stlxrh_aarch64_instrs_memory_exclusive_single (Rt, Rn, Rt2, o0, Rs, L, size) = {
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 't2 = UInt(Rt2);
    let 's = UInt(Rs);
    let acqrel : bool = o0 == 0b1;
    let pair : bool = false;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'elsize = (8 << UInt(size));
    let 'regsize = if elsize == 64 then 64 else 32;
    let 'datasize = if pair then elsize * 2 else elsize;
    let tagchecked : bool = n != 31;
    rt_unknown : bool = false;
    rn_unknown : bool = false;
    if (memop == MemOp_LOAD & pair) & t == t2 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);
        assert(c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    if memop == MemOp_STORE then {
        if s == t | pair & s == t2 then {
            let c : Constraint = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);
            assert(c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
            match c {
              Constraint_UNKNOWN => {
                  rt_unknown = true
              },
              Constraint_UNDEF => {
                  throw(Error_Undefined())
              },
              Constraint_NOP => {
                  EndOfInstruction()
              },
              _ => ()
            }
        };
        if s == n & n != 31 then {
            let c : Constraint = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);
            assert(c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
            match c {
              Constraint_UNKNOWN => {
                  rn_unknown = true
              },
              Constraint_UNDEF => {
                  throw(Error_Undefined())
              },
              Constraint_NOP => {
                  EndOfInstruction()
              },
              _ => ()
            }
        };
        ()
    };
    execute_aarch64_instrs_memory_exclusive_single(acqrel, datasize, elsize, memop, n, pair, regsize, rn_unknown, rt_unknown, s, t, t2, tagchecked)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, bitone, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, bitone, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 591) = {
    SEE = 591;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rt2 = Slice(__opcode, 10, 5);
    let o0 = Slice(__opcode, 15, 1);
    let Rs = Slice(__opcode, 16, 5);
    let L = Slice(__opcode, 22, 1);
    let size = Slice(__opcode, 30, 2);
    if ((([__opcode[10]] != 0b1 | [__opcode[11]] != 0b1) | [__opcode[12]] != 0b1) | [__opcode[13]] != 0b1) | [__opcode[14]] != 0b1 then {
        throw(Error_ConstrainedUnpredictable())
    } else {
        decode_stlxrh_aarch64_instrs_memory_exclusive_single(Rt, Rn, Rt2, o0, Rs, L, size)
    }
}

val decode_stxr_aarch64_instrs_memory_exclusive_single : (bits(5), bits(5), bits(5), bits(1), bits(5), bits(1), bits(2)) -> unit

function decode_stxr_aarch64_instrs_memory_exclusive_single (Rt, Rn, Rt2, o0, Rs, L, size) = {
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 't2 = UInt(Rt2);
    let 's = UInt(Rs);
    let acqrel : bool = o0 == 0b1;
    let pair : bool = false;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'elsize = (8 << UInt(size));
    let 'regsize = if elsize == 64 then 64 else 32;
    let 'datasize = if pair then elsize * 2 else elsize;
    let tagchecked : bool = n != 31;
    rt_unknown : bool = false;
    rn_unknown : bool = false;
    if (memop == MemOp_LOAD & pair) & t == t2 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);
        assert(c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    if memop == MemOp_STORE then {
        if s == t | pair & s == t2 then {
            let c : Constraint = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);
            assert(c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
            match c {
              Constraint_UNKNOWN => {
                  rt_unknown = true
              },
              Constraint_UNDEF => {
                  throw(Error_Undefined())
              },
              Constraint_NOP => {
                  EndOfInstruction()
              },
              _ => ()
            }
        };
        if s == n & n != 31 then {
            let c : Constraint = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);
            assert(c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
            match c {
              Constraint_UNKNOWN => {
                  rn_unknown = true
              },
              Constraint_UNDEF => {
                  throw(Error_Undefined())
              },
              Constraint_NOP => {
                  EndOfInstruction()
              },
              _ => ()
            }
        };
        ()
    };
    execute_aarch64_instrs_memory_exclusive_single(acqrel, datasize, elsize, memop, n, pair, regsize, rn_unknown, rt_unknown, s, t, t2, tagchecked)
}

function clause __DecodeA64_LoadStore ((pc, ([bitone, _, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, bitzero, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 592) = {
    SEE = 592;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rt2 = Slice(__opcode, 10, 5);
    let o0 = Slice(__opcode, 15, 1);
    let Rs = Slice(__opcode, 16, 5);
    let L = Slice(__opcode, 22, 1);
    let size = Slice(__opcode, 30, 2);
    if ((([__opcode[10]] != 0b1 | [__opcode[11]] != 0b1) | [__opcode[12]] != 0b1) | [__opcode[13]] != 0b1) | [__opcode[14]] != 0b1 then {
        throw(Error_ConstrainedUnpredictable())
    } else {
        decode_stxr_aarch64_instrs_memory_exclusive_single(Rt, Rn, Rt2, o0, Rs, L, size)
    }
}

val decode_stxrb_aarch64_instrs_memory_exclusive_single : (bits(5), bits(5), bits(5), bits(1), bits(5), bits(1), bits(2)) -> unit

function decode_stxrb_aarch64_instrs_memory_exclusive_single (Rt, Rn, Rt2, o0, Rs, L, size) = {
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 't2 = UInt(Rt2);
    let 's = UInt(Rs);
    let acqrel : bool = o0 == 0b1;
    let pair : bool = false;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'elsize = (8 << UInt(size));
    let 'regsize = if elsize == 64 then 64 else 32;
    let 'datasize = if pair then elsize * 2 else elsize;
    let tagchecked : bool = n != 31;
    rt_unknown : bool = false;
    rn_unknown : bool = false;
    if (memop == MemOp_LOAD & pair) & t == t2 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);
        assert(c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    if memop == MemOp_STORE then {
        if s == t | pair & s == t2 then {
            let c : Constraint = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);
            assert(c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
            match c {
              Constraint_UNKNOWN => {
                  rt_unknown = true
              },
              Constraint_UNDEF => {
                  throw(Error_Undefined())
              },
              Constraint_NOP => {
                  EndOfInstruction()
              },
              _ => ()
            }
        };
        if s == n & n != 31 then {
            let c : Constraint = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);
            assert(c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
            match c {
              Constraint_UNKNOWN => {
                  rn_unknown = true
              },
              Constraint_UNDEF => {
                  throw(Error_Undefined())
              },
              Constraint_NOP => {
                  EndOfInstruction()
              },
              _ => ()
            }
        };
        ()
    };
    execute_aarch64_instrs_memory_exclusive_single(acqrel, datasize, elsize, memop, n, pair, regsize, rn_unknown, rt_unknown, s, t, t2, tagchecked)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, bitzero, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 593) = {
    SEE = 593;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rt2 = Slice(__opcode, 10, 5);
    let o0 = Slice(__opcode, 15, 1);
    let Rs = Slice(__opcode, 16, 5);
    let L = Slice(__opcode, 22, 1);
    let size = Slice(__opcode, 30, 2);
    if ((([__opcode[10]] != 0b1 | [__opcode[11]] != 0b1) | [__opcode[12]] != 0b1) | [__opcode[13]] != 0b1) | [__opcode[14]] != 0b1 then {
        throw(Error_ConstrainedUnpredictable())
    } else {
        decode_stxrb_aarch64_instrs_memory_exclusive_single(Rt, Rn, Rt2, o0, Rs, L, size)
    }
}

val decode_stxrh_aarch64_instrs_memory_exclusive_single : (bits(5), bits(5), bits(5), bits(1), bits(5), bits(1), bits(2)) -> unit

function decode_stxrh_aarch64_instrs_memory_exclusive_single (Rt, Rn, Rt2, o0, Rs, L, size) = {
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 't2 = UInt(Rt2);
    let 's = UInt(Rs);
    let acqrel : bool = o0 == 0b1;
    let pair : bool = false;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'elsize = (8 << UInt(size));
    let 'regsize = if elsize == 64 then 64 else 32;
    let 'datasize = if pair then elsize * 2 else elsize;
    let tagchecked : bool = n != 31;
    rt_unknown : bool = false;
    rn_unknown : bool = false;
    if (memop == MemOp_LOAD & pair) & t == t2 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);
        assert(c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    if memop == MemOp_STORE then {
        if s == t | pair & s == t2 then {
            let c : Constraint = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);
            assert(c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
            match c {
              Constraint_UNKNOWN => {
                  rt_unknown = true
              },
              Constraint_UNDEF => {
                  throw(Error_Undefined())
              },
              Constraint_NOP => {
                  EndOfInstruction()
              },
              _ => ()
            }
        };
        if s == n & n != 31 then {
            let c : Constraint = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);
            assert(c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
            match c {
              Constraint_UNKNOWN => {
                  rn_unknown = true
              },
              Constraint_UNDEF => {
                  throw(Error_Undefined())
              },
              Constraint_NOP => {
                  EndOfInstruction()
              },
              _ => ()
            }
        };
        ()
    };
    execute_aarch64_instrs_memory_exclusive_single(acqrel, datasize, elsize, memop, n, pair, regsize, rn_unknown, rt_unknown, s, t, t2, tagchecked)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, bitone, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, bitzero, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 594) = {
    SEE = 594;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rt2 = Slice(__opcode, 10, 5);
    let o0 = Slice(__opcode, 15, 1);
    let Rs = Slice(__opcode, 16, 5);
    let L = Slice(__opcode, 22, 1);
    let size = Slice(__opcode, 30, 2);
    if ((([__opcode[10]] != 0b1 | [__opcode[11]] != 0b1) | [__opcode[12]] != 0b1) | [__opcode[13]] != 0b1) | [__opcode[14]] != 0b1 then {
        throw(Error_ConstrainedUnpredictable())
    } else {
        decode_stxrh_aarch64_instrs_memory_exclusive_single(Rt, Rn, Rt2, o0, Rs, L, size)
    }
}

val execute_aarch64_instrs_memory_atomicops_ld_128_ldclrp : forall ('acquire : Bool) 'n ('release : Bool) 't 't2 ('tagchecked : Bool),
  (0 <= 't2 & 't2 <= 31 & 0 <= 't & 't <= 31 & 0 <= 'n & 'n <= 31).
  (bool('acquire), int('n), MemAtomicOp, bool('release), int('t), int('t2), bool('tagchecked)) -> unit

function execute_aarch64_instrs_memory_atomicops_ld_128_ldclrp (acquire, n, op, release, t, t2, tagchecked) = {
    address : bits(64) = undefined;
    let value1_name : bits(64) = X_read(t, 64);
    let value2_name : bits(64) = X_read(t2, 64);
    let accdesc : AccessDescriptor = CreateAccDescAtomicOp(op, acquire, release, tagchecked);
    if n == 31 then {
        CheckSPAlignment();
        address = SP_read()
    } else {
        address = X_read(n, 64)
    };
    let store_value : bits(128) = if BigEndian(accdesc.acctype) then
      value1_name @ value2_name
    else
      value2_name @ value1_name;
    let comparevalue : bits(128) = __UNKNOWN_bits(128);
    let data : bits(128) = MemAtomic(address, comparevalue, store_value, accdesc);
    if BigEndian(accdesc.acctype) then {
        X_set(t, 64) = data[127 .. 64];
        X_set(t2, 64) = data[63 .. 0]
    } else {
        X_set(t, 64) = data[63 .. 0];
        X_set(t2, 64) = data[127 .. 64]
    }
}

val decode_ldclrp_aarch64_instrs_memory_atomicops_ld_128_ldclrp : (bits(5), bits(5), bits(3), bits(1), bits(5), bits(1), bits(1), bits(1)) -> unit

function decode_ldclrp_aarch64_instrs_memory_atomicops_ld_128_ldclrp (Rt, Rn, opc, o3, Rt2, R, A, S) = {
    if not_bool(HaveLSE128()) then {
        throw(Error_Undefined())
    };
    if Rt == 0b11111 then {
        throw(Error_Undefined())
    };
    if Rt2 == 0b11111 then {
        throw(Error_Undefined())
    };
    let 't = UInt(Rt);
    let 't2 = UInt(Rt2);
    let 'n = UInt(Rn);
    op : MemAtomicOp = undefined;
    match opc {
      0b001 => {
          op = MemAtomicOp_BIC
      },
      0b011 => {
          op = MemAtomicOp_ORR
      },
      _ => ()
    };
    let acquire : bool = A == 0b1;
    let release : bool = R == 0b1;
    let tagchecked : bool = n != 31;
    execute_aarch64_instrs_memory_atomicops_ld_128_ldclrp(acquire, n, op, release, t, t2, tagchecked)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitone, _, _, bitone, _, _, _, _, _, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 595) = {
    SEE = 595;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let opc = Slice(__opcode, 12, 3);
    let o3 = Slice(__opcode, 15, 1);
    let Rt2 = Slice(__opcode, 16, 5);
    let R = Slice(__opcode, 22, 1);
    let A = Slice(__opcode, 23, 1);
    let S = Slice(__opcode, 30, 1);
    decode_ldclrp_aarch64_instrs_memory_atomicops_ld_128_ldclrp(Rt, Rn, opc, o3, Rt2, R, A, S)
}

val execute_aarch64_instrs_integer_tags_mcgettag : forall 'n 't,
  (0 <= 't & 't <= 31 & 0 <= 'n & 'n <= 31).
  (int('n), bits(64), int('t)) -> unit

function execute_aarch64_instrs_integer_tags_mcgettag (n, offset, t) = {
    address : bits(64) = undefined;
    if n == 31 then {
        CheckSPAlignment();
        address = SP_read()
    } else {
        address = X_read(n, 64)
    };
    address : bits(64) = address + offset;
    let address : bits(64) = Align(address, TAG_GRANULE);
    let accdesc : AccessDescriptor = CreateAccDescLDGSTG(MemOp_LOAD);
    let tag : bits(4) = AArch64_MemTag_read(address, accdesc);
    X_set(t, 64) = AArch64_AddressWithAllocationTag(X_read(t, 64), tag)
}

val decode_ldg_aarch64_instrs_integer_tags_mcgettag : (bits(5), bits(5), bits(9)) -> unit

function decode_ldg_aarch64_instrs_integer_tags_mcgettag (Xt, Xn, imm9) = {
    if not_bool(HaveMTEExt()) then {
        throw(Error_Undefined())
    };
    let 't = UInt(Xt);
    let 'n = UInt(Xn);
    let offset : bits(64) = LSL(SignExtend(imm9, 64), LOG2_TAG_GRANULE);
    execute_aarch64_instrs_integer_tags_mcgettag(n, offset, t)
}

function clause __DecodeA64_LoadStore ((pc, ([bitone, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitone, bitzero, bitone, bitone, _, _, _, _, _, _, _, _, _, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 596) = {
    SEE = 596;
    let Xt = Slice(__opcode, 0, 5);
    let Xn = Slice(__opcode, 5, 5);
    let imm9 = Slice(__opcode, 12, 9);
    decode_ldg_aarch64_instrs_integer_tags_mcgettag(Xt, Xn, imm9)
}

val execute_aarch64_instrs_integer_tags_mcgettagarray : forall 'n 't,
  (0 <= 't & 't <= 31 & 0 <= 'n & 'n <= 31).
  (int('n), int('t)) -> unit

function execute_aarch64_instrs_integer_tags_mcgettagarray (n, t) = {
    if PSTATE.EL == EL0 then {
        throw(Error_Undefined())
    };
    data : bits(64) = Zeros(64);
    address : bits(64) = undefined;
    if n == 31 then {
        CheckSPAlignment();
        address = SP_read()
    } else {
        address = X_read(n, 64)
    };
    let 'size = 4 * pow2(UInt(GMID_EL1[BS]));
    address : bits(64) = Align(address, size);
    let 'count = (size >> LOG2_TAG_GRANULE);
    index : int = UInt(address[LOG2_TAG_GRANULE + 3 .. LOG2_TAG_GRANULE]);
    let accdesc : AccessDescriptor = CreateAccDescLDGSTG(MemOp_LOAD);
    foreach (i from 0 to (count - 1) by 1 in inc) {
        let tag : bits(4) = AArch64_MemTag_read(address, accdesc);
        let 'index = index in
          {
              assert(constraint((0 <= 'index * 4 & 'index * 4 + 3 < 64)));
              data[index * 4 + 3 .. index * 4] = tag
          };
        address = address + TAG_GRANULE;
        index = index + 1
    };
    X_set(t, 64) = data
}

val decode_ldgm_aarch64_instrs_integer_tags_mcgettagarray : (bits(5), bits(5)) -> unit

function decode_ldgm_aarch64_instrs_integer_tags_mcgettagarray (Xt, Xn) = {
    if not_bool(HaveMTE2Ext()) then {
        throw(Error_Undefined())
    };
    let 't = UInt(Xt);
    let 'n = UInt(Xn);
    execute_aarch64_instrs_integer_tags_mcgettagarray(n, t)
}

function clause __DecodeA64_LoadStore ((pc, ([bitone, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 597) = {
    SEE = 597;
    let Xt = Slice(__opcode, 0, 5);
    let Xn = Slice(__opcode, 5, 5);
    decode_ldgm_aarch64_instrs_integer_tags_mcgettagarray(Xt, Xn)
}

val execute_aarch64_instrs_memory_ordered_pair_ldiapp : forall 'datasize 'n 'offset ('postindex : Bool) ('rt_unknown : Bool) 't 't2 ('tagchecked : Bool) ('wb_unknown : Bool) ('wback : Bool),
  (0 <= 't2 & 't2 <= 31 & 0 <= 't & 't <= 31 & 0 <= 'n & 'n <= 31 & 'datasize in {32, 64}).
  (int('datasize), MemOp, int('n), int('offset), bool('postindex), bool('rt_unknown), int('t), int('t2), bool('tagchecked), bool('wb_unknown), bool('wback)) -> unit

function execute_aarch64_instrs_memory_ordered_pair_ldiapp (datasize, memop, n, offset, postindex, rt_unknown, t, t2, tagchecked, wb_unknown, wback) = {
    address : bits(64) = undefined;
    data1 : bits('datasize) = undefined;
    data2 : bits('datasize) = undefined;
    let 'dbytes = DIV(datasize, 8);
    let accdesc : AccessDescriptor = CreateAccDescAcqRel(memop, tagchecked);
    if n == 31 then {
        CheckSPAlignment();
        address = SP_read()
    } else {
        address = X_read(n, 64)
    };
    if not_bool(postindex) then {
        address = address + offset
    };
    match memop {
      MemOp_STORE => {
          if rt_unknown & t == n then {
              data1 = __UNKNOWN_bits(datasize)
          } else {
              data1 = X_read(t, datasize)
          };
          if rt_unknown & t2 == n then {
              data2 = __UNKNOWN_bits(datasize)
          } else {
              data2 = X_read(t2, datasize)
          };
          if HaveLSE2Ext() then {
              full_data : bits(2 * 'datasize) = undefined;
              if BigEndian(accdesc.acctype) then {
                  full_data = data1 @ data2
              } else {
                  full_data = data2 @ data1
              };
              let ispair : bool = true;
              let highestAddressfirst : bool = not_bool(postindex) & offset < 0;
              Mem_set__2(address, 2 * dbytes, accdesc, ispair, highestAddressfirst) = full_data
          } else {
              if not_bool(postindex) & offset < 0 then {
                  Mem_set(address + dbytes, dbytes, accdesc) = data2;
                  Mem_set(address + 0, dbytes, accdesc) = data1
              } else {
                  Mem_set(address + 0, dbytes, accdesc) = data1;
                  Mem_set(address + dbytes, dbytes, accdesc) = data2
              }
          }
      },
      MemOp_LOAD => {
          if HaveLSE2Ext() then {
              let ispair : bool = true;
              let full_data : bits(2 * 'datasize) = Mem_read__1(address, 2 * dbytes, accdesc, ispair);
              if BigEndian(accdesc.acctype) then {
                  data2 = full_data[datasize - 1 .. 0];
                  data1 = full_data[2 * datasize - 1 .. datasize]
              } else {
                  data1 = full_data[datasize - 1 .. 0];
                  data2 = full_data[2 * datasize - 1 .. datasize]
              }
          } else {
              data1 = Mem_read(address + 0, dbytes, accdesc);
              data2 = Mem_read(address + dbytes, dbytes, accdesc)
          };
          if rt_unknown then {
              data1 = __UNKNOWN_bits(datasize);
              data2 = __UNKNOWN_bits(datasize)
          };
          X_set(t, datasize) = data1;
          X_set(t2, datasize) = data2
      },
      _ => ()
    };
    if wback then {
        if wb_unknown then {
            address = __UNKNOWN_bits(64)
        } else if postindex then {
            address = address + offset
        } else ();
        if n == 31 then {
            SP_set() = address
        } else {
            X_set(n, 64) = address
        }
    };
    if SPESampleInFlight then {
        SPESampleGeneralPurposeLoadStore()
    };
    ()
}

val decode_ldiapp_aarch64_instrs_memory_ordered_pair_ldiapp : (bits(5), bits(5), bits(4), bits(5), bits(1), bits(2)) -> unit

function decode_ldiapp_aarch64_instrs_memory_ordered_pair_ldiapp (Rt, Rn, opc2, Rt2, L, size) = {
    let postindex : bool = [opc2[0]] == 0b0;
    wback : bool = [opc2[0]] == 0b0;
    offset : int = undefined;
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 't2 = UInt(Rt2);
    let 'scale = 2 + UInt([size[0]]);
    let 'datasize = (8 << scale);
    memop : MemOp = undefined;
    if L == 0b1 then {
        memop = MemOp_LOAD;
        offset = if [opc2[0]] == 0b0 then (2 << scale) else 0
    } else {
        memop = MemOp_STORE;
        offset = if [opc2[0]] == 0b0 then negate(1) * (2 << scale) else 0
    };
    let 'offset = offset;
    let tagchecked : bool = wback | n != 31;
    rt_unknown : bool = false;
    wb_unknown : bool = false;
    if ((memop == MemOp_LOAD & wback) & (t == n | t2 == n)) & n != 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
        assert(c == Constraint_WBSUPPRESS | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_WBSUPPRESS => {
              wback = false
          },
          Constraint_UNKNOWN => {
              wb_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    if ((memop == MemOp_STORE & wback) & (t == n | t2 == n)) & n != 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
        assert(c == Constraint_NONE | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_NONE => {
              rt_unknown = false
          },
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    if memop == MemOp_LOAD & t == t2 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);
        assert(c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    assert(constraint('datasize in {32, 64}));
    execute_aarch64_instrs_memory_ordered_pair_ldiapp(datasize, memop, n, offset, postindex, rt_unknown, t, t2, tagchecked, wb_unknown, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([bitone, _, bitzero, bitone, bitone, bitzero, bitzero, bitone, bitzero, bitone, bitzero, _, _, _, _, _, bitzero, bitzero, bitzero, _, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 598) = {
    SEE = 598;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let opc2 = Slice(__opcode, 12, 4);
    let Rt2 = Slice(__opcode, 16, 5);
    let L = Slice(__opcode, 22, 1);
    let size = Slice(__opcode, 30, 2);
    decode_ldiapp_aarch64_instrs_memory_ordered_pair_ldiapp(Rt, Rn, opc2, Rt2, L, size)
}

val execute_aarch64_instrs_memory_pair_general_no_alloc : forall 'datasize 'n ('nontemporal : Bool) ('postindex : Bool) ('rt_unknown : Bool) 't 't2 ('tagchecked : Bool) ('wback : Bool),
  (0 <= 't2 & 't2 <= 31 & 0 <= 't & 't <= 31 & 0 <= 'n & 'n <= 31 & 'datasize in {32, 64}).
  (int('datasize), MemOp, int('n), bool('nontemporal), bits(64), bool('postindex), bool('rt_unknown), int('t), int('t2), bool('tagchecked), bool('wback)) -> unit

function execute_aarch64_instrs_memory_pair_general_no_alloc (datasize, memop, n, nontemporal, offset, postindex, rt_unknown, t, t2, tagchecked, wback) = {
    address : bits(64) = undefined;
    data1 : bits('datasize) = undefined;
    data2 : bits('datasize) = undefined;
    let 'dbytes = DIV(datasize, 8);
    let privileged : bool = PSTATE.EL != EL0;
    let accdesc : AccessDescriptor = CreateAccDescGPR(memop, nontemporal, privileged, tagchecked);
    if n == 31 then {
        CheckSPAlignment();
        address = SP_read()
    } else {
        address = X_read(n, 64)
    };
    if not_bool(postindex) then {
        address = address + offset
    };
    match memop {
      MemOp_STORE => {
          if rt_unknown & t == n then {
              data1 = __UNKNOWN_bits(datasize)
          } else {
              data1 = X_read(t, datasize)
          };
          if rt_unknown & t2 == n then {
              data2 = __UNKNOWN_bits(datasize)
          } else {
              data2 = X_read(t2, datasize)
          };
          Mem_set(address + 0, dbytes, accdesc) = data1;
          Mem_set(address + dbytes, dbytes, accdesc) = data2
      },
      MemOp_LOAD => {
          if HaveLSE2Ext() then {
              let ispair : bool = true;
              let full_data : bits(2 * 'datasize) = Mem_read__1(address, 2 * dbytes, accdesc, ispair);
              if BigEndian(accdesc.acctype) then {
                  data2 = full_data[datasize - 1 .. 0];
                  data1 = full_data[2 * datasize - 1 .. datasize]
              } else {
                  data1 = full_data[datasize - 1 .. 0];
                  data2 = full_data[2 * datasize - 1 .. datasize]
              }
          } else {
              data1 = Mem_read(address + 0, dbytes, accdesc);
              data2 = Mem_read(address + dbytes, dbytes, accdesc)
          };
          if rt_unknown then {
              data1 = __UNKNOWN_bits(datasize);
              data2 = __UNKNOWN_bits(datasize)
          };
          X_set(t, datasize) = data1;
          X_set(t2, datasize) = data2
      },
      _ => ()
    };
    if wback then {
        if postindex then {
            address = address + offset
        };
        if n == 31 then {
            SP_set() = address
        } else {
            X_set(n, 64) = address
        }
    };
    if SPESampleInFlight then {
        SPESampleGeneralPurposeLoadStore()
    };
    ()
}

val decode_ldnp_gen_aarch64_instrs_memory_pair_general_no_alloc : (bits(5), bits(5), bits(5), bits(7), bits(1), bits(2)) -> unit

function decode_ldnp_gen_aarch64_instrs_memory_pair_general_no_alloc (Rt, Rn, Rt2, imm7, L, opc) = {
    let wback : bool = false;
    let postindex : bool = false;
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 't2 = UInt(Rt2);
    let nontemporal : bool = true;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    if [opc[0]] == 0b1 then {
        throw(Error_Undefined())
    };
    let 'scale = 2 + UInt([opc[1]]);
    let 'datasize = (8 << scale);
    let offset : bits(64) = LSL(SignExtend(imm7, 64), scale);
    let tagchecked : bool = wback | n != 31;
    rt_unknown : bool = false;
    if memop == MemOp_LOAD & t == t2 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);
        assert(c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    assert(constraint('datasize in {32, 64}));
    execute_aarch64_instrs_memory_pair_general_no_alloc(datasize, memop, n, nontemporal, offset, postindex, rt_unknown, t, t2, tagchecked, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([_, bitzero, bitone, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 599) = {
    SEE = 599;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rt2 = Slice(__opcode, 10, 5);
    let imm7 = Slice(__opcode, 15, 7);
    let L = Slice(__opcode, 22, 1);
    let opc = Slice(__opcode, 30, 2);
    decode_ldnp_gen_aarch64_instrs_memory_pair_general_no_alloc(Rt, Rn, Rt2, imm7, L, opc)
}

val decode_stnp_gen_aarch64_instrs_memory_pair_general_no_alloc : (bits(5), bits(5), bits(5), bits(7), bits(1), bits(2)) -> unit

function decode_stnp_gen_aarch64_instrs_memory_pair_general_no_alloc (Rt, Rn, Rt2, imm7, L, opc) = {
    let wback : bool = false;
    let postindex : bool = false;
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 't2 = UInt(Rt2);
    let nontemporal : bool = true;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    if [opc[0]] == 0b1 then {
        throw(Error_Undefined())
    };
    let 'scale = 2 + UInt([opc[1]]);
    let 'datasize = (8 << scale);
    let offset : bits(64) = LSL(SignExtend(imm7, 64), scale);
    let tagchecked : bool = wback | n != 31;
    rt_unknown : bool = false;
    if memop == MemOp_LOAD & t == t2 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);
        assert(c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    assert(constraint('datasize in {32, 64}));
    execute_aarch64_instrs_memory_pair_general_no_alloc(datasize, memop, n, nontemporal, offset, postindex, rt_unknown, t, t2, tagchecked, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([_, bitzero, bitone, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 600) = {
    SEE = 600;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rt2 = Slice(__opcode, 10, 5);
    let imm7 = Slice(__opcode, 15, 7);
    let L = Slice(__opcode, 22, 1);
    let opc = Slice(__opcode, 30, 2);
    decode_stnp_gen_aarch64_instrs_memory_pair_general_no_alloc(Rt, Rn, Rt2, imm7, L, opc)
}

val execute_aarch64_instrs_memory_pair_simdfp_no_alloc : forall 'datasize 'n ('nontemporal : Bool) ('postindex : Bool) ('rt_unknown : Bool) 't 't2 ('tagchecked : Bool) ('wback : Bool),
  (0 <= 't2 & 't2 <= 31 & 0 <= 't & 't <= 31 & 0 <= 'n & 'n <= 31 & 'datasize in {32, 64, 128, 256}).
  (int('datasize), MemOp, int('n), bool('nontemporal), bits(64), bool('postindex), bool('rt_unknown), int('t), int('t2), bool('tagchecked), bool('wback)) -> unit

function execute_aarch64_instrs_memory_pair_simdfp_no_alloc (datasize, memop, n, nontemporal, offset, postindex, rt_unknown, t, t2, tagchecked, wback) = {
    CheckFPEnabled64();
    address : bits(64) = undefined;
    data1 : bits('datasize) = undefined;
    data2 : bits('datasize) = undefined;
    let 'dbytes = DIV(datasize, 8);
    let accdesc : AccessDescriptor = CreateAccDescASIMD(memop, nontemporal, tagchecked);
    if n == 31 then {
        CheckSPAlignment();
        address = SP_read()
    } else {
        address = X_read(n, 64)
    };
    if not_bool(postindex) then {
        address = address + offset
    };
    match memop {
      MemOp_STORE => {
          assert(constraint('datasize in {8, 16, 32, 64, 128}));
          let data1 : bits('datasize) = V_read(t, datasize);
          let data2 : bits('datasize) = V_read(t2, datasize);
          Mem_set(address + 0, dbytes, accdesc) = data1;
          Mem_set(address + dbytes, dbytes, accdesc) = data2
      },
      MemOp_LOAD => {
          data1 : bits('datasize) = Mem_read(address + 0, dbytes, accdesc);
          data2 : bits('datasize) = Mem_read(address + dbytes, dbytes, accdesc);
          if rt_unknown then {
              data1 = __UNKNOWN_bits(datasize);
              data2 = __UNKNOWN_bits(datasize)
          };
          assert(constraint('datasize in {8, 16, 32, 64, 128}));
          V_set(t, datasize) = data1;
          V_set(t2, datasize) = data2
      },
      _ => ()
    };
    if wback then {
        if postindex then {
            address = address + offset
        };
        if n == 31 then {
            SP_set() = address
        } else {
            X_set(n, 64) = address
        }
    };
    if SPESampleInFlight then {
        SPESampleSIMDFPLoadStore()
    };
    ()
}

val decode_ldnp_fpsimd_aarch64_instrs_memory_pair_simdfp_no_alloc : (bits(5), bits(5), bits(5), bits(7), bits(1), bits(2)) -> unit

function decode_ldnp_fpsimd_aarch64_instrs_memory_pair_simdfp_no_alloc (Rt, Rn, Rt2, imm7, L, opc) = {
    let wback : bool = false;
    let postindex : bool = false;
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 't2 = UInt(Rt2);
    let nontemporal : bool = true;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    if opc == 0b11 then {
        throw(Error_Undefined())
    };
    let 'scale = 2 + UInt(opc);
    let 'datasize = (8 << scale);
    let offset : bits(64) = LSL(SignExtend(imm7, 64), scale);
    let tagchecked : bool = wback | n != 31;
    rt_unknown : bool = false;
    if memop == MemOp_LOAD & t == t2 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);
        assert(c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    assert(constraint('datasize in {32, 64, 128, 256}));
    execute_aarch64_instrs_memory_pair_simdfp_no_alloc(datasize, memop, n, nontemporal, offset, postindex, rt_unknown, t, t2, tagchecked, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([_, _, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 601) = {
    SEE = 601;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rt2 = Slice(__opcode, 10, 5);
    let imm7 = Slice(__opcode, 15, 7);
    let L = Slice(__opcode, 22, 1);
    let opc = Slice(__opcode, 30, 2);
    decode_ldnp_fpsimd_aarch64_instrs_memory_pair_simdfp_no_alloc(Rt, Rn, Rt2, imm7, L, opc)
}

val decode_stnp_fpsimd_aarch64_instrs_memory_pair_simdfp_no_alloc : (bits(5), bits(5), bits(5), bits(7), bits(1), bits(2)) -> unit

function decode_stnp_fpsimd_aarch64_instrs_memory_pair_simdfp_no_alloc (Rt, Rn, Rt2, imm7, L, opc) = {
    let wback : bool = false;
    let postindex : bool = false;
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 't2 = UInt(Rt2);
    let nontemporal : bool = true;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    if opc == 0b11 then {
        throw(Error_Undefined())
    };
    let 'scale = 2 + UInt(opc);
    let 'datasize = (8 << scale);
    let offset : bits(64) = LSL(SignExtend(imm7, 64), scale);
    let tagchecked : bool = wback | n != 31;
    rt_unknown : bool = false;
    if memop == MemOp_LOAD & t == t2 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);
        assert(c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    assert(constraint('datasize in {32, 64, 128, 256}));
    execute_aarch64_instrs_memory_pair_simdfp_no_alloc(datasize, memop, n, nontemporal, offset, postindex, rt_unknown, t, t2, tagchecked, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([_, _, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 602) = {
    SEE = 602;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rt2 = Slice(__opcode, 10, 5);
    let imm7 = Slice(__opcode, 15, 7);
    let L = Slice(__opcode, 22, 1);
    let opc = Slice(__opcode, 30, 2);
    decode_stnp_fpsimd_aarch64_instrs_memory_pair_simdfp_no_alloc(Rt, Rn, Rt2, imm7, L, opc)
}

val execute_aarch64_instrs_memory_pair_simdfp_post_idx : forall 'datasize 'n ('nontemporal : Bool) ('postindex : Bool) ('rt_unknown : Bool) 't 't2 ('tagchecked : Bool) ('wback : Bool),
  (0 <= 't2 & 't2 <= 31 & 0 <= 't & 't <= 31 & 0 <= 'n & 'n <= 31 & 'datasize in {32, 64, 128, 256}).
  (int('datasize), MemOp, int('n), bool('nontemporal), bits(64), bool('postindex), bool('rt_unknown), int('t), int('t2), bool('tagchecked), bool('wback)) -> unit

function execute_aarch64_instrs_memory_pair_simdfp_post_idx (datasize, memop, n, nontemporal, offset, postindex, rt_unknown, t, t2, tagchecked, wback) = {
    CheckFPEnabled64();
    address : bits(64) = undefined;
    data1 : bits('datasize) = undefined;
    data2 : bits('datasize) = undefined;
    let 'dbytes = DIV(datasize, 8);
    let accdesc : AccessDescriptor = CreateAccDescASIMD(memop, nontemporal, tagchecked);
    if n == 31 then {
        CheckSPAlignment();
        address = SP_read()
    } else {
        address = X_read(n, 64)
    };
    if not_bool(postindex) then {
        address = address + offset
    };
    match memop {
      MemOp_STORE => {
          assert(constraint('datasize in {8, 16, 32, 64, 128}));
          let data1 : bits('datasize) = V_read(t, datasize);
          let data2 : bits('datasize) = V_read(t2, datasize);
          Mem_set(address + 0, dbytes, accdesc) = data1;
          Mem_set(address + dbytes, dbytes, accdesc) = data2
      },
      MemOp_LOAD => {
          data1 : bits('datasize) = Mem_read(address + 0, dbytes, accdesc);
          data2 : bits('datasize) = Mem_read(address + dbytes, dbytes, accdesc);
          if rt_unknown then {
              data1 = __UNKNOWN_bits(datasize);
              data2 = __UNKNOWN_bits(datasize)
          };
          assert(constraint('datasize in {8, 16, 32, 64, 128}));
          V_set(t, datasize) = data1;
          V_set(t2, datasize) = data2
      },
      _ => ()
    };
    if wback then {
        if postindex then {
            address = address + offset
        };
        if n == 31 then {
            SP_set() = address
        } else {
            X_set(n, 64) = address
        }
    };
    if SPESampleInFlight then {
        SPESampleSIMDFPLoadStore()
    };
    ()
}

val decode_ldp_fpsimd_aarch64_instrs_memory_pair_simdfp_post_idx : (bits(5), bits(5), bits(5), bits(7), bits(1), bits(2)) -> unit

function decode_ldp_fpsimd_aarch64_instrs_memory_pair_simdfp_post_idx (Rt, Rn, Rt2, imm7, L, opc) = {
    let wback : bool = true;
    let postindex : bool = true;
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 't2 = UInt(Rt2);
    let nontemporal : bool = false;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    if opc == 0b11 then {
        throw(Error_Undefined())
    };
    let 'scale = 2 + UInt(opc);
    let 'datasize = (8 << scale);
    let offset : bits(64) = LSL(SignExtend(imm7, 64), scale);
    let tagchecked : bool = wback | n != 31;
    rt_unknown : bool = false;
    if memop == MemOp_LOAD & t == t2 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);
        assert(c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    assert(constraint('datasize in {32, 64, 128, 256}));
    execute_aarch64_instrs_memory_pair_simdfp_post_idx(datasize, memop, n, nontemporal, offset, postindex, rt_unknown, t, t2, tagchecked, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([_, _, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitone, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 603) = {
    SEE = 603;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rt2 = Slice(__opcode, 10, 5);
    let imm7 = Slice(__opcode, 15, 7);
    let L = Slice(__opcode, 22, 1);
    let opc = Slice(__opcode, 30, 2);
    decode_ldp_fpsimd_aarch64_instrs_memory_pair_simdfp_post_idx(Rt, Rn, Rt2, imm7, L, opc)
}

val decode_ldp_fpsimd_aarch64_instrs_memory_pair_simdfp_pre_idx : (bits(5), bits(5), bits(5), bits(7), bits(1), bits(2)) -> unit

function decode_ldp_fpsimd_aarch64_instrs_memory_pair_simdfp_pre_idx (Rt, Rn, Rt2, imm7, L, opc) = {
    let wback : bool = true;
    let postindex : bool = false;
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 't2 = UInt(Rt2);
    let nontemporal : bool = false;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    if opc == 0b11 then {
        throw(Error_Undefined())
    };
    let 'scale = 2 + UInt(opc);
    let 'datasize = (8 << scale);
    let offset : bits(64) = LSL(SignExtend(imm7, 64), scale);
    let tagchecked : bool = wback | n != 31;
    rt_unknown : bool = false;
    if memop == MemOp_LOAD & t == t2 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);
        assert(c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    assert(constraint('datasize in {32, 64, 128, 256}));
    execute_aarch64_instrs_memory_pair_simdfp_post_idx(datasize, memop, n, nontemporal, offset, postindex, rt_unknown, t, t2, tagchecked, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([_, _, bitone, bitzero, bitone, bitone, bitzero, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 604) = {
    SEE = 604;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rt2 = Slice(__opcode, 10, 5);
    let imm7 = Slice(__opcode, 15, 7);
    let L = Slice(__opcode, 22, 1);
    let opc = Slice(__opcode, 30, 2);
    decode_ldp_fpsimd_aarch64_instrs_memory_pair_simdfp_pre_idx(Rt, Rn, Rt2, imm7, L, opc)
}

val decode_ldp_fpsimd_aarch64_instrs_memory_pair_simdfp_offset : (bits(5), bits(5), bits(5), bits(7), bits(1), bits(2)) -> unit

function decode_ldp_fpsimd_aarch64_instrs_memory_pair_simdfp_offset (Rt, Rn, Rt2, imm7, L, opc) = {
    let wback : bool = false;
    let postindex : bool = false;
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 't2 = UInt(Rt2);
    let nontemporal : bool = false;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    if opc == 0b11 then {
        throw(Error_Undefined())
    };
    let 'scale = 2 + UInt(opc);
    let 'datasize = (8 << scale);
    let offset : bits(64) = LSL(SignExtend(imm7, 64), scale);
    let tagchecked : bool = wback | n != 31;
    rt_unknown : bool = false;
    if memop == MemOp_LOAD & t == t2 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);
        assert(c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    assert(constraint('datasize in {32, 64, 128, 256}));
    execute_aarch64_instrs_memory_pair_simdfp_post_idx(datasize, memop, n, nontemporal, offset, postindex, rt_unknown, t, t2, tagchecked, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([_, _, bitone, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 605) = {
    SEE = 605;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rt2 = Slice(__opcode, 10, 5);
    let imm7 = Slice(__opcode, 15, 7);
    let L = Slice(__opcode, 22, 1);
    let opc = Slice(__opcode, 30, 2);
    decode_ldp_fpsimd_aarch64_instrs_memory_pair_simdfp_offset(Rt, Rn, Rt2, imm7, L, opc)
}

val decode_stp_fpsimd_aarch64_instrs_memory_pair_simdfp_post_idx : (bits(5), bits(5), bits(5), bits(7), bits(1), bits(2)) -> unit

function decode_stp_fpsimd_aarch64_instrs_memory_pair_simdfp_post_idx (Rt, Rn, Rt2, imm7, L, opc) = {
    let wback : bool = true;
    let postindex : bool = true;
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 't2 = UInt(Rt2);
    let nontemporal : bool = false;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    if opc == 0b11 then {
        throw(Error_Undefined())
    };
    let 'scale = 2 + UInt(opc);
    let 'datasize = (8 << scale);
    let offset : bits(64) = LSL(SignExtend(imm7, 64), scale);
    let tagchecked : bool = wback | n != 31;
    rt_unknown : bool = false;
    if memop == MemOp_LOAD & t == t2 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);
        assert(c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    assert(constraint('datasize in {32, 64, 128, 256}));
    execute_aarch64_instrs_memory_pair_simdfp_post_idx(datasize, memop, n, nontemporal, offset, postindex, rt_unknown, t, t2, tagchecked, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([_, _, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 606) = {
    SEE = 606;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rt2 = Slice(__opcode, 10, 5);
    let imm7 = Slice(__opcode, 15, 7);
    let L = Slice(__opcode, 22, 1);
    let opc = Slice(__opcode, 30, 2);
    decode_stp_fpsimd_aarch64_instrs_memory_pair_simdfp_post_idx(Rt, Rn, Rt2, imm7, L, opc)
}

val decode_stp_fpsimd_aarch64_instrs_memory_pair_simdfp_pre_idx : (bits(5), bits(5), bits(5), bits(7), bits(1), bits(2)) -> unit

function decode_stp_fpsimd_aarch64_instrs_memory_pair_simdfp_pre_idx (Rt, Rn, Rt2, imm7, L, opc) = {
    let wback : bool = true;
    let postindex : bool = false;
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 't2 = UInt(Rt2);
    let nontemporal : bool = false;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    if opc == 0b11 then {
        throw(Error_Undefined())
    };
    let 'scale = 2 + UInt(opc);
    let 'datasize = (8 << scale);
    let offset : bits(64) = LSL(SignExtend(imm7, 64), scale);
    let tagchecked : bool = wback | n != 31;
    rt_unknown : bool = false;
    if memop == MemOp_LOAD & t == t2 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);
        assert(c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    assert(constraint('datasize in {32, 64, 128, 256}));
    execute_aarch64_instrs_memory_pair_simdfp_post_idx(datasize, memop, n, nontemporal, offset, postindex, rt_unknown, t, t2, tagchecked, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([_, _, bitone, bitzero, bitone, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 607) = {
    SEE = 607;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rt2 = Slice(__opcode, 10, 5);
    let imm7 = Slice(__opcode, 15, 7);
    let L = Slice(__opcode, 22, 1);
    let opc = Slice(__opcode, 30, 2);
    decode_stp_fpsimd_aarch64_instrs_memory_pair_simdfp_pre_idx(Rt, Rn, Rt2, imm7, L, opc)
}

val decode_stp_fpsimd_aarch64_instrs_memory_pair_simdfp_offset : (bits(5), bits(5), bits(5), bits(7), bits(1), bits(2)) -> unit

function decode_stp_fpsimd_aarch64_instrs_memory_pair_simdfp_offset (Rt, Rn, Rt2, imm7, L, opc) = {
    let wback : bool = false;
    let postindex : bool = false;
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 't2 = UInt(Rt2);
    let nontemporal : bool = false;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    if opc == 0b11 then {
        throw(Error_Undefined())
    };
    let 'scale = 2 + UInt(opc);
    let 'datasize = (8 << scale);
    let offset : bits(64) = LSL(SignExtend(imm7, 64), scale);
    let tagchecked : bool = wback | n != 31;
    rt_unknown : bool = false;
    if memop == MemOp_LOAD & t == t2 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);
        assert(c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    assert(constraint('datasize in {32, 64, 128, 256}));
    execute_aarch64_instrs_memory_pair_simdfp_post_idx(datasize, memop, n, nontemporal, offset, postindex, rt_unknown, t, t2, tagchecked, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([_, _, bitone, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 608) = {
    SEE = 608;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rt2 = Slice(__opcode, 10, 5);
    let imm7 = Slice(__opcode, 15, 7);
    let L = Slice(__opcode, 22, 1);
    let opc = Slice(__opcode, 30, 2);
    decode_stp_fpsimd_aarch64_instrs_memory_pair_simdfp_offset(Rt, Rn, Rt2, imm7, L, opc)
}

val execute_aarch64_instrs_memory_pair_general_post_idx : forall 'datasize ('is_signed : Bool) 'n ('nontemporal : Bool) ('postindex : Bool) ('rt_unknown : Bool) 't 't2 ('tagchecked : Bool) ('wb_unknown : Bool) ('wback : Bool),
  (0 <= 't2 & 't2 <= 31 & 0 <= 't & 't <= 31 & 0 <= 'n & 'n <= 31 & 'datasize in {32, 64}).
  (int('datasize), MemOp, int('n), bool('nontemporal), bits(64), bool('postindex), bool('rt_unknown), bool('is_signed), int('t), int('t2), bool('tagchecked), bool('wb_unknown), bool('wback)) -> unit

function execute_aarch64_instrs_memory_pair_general_post_idx (datasize, memop, n, nontemporal, offset, postindex, rt_unknown, is_signed, t, t2, tagchecked, wb_unknown, wback) = {
    address : bits(64) = undefined;
    data1 : bits('datasize) = undefined;
    data2 : bits('datasize) = undefined;
    let 'dbytes = DIV(datasize, 8);
    let privileged : bool = PSTATE.EL != EL0;
    let accdesc : AccessDescriptor = CreateAccDescGPR(memop, nontemporal, privileged, tagchecked);
    if n == 31 then {
        CheckSPAlignment();
        address = SP_read()
    } else {
        address = X_read(n, 64)
    };
    if not_bool(postindex) then {
        address = address + offset
    };
    match memop {
      MemOp_STORE => {
          if rt_unknown & t == n then {
              data1 = __UNKNOWN_bits(datasize)
          } else {
              data1 = X_read(t, datasize)
          };
          if rt_unknown & t2 == n then {
              data2 = __UNKNOWN_bits(datasize)
          } else {
              data2 = X_read(t2, datasize)
          };
          if HaveLSE2Ext() then {
              full_data : bits(2 * 'datasize) = undefined;
              if BigEndian(accdesc.acctype) then {
                  full_data = data1 @ data2
              } else {
                  full_data = data2 @ data1
              };
              let ispair : bool = true;
              Mem_set__1(address, 2 * dbytes, accdesc, ispair) = full_data
          } else {
              Mem_set(address + 0, dbytes, accdesc) = data1;
              Mem_set(address + dbytes, dbytes, accdesc) = data2
          }
      },
      MemOp_LOAD => {
          if HaveLSE2Ext() & not_bool(is_signed) then {
              let ispair : bool = true;
              let full_data : bits(2 * 'datasize) = Mem_read__1(address, 2 * dbytes, accdesc, ispair);
              if BigEndian(accdesc.acctype) then {
                  data2 = full_data[datasize - 1 .. 0];
                  data1 = full_data[2 * datasize - 1 .. datasize]
              } else {
                  data1 = full_data[datasize - 1 .. 0];
                  data2 = full_data[2 * datasize - 1 .. datasize]
              }
          } else {
              data1 = Mem_read(address + 0, dbytes, accdesc);
              data2 = Mem_read(address + dbytes, dbytes, accdesc)
          };
          if rt_unknown then {
              data1 = __UNKNOWN_bits(datasize);
              data2 = __UNKNOWN_bits(datasize)
          };
          if is_signed then {
              X_set(t, 64) = SignExtend(data1, 64);
              X_set(t2, 64) = SignExtend(data2, 64)
          } else {
              X_set(t, datasize) = data1;
              X_set(t2, datasize) = data2
          }
      },
      _ => ()
    };
    if wback then {
        if wb_unknown then {
            address = __UNKNOWN_bits(64)
        } else if postindex then {
            address = address + offset
        } else ();
        if n == 31 then {
            SP_set() = address
        } else {
            X_set(n, 64) = address
        }
    };
    if SPESampleInFlight then {
        SPESampleGeneralPurposeLoadStore()
    };
    ()
}

val decode_ldp_gen_aarch64_instrs_memory_pair_general_post_idx : (bits(5), bits(5), bits(5), bits(7), bits(1), bits(2)) -> unit

function decode_ldp_gen_aarch64_instrs_memory_pair_general_post_idx (Rt, Rn, Rt2, imm7, L, opc) = {
    wback : bool = true;
    let postindex : bool = true;
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 't2 = UInt(Rt2);
    let nontemporal : bool = false;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    if (L @ [opc[0]]) == 0b01 | opc == 0b11 then {
        throw(Error_Undefined())
    };
    let is_signed : bool = [opc[0]] != 0b0;
    let 'scale = 2 + UInt([opc[1]]);
    let 'datasize = (8 << scale);
    let offset : bits(64) = LSL(SignExtend(imm7, 64), scale);
    let tagchecked : bool = wback | n != 31;
    rt_unknown : bool = false;
    wb_unknown : bool = false;
    if ((memop == MemOp_LOAD & wback) & (t == n | t2 == n)) & n != 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
        assert(c == Constraint_WBSUPPRESS | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_WBSUPPRESS => {
              wback = false
          },
          Constraint_UNKNOWN => {
              wb_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    if ((memop == MemOp_STORE & wback) & (t == n | t2 == n)) & n != 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
        assert(c == Constraint_NONE | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_NONE => {
              rt_unknown = false
          },
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    if memop == MemOp_LOAD & t == t2 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);
        assert(c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    assert(constraint('datasize in {32, 64}));
    execute_aarch64_instrs_memory_pair_general_post_idx(datasize, memop, n, nontemporal, offset, postindex, rt_unknown, is_signed, t, t2, tagchecked, wb_unknown, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([_, bitzero, bitone, bitzero, bitone, bitzero, bitzero, bitzero, bitone, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 609) = {
    SEE = 609;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rt2 = Slice(__opcode, 10, 5);
    let imm7 = Slice(__opcode, 15, 7);
    let L = Slice(__opcode, 22, 1);
    let opc = Slice(__opcode, 30, 2);
    decode_ldp_gen_aarch64_instrs_memory_pair_general_post_idx(Rt, Rn, Rt2, imm7, L, opc)
}

val decode_ldp_gen_aarch64_instrs_memory_pair_general_pre_idx : (bits(5), bits(5), bits(5), bits(7), bits(1), bits(2)) -> unit

function decode_ldp_gen_aarch64_instrs_memory_pair_general_pre_idx (Rt, Rn, Rt2, imm7, L, opc) = {
    wback : bool = true;
    let postindex : bool = false;
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 't2 = UInt(Rt2);
    let nontemporal : bool = false;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    if (L @ [opc[0]]) == 0b01 | opc == 0b11 then {
        throw(Error_Undefined())
    };
    let is_signed : bool = [opc[0]] != 0b0;
    let 'scale = 2 + UInt([opc[1]]);
    let 'datasize = (8 << scale);
    let offset : bits(64) = LSL(SignExtend(imm7, 64), scale);
    let tagchecked : bool = wback | n != 31;
    rt_unknown : bool = false;
    wb_unknown : bool = false;
    if ((memop == MemOp_LOAD & wback) & (t == n | t2 == n)) & n != 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
        assert(c == Constraint_WBSUPPRESS | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_WBSUPPRESS => {
              wback = false
          },
          Constraint_UNKNOWN => {
              wb_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    if ((memop == MemOp_STORE & wback) & (t == n | t2 == n)) & n != 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
        assert(c == Constraint_NONE | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_NONE => {
              rt_unknown = false
          },
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    if memop == MemOp_LOAD & t == t2 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);
        assert(c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    assert(constraint('datasize in {32, 64}));
    execute_aarch64_instrs_memory_pair_general_post_idx(datasize, memop, n, nontemporal, offset, postindex, rt_unknown, is_signed, t, t2, tagchecked, wb_unknown, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([_, bitzero, bitone, bitzero, bitone, bitzero, bitzero, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 610) = {
    SEE = 610;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rt2 = Slice(__opcode, 10, 5);
    let imm7 = Slice(__opcode, 15, 7);
    let L = Slice(__opcode, 22, 1);
    let opc = Slice(__opcode, 30, 2);
    decode_ldp_gen_aarch64_instrs_memory_pair_general_pre_idx(Rt, Rn, Rt2, imm7, L, opc)
}

val decode_ldp_gen_aarch64_instrs_memory_pair_general_offset : (bits(5), bits(5), bits(5), bits(7), bits(1), bits(2)) -> unit

function decode_ldp_gen_aarch64_instrs_memory_pair_general_offset (Rt, Rn, Rt2, imm7, L, opc) = {
    wback : bool = false;
    let postindex : bool = false;
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 't2 = UInt(Rt2);
    let nontemporal : bool = false;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    if (L @ [opc[0]]) == 0b01 | opc == 0b11 then {
        throw(Error_Undefined())
    };
    let is_signed : bool = [opc[0]] != 0b0;
    let 'scale = 2 + UInt([opc[1]]);
    let 'datasize = (8 << scale);
    let offset : bits(64) = LSL(SignExtend(imm7, 64), scale);
    let tagchecked : bool = wback | n != 31;
    rt_unknown : bool = false;
    wb_unknown : bool = false;
    if ((memop == MemOp_LOAD & wback) & (t == n | t2 == n)) & n != 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
        assert(c == Constraint_WBSUPPRESS | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_WBSUPPRESS => {
              wback = false
          },
          Constraint_UNKNOWN => {
              wb_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    if ((memop == MemOp_STORE & wback) & (t == n | t2 == n)) & n != 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
        assert(c == Constraint_NONE | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_NONE => {
              rt_unknown = false
          },
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    if memop == MemOp_LOAD & t == t2 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);
        assert(c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    assert(constraint('datasize in {32, 64}));
    execute_aarch64_instrs_memory_pair_general_post_idx(datasize, memop, n, nontemporal, offset, postindex, rt_unknown, is_signed, t, t2, tagchecked, wb_unknown, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([_, bitzero, bitone, bitzero, bitone, bitzero, bitzero, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 611) = {
    SEE = 611;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rt2 = Slice(__opcode, 10, 5);
    let imm7 = Slice(__opcode, 15, 7);
    let L = Slice(__opcode, 22, 1);
    let opc = Slice(__opcode, 30, 2);
    decode_ldp_gen_aarch64_instrs_memory_pair_general_offset(Rt, Rn, Rt2, imm7, L, opc)
}

val decode_ldpsw_aarch64_instrs_memory_pair_general_post_idx : (bits(5), bits(5), bits(5), bits(7), bits(1), bits(2)) -> unit

function decode_ldpsw_aarch64_instrs_memory_pair_general_post_idx (Rt, Rn, Rt2, imm7, L, opc) = {
    wback : bool = true;
    let postindex : bool = true;
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 't2 = UInt(Rt2);
    let nontemporal : bool = false;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    if (L @ [opc[0]]) == 0b01 | opc == 0b11 then {
        throw(Error_Undefined())
    };
    let is_signed : bool = [opc[0]] != 0b0;
    let 'scale = 2 + UInt([opc[1]]);
    let 'datasize = (8 << scale);
    let offset : bits(64) = LSL(SignExtend(imm7, 64), scale);
    let tagchecked : bool = wback | n != 31;
    rt_unknown : bool = false;
    wb_unknown : bool = false;
    if ((memop == MemOp_LOAD & wback) & (t == n | t2 == n)) & n != 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
        assert(c == Constraint_WBSUPPRESS | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_WBSUPPRESS => {
              wback = false
          },
          Constraint_UNKNOWN => {
              wb_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    if ((memop == MemOp_STORE & wback) & (t == n | t2 == n)) & n != 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
        assert(c == Constraint_NONE | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_NONE => {
              rt_unknown = false
          },
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    if memop == MemOp_LOAD & t == t2 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);
        assert(c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    assert(constraint('datasize in {32, 64}));
    execute_aarch64_instrs_memory_pair_general_post_idx(datasize, memop, n, nontemporal, offset, postindex, rt_unknown, is_signed, t, t2, tagchecked, wb_unknown, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, bitone, bitone, bitzero, bitone, bitzero, bitzero, bitzero, bitone, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 612) = {
    SEE = 612;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rt2 = Slice(__opcode, 10, 5);
    let imm7 = Slice(__opcode, 15, 7);
    let L = Slice(__opcode, 22, 1);
    let opc = Slice(__opcode, 30, 2);
    decode_ldpsw_aarch64_instrs_memory_pair_general_post_idx(Rt, Rn, Rt2, imm7, L, opc)
}

val decode_ldpsw_aarch64_instrs_memory_pair_general_pre_idx : (bits(5), bits(5), bits(5), bits(7), bits(1), bits(2)) -> unit

function decode_ldpsw_aarch64_instrs_memory_pair_general_pre_idx (Rt, Rn, Rt2, imm7, L, opc) = {
    wback : bool = true;
    let postindex : bool = false;
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 't2 = UInt(Rt2);
    let nontemporal : bool = false;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    if (L @ [opc[0]]) == 0b01 | opc == 0b11 then {
        throw(Error_Undefined())
    };
    let is_signed : bool = [opc[0]] != 0b0;
    let 'scale = 2 + UInt([opc[1]]);
    let 'datasize = (8 << scale);
    let offset : bits(64) = LSL(SignExtend(imm7, 64), scale);
    let tagchecked : bool = wback | n != 31;
    rt_unknown : bool = false;
    wb_unknown : bool = false;
    if ((memop == MemOp_LOAD & wback) & (t == n | t2 == n)) & n != 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
        assert(c == Constraint_WBSUPPRESS | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_WBSUPPRESS => {
              wback = false
          },
          Constraint_UNKNOWN => {
              wb_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    if ((memop == MemOp_STORE & wback) & (t == n | t2 == n)) & n != 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
        assert(c == Constraint_NONE | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_NONE => {
              rt_unknown = false
          },
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    if memop == MemOp_LOAD & t == t2 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);
        assert(c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    assert(constraint('datasize in {32, 64}));
    execute_aarch64_instrs_memory_pair_general_post_idx(datasize, memop, n, nontemporal, offset, postindex, rt_unknown, is_signed, t, t2, tagchecked, wb_unknown, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, bitone, bitone, bitzero, bitone, bitzero, bitzero, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 613) = {
    SEE = 613;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rt2 = Slice(__opcode, 10, 5);
    let imm7 = Slice(__opcode, 15, 7);
    let L = Slice(__opcode, 22, 1);
    let opc = Slice(__opcode, 30, 2);
    decode_ldpsw_aarch64_instrs_memory_pair_general_pre_idx(Rt, Rn, Rt2, imm7, L, opc)
}

val decode_ldpsw_aarch64_instrs_memory_pair_general_offset : (bits(5), bits(5), bits(5), bits(7), bits(1), bits(2)) -> unit

function decode_ldpsw_aarch64_instrs_memory_pair_general_offset (Rt, Rn, Rt2, imm7, L, opc) = {
    wback : bool = false;
    let postindex : bool = false;
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 't2 = UInt(Rt2);
    let nontemporal : bool = false;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    if (L @ [opc[0]]) == 0b01 | opc == 0b11 then {
        throw(Error_Undefined())
    };
    let is_signed : bool = [opc[0]] != 0b0;
    let 'scale = 2 + UInt([opc[1]]);
    let 'datasize = (8 << scale);
    let offset : bits(64) = LSL(SignExtend(imm7, 64), scale);
    let tagchecked : bool = wback | n != 31;
    rt_unknown : bool = false;
    wb_unknown : bool = false;
    if ((memop == MemOp_LOAD & wback) & (t == n | t2 == n)) & n != 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
        assert(c == Constraint_WBSUPPRESS | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_WBSUPPRESS => {
              wback = false
          },
          Constraint_UNKNOWN => {
              wb_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    if ((memop == MemOp_STORE & wback) & (t == n | t2 == n)) & n != 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
        assert(c == Constraint_NONE | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_NONE => {
              rt_unknown = false
          },
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    if memop == MemOp_LOAD & t == t2 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);
        assert(c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    assert(constraint('datasize in {32, 64}));
    execute_aarch64_instrs_memory_pair_general_post_idx(datasize, memop, n, nontemporal, offset, postindex, rt_unknown, is_signed, t, t2, tagchecked, wb_unknown, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, bitone, bitone, bitzero, bitone, bitzero, bitzero, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 614) = {
    SEE = 614;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rt2 = Slice(__opcode, 10, 5);
    let imm7 = Slice(__opcode, 15, 7);
    let L = Slice(__opcode, 22, 1);
    let opc = Slice(__opcode, 30, 2);
    decode_ldpsw_aarch64_instrs_memory_pair_general_offset(Rt, Rn, Rt2, imm7, L, opc)
}

val decode_stp_gen_aarch64_instrs_memory_pair_general_post_idx : (bits(5), bits(5), bits(5), bits(7), bits(1), bits(2)) -> unit

function decode_stp_gen_aarch64_instrs_memory_pair_general_post_idx (Rt, Rn, Rt2, imm7, L, opc) = {
    wback : bool = true;
    let postindex : bool = true;
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 't2 = UInt(Rt2);
    let nontemporal : bool = false;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    if (L @ [opc[0]]) == 0b01 | opc == 0b11 then {
        throw(Error_Undefined())
    };
    let is_signed : bool = [opc[0]] != 0b0;
    let 'scale = 2 + UInt([opc[1]]);
    let 'datasize = (8 << scale);
    let offset : bits(64) = LSL(SignExtend(imm7, 64), scale);
    let tagchecked : bool = wback | n != 31;
    rt_unknown : bool = false;
    wb_unknown : bool = false;
    if ((memop == MemOp_LOAD & wback) & (t == n | t2 == n)) & n != 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
        assert(c == Constraint_WBSUPPRESS | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_WBSUPPRESS => {
              wback = false
          },
          Constraint_UNKNOWN => {
              wb_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    if ((memop == MemOp_STORE & wback) & (t == n | t2 == n)) & n != 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
        assert(c == Constraint_NONE | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_NONE => {
              rt_unknown = false
          },
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    if memop == MemOp_LOAD & t == t2 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);
        assert(c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    assert(constraint('datasize in {32, 64}));
    execute_aarch64_instrs_memory_pair_general_post_idx(datasize, memop, n, nontemporal, offset, postindex, rt_unknown, is_signed, t, t2, tagchecked, wb_unknown, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([_, bitzero, bitone, bitzero, bitone, bitzero, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 615) = {
    SEE = 615;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rt2 = Slice(__opcode, 10, 5);
    let imm7 = Slice(__opcode, 15, 7);
    let L = Slice(__opcode, 22, 1);
    let opc = Slice(__opcode, 30, 2);
    decode_stp_gen_aarch64_instrs_memory_pair_general_post_idx(Rt, Rn, Rt2, imm7, L, opc)
}

val decode_stp_gen_aarch64_instrs_memory_pair_general_pre_idx : (bits(5), bits(5), bits(5), bits(7), bits(1), bits(2)) -> unit

function decode_stp_gen_aarch64_instrs_memory_pair_general_pre_idx (Rt, Rn, Rt2, imm7, L, opc) = {
    wback : bool = true;
    let postindex : bool = false;
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 't2 = UInt(Rt2);
    let nontemporal : bool = false;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    if (L @ [opc[0]]) == 0b01 | opc == 0b11 then {
        throw(Error_Undefined())
    };
    let is_signed : bool = [opc[0]] != 0b0;
    let 'scale = 2 + UInt([opc[1]]);
    let 'datasize = (8 << scale);
    let offset : bits(64) = LSL(SignExtend(imm7, 64), scale);
    let tagchecked : bool = wback | n != 31;
    rt_unknown : bool = false;
    wb_unknown : bool = false;
    if ((memop == MemOp_LOAD & wback) & (t == n | t2 == n)) & n != 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
        assert(c == Constraint_WBSUPPRESS | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_WBSUPPRESS => {
              wback = false
          },
          Constraint_UNKNOWN => {
              wb_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    if ((memop == MemOp_STORE & wback) & (t == n | t2 == n)) & n != 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
        assert(c == Constraint_NONE | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_NONE => {
              rt_unknown = false
          },
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    if memop == MemOp_LOAD & t == t2 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);
        assert(c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    assert(constraint('datasize in {32, 64}));
    execute_aarch64_instrs_memory_pair_general_post_idx(datasize, memop, n, nontemporal, offset, postindex, rt_unknown, is_signed, t, t2, tagchecked, wb_unknown, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([_, bitzero, bitone, bitzero, bitone, bitzero, bitzero, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 616) = {
    SEE = 616;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rt2 = Slice(__opcode, 10, 5);
    let imm7 = Slice(__opcode, 15, 7);
    let L = Slice(__opcode, 22, 1);
    let opc = Slice(__opcode, 30, 2);
    decode_stp_gen_aarch64_instrs_memory_pair_general_pre_idx(Rt, Rn, Rt2, imm7, L, opc)
}

val decode_stp_gen_aarch64_instrs_memory_pair_general_offset : (bits(5), bits(5), bits(5), bits(7), bits(1), bits(2)) -> unit

function decode_stp_gen_aarch64_instrs_memory_pair_general_offset (Rt, Rn, Rt2, imm7, L, opc) = {
    wback : bool = false;
    let postindex : bool = false;
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 't2 = UInt(Rt2);
    let nontemporal : bool = false;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    if (L @ [opc[0]]) == 0b01 | opc == 0b11 then {
        throw(Error_Undefined())
    };
    let is_signed : bool = [opc[0]] != 0b0;
    let 'scale = 2 + UInt([opc[1]]);
    let 'datasize = (8 << scale);
    let offset : bits(64) = LSL(SignExtend(imm7, 64), scale);
    let tagchecked : bool = wback | n != 31;
    rt_unknown : bool = false;
    wb_unknown : bool = false;
    if ((memop == MemOp_LOAD & wback) & (t == n | t2 == n)) & n != 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
        assert(c == Constraint_WBSUPPRESS | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_WBSUPPRESS => {
              wback = false
          },
          Constraint_UNKNOWN => {
              wb_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    if ((memop == MemOp_STORE & wback) & (t == n | t2 == n)) & n != 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
        assert(c == Constraint_NONE | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_NONE => {
              rt_unknown = false
          },
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    if memop == MemOp_LOAD & t == t2 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);
        assert(c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    assert(constraint('datasize in {32, 64}));
    execute_aarch64_instrs_memory_pair_general_post_idx(datasize, memop, n, nontemporal, offset, postindex, rt_unknown, is_signed, t, t2, tagchecked, wb_unknown, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([_, bitzero, bitone, bitzero, bitone, bitzero, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 617) = {
    SEE = 617;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rt2 = Slice(__opcode, 10, 5);
    let imm7 = Slice(__opcode, 15, 7);
    let L = Slice(__opcode, 22, 1);
    let opc = Slice(__opcode, 30, 2);
    decode_stp_gen_aarch64_instrs_memory_pair_general_offset(Rt, Rn, Rt2, imm7, L, opc)
}

val execute_aarch64_instrs_memory_single_simdfp_immediate_signed_post_idx : forall 'datasize 'n ('nontemporal : Bool) ('postindex : Bool) 't ('tagchecked : Bool) ('wback : Bool),
  (0 <= 't & 't <= 31 & 0 <= 'n & 'n <= 31 & 'datasize in {8, 16, 32, 64, 128, 256, 512, 1024}).
  (int('datasize), MemOp, int('n), bool('nontemporal), bits(64), bool('postindex), int('t), bool('tagchecked), bool('wback)) -> unit

function execute_aarch64_instrs_memory_single_simdfp_immediate_signed_post_idx (datasize, memop, n, nontemporal, offset, postindex, t, tagchecked, wback) = {
    CheckFPEnabled64();
    address : bits(64) = undefined;
    data : bits('datasize) = undefined;
    let accdesc : AccessDescriptor = CreateAccDescASIMD(memop, nontemporal, tagchecked);
    if n == 31 then {
        CheckSPAlignment();
        address = SP_read()
    } else {
        address = X_read(n, 64)
    };
    if not_bool(postindex) then {
        address = address + offset
    };
    match memop {
      MemOp_STORE => {
          assert(constraint('datasize in {8, 16, 32, 64, 128}));
          let data : bits('datasize) = V_read(t, datasize);
          Mem_set(address, DIV(datasize, 8), accdesc) = data
      },
      MemOp_LOAD => {
          let data : bits('datasize) = Mem_read(address, DIV(datasize, 8), accdesc);
          assert(constraint('datasize in {8, 16, 32, 64, 128}));
          V_set(t, datasize) = data
      },
      _ => ()
    };
    if wback then {
        if postindex then {
            address = address + offset
        };
        if n == 31 then {
            SP_set() = address
        } else {
            X_set(n, 64) = address
        }
    };
    if SPESampleInFlight then {
        SPESampleSIMDFPLoadStore()
    };
    ()
}

val decode_ldr_imm_fpsimd_aarch64_instrs_memory_single_simdfp_immediate_signed_post_idx : (bits(5), bits(5), bits(9), bits(2), bits(2)) -> unit

function decode_ldr_imm_fpsimd_aarch64_instrs_memory_single_simdfp_immediate_signed_post_idx (Rt, Rn, imm9, opc, size) = {
    let wback : bool = true;
    let postindex : bool = true;
    let 'scale = UInt([opc[1]] @ size);
    if scale > 4 then {
        throw(Error_Undefined())
    };
    let offset : bits(64) = SignExtend(imm9, 64);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let nontemporal : bool = false;
    let memop : MemOp = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'datasize = (8 << scale);
    let tagchecked : bool = memop != MemOp_PREFETCH & (wback | n != 31);
    assert(constraint('datasize in {8, 16, 32, 64, 128, 256, 512, 1024}));
    execute_aarch64_instrs_memory_single_simdfp_immediate_signed_post_idx(datasize, memop, n, nontemporal, offset, postindex, t, tagchecked, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([_, _, bitone, bitone, bitone, bitone, bitzero, bitzero, _, bitone, bitzero, _, _, _, _, _, _, _, _, _, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 618) = {
    SEE = 618;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm9 = Slice(__opcode, 12, 9);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_ldr_imm_fpsimd_aarch64_instrs_memory_single_simdfp_immediate_signed_post_idx(Rt, Rn, imm9, opc, size)
}

val decode_ldr_imm_fpsimd_aarch64_instrs_memory_single_simdfp_immediate_signed_pre_idx : (bits(5), bits(5), bits(9), bits(2), bits(2)) -> unit

function decode_ldr_imm_fpsimd_aarch64_instrs_memory_single_simdfp_immediate_signed_pre_idx (Rt, Rn, imm9, opc, size) = {
    let wback : bool = true;
    let postindex : bool = false;
    let 'scale = UInt([opc[1]] @ size);
    if scale > 4 then {
        throw(Error_Undefined())
    };
    let offset : bits(64) = SignExtend(imm9, 64);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let nontemporal : bool = false;
    let memop : MemOp = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'datasize = (8 << scale);
    let tagchecked : bool = memop != MemOp_PREFETCH & (wback | n != 31);
    assert(constraint('datasize in {8, 16, 32, 64, 128, 256, 512, 1024}));
    execute_aarch64_instrs_memory_single_simdfp_immediate_signed_post_idx(datasize, memop, n, nontemporal, offset, postindex, t, tagchecked, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([_, _, bitone, bitone, bitone, bitone, bitzero, bitzero, _, bitone, bitzero, _, _, _, _, _, _, _, _, _, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 619) = {
    SEE = 619;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm9 = Slice(__opcode, 12, 9);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_ldr_imm_fpsimd_aarch64_instrs_memory_single_simdfp_immediate_signed_pre_idx(Rt, Rn, imm9, opc, size)
}

val decode_ldr_imm_fpsimd_aarch64_instrs_memory_single_simdfp_immediate_unsigned : (bits(5), bits(5), bits(12), bits(2), bits(2)) -> unit

function decode_ldr_imm_fpsimd_aarch64_instrs_memory_single_simdfp_immediate_unsigned (Rt, Rn, imm12, opc, size) = {
    let wback : bool = false;
    let postindex : bool = false;
    let 'scale = UInt([opc[1]] @ size);
    if scale > 4 then {
        throw(Error_Undefined())
    };
    let offset : bits(64) = LSL(ZeroExtend(imm12, 64), scale);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let nontemporal : bool = false;
    let memop : MemOp = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'datasize = (8 << scale);
    let tagchecked : bool = memop != MemOp_PREFETCH & (wback | n != 31);
    assert(constraint('datasize in {8, 16, 32, 64, 128, 256, 512, 1024}));
    execute_aarch64_instrs_memory_single_simdfp_immediate_signed_post_idx(datasize, memop, n, nontemporal, offset, postindex, t, tagchecked, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([_, _, bitone, bitone, bitone, bitone, bitzero, bitone, _, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 620) = {
    SEE = 620;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm12 = Slice(__opcode, 10, 12);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_ldr_imm_fpsimd_aarch64_instrs_memory_single_simdfp_immediate_unsigned(Rt, Rn, imm12, opc, size)
}

val decode_str_imm_fpsimd_aarch64_instrs_memory_single_simdfp_immediate_signed_post_idx : (bits(5), bits(5), bits(9), bits(2), bits(2)) -> unit

function decode_str_imm_fpsimd_aarch64_instrs_memory_single_simdfp_immediate_signed_post_idx (Rt, Rn, imm9, opc, size) = {
    let wback : bool = true;
    let postindex : bool = true;
    let 'scale = UInt([opc[1]] @ size);
    if scale > 4 then {
        throw(Error_Undefined())
    };
    let offset : bits(64) = SignExtend(imm9, 64);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let nontemporal : bool = false;
    let memop : MemOp = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'datasize = (8 << scale);
    let tagchecked : bool = memop != MemOp_PREFETCH & (wback | n != 31);
    assert(constraint('datasize in {8, 16, 32, 64, 128, 256, 512, 1024}));
    execute_aarch64_instrs_memory_single_simdfp_immediate_signed_post_idx(datasize, memop, n, nontemporal, offset, postindex, t, tagchecked, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([_, _, bitone, bitone, bitone, bitone, bitzero, bitzero, _, bitzero, bitzero, _, _, _, _, _, _, _, _, _, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 621) = {
    SEE = 621;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm9 = Slice(__opcode, 12, 9);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_str_imm_fpsimd_aarch64_instrs_memory_single_simdfp_immediate_signed_post_idx(Rt, Rn, imm9, opc, size)
}

val decode_str_imm_fpsimd_aarch64_instrs_memory_single_simdfp_immediate_signed_pre_idx : (bits(5), bits(5), bits(9), bits(2), bits(2)) -> unit

function decode_str_imm_fpsimd_aarch64_instrs_memory_single_simdfp_immediate_signed_pre_idx (Rt, Rn, imm9, opc, size) = {
    let wback : bool = true;
    let postindex : bool = false;
    let 'scale = UInt([opc[1]] @ size);
    if scale > 4 then {
        throw(Error_Undefined())
    };
    let offset : bits(64) = SignExtend(imm9, 64);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let nontemporal : bool = false;
    let memop : MemOp = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'datasize = (8 << scale);
    let tagchecked : bool = memop != MemOp_PREFETCH & (wback | n != 31);
    assert(constraint('datasize in {8, 16, 32, 64, 128, 256, 512, 1024}));
    execute_aarch64_instrs_memory_single_simdfp_immediate_signed_post_idx(datasize, memop, n, nontemporal, offset, postindex, t, tagchecked, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([_, _, bitone, bitone, bitone, bitone, bitzero, bitzero, _, bitzero, bitzero, _, _, _, _, _, _, _, _, _, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 622) = {
    SEE = 622;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm9 = Slice(__opcode, 12, 9);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_str_imm_fpsimd_aarch64_instrs_memory_single_simdfp_immediate_signed_pre_idx(Rt, Rn, imm9, opc, size)
}

val decode_str_imm_fpsimd_aarch64_instrs_memory_single_simdfp_immediate_unsigned : (bits(5), bits(5), bits(12), bits(2), bits(2)) -> unit

function decode_str_imm_fpsimd_aarch64_instrs_memory_single_simdfp_immediate_unsigned (Rt, Rn, imm12, opc, size) = {
    let wback : bool = false;
    let postindex : bool = false;
    let 'scale = UInt([opc[1]] @ size);
    if scale > 4 then {
        throw(Error_Undefined())
    };
    let offset : bits(64) = LSL(ZeroExtend(imm12, 64), scale);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let nontemporal : bool = false;
    let memop : MemOp = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'datasize = (8 << scale);
    let tagchecked : bool = memop != MemOp_PREFETCH & (wback | n != 31);
    assert(constraint('datasize in {8, 16, 32, 64, 128, 256, 512, 1024}));
    execute_aarch64_instrs_memory_single_simdfp_immediate_signed_post_idx(datasize, memop, n, nontemporal, offset, postindex, t, tagchecked, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([_, _, bitone, bitone, bitone, bitone, bitzero, bitone, _, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 623) = {
    SEE = 623;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm12 = Slice(__opcode, 10, 12);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_str_imm_fpsimd_aarch64_instrs_memory_single_simdfp_immediate_unsigned(Rt, Rn, imm12, opc, size)
}

val execute_aarch64_instrs_memory_literal_general : forall ('is_signed : Bool) ('nontemporal : Bool) 'size 't ('tagchecked : Bool),
  (0 <= 't & 't <= 31 & 'size in {4, 8}).
  (MemOp, bool('nontemporal), bits(64), bool('is_signed), int('size), int('t), bool('tagchecked)) -> unit

function execute_aarch64_instrs_memory_literal_general (memop, nontemporal, offset, is_signed, size, t, tagchecked) = {
    let address : bits(64) = PC_read() + offset;
    data : bits('size * 8) = undefined;
    let privileged : bool = PSTATE.EL != EL0;
    let accdesc : AccessDescriptor = CreateAccDescGPR(memop, nontemporal, privileged, tagchecked);
    match memop {
      MemOp_LOAD => {
          let data : bits('size * 8) = Mem_read(address, size, accdesc);
          if is_signed then {
              X_set(t, 64) = SignExtend(data, 64)
          } else {
              X_set(t, size * 8) = data
          }
      },
      MemOp_PREFETCH => {
          Prefetch(address, t[4 .. 0])
      },
      _ => ()
    };
    if SPESampleInFlight then {
        SPESampleGeneralPurposeLoadStore()
    };
    ()
}

val decode_ldr_lit_gen_aarch64_instrs_memory_literal_general : (bits(5), bits(19), bits(2)) -> unit

function decode_ldr_lit_gen_aarch64_instrs_memory_literal_general (Rt, imm19, opc) = {
    let 't = UInt(Rt);
    memop : MemOp = MemOp_LOAD;
    is_signed : bool = false;
    let nontemporal : bool = false;
    size : {4, 8} = 4;
    match opc {
      0b00 => {
          size = 4
      },
      0b01 => {
          size = 8
      },
      0b10 => {
          size = 4;
          is_signed = true
      },
      0b11 => {
          memop = MemOp_PREFETCH
      }
    };
    let 'size = size;
    let offset : bits(64) = SignExtend(imm19 @ 0b00, 64);
    let tagchecked : bool = false;
    execute_aarch64_instrs_memory_literal_general(memop, nontemporal, offset, is_signed, size, t, tagchecked)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, _, bitzero, bitone, bitone, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 624) = {
    SEE = 624;
    let Rt = Slice(__opcode, 0, 5);
    let imm19 = Slice(__opcode, 5, 19);
    let opc = Slice(__opcode, 30, 2);
    decode_ldr_lit_gen_aarch64_instrs_memory_literal_general(Rt, imm19, opc)
}

val decode_ldrsw_lit_aarch64_instrs_memory_literal_general : (bits(5), bits(19), bits(2)) -> unit

function decode_ldrsw_lit_aarch64_instrs_memory_literal_general (Rt, imm19, opc) = {
    let 't = UInt(Rt);
    memop : MemOp = MemOp_LOAD;
    is_signed : bool = false;
    let nontemporal : bool = false;
    size : {4, 8} = 4;
    match opc {
      0b00 => {
          size = 4
      },
      0b01 => {
          size = 8
      },
      0b10 => {
          size = 4;
          is_signed = true
      },
      0b11 => {
          memop = MemOp_PREFETCH
      }
    };
    let 'size = size;
    let offset : bits(64) = SignExtend(imm19 @ 0b00, 64);
    let tagchecked : bool = false;
    execute_aarch64_instrs_memory_literal_general(memop, nontemporal, offset, is_signed, size, t, tagchecked)
}

function clause __DecodeA64_LoadStore ((pc, ([bitone, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 625) = {
    SEE = 625;
    let Rt = Slice(__opcode, 0, 5);
    let imm19 = Slice(__opcode, 5, 19);
    let opc = Slice(__opcode, 30, 2);
    decode_ldrsw_lit_aarch64_instrs_memory_literal_general(Rt, imm19, opc)
}

val decode_prfm_lit_aarch64_instrs_memory_literal_general : (bits(5), bits(19), bits(2)) -> unit

function decode_prfm_lit_aarch64_instrs_memory_literal_general (Rt, imm19, opc) = {
    let 't = UInt(Rt);
    memop : MemOp = MemOp_LOAD;
    is_signed : bool = false;
    let nontemporal : bool = false;
    size : {4, 8} = 4;
    match opc {
      0b00 => {
          size = 4
      },
      0b01 => {
          size = 8
      },
      0b10 => {
          size = 4;
          is_signed = true
      },
      0b11 => {
          memop = MemOp_PREFETCH
      }
    };
    let 'size = size;
    let offset : bits(64) = SignExtend(imm19 @ 0b00, 64);
    let tagchecked : bool = false;
    execute_aarch64_instrs_memory_literal_general(memop, nontemporal, offset, is_signed, size, t, tagchecked)
}

function clause __DecodeA64_LoadStore ((pc, ([bitone, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 626) = {
    SEE = 626;
    let Rt = Slice(__opcode, 0, 5);
    let imm19 = Slice(__opcode, 5, 19);
    let opc = Slice(__opcode, 30, 2);
    decode_prfm_lit_aarch64_instrs_memory_literal_general(Rt, imm19, opc)
}

val execute_aarch64_instrs_memory_literal_simdfp : forall ('nontemporal : Bool) 'size 't ('tagchecked : Bool),
  (0 <= 't & 't <= 31 & 'size in {4, 8, 16}).
  (bool('nontemporal), bits(64), int('size), int('t), bool('tagchecked)) -> unit

function execute_aarch64_instrs_memory_literal_simdfp (nontemporal, offset, size, t, tagchecked) = {
    let address : bits(64) = PC_read() + offset;
    let privileged : bool = PSTATE.EL != EL0;
    CheckFPEnabled64();
    let accdesc : AccessDescriptor = CreateAccDescASIMD(MemOp_LOAD, nontemporal, tagchecked);
    let data : bits('size * 8) = Mem_read(address, size, accdesc);
    V_set(t, size * 8) = data;
    if SPESampleInFlight then {
        SPESampleSIMDFPLoadStore()
    };
    ()
}

val decode_ldr_lit_fpsimd_aarch64_instrs_memory_literal_simdfp : (bits(5), bits(19), bits(2)) -> unit

function decode_ldr_lit_fpsimd_aarch64_instrs_memory_literal_simdfp (Rt, imm19, opc) = {
    let 't = UInt(Rt);
    let nontemporal : bool = false;
    size : {4, 8, 16} = 4;
    match opc {
      0b00 => {
          size = 4
      },
      0b01 => {
          size = 8
      },
      0b10 => {
          size = 16
      },
      0b11 => {
          throw(Error_Undefined())
      }
    };
    let 'size = size;
    let offset : bits(64) = SignExtend(imm19 @ 0b00, 64);
    let tagchecked : bool = false;
    execute_aarch64_instrs_memory_literal_simdfp(nontemporal, offset, size, t, tagchecked)
}

function clause __DecodeA64_LoadStore ((pc, ([_, _, bitzero, bitone, bitone, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 627) = {
    SEE = 627;
    let Rt = Slice(__opcode, 0, 5);
    let imm19 = Slice(__opcode, 5, 19);
    let opc = Slice(__opcode, 30, 2);
    decode_ldr_lit_fpsimd_aarch64_instrs_memory_literal_simdfp(Rt, imm19, opc)
}

val execute_aarch64_instrs_memory_single_general_immediate_signed_post_idx : forall 'datasize ('is_signed : Bool) 'n ('nontemporal : Bool) ('postindex : Bool) 'regsize ('rt_unknown : Bool) 't ('tagchecked : Bool) ('wb_unknown : Bool) ('wback : Bool),
  (0 <= 't & 't <= 31 & 'regsize in {32, 64} & 0 <= 'n & 'n <= 31 & 'datasize in {8, 16, 32, 64}).
  (int('datasize), MemOp, int('n), bool('nontemporal), bits(64), bool('postindex), int('regsize), bool('rt_unknown), bool('is_signed), int('t), bool('tagchecked), bool('wb_unknown), bool('wback)) -> unit

function execute_aarch64_instrs_memory_single_general_immediate_signed_post_idx (datasize, memop, n, nontemporal, offset, postindex, regsize, rt_unknown, is_signed, t, tagchecked, wb_unknown, wback) = {
    address : bits(64) = undefined;
    data : bits('datasize) = undefined;
    let privileged : bool = PSTATE.EL != EL0;
    let accdesc : AccessDescriptor = CreateAccDescGPR(memop, nontemporal, privileged, tagchecked);
    if n == 31 then {
        if memop != MemOp_PREFETCH then {
            CheckSPAlignment()
        };
        address = SP_read()
    } else {
        address = X_read(n, 64)
    };
    if not_bool(postindex) then {
        address = address + offset
    };
    match memop {
      MemOp_STORE => {
          if rt_unknown then {
              data = __UNKNOWN_bits(datasize)
          } else {
              data = X_read(t, datasize)
          };
          if not_bool(wback) then {
              AArch64_SetLSInstructionSyndrome(DIV(datasize, 8), false, t, regsize == 64, false)
          };
          Mem_set(address, DIV(datasize, 8), accdesc) = data
      },
      MemOp_LOAD => {
          if not_bool(wback) then {
              AArch64_SetLSInstructionSyndrome(DIV(datasize, 8), is_signed, t, regsize == 64, false)
          };
          let data : bits('datasize) = Mem_read(address, DIV(datasize, 8), accdesc);
          if is_signed then {
              assert(constraint(('datasize > 0 & 'regsize >= 'datasize)));
              X_set(t, regsize) = SignExtend(data, regsize)
          } else {
              assert(constraint(('datasize >= 0 & 'regsize >= 'datasize)));
              X_set(t, regsize) = ZeroExtend(data, regsize)
          }
      },
      MemOp_PREFETCH => {
          Prefetch(address, t[4 .. 0])
      }
    };
    if wback then {
        if wb_unknown then {
            address = __UNKNOWN_bits(64)
        } else if postindex then {
            address = address + offset
        } else ();
        if n == 31 then {
            SP_set() = address
        } else {
            X_set(n, 64) = address
        }
    };
    if SPESampleInFlight then {
        SPESampleGeneralPurposeLoadStore()
    };
    ()
}

val decode_ldr_imm_gen_aarch64_instrs_memory_single_general_immediate_signed_post_idx : (bits(5), bits(5), bits(9), bits(2), bits(2)) -> unit

function decode_ldr_imm_gen_aarch64_instrs_memory_single_general_immediate_signed_post_idx (Rt, Rn, imm9, opc, size) = {
    wback : bool = true;
    let postindex : bool = true;
    let 'scale = UInt(size);
    let offset : bits(64) = SignExtend(imm9, 64);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let nontemporal : bool = false;
    memop : MemOp = undefined;
    is_signed : bool = undefined;
    regsize : {32, 64} = 32;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        is_signed = false
    } else {
        if size == 0b11 then {
            throw(Error_Undefined())
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            };
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            is_signed = true
        }
    };
    let 'regsize = regsize;
    let 'datasize = (8 << scale);
    let tagchecked : bool = memop != MemOp_PREFETCH & (wback | n != 31);
    wb_unknown : bool = false;
    rt_unknown : bool = false;
    c : Constraint = undefined;
    if ((memop == MemOp_LOAD & wback) & n == t) & n != 31 then {
        c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
        assert(c == Constraint_WBSUPPRESS | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_WBSUPPRESS => {
              wback = false
          },
          Constraint_UNKNOWN => {
              wb_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    if ((memop == MemOp_STORE & wback) & n == t) & n != 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
        assert(c == Constraint_NONE | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_NONE => {
              rt_unknown = false
          },
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    execute_aarch64_instrs_memory_single_general_immediate_signed_post_idx(datasize, memop, n, nontemporal, offset, postindex, regsize, rt_unknown, is_signed, t, tagchecked, wb_unknown, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([bitone, _, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 628) = {
    SEE = 628;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm9 = Slice(__opcode, 12, 9);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_ldr_imm_gen_aarch64_instrs_memory_single_general_immediate_signed_post_idx(Rt, Rn, imm9, opc, size)
}

val decode_ldr_imm_gen_aarch64_instrs_memory_single_general_immediate_signed_pre_idx : (bits(5), bits(5), bits(9), bits(2), bits(2)) -> unit

function decode_ldr_imm_gen_aarch64_instrs_memory_single_general_immediate_signed_pre_idx (Rt, Rn, imm9, opc, size) = {
    wback : bool = true;
    let postindex : bool = false;
    let 'scale = UInt(size);
    let offset : bits(64) = SignExtend(imm9, 64);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let nontemporal : bool = false;
    memop : MemOp = undefined;
    is_signed : bool = undefined;
    regsize : {32, 64} = 32;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        is_signed = false
    } else {
        if size == 0b11 then {
            throw(Error_Undefined())
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            };
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            is_signed = true
        }
    };
    let 'regsize = regsize;
    let 'datasize = (8 << scale);
    let tagchecked : bool = memop != MemOp_PREFETCH & (wback | n != 31);
    wb_unknown : bool = false;
    rt_unknown : bool = false;
    c : Constraint = undefined;
    if ((memop == MemOp_LOAD & wback) & n == t) & n != 31 then {
        c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
        assert(c == Constraint_WBSUPPRESS | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_WBSUPPRESS => {
              wback = false
          },
          Constraint_UNKNOWN => {
              wb_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    if ((memop == MemOp_STORE & wback) & n == t) & n != 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
        assert(c == Constraint_NONE | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_NONE => {
              rt_unknown = false
          },
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    execute_aarch64_instrs_memory_single_general_immediate_signed_post_idx(datasize, memop, n, nontemporal, offset, postindex, regsize, rt_unknown, is_signed, t, tagchecked, wb_unknown, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([bitone, _, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 629) = {
    SEE = 629;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm9 = Slice(__opcode, 12, 9);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_ldr_imm_gen_aarch64_instrs_memory_single_general_immediate_signed_pre_idx(Rt, Rn, imm9, opc, size)
}

val decode_ldr_imm_gen_aarch64_instrs_memory_single_general_immediate_unsigned : (bits(5), bits(5), bits(12), bits(2), bits(2)) -> unit

function decode_ldr_imm_gen_aarch64_instrs_memory_single_general_immediate_unsigned (Rt, Rn, imm12, opc, size) = {
    wback : bool = false;
    let postindex : bool = false;
    let 'scale = UInt(size);
    let offset : bits(64) = LSL(ZeroExtend(imm12, 64), scale);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let nontemporal : bool = false;
    memop : MemOp = undefined;
    is_signed : bool = undefined;
    regsize : {32, 64} = 32;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        is_signed = false
    } else {
        if size == 0b11 then {
            throw(Error_Undefined())
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            };
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            is_signed = true
        }
    };
    let 'regsize = regsize;
    let 'datasize = (8 << scale);
    let tagchecked : bool = memop != MemOp_PREFETCH & (wback | n != 31);
    wb_unknown : bool = false;
    rt_unknown : bool = false;
    c : Constraint = undefined;
    if ((memop == MemOp_LOAD & wback) & n == t) & n != 31 then {
        c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
        assert(c == Constraint_WBSUPPRESS | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_WBSUPPRESS => {
              wback = false
          },
          Constraint_UNKNOWN => {
              wb_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    if ((memop == MemOp_STORE & wback) & n == t) & n != 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
        assert(c == Constraint_NONE | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_NONE => {
              rt_unknown = false
          },
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    execute_aarch64_instrs_memory_single_general_immediate_signed_post_idx(datasize, memop, n, nontemporal, offset, postindex, regsize, rt_unknown, is_signed, t, tagchecked, wb_unknown, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([bitone, _, bitone, bitone, bitone, bitzero, bitzero, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 630) = {
    SEE = 630;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm12 = Slice(__opcode, 10, 12);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_ldr_imm_gen_aarch64_instrs_memory_single_general_immediate_unsigned(Rt, Rn, imm12, opc, size)
}

val decode_ldrb_imm_aarch64_instrs_memory_single_general_immediate_signed_post_idx : (bits(5), bits(5), bits(9), bits(2), bits(2)) -> unit

function decode_ldrb_imm_aarch64_instrs_memory_single_general_immediate_signed_post_idx (Rt, Rn, imm9, opc, size) = {
    wback : bool = true;
    let postindex : bool = true;
    let 'scale = UInt(size);
    let offset : bits(64) = SignExtend(imm9, 64);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let nontemporal : bool = false;
    memop : MemOp = undefined;
    is_signed : bool = undefined;
    regsize : {32, 64} = 32;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        is_signed = false
    } else {
        if size == 0b11 then {
            throw(Error_Undefined())
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            };
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            is_signed = true
        }
    };
    let 'regsize = regsize;
    let 'datasize = (8 << scale);
    let tagchecked : bool = memop != MemOp_PREFETCH & (wback | n != 31);
    wb_unknown : bool = false;
    rt_unknown : bool = false;
    c : Constraint = undefined;
    if ((memop == MemOp_LOAD & wback) & n == t) & n != 31 then {
        c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
        assert(c == Constraint_WBSUPPRESS | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_WBSUPPRESS => {
              wback = false
          },
          Constraint_UNKNOWN => {
              wb_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    if ((memop == MemOp_STORE & wback) & n == t) & n != 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
        assert(c == Constraint_NONE | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_NONE => {
              rt_unknown = false
          },
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    execute_aarch64_instrs_memory_single_general_immediate_signed_post_idx(datasize, memop, n, nontemporal, offset, postindex, regsize, rt_unknown, is_signed, t, tagchecked, wb_unknown, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 631) = {
    SEE = 631;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm9 = Slice(__opcode, 12, 9);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_ldrb_imm_aarch64_instrs_memory_single_general_immediate_signed_post_idx(Rt, Rn, imm9, opc, size)
}

val decode_ldrb_imm_aarch64_instrs_memory_single_general_immediate_signed_pre_idx : (bits(5), bits(5), bits(9), bits(2), bits(2)) -> unit

function decode_ldrb_imm_aarch64_instrs_memory_single_general_immediate_signed_pre_idx (Rt, Rn, imm9, opc, size) = {
    wback : bool = true;
    let postindex : bool = false;
    let 'scale = UInt(size);
    let offset : bits(64) = SignExtend(imm9, 64);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let nontemporal : bool = false;
    memop : MemOp = undefined;
    is_signed : bool = undefined;
    regsize : {32, 64} = 32;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        is_signed = false
    } else {
        if size == 0b11 then {
            throw(Error_Undefined())
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            };
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            is_signed = true
        }
    };
    let 'regsize = regsize;
    let 'datasize = (8 << scale);
    let tagchecked : bool = memop != MemOp_PREFETCH & (wback | n != 31);
    wb_unknown : bool = false;
    rt_unknown : bool = false;
    c : Constraint = undefined;
    if ((memop == MemOp_LOAD & wback) & n == t) & n != 31 then {
        c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
        assert(c == Constraint_WBSUPPRESS | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_WBSUPPRESS => {
              wback = false
          },
          Constraint_UNKNOWN => {
              wb_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    if ((memop == MemOp_STORE & wback) & n == t) & n != 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
        assert(c == Constraint_NONE | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_NONE => {
              rt_unknown = false
          },
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    execute_aarch64_instrs_memory_single_general_immediate_signed_post_idx(datasize, memop, n, nontemporal, offset, postindex, regsize, rt_unknown, is_signed, t, tagchecked, wb_unknown, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 632) = {
    SEE = 632;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm9 = Slice(__opcode, 12, 9);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_ldrb_imm_aarch64_instrs_memory_single_general_immediate_signed_pre_idx(Rt, Rn, imm9, opc, size)
}

val decode_ldrb_imm_aarch64_instrs_memory_single_general_immediate_unsigned : (bits(5), bits(5), bits(12), bits(2), bits(2)) -> unit

function decode_ldrb_imm_aarch64_instrs_memory_single_general_immediate_unsigned (Rt, Rn, imm12, opc, size) = {
    wback : bool = false;
    let postindex : bool = false;
    let 'scale = UInt(size);
    let offset : bits(64) = LSL(ZeroExtend(imm12, 64), scale);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let nontemporal : bool = false;
    memop : MemOp = undefined;
    is_signed : bool = undefined;
    regsize : {32, 64} = 32;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        is_signed = false
    } else {
        if size == 0b11 then {
            throw(Error_Undefined())
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            };
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            is_signed = true
        }
    };
    let 'regsize = regsize;
    let 'datasize = (8 << scale);
    let tagchecked : bool = memop != MemOp_PREFETCH & (wback | n != 31);
    wb_unknown : bool = false;
    rt_unknown : bool = false;
    c : Constraint = undefined;
    if ((memop == MemOp_LOAD & wback) & n == t) & n != 31 then {
        c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
        assert(c == Constraint_WBSUPPRESS | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_WBSUPPRESS => {
              wback = false
          },
          Constraint_UNKNOWN => {
              wb_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    if ((memop == MemOp_STORE & wback) & n == t) & n != 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
        assert(c == Constraint_NONE | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_NONE => {
              rt_unknown = false
          },
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    execute_aarch64_instrs_memory_single_general_immediate_signed_post_idx(datasize, memop, n, nontemporal, offset, postindex, regsize, rt_unknown, is_signed, t, tagchecked, wb_unknown, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 633) = {
    SEE = 633;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm12 = Slice(__opcode, 10, 12);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_ldrb_imm_aarch64_instrs_memory_single_general_immediate_unsigned(Rt, Rn, imm12, opc, size)
}

val decode_ldrh_imm_aarch64_instrs_memory_single_general_immediate_signed_post_idx : (bits(5), bits(5), bits(9), bits(2), bits(2)) -> unit

function decode_ldrh_imm_aarch64_instrs_memory_single_general_immediate_signed_post_idx (Rt, Rn, imm9, opc, size) = {
    wback : bool = true;
    let postindex : bool = true;
    let 'scale = UInt(size);
    let offset : bits(64) = SignExtend(imm9, 64);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let nontemporal : bool = false;
    memop : MemOp = undefined;
    is_signed : bool = undefined;
    regsize : {32, 64} = 32;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        is_signed = false
    } else {
        if size == 0b11 then {
            throw(Error_Undefined())
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            };
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            is_signed = true
        }
    };
    let 'regsize = regsize;
    let 'datasize = (8 << scale);
    let tagchecked : bool = memop != MemOp_PREFETCH & (wback | n != 31);
    wb_unknown : bool = false;
    rt_unknown : bool = false;
    c : Constraint = undefined;
    if ((memop == MemOp_LOAD & wback) & n == t) & n != 31 then {
        c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
        assert(c == Constraint_WBSUPPRESS | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_WBSUPPRESS => {
              wback = false
          },
          Constraint_UNKNOWN => {
              wb_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    if ((memop == MemOp_STORE & wback) & n == t) & n != 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
        assert(c == Constraint_NONE | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_NONE => {
              rt_unknown = false
          },
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    execute_aarch64_instrs_memory_single_general_immediate_signed_post_idx(datasize, memop, n, nontemporal, offset, postindex, regsize, rt_unknown, is_signed, t, tagchecked, wb_unknown, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 634) = {
    SEE = 634;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm9 = Slice(__opcode, 12, 9);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_ldrh_imm_aarch64_instrs_memory_single_general_immediate_signed_post_idx(Rt, Rn, imm9, opc, size)
}

val decode_ldrh_imm_aarch64_instrs_memory_single_general_immediate_signed_pre_idx : (bits(5), bits(5), bits(9), bits(2), bits(2)) -> unit

function decode_ldrh_imm_aarch64_instrs_memory_single_general_immediate_signed_pre_idx (Rt, Rn, imm9, opc, size) = {
    wback : bool = true;
    let postindex : bool = false;
    let 'scale = UInt(size);
    let offset : bits(64) = SignExtend(imm9, 64);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let nontemporal : bool = false;
    memop : MemOp = undefined;
    is_signed : bool = undefined;
    regsize : {32, 64} = 32;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        is_signed = false
    } else {
        if size == 0b11 then {
            throw(Error_Undefined())
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            };
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            is_signed = true
        }
    };
    let 'regsize = regsize;
    let 'datasize = (8 << scale);
    let tagchecked : bool = memop != MemOp_PREFETCH & (wback | n != 31);
    wb_unknown : bool = false;
    rt_unknown : bool = false;
    c : Constraint = undefined;
    if ((memop == MemOp_LOAD & wback) & n == t) & n != 31 then {
        c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
        assert(c == Constraint_WBSUPPRESS | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_WBSUPPRESS => {
              wback = false
          },
          Constraint_UNKNOWN => {
              wb_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    if ((memop == MemOp_STORE & wback) & n == t) & n != 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
        assert(c == Constraint_NONE | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_NONE => {
              rt_unknown = false
          },
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    execute_aarch64_instrs_memory_single_general_immediate_signed_post_idx(datasize, memop, n, nontemporal, offset, postindex, regsize, rt_unknown, is_signed, t, tagchecked, wb_unknown, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 635) = {
    SEE = 635;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm9 = Slice(__opcode, 12, 9);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_ldrh_imm_aarch64_instrs_memory_single_general_immediate_signed_pre_idx(Rt, Rn, imm9, opc, size)
}

val decode_ldrh_imm_aarch64_instrs_memory_single_general_immediate_unsigned : (bits(5), bits(5), bits(12), bits(2), bits(2)) -> unit

function decode_ldrh_imm_aarch64_instrs_memory_single_general_immediate_unsigned (Rt, Rn, imm12, opc, size) = {
    wback : bool = false;
    let postindex : bool = false;
    let 'scale = UInt(size);
    let offset : bits(64) = LSL(ZeroExtend(imm12, 64), scale);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let nontemporal : bool = false;
    memop : MemOp = undefined;
    is_signed : bool = undefined;
    regsize : {32, 64} = 32;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        is_signed = false
    } else {
        if size == 0b11 then {
            throw(Error_Undefined())
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            };
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            is_signed = true
        }
    };
    let 'regsize = regsize;
    let 'datasize = (8 << scale);
    let tagchecked : bool = memop != MemOp_PREFETCH & (wback | n != 31);
    wb_unknown : bool = false;
    rt_unknown : bool = false;
    c : Constraint = undefined;
    if ((memop == MemOp_LOAD & wback) & n == t) & n != 31 then {
        c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
        assert(c == Constraint_WBSUPPRESS | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_WBSUPPRESS => {
              wback = false
          },
          Constraint_UNKNOWN => {
              wb_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    if ((memop == MemOp_STORE & wback) & n == t) & n != 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
        assert(c == Constraint_NONE | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_NONE => {
              rt_unknown = false
          },
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    execute_aarch64_instrs_memory_single_general_immediate_signed_post_idx(datasize, memop, n, nontemporal, offset, postindex, regsize, rt_unknown, is_signed, t, tagchecked, wb_unknown, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 636) = {
    SEE = 636;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm12 = Slice(__opcode, 10, 12);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_ldrh_imm_aarch64_instrs_memory_single_general_immediate_unsigned(Rt, Rn, imm12, opc, size)
}

val decode_ldrsb_imm_aarch64_instrs_memory_single_general_immediate_signed_post_idx : (bits(5), bits(5), bits(9), bits(2), bits(2)) -> unit

function decode_ldrsb_imm_aarch64_instrs_memory_single_general_immediate_signed_post_idx (Rt, Rn, imm9, opc, size) = {
    wback : bool = true;
    let postindex : bool = true;
    let 'scale = UInt(size);
    let offset : bits(64) = SignExtend(imm9, 64);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let nontemporal : bool = false;
    memop : MemOp = undefined;
    is_signed : bool = undefined;
    regsize : {32, 64} = 32;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        is_signed = false
    } else {
        if size == 0b11 then {
            throw(Error_Undefined())
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            };
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            is_signed = true
        }
    };
    let 'regsize = regsize;
    let 'datasize = (8 << scale);
    let tagchecked : bool = memop != MemOp_PREFETCH & (wback | n != 31);
    wb_unknown : bool = false;
    rt_unknown : bool = false;
    c : Constraint = undefined;
    if ((memop == MemOp_LOAD & wback) & n == t) & n != 31 then {
        c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
        assert(c == Constraint_WBSUPPRESS | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_WBSUPPRESS => {
              wback = false
          },
          Constraint_UNKNOWN => {
              wb_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    if ((memop == MemOp_STORE & wback) & n == t) & n != 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
        assert(c == Constraint_NONE | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_NONE => {
              rt_unknown = false
          },
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    execute_aarch64_instrs_memory_single_general_immediate_signed_post_idx(datasize, memop, n, nontemporal, offset, postindex, regsize, rt_unknown, is_signed, t, tagchecked, wb_unknown, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitone, _, bitzero, _, _, _, _, _, _, _, _, _, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 637) = {
    SEE = 637;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm9 = Slice(__opcode, 12, 9);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_ldrsb_imm_aarch64_instrs_memory_single_general_immediate_signed_post_idx(Rt, Rn, imm9, opc, size)
}

val decode_ldrsb_imm_aarch64_instrs_memory_single_general_immediate_signed_pre_idx : (bits(5), bits(5), bits(9), bits(2), bits(2)) -> unit

function decode_ldrsb_imm_aarch64_instrs_memory_single_general_immediate_signed_pre_idx (Rt, Rn, imm9, opc, size) = {
    wback : bool = true;
    let postindex : bool = false;
    let 'scale = UInt(size);
    let offset : bits(64) = SignExtend(imm9, 64);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let nontemporal : bool = false;
    memop : MemOp = undefined;
    is_signed : bool = undefined;
    regsize : {32, 64} = 32;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        is_signed = false
    } else {
        if size == 0b11 then {
            throw(Error_Undefined())
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            };
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            is_signed = true
        }
    };
    let 'regsize = regsize;
    let 'datasize = (8 << scale);
    let tagchecked : bool = memop != MemOp_PREFETCH & (wback | n != 31);
    wb_unknown : bool = false;
    rt_unknown : bool = false;
    c : Constraint = undefined;
    if ((memop == MemOp_LOAD & wback) & n == t) & n != 31 then {
        c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
        assert(c == Constraint_WBSUPPRESS | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_WBSUPPRESS => {
              wback = false
          },
          Constraint_UNKNOWN => {
              wb_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    if ((memop == MemOp_STORE & wback) & n == t) & n != 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
        assert(c == Constraint_NONE | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_NONE => {
              rt_unknown = false
          },
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    execute_aarch64_instrs_memory_single_general_immediate_signed_post_idx(datasize, memop, n, nontemporal, offset, postindex, regsize, rt_unknown, is_signed, t, tagchecked, wb_unknown, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitone, _, bitzero, _, _, _, _, _, _, _, _, _, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 638) = {
    SEE = 638;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm9 = Slice(__opcode, 12, 9);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_ldrsb_imm_aarch64_instrs_memory_single_general_immediate_signed_pre_idx(Rt, Rn, imm9, opc, size)
}

val decode_ldrsb_imm_aarch64_instrs_memory_single_general_immediate_unsigned : (bits(5), bits(5), bits(12), bits(2), bits(2)) -> unit

function decode_ldrsb_imm_aarch64_instrs_memory_single_general_immediate_unsigned (Rt, Rn, imm12, opc, size) = {
    wback : bool = false;
    let postindex : bool = false;
    let 'scale = UInt(size);
    let offset : bits(64) = LSL(ZeroExtend(imm12, 64), scale);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let nontemporal : bool = false;
    memop : MemOp = undefined;
    is_signed : bool = undefined;
    regsize : {32, 64} = 32;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        is_signed = false
    } else {
        if size == 0b11 then {
            throw(Error_Undefined())
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            };
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            is_signed = true
        }
    };
    let 'regsize = regsize;
    let 'datasize = (8 << scale);
    let tagchecked : bool = memop != MemOp_PREFETCH & (wback | n != 31);
    wb_unknown : bool = false;
    rt_unknown : bool = false;
    c : Constraint = undefined;
    if ((memop == MemOp_LOAD & wback) & n == t) & n != 31 then {
        c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
        assert(c == Constraint_WBSUPPRESS | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_WBSUPPRESS => {
              wback = false
          },
          Constraint_UNKNOWN => {
              wb_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    if ((memop == MemOp_STORE & wback) & n == t) & n != 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
        assert(c == Constraint_NONE | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_NONE => {
              rt_unknown = false
          },
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    execute_aarch64_instrs_memory_single_general_immediate_signed_post_idx(datasize, memop, n, nontemporal, offset, postindex, regsize, rt_unknown, is_signed, t, tagchecked, wb_unknown, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 639) = {
    SEE = 639;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm12 = Slice(__opcode, 10, 12);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_ldrsb_imm_aarch64_instrs_memory_single_general_immediate_unsigned(Rt, Rn, imm12, opc, size)
}

val decode_ldrsh_imm_aarch64_instrs_memory_single_general_immediate_signed_post_idx : (bits(5), bits(5), bits(9), bits(2), bits(2)) -> unit

function decode_ldrsh_imm_aarch64_instrs_memory_single_general_immediate_signed_post_idx (Rt, Rn, imm9, opc, size) = {
    wback : bool = true;
    let postindex : bool = true;
    let 'scale = UInt(size);
    let offset : bits(64) = SignExtend(imm9, 64);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let nontemporal : bool = false;
    memop : MemOp = undefined;
    is_signed : bool = undefined;
    regsize : {32, 64} = 32;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        is_signed = false
    } else {
        if size == 0b11 then {
            throw(Error_Undefined())
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            };
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            is_signed = true
        }
    };
    let 'regsize = regsize;
    let 'datasize = (8 << scale);
    let tagchecked : bool = memop != MemOp_PREFETCH & (wback | n != 31);
    wb_unknown : bool = false;
    rt_unknown : bool = false;
    c : Constraint = undefined;
    if ((memop == MemOp_LOAD & wback) & n == t) & n != 31 then {
        c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
        assert(c == Constraint_WBSUPPRESS | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_WBSUPPRESS => {
              wback = false
          },
          Constraint_UNKNOWN => {
              wb_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    if ((memop == MemOp_STORE & wback) & n == t) & n != 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
        assert(c == Constraint_NONE | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_NONE => {
              rt_unknown = false
          },
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    execute_aarch64_instrs_memory_single_general_immediate_signed_post_idx(datasize, memop, n, nontemporal, offset, postindex, regsize, rt_unknown, is_signed, t, tagchecked, wb_unknown, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitone, _, bitzero, _, _, _, _, _, _, _, _, _, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 640) = {
    SEE = 640;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm9 = Slice(__opcode, 12, 9);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_ldrsh_imm_aarch64_instrs_memory_single_general_immediate_signed_post_idx(Rt, Rn, imm9, opc, size)
}

val decode_ldrsh_imm_aarch64_instrs_memory_single_general_immediate_signed_pre_idx : (bits(5), bits(5), bits(9), bits(2), bits(2)) -> unit

function decode_ldrsh_imm_aarch64_instrs_memory_single_general_immediate_signed_pre_idx (Rt, Rn, imm9, opc, size) = {
    wback : bool = true;
    let postindex : bool = false;
    let 'scale = UInt(size);
    let offset : bits(64) = SignExtend(imm9, 64);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let nontemporal : bool = false;
    memop : MemOp = undefined;
    is_signed : bool = undefined;
    regsize : {32, 64} = 32;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        is_signed = false
    } else {
        if size == 0b11 then {
            throw(Error_Undefined())
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            };
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            is_signed = true
        }
    };
    let 'regsize = regsize;
    let 'datasize = (8 << scale);
    let tagchecked : bool = memop != MemOp_PREFETCH & (wback | n != 31);
    wb_unknown : bool = false;
    rt_unknown : bool = false;
    c : Constraint = undefined;
    if ((memop == MemOp_LOAD & wback) & n == t) & n != 31 then {
        c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
        assert(c == Constraint_WBSUPPRESS | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_WBSUPPRESS => {
              wback = false
          },
          Constraint_UNKNOWN => {
              wb_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    if ((memop == MemOp_STORE & wback) & n == t) & n != 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
        assert(c == Constraint_NONE | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_NONE => {
              rt_unknown = false
          },
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    execute_aarch64_instrs_memory_single_general_immediate_signed_post_idx(datasize, memop, n, nontemporal, offset, postindex, regsize, rt_unknown, is_signed, t, tagchecked, wb_unknown, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitone, _, bitzero, _, _, _, _, _, _, _, _, _, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 641) = {
    SEE = 641;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm9 = Slice(__opcode, 12, 9);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_ldrsh_imm_aarch64_instrs_memory_single_general_immediate_signed_pre_idx(Rt, Rn, imm9, opc, size)
}

val decode_ldrsh_imm_aarch64_instrs_memory_single_general_immediate_unsigned : (bits(5), bits(5), bits(12), bits(2), bits(2)) -> unit

function decode_ldrsh_imm_aarch64_instrs_memory_single_general_immediate_unsigned (Rt, Rn, imm12, opc, size) = {
    wback : bool = false;
    let postindex : bool = false;
    let 'scale = UInt(size);
    let offset : bits(64) = LSL(ZeroExtend(imm12, 64), scale);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let nontemporal : bool = false;
    memop : MemOp = undefined;
    is_signed : bool = undefined;
    regsize : {32, 64} = 32;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        is_signed = false
    } else {
        if size == 0b11 then {
            throw(Error_Undefined())
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            };
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            is_signed = true
        }
    };
    let 'regsize = regsize;
    let 'datasize = (8 << scale);
    let tagchecked : bool = memop != MemOp_PREFETCH & (wback | n != 31);
    wb_unknown : bool = false;
    rt_unknown : bool = false;
    c : Constraint = undefined;
    if ((memop == MemOp_LOAD & wback) & n == t) & n != 31 then {
        c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
        assert(c == Constraint_WBSUPPRESS | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_WBSUPPRESS => {
              wback = false
          },
          Constraint_UNKNOWN => {
              wb_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    if ((memop == MemOp_STORE & wback) & n == t) & n != 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
        assert(c == Constraint_NONE | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_NONE => {
              rt_unknown = false
          },
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    execute_aarch64_instrs_memory_single_general_immediate_signed_post_idx(datasize, memop, n, nontemporal, offset, postindex, regsize, rt_unknown, is_signed, t, tagchecked, wb_unknown, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 642) = {
    SEE = 642;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm12 = Slice(__opcode, 10, 12);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_ldrsh_imm_aarch64_instrs_memory_single_general_immediate_unsigned(Rt, Rn, imm12, opc, size)
}

val decode_ldrsw_imm_aarch64_instrs_memory_single_general_immediate_signed_post_idx : (bits(5), bits(5), bits(9), bits(2), bits(2)) -> unit

function decode_ldrsw_imm_aarch64_instrs_memory_single_general_immediate_signed_post_idx (Rt, Rn, imm9, opc, size) = {
    wback : bool = true;
    let postindex : bool = true;
    let 'scale = UInt(size);
    let offset : bits(64) = SignExtend(imm9, 64);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let nontemporal : bool = false;
    memop : MemOp = undefined;
    is_signed : bool = undefined;
    regsize : {32, 64} = 32;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        is_signed = false
    } else {
        if size == 0b11 then {
            throw(Error_Undefined())
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            };
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            is_signed = true
        }
    };
    let 'regsize = regsize;
    let 'datasize = (8 << scale);
    let tagchecked : bool = memop != MemOp_PREFETCH & (wback | n != 31);
    wb_unknown : bool = false;
    rt_unknown : bool = false;
    c : Constraint = undefined;
    if ((memop == MemOp_LOAD & wback) & n == t) & n != 31 then {
        c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
        assert(c == Constraint_WBSUPPRESS | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_WBSUPPRESS => {
              wback = false
          },
          Constraint_UNKNOWN => {
              wb_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    if ((memop == MemOp_STORE & wback) & n == t) & n != 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
        assert(c == Constraint_NONE | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_NONE => {
              rt_unknown = false
          },
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    execute_aarch64_instrs_memory_single_general_immediate_signed_post_idx(datasize, memop, n, nontemporal, offset, postindex, regsize, rt_unknown, is_signed, t, tagchecked, wb_unknown, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([bitone, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 643) = {
    SEE = 643;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm9 = Slice(__opcode, 12, 9);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_ldrsw_imm_aarch64_instrs_memory_single_general_immediate_signed_post_idx(Rt, Rn, imm9, opc, size)
}

val decode_ldrsw_imm_aarch64_instrs_memory_single_general_immediate_signed_pre_idx : (bits(5), bits(5), bits(9), bits(2), bits(2)) -> unit

function decode_ldrsw_imm_aarch64_instrs_memory_single_general_immediate_signed_pre_idx (Rt, Rn, imm9, opc, size) = {
    wback : bool = true;
    let postindex : bool = false;
    let 'scale = UInt(size);
    let offset : bits(64) = SignExtend(imm9, 64);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let nontemporal : bool = false;
    memop : MemOp = undefined;
    is_signed : bool = undefined;
    regsize : {32, 64} = 32;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        is_signed = false
    } else {
        if size == 0b11 then {
            throw(Error_Undefined())
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            };
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            is_signed = true
        }
    };
    let 'regsize = regsize;
    let 'datasize = (8 << scale);
    let tagchecked : bool = memop != MemOp_PREFETCH & (wback | n != 31);
    wb_unknown : bool = false;
    rt_unknown : bool = false;
    c : Constraint = undefined;
    if ((memop == MemOp_LOAD & wback) & n == t) & n != 31 then {
        c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
        assert(c == Constraint_WBSUPPRESS | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_WBSUPPRESS => {
              wback = false
          },
          Constraint_UNKNOWN => {
              wb_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    if ((memop == MemOp_STORE & wback) & n == t) & n != 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
        assert(c == Constraint_NONE | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_NONE => {
              rt_unknown = false
          },
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    execute_aarch64_instrs_memory_single_general_immediate_signed_post_idx(datasize, memop, n, nontemporal, offset, postindex, regsize, rt_unknown, is_signed, t, tagchecked, wb_unknown, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([bitone, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 644) = {
    SEE = 644;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm9 = Slice(__opcode, 12, 9);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_ldrsw_imm_aarch64_instrs_memory_single_general_immediate_signed_pre_idx(Rt, Rn, imm9, opc, size)
}

val decode_ldrsw_imm_aarch64_instrs_memory_single_general_immediate_unsigned : (bits(5), bits(5), bits(12), bits(2), bits(2)) -> unit

function decode_ldrsw_imm_aarch64_instrs_memory_single_general_immediate_unsigned (Rt, Rn, imm12, opc, size) = {
    wback : bool = false;
    let postindex : bool = false;
    let 'scale = UInt(size);
    let offset : bits(64) = LSL(ZeroExtend(imm12, 64), scale);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let nontemporal : bool = false;
    memop : MemOp = undefined;
    is_signed : bool = undefined;
    regsize : {32, 64} = 32;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        is_signed = false
    } else {
        if size == 0b11 then {
            throw(Error_Undefined())
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            };
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            is_signed = true
        }
    };
    let 'regsize = regsize;
    let 'datasize = (8 << scale);
    let tagchecked : bool = memop != MemOp_PREFETCH & (wback | n != 31);
    wb_unknown : bool = false;
    rt_unknown : bool = false;
    c : Constraint = undefined;
    if ((memop == MemOp_LOAD & wback) & n == t) & n != 31 then {
        c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
        assert(c == Constraint_WBSUPPRESS | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_WBSUPPRESS => {
              wback = false
          },
          Constraint_UNKNOWN => {
              wb_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    if ((memop == MemOp_STORE & wback) & n == t) & n != 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
        assert(c == Constraint_NONE | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_NONE => {
              rt_unknown = false
          },
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    execute_aarch64_instrs_memory_single_general_immediate_signed_post_idx(datasize, memop, n, nontemporal, offset, postindex, regsize, rt_unknown, is_signed, t, tagchecked, wb_unknown, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([bitone, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 645) = {
    SEE = 645;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm12 = Slice(__opcode, 10, 12);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_ldrsw_imm_aarch64_instrs_memory_single_general_immediate_unsigned(Rt, Rn, imm12, opc, size)
}

val decode_str_imm_gen_aarch64_instrs_memory_single_general_immediate_signed_post_idx : (bits(5), bits(5), bits(9), bits(2), bits(2)) -> unit

function decode_str_imm_gen_aarch64_instrs_memory_single_general_immediate_signed_post_idx (Rt, Rn, imm9, opc, size) = {
    wback : bool = true;
    let postindex : bool = true;
    let 'scale = UInt(size);
    let offset : bits(64) = SignExtend(imm9, 64);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let nontemporal : bool = false;
    memop : MemOp = undefined;
    is_signed : bool = undefined;
    regsize : {32, 64} = 32;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        is_signed = false
    } else {
        if size == 0b11 then {
            throw(Error_Undefined())
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            };
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            is_signed = true
        }
    };
    let 'regsize = regsize;
    let 'datasize = (8 << scale);
    let tagchecked : bool = memop != MemOp_PREFETCH & (wback | n != 31);
    wb_unknown : bool = false;
    rt_unknown : bool = false;
    c : Constraint = undefined;
    if ((memop == MemOp_LOAD & wback) & n == t) & n != 31 then {
        c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
        assert(c == Constraint_WBSUPPRESS | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_WBSUPPRESS => {
              wback = false
          },
          Constraint_UNKNOWN => {
              wb_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    if ((memop == MemOp_STORE & wback) & n == t) & n != 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
        assert(c == Constraint_NONE | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_NONE => {
              rt_unknown = false
          },
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    execute_aarch64_instrs_memory_single_general_immediate_signed_post_idx(datasize, memop, n, nontemporal, offset, postindex, regsize, rt_unknown, is_signed, t, tagchecked, wb_unknown, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([bitone, _, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 646) = {
    SEE = 646;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm9 = Slice(__opcode, 12, 9);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_str_imm_gen_aarch64_instrs_memory_single_general_immediate_signed_post_idx(Rt, Rn, imm9, opc, size)
}

val decode_str_imm_gen_aarch64_instrs_memory_single_general_immediate_signed_pre_idx : (bits(5), bits(5), bits(9), bits(2), bits(2)) -> unit

function decode_str_imm_gen_aarch64_instrs_memory_single_general_immediate_signed_pre_idx (Rt, Rn, imm9, opc, size) = {
    wback : bool = true;
    let postindex : bool = false;
    let 'scale = UInt(size);
    let offset : bits(64) = SignExtend(imm9, 64);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let nontemporal : bool = false;
    memop : MemOp = undefined;
    is_signed : bool = undefined;
    regsize : {32, 64} = 32;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        is_signed = false
    } else {
        if size == 0b11 then {
            throw(Error_Undefined())
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            };
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            is_signed = true
        }
    };
    let 'regsize = regsize;
    let 'datasize = (8 << scale);
    let tagchecked : bool = memop != MemOp_PREFETCH & (wback | n != 31);
    wb_unknown : bool = false;
    rt_unknown : bool = false;
    c : Constraint = undefined;
    if ((memop == MemOp_LOAD & wback) & n == t) & n != 31 then {
        c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
        assert(c == Constraint_WBSUPPRESS | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_WBSUPPRESS => {
              wback = false
          },
          Constraint_UNKNOWN => {
              wb_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    if ((memop == MemOp_STORE & wback) & n == t) & n != 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
        assert(c == Constraint_NONE | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_NONE => {
              rt_unknown = false
          },
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    execute_aarch64_instrs_memory_single_general_immediate_signed_post_idx(datasize, memop, n, nontemporal, offset, postindex, regsize, rt_unknown, is_signed, t, tagchecked, wb_unknown, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([bitone, _, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 647) = {
    SEE = 647;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm9 = Slice(__opcode, 12, 9);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_str_imm_gen_aarch64_instrs_memory_single_general_immediate_signed_pre_idx(Rt, Rn, imm9, opc, size)
}

val decode_str_imm_gen_aarch64_instrs_memory_single_general_immediate_unsigned : (bits(5), bits(5), bits(12), bits(2), bits(2)) -> unit

function decode_str_imm_gen_aarch64_instrs_memory_single_general_immediate_unsigned (Rt, Rn, imm12, opc, size) = {
    wback : bool = false;
    let postindex : bool = false;
    let 'scale = UInt(size);
    let offset : bits(64) = LSL(ZeroExtend(imm12, 64), scale);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let nontemporal : bool = false;
    memop : MemOp = undefined;
    is_signed : bool = undefined;
    regsize : {32, 64} = 32;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        is_signed = false
    } else {
        if size == 0b11 then {
            throw(Error_Undefined())
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            };
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            is_signed = true
        }
    };
    let 'regsize = regsize;
    let 'datasize = (8 << scale);
    let tagchecked : bool = memop != MemOp_PREFETCH & (wback | n != 31);
    wb_unknown : bool = false;
    rt_unknown : bool = false;
    c : Constraint = undefined;
    if ((memop == MemOp_LOAD & wback) & n == t) & n != 31 then {
        c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
        assert(c == Constraint_WBSUPPRESS | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_WBSUPPRESS => {
              wback = false
          },
          Constraint_UNKNOWN => {
              wb_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    if ((memop == MemOp_STORE & wback) & n == t) & n != 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
        assert(c == Constraint_NONE | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_NONE => {
              rt_unknown = false
          },
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    execute_aarch64_instrs_memory_single_general_immediate_signed_post_idx(datasize, memop, n, nontemporal, offset, postindex, regsize, rt_unknown, is_signed, t, tagchecked, wb_unknown, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([bitone, _, bitone, bitone, bitone, bitzero, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 648) = {
    SEE = 648;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm12 = Slice(__opcode, 10, 12);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_str_imm_gen_aarch64_instrs_memory_single_general_immediate_unsigned(Rt, Rn, imm12, opc, size)
}

val decode_strb_imm_aarch64_instrs_memory_single_general_immediate_signed_post_idx : (bits(5), bits(5), bits(9), bits(2), bits(2)) -> unit

function decode_strb_imm_aarch64_instrs_memory_single_general_immediate_signed_post_idx (Rt, Rn, imm9, opc, size) = {
    wback : bool = true;
    let postindex : bool = true;
    let 'scale = UInt(size);
    let offset : bits(64) = SignExtend(imm9, 64);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let nontemporal : bool = false;
    memop : MemOp = undefined;
    is_signed : bool = undefined;
    regsize : {32, 64} = 32;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        is_signed = false
    } else {
        if size == 0b11 then {
            throw(Error_Undefined())
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            };
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            is_signed = true
        }
    };
    let 'regsize = regsize;
    let 'datasize = (8 << scale);
    let tagchecked : bool = memop != MemOp_PREFETCH & (wback | n != 31);
    wb_unknown : bool = false;
    rt_unknown : bool = false;
    c : Constraint = undefined;
    if ((memop == MemOp_LOAD & wback) & n == t) & n != 31 then {
        c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
        assert(c == Constraint_WBSUPPRESS | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_WBSUPPRESS => {
              wback = false
          },
          Constraint_UNKNOWN => {
              wb_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    if ((memop == MemOp_STORE & wback) & n == t) & n != 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
        assert(c == Constraint_NONE | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_NONE => {
              rt_unknown = false
          },
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    execute_aarch64_instrs_memory_single_general_immediate_signed_post_idx(datasize, memop, n, nontemporal, offset, postindex, regsize, rt_unknown, is_signed, t, tagchecked, wb_unknown, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 649) = {
    SEE = 649;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm9 = Slice(__opcode, 12, 9);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_strb_imm_aarch64_instrs_memory_single_general_immediate_signed_post_idx(Rt, Rn, imm9, opc, size)
}

val decode_strb_imm_aarch64_instrs_memory_single_general_immediate_signed_pre_idx : (bits(5), bits(5), bits(9), bits(2), bits(2)) -> unit

function decode_strb_imm_aarch64_instrs_memory_single_general_immediate_signed_pre_idx (Rt, Rn, imm9, opc, size) = {
    wback : bool = true;
    let postindex : bool = false;
    let 'scale = UInt(size);
    let offset : bits(64) = SignExtend(imm9, 64);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let nontemporal : bool = false;
    memop : MemOp = undefined;
    is_signed : bool = undefined;
    regsize : {32, 64} = 32;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        is_signed = false
    } else {
        if size == 0b11 then {
            throw(Error_Undefined())
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            };
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            is_signed = true
        }
    };
    let 'regsize = regsize;
    let 'datasize = (8 << scale);
    let tagchecked : bool = memop != MemOp_PREFETCH & (wback | n != 31);
    wb_unknown : bool = false;
    rt_unknown : bool = false;
    c : Constraint = undefined;
    if ((memop == MemOp_LOAD & wback) & n == t) & n != 31 then {
        c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
        assert(c == Constraint_WBSUPPRESS | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_WBSUPPRESS => {
              wback = false
          },
          Constraint_UNKNOWN => {
              wb_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    if ((memop == MemOp_STORE & wback) & n == t) & n != 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
        assert(c == Constraint_NONE | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_NONE => {
              rt_unknown = false
          },
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    execute_aarch64_instrs_memory_single_general_immediate_signed_post_idx(datasize, memop, n, nontemporal, offset, postindex, regsize, rt_unknown, is_signed, t, tagchecked, wb_unknown, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 650) = {
    SEE = 650;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm9 = Slice(__opcode, 12, 9);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_strb_imm_aarch64_instrs_memory_single_general_immediate_signed_pre_idx(Rt, Rn, imm9, opc, size)
}

val decode_strb_imm_aarch64_instrs_memory_single_general_immediate_unsigned : (bits(5), bits(5), bits(12), bits(2), bits(2)) -> unit

function decode_strb_imm_aarch64_instrs_memory_single_general_immediate_unsigned (Rt, Rn, imm12, opc, size) = {
    wback : bool = false;
    let postindex : bool = false;
    let 'scale = UInt(size);
    let offset : bits(64) = LSL(ZeroExtend(imm12, 64), scale);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let nontemporal : bool = false;
    memop : MemOp = undefined;
    is_signed : bool = undefined;
    regsize : {32, 64} = 32;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        is_signed = false
    } else {
        if size == 0b11 then {
            throw(Error_Undefined())
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            };
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            is_signed = true
        }
    };
    let 'regsize = regsize;
    let 'datasize = (8 << scale);
    let tagchecked : bool = memop != MemOp_PREFETCH & (wback | n != 31);
    wb_unknown : bool = false;
    rt_unknown : bool = false;
    c : Constraint = undefined;
    if ((memop == MemOp_LOAD & wback) & n == t) & n != 31 then {
        c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
        assert(c == Constraint_WBSUPPRESS | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_WBSUPPRESS => {
              wback = false
          },
          Constraint_UNKNOWN => {
              wb_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    if ((memop == MemOp_STORE & wback) & n == t) & n != 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
        assert(c == Constraint_NONE | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_NONE => {
              rt_unknown = false
          },
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    execute_aarch64_instrs_memory_single_general_immediate_signed_post_idx(datasize, memop, n, nontemporal, offset, postindex, regsize, rt_unknown, is_signed, t, tagchecked, wb_unknown, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 651) = {
    SEE = 651;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm12 = Slice(__opcode, 10, 12);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_strb_imm_aarch64_instrs_memory_single_general_immediate_unsigned(Rt, Rn, imm12, opc, size)
}

val decode_strh_imm_aarch64_instrs_memory_single_general_immediate_signed_post_idx : (bits(5), bits(5), bits(9), bits(2), bits(2)) -> unit

function decode_strh_imm_aarch64_instrs_memory_single_general_immediate_signed_post_idx (Rt, Rn, imm9, opc, size) = {
    wback : bool = true;
    let postindex : bool = true;
    let 'scale = UInt(size);
    let offset : bits(64) = SignExtend(imm9, 64);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let nontemporal : bool = false;
    memop : MemOp = undefined;
    is_signed : bool = undefined;
    regsize : {32, 64} = 32;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        is_signed = false
    } else {
        if size == 0b11 then {
            throw(Error_Undefined())
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            };
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            is_signed = true
        }
    };
    let 'regsize = regsize;
    let 'datasize = (8 << scale);
    let tagchecked : bool = memop != MemOp_PREFETCH & (wback | n != 31);
    wb_unknown : bool = false;
    rt_unknown : bool = false;
    c : Constraint = undefined;
    if ((memop == MemOp_LOAD & wback) & n == t) & n != 31 then {
        c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
        assert(c == Constraint_WBSUPPRESS | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_WBSUPPRESS => {
              wback = false
          },
          Constraint_UNKNOWN => {
              wb_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    if ((memop == MemOp_STORE & wback) & n == t) & n != 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
        assert(c == Constraint_NONE | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_NONE => {
              rt_unknown = false
          },
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    execute_aarch64_instrs_memory_single_general_immediate_signed_post_idx(datasize, memop, n, nontemporal, offset, postindex, regsize, rt_unknown, is_signed, t, tagchecked, wb_unknown, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 652) = {
    SEE = 652;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm9 = Slice(__opcode, 12, 9);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_strh_imm_aarch64_instrs_memory_single_general_immediate_signed_post_idx(Rt, Rn, imm9, opc, size)
}

val decode_strh_imm_aarch64_instrs_memory_single_general_immediate_signed_pre_idx : (bits(5), bits(5), bits(9), bits(2), bits(2)) -> unit

function decode_strh_imm_aarch64_instrs_memory_single_general_immediate_signed_pre_idx (Rt, Rn, imm9, opc, size) = {
    wback : bool = true;
    let postindex : bool = false;
    let 'scale = UInt(size);
    let offset : bits(64) = SignExtend(imm9, 64);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let nontemporal : bool = false;
    memop : MemOp = undefined;
    is_signed : bool = undefined;
    regsize : {32, 64} = 32;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        is_signed = false
    } else {
        if size == 0b11 then {
            throw(Error_Undefined())
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            };
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            is_signed = true
        }
    };
    let 'regsize = regsize;
    let 'datasize = (8 << scale);
    let tagchecked : bool = memop != MemOp_PREFETCH & (wback | n != 31);
    wb_unknown : bool = false;
    rt_unknown : bool = false;
    c : Constraint = undefined;
    if ((memop == MemOp_LOAD & wback) & n == t) & n != 31 then {
        c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
        assert(c == Constraint_WBSUPPRESS | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_WBSUPPRESS => {
              wback = false
          },
          Constraint_UNKNOWN => {
              wb_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    if ((memop == MemOp_STORE & wback) & n == t) & n != 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
        assert(c == Constraint_NONE | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_NONE => {
              rt_unknown = false
          },
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    execute_aarch64_instrs_memory_single_general_immediate_signed_post_idx(datasize, memop, n, nontemporal, offset, postindex, regsize, rt_unknown, is_signed, t, tagchecked, wb_unknown, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 653) = {
    SEE = 653;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm9 = Slice(__opcode, 12, 9);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_strh_imm_aarch64_instrs_memory_single_general_immediate_signed_pre_idx(Rt, Rn, imm9, opc, size)
}

val decode_strh_imm_aarch64_instrs_memory_single_general_immediate_unsigned : (bits(5), bits(5), bits(12), bits(2), bits(2)) -> unit

function decode_strh_imm_aarch64_instrs_memory_single_general_immediate_unsigned (Rt, Rn, imm12, opc, size) = {
    wback : bool = false;
    let postindex : bool = false;
    let 'scale = UInt(size);
    let offset : bits(64) = LSL(ZeroExtend(imm12, 64), scale);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let nontemporal : bool = false;
    memop : MemOp = undefined;
    is_signed : bool = undefined;
    regsize : {32, 64} = 32;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        is_signed = false
    } else {
        if size == 0b11 then {
            throw(Error_Undefined())
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            };
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            is_signed = true
        }
    };
    let 'regsize = regsize;
    let 'datasize = (8 << scale);
    let tagchecked : bool = memop != MemOp_PREFETCH & (wback | n != 31);
    wb_unknown : bool = false;
    rt_unknown : bool = false;
    c : Constraint = undefined;
    if ((memop == MemOp_LOAD & wback) & n == t) & n != 31 then {
        c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
        assert(c == Constraint_WBSUPPRESS | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_WBSUPPRESS => {
              wback = false
          },
          Constraint_UNKNOWN => {
              wb_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    if ((memop == MemOp_STORE & wback) & n == t) & n != 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
        assert(c == Constraint_NONE | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_NONE => {
              rt_unknown = false
          },
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    execute_aarch64_instrs_memory_single_general_immediate_signed_post_idx(datasize, memop, n, nontemporal, offset, postindex, regsize, rt_unknown, is_signed, t, tagchecked, wb_unknown, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 654) = {
    SEE = 654;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm12 = Slice(__opcode, 10, 12);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_strh_imm_aarch64_instrs_memory_single_general_immediate_unsigned(Rt, Rn, imm12, opc, size)
}

val execute_aarch64_instrs_memory_single_general_register : forall 'datasize ('is_signed : Bool) 'm 'n ('nontemporal : Bool) ('postindex : Bool) 'regsize ('rt_unknown : Bool) 'shift 't ('tagchecked : Bool) ('wb_unknown : Bool) ('wback : Bool),
  (0 <= 't & 't <= 31 & 'shift in {0, 1, 2, 3} & 'regsize in {32, 64} & 0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'datasize in {8, 16, 32, 64}).
  (int('datasize), ExtendType, int('m), MemOp, int('n), bool('nontemporal), bool('postindex), int('regsize), bool('rt_unknown), int('shift), bool('is_signed), int('t), bool('tagchecked), bool('wb_unknown), bool('wback)) -> unit

function execute_aarch64_instrs_memory_single_general_register (datasize, extend_type, m, memop, n, nontemporal, postindex, regsize, rt_unknown, shift, is_signed, t, tagchecked, wb_unknown, wback) = {
    let offset : bits(64) = ExtendReg(m, extend_type, shift, 64);
    address : bits(64) = undefined;
    data : bits('datasize) = undefined;
    let privileged : bool = PSTATE.EL != EL0;
    let accdesc : AccessDescriptor = CreateAccDescGPR(memop, nontemporal, privileged, tagchecked);
    if n == 31 then {
        if memop != MemOp_PREFETCH then {
            CheckSPAlignment()
        };
        address = SP_read()
    } else {
        address = X_read(n, 64)
    };
    if not_bool(postindex) then {
        address = address + offset
    };
    match memop {
      MemOp_STORE => {
          if rt_unknown then {
              data = __UNKNOWN_bits(datasize)
          } else {
              data = X_read(t, datasize)
          };
          if not_bool(wback) then {
              AArch64_SetLSInstructionSyndrome(DIV(datasize, 8), false, t, regsize == 64, false)
          };
          Mem_set(address, DIV(datasize, 8), accdesc) = data
      },
      MemOp_LOAD => {
          if not_bool(wback) then {
              AArch64_SetLSInstructionSyndrome(DIV(datasize, 8), is_signed, t, regsize == 64, false)
          };
          let data : bits('datasize) = Mem_read(address, DIV(datasize, 8), accdesc);
          if is_signed then {
              assert(constraint(('datasize > 0 & 'regsize >= 'datasize)));
              X_set(t, regsize) = SignExtend(data, regsize)
          } else {
              assert(constraint(('datasize >= 0 & 'regsize >= 'datasize)));
              X_set(t, regsize) = ZeroExtend(data, regsize)
          }
      },
      MemOp_PREFETCH => {
          Prefetch(address, t[4 .. 0])
      }
    };
    if wback then {
        if wb_unknown then {
            address = __UNKNOWN_bits(64)
        } else if postindex then {
            address = address + offset
        } else ();
        if n == 31 then {
            SP_set() = address
        } else {
            X_set(n, 64) = address
        }
    };
    if SPESampleInFlight then {
        SPESampleGeneralPurposeLoadStore()
    };
    ()
}

val decode_ldr_reg_gen_aarch64_instrs_memory_single_general_register : (bits(5), bits(5), bits(1), bits(3), bits(5), bits(2), bits(2)) -> unit

function decode_ldr_reg_gen_aarch64_instrs_memory_single_general_register (Rt, Rn, S, option_name, Rm, opc, size) = {
    wback : bool = false;
    let postindex : bool = false;
    let 'scale = UInt(size);
    if [option_name[1]] == 0b0 then {
        throw(Error_Undefined())
    };
    let extend_type : ExtendType = DecodeRegExtend(option_name);
    let 'shift = if S == 0b1 then scale else 0;
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 'm = UInt(Rm);
    let nontemporal : bool = false;
    memop : MemOp = undefined;
    is_signed : bool = undefined;
    regsize : {32, 64} = 32;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        is_signed = false
    } else {
        if size == 0b11 then {
            memop = MemOp_PREFETCH;
            if [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            };
            ()
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            };
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            is_signed = true
        }
    };
    let 'regsize = regsize;
    let 'datasize = (8 << scale);
    let tagchecked : bool = memop != MemOp_PREFETCH;
    wb_unknown : bool = false;
    rt_unknown : bool = false;
    c : Constraint = undefined;
    if ((memop == MemOp_LOAD & wback) & n == t) & n != 31 then {
        c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
        assert(c == Constraint_WBSUPPRESS | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_WBSUPPRESS => {
              wback = false
          },
          Constraint_UNKNOWN => {
              wb_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    if ((memop == MemOp_STORE & wback) & n == t) & n != 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
        assert(c == Constraint_NONE | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_NONE => {
              rt_unknown = false
          },
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    execute_aarch64_instrs_memory_single_general_register(datasize, extend_type, m, memop, n, nontemporal, postindex, regsize, rt_unknown, shift, is_signed, t, tagchecked, wb_unknown, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([bitone, _, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, _, _, _, _, _, _, _, _, _, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 655) = {
    SEE = 655;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let S = Slice(__opcode, 12, 1);
    let option_name = Slice(__opcode, 13, 3);
    let Rm = Slice(__opcode, 16, 5);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_ldr_reg_gen_aarch64_instrs_memory_single_general_register(Rt, Rn, S, option_name, Rm, opc, size)
}

val decode_ldrb_reg_aarch64_instrs_memory_single_general_register : (bits(5), bits(5), bits(1), bits(3), bits(5), bits(2), bits(2)) -> unit

function decode_ldrb_reg_aarch64_instrs_memory_single_general_register (Rt, Rn, S, option_name, Rm, opc, size) = {
    wback : bool = false;
    let postindex : bool = false;
    let 'scale = UInt(size);
    if [option_name[1]] == 0b0 then {
        throw(Error_Undefined())
    };
    let extend_type : ExtendType = DecodeRegExtend(option_name);
    let 'shift = if S == 0b1 then scale else 0;
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 'm = UInt(Rm);
    let nontemporal : bool = false;
    memop : MemOp = undefined;
    is_signed : bool = undefined;
    regsize : {32, 64} = 32;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        is_signed = false
    } else {
        if size == 0b11 then {
            memop = MemOp_PREFETCH;
            if [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            };
            ()
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            };
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            is_signed = true
        }
    };
    let 'regsize = regsize;
    let 'datasize = (8 << scale);
    let tagchecked : bool = memop != MemOp_PREFETCH;
    wb_unknown : bool = false;
    rt_unknown : bool = false;
    c : Constraint = undefined;
    if ((memop == MemOp_LOAD & wback) & n == t) & n != 31 then {
        c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
        assert(c == Constraint_WBSUPPRESS | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_WBSUPPRESS => {
              wback = false
          },
          Constraint_UNKNOWN => {
              wb_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    if ((memop == MemOp_STORE & wback) & n == t) & n != 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
        assert(c == Constraint_NONE | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_NONE => {
              rt_unknown = false
          },
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    execute_aarch64_instrs_memory_single_general_register(datasize, extend_type, m, memop, n, nontemporal, postindex, regsize, rt_unknown, shift, is_signed, t, tagchecked, wb_unknown, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, _, _, _, _, _, _, _, _, _, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 656) = {
    SEE = 656;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let S = Slice(__opcode, 12, 1);
    let option_name = Slice(__opcode, 13, 3);
    let Rm = Slice(__opcode, 16, 5);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_ldrb_reg_aarch64_instrs_memory_single_general_register(Rt, Rn, S, option_name, Rm, opc, size)
}

val decode_ldrh_reg_aarch64_instrs_memory_single_general_register : (bits(5), bits(5), bits(1), bits(3), bits(5), bits(2), bits(2)) -> unit

function decode_ldrh_reg_aarch64_instrs_memory_single_general_register (Rt, Rn, S, option_name, Rm, opc, size) = {
    wback : bool = false;
    let postindex : bool = false;
    let 'scale = UInt(size);
    if [option_name[1]] == 0b0 then {
        throw(Error_Undefined())
    };
    let extend_type : ExtendType = DecodeRegExtend(option_name);
    let 'shift = if S == 0b1 then scale else 0;
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 'm = UInt(Rm);
    let nontemporal : bool = false;
    memop : MemOp = undefined;
    is_signed : bool = undefined;
    regsize : {32, 64} = 32;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        is_signed = false
    } else {
        if size == 0b11 then {
            memop = MemOp_PREFETCH;
            if [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            };
            ()
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            };
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            is_signed = true
        }
    };
    let 'regsize = regsize;
    let 'datasize = (8 << scale);
    let tagchecked : bool = memop != MemOp_PREFETCH;
    wb_unknown : bool = false;
    rt_unknown : bool = false;
    c : Constraint = undefined;
    if ((memop == MemOp_LOAD & wback) & n == t) & n != 31 then {
        c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
        assert(c == Constraint_WBSUPPRESS | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_WBSUPPRESS => {
              wback = false
          },
          Constraint_UNKNOWN => {
              wb_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    if ((memop == MemOp_STORE & wback) & n == t) & n != 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
        assert(c == Constraint_NONE | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_NONE => {
              rt_unknown = false
          },
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    execute_aarch64_instrs_memory_single_general_register(datasize, extend_type, m, memop, n, nontemporal, postindex, regsize, rt_unknown, shift, is_signed, t, tagchecked, wb_unknown, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, _, _, _, _, _, _, _, _, _, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 657) = {
    SEE = 657;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let S = Slice(__opcode, 12, 1);
    let option_name = Slice(__opcode, 13, 3);
    let Rm = Slice(__opcode, 16, 5);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_ldrh_reg_aarch64_instrs_memory_single_general_register(Rt, Rn, S, option_name, Rm, opc, size)
}

val decode_ldrsb_reg_aarch64_instrs_memory_single_general_register : (bits(5), bits(5), bits(1), bits(3), bits(5), bits(2), bits(2)) -> unit

function decode_ldrsb_reg_aarch64_instrs_memory_single_general_register (Rt, Rn, S, option_name, Rm, opc, size) = {
    wback : bool = false;
    let postindex : bool = false;
    let 'scale = UInt(size);
    if [option_name[1]] == 0b0 then {
        throw(Error_Undefined())
    };
    let extend_type : ExtendType = DecodeRegExtend(option_name);
    let 'shift = if S == 0b1 then scale else 0;
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 'm = UInt(Rm);
    let nontemporal : bool = false;
    memop : MemOp = undefined;
    is_signed : bool = undefined;
    regsize : {32, 64} = 32;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        is_signed = false
    } else {
        if size == 0b11 then {
            memop = MemOp_PREFETCH;
            if [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            };
            ()
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            };
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            is_signed = true
        }
    };
    let 'regsize = regsize;
    let 'datasize = (8 << scale);
    let tagchecked : bool = memop != MemOp_PREFETCH;
    wb_unknown : bool = false;
    rt_unknown : bool = false;
    c : Constraint = undefined;
    if ((memop == MemOp_LOAD & wback) & n == t) & n != 31 then {
        c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
        assert(c == Constraint_WBSUPPRESS | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_WBSUPPRESS => {
              wback = false
          },
          Constraint_UNKNOWN => {
              wb_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    if ((memop == MemOp_STORE & wback) & n == t) & n != 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
        assert(c == Constraint_NONE | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_NONE => {
              rt_unknown = false
          },
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    execute_aarch64_instrs_memory_single_general_register(datasize, extend_type, m, memop, n, nontemporal, postindex, regsize, rt_unknown, shift, is_signed, t, tagchecked, wb_unknown, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitone, _, bitone, _, _, _, _, _, _, _, _, _, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 658) = {
    SEE = 658;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let S = Slice(__opcode, 12, 1);
    let option_name = Slice(__opcode, 13, 3);
    let Rm = Slice(__opcode, 16, 5);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_ldrsb_reg_aarch64_instrs_memory_single_general_register(Rt, Rn, S, option_name, Rm, opc, size)
}

val decode_ldrsh_reg_aarch64_instrs_memory_single_general_register : (bits(5), bits(5), bits(1), bits(3), bits(5), bits(2), bits(2)) -> unit

function decode_ldrsh_reg_aarch64_instrs_memory_single_general_register (Rt, Rn, S, option_name, Rm, opc, size) = {
    wback : bool = false;
    let postindex : bool = false;
    let 'scale = UInt(size);
    if [option_name[1]] == 0b0 then {
        throw(Error_Undefined())
    };
    let extend_type : ExtendType = DecodeRegExtend(option_name);
    let 'shift = if S == 0b1 then scale else 0;
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 'm = UInt(Rm);
    let nontemporal : bool = false;
    memop : MemOp = undefined;
    is_signed : bool = undefined;
    regsize : {32, 64} = 32;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        is_signed = false
    } else {
        if size == 0b11 then {
            memop = MemOp_PREFETCH;
            if [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            };
            ()
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            };
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            is_signed = true
        }
    };
    let 'regsize = regsize;
    let 'datasize = (8 << scale);
    let tagchecked : bool = memop != MemOp_PREFETCH;
    wb_unknown : bool = false;
    rt_unknown : bool = false;
    c : Constraint = undefined;
    if ((memop == MemOp_LOAD & wback) & n == t) & n != 31 then {
        c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
        assert(c == Constraint_WBSUPPRESS | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_WBSUPPRESS => {
              wback = false
          },
          Constraint_UNKNOWN => {
              wb_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    if ((memop == MemOp_STORE & wback) & n == t) & n != 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
        assert(c == Constraint_NONE | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_NONE => {
              rt_unknown = false
          },
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    execute_aarch64_instrs_memory_single_general_register(datasize, extend_type, m, memop, n, nontemporal, postindex, regsize, rt_unknown, shift, is_signed, t, tagchecked, wb_unknown, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitone, _, bitone, _, _, _, _, _, _, _, _, _, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 659) = {
    SEE = 659;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let S = Slice(__opcode, 12, 1);
    let option_name = Slice(__opcode, 13, 3);
    let Rm = Slice(__opcode, 16, 5);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_ldrsh_reg_aarch64_instrs_memory_single_general_register(Rt, Rn, S, option_name, Rm, opc, size)
}

val decode_ldrsw_reg_aarch64_instrs_memory_single_general_register : (bits(5), bits(5), bits(1), bits(3), bits(5), bits(2), bits(2)) -> unit

function decode_ldrsw_reg_aarch64_instrs_memory_single_general_register (Rt, Rn, S, option_name, Rm, opc, size) = {
    wback : bool = false;
    let postindex : bool = false;
    let 'scale = UInt(size);
    if [option_name[1]] == 0b0 then {
        throw(Error_Undefined())
    };
    let extend_type : ExtendType = DecodeRegExtend(option_name);
    let 'shift = if S == 0b1 then scale else 0;
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 'm = UInt(Rm);
    let nontemporal : bool = false;
    memop : MemOp = undefined;
    is_signed : bool = undefined;
    regsize : {32, 64} = 32;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        is_signed = false
    } else {
        if size == 0b11 then {
            memop = MemOp_PREFETCH;
            if [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            };
            ()
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            };
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            is_signed = true
        }
    };
    let 'regsize = regsize;
    let 'datasize = (8 << scale);
    let tagchecked : bool = memop != MemOp_PREFETCH;
    wb_unknown : bool = false;
    rt_unknown : bool = false;
    c : Constraint = undefined;
    if ((memop == MemOp_LOAD & wback) & n == t) & n != 31 then {
        c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
        assert(c == Constraint_WBSUPPRESS | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_WBSUPPRESS => {
              wback = false
          },
          Constraint_UNKNOWN => {
              wb_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    if ((memop == MemOp_STORE & wback) & n == t) & n != 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
        assert(c == Constraint_NONE | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_NONE => {
              rt_unknown = false
          },
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    execute_aarch64_instrs_memory_single_general_register(datasize, extend_type, m, memop, n, nontemporal, postindex, regsize, rt_unknown, shift, is_signed, t, tagchecked, wb_unknown, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([bitone, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 660) = {
    SEE = 660;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let S = Slice(__opcode, 12, 1);
    let option_name = Slice(__opcode, 13, 3);
    let Rm = Slice(__opcode, 16, 5);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_ldrsw_reg_aarch64_instrs_memory_single_general_register(Rt, Rn, S, option_name, Rm, opc, size)
}

val decode_prfm_reg_aarch64_instrs_memory_single_general_register : (bits(5), bits(5), bits(1), bits(3), bits(5), bits(2), bits(2)) -> unit

function decode_prfm_reg_aarch64_instrs_memory_single_general_register (Rt, Rn, S, option_name, Rm, opc, size) = {
    assert(not_bool((match Rt {
      [bitone, bitone, _, _, _] => true,
      _ => false
    }) : bool));
    wback : bool = false;
    let postindex : bool = false;
    let 'scale = UInt(size);
    if [option_name[1]] == 0b0 then {
        throw(Error_Undefined())
    };
    let extend_type : ExtendType = DecodeRegExtend(option_name);
    let 'shift = if S == 0b1 then scale else 0;
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 'm = UInt(Rm);
    let nontemporal : bool = false;
    memop : MemOp = undefined;
    is_signed : bool = undefined;
    regsize : {32, 64} = 32;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        is_signed = false
    } else {
        if size == 0b11 then {
            memop = MemOp_PREFETCH;
            if [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            };
            ()
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            };
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            is_signed = true
        }
    };
    let 'regsize = regsize;
    let 'datasize = (8 << scale);
    let tagchecked : bool = memop != MemOp_PREFETCH;
    wb_unknown : bool = false;
    rt_unknown : bool = false;
    c : Constraint = undefined;
    if ((memop == MemOp_LOAD & wback) & n == t) & n != 31 then {
        c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
        assert(c == Constraint_WBSUPPRESS | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_WBSUPPRESS => {
              wback = false
          },
          Constraint_UNKNOWN => {
              wb_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    if ((memop == MemOp_STORE & wback) & n == t) & n != 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
        assert(c == Constraint_NONE | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_NONE => {
              rt_unknown = false
          },
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    execute_aarch64_instrs_memory_single_general_register(datasize, extend_type, m, memop, n, nontemporal, postindex, regsize, rt_unknown, shift, is_signed, t, tagchecked, wb_unknown, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitone, _, _, _, _, _, _, bitone, _, _, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if not_bool((match Slice(__opcode, 0, 5) {
  [bitone, bitone, _, _, _] => true,
  _ => false
}) : bool) & SEE < 661) = {
    SEE = 661;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let S = Slice(__opcode, 12, 1);
    let option_name = Slice(__opcode, 13, 3);
    let Rm = Slice(__opcode, 16, 5);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_prfm_reg_aarch64_instrs_memory_single_general_register(Rt, Rn, S, option_name, Rm, opc, size)
}

val decode_str_reg_gen_aarch64_instrs_memory_single_general_register : (bits(5), bits(5), bits(1), bits(3), bits(5), bits(2), bits(2)) -> unit

function decode_str_reg_gen_aarch64_instrs_memory_single_general_register (Rt, Rn, S, option_name, Rm, opc, size) = {
    wback : bool = false;
    let postindex : bool = false;
    let 'scale = UInt(size);
    if [option_name[1]] == 0b0 then {
        throw(Error_Undefined())
    };
    let extend_type : ExtendType = DecodeRegExtend(option_name);
    let 'shift = if S == 0b1 then scale else 0;
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 'm = UInt(Rm);
    let nontemporal : bool = false;
    memop : MemOp = undefined;
    is_signed : bool = undefined;
    regsize : {32, 64} = 32;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        is_signed = false
    } else {
        if size == 0b11 then {
            memop = MemOp_PREFETCH;
            if [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            };
            ()
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            };
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            is_signed = true
        }
    };
    let 'regsize = regsize;
    let 'datasize = (8 << scale);
    let tagchecked : bool = memop != MemOp_PREFETCH;
    wb_unknown : bool = false;
    rt_unknown : bool = false;
    c : Constraint = undefined;
    if ((memop == MemOp_LOAD & wback) & n == t) & n != 31 then {
        c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
        assert(c == Constraint_WBSUPPRESS | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_WBSUPPRESS => {
              wback = false
          },
          Constraint_UNKNOWN => {
              wb_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    if ((memop == MemOp_STORE & wback) & n == t) & n != 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
        assert(c == Constraint_NONE | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_NONE => {
              rt_unknown = false
          },
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    execute_aarch64_instrs_memory_single_general_register(datasize, extend_type, m, memop, n, nontemporal, postindex, regsize, rt_unknown, shift, is_signed, t, tagchecked, wb_unknown, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([bitone, _, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 662) = {
    SEE = 662;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let S = Slice(__opcode, 12, 1);
    let option_name = Slice(__opcode, 13, 3);
    let Rm = Slice(__opcode, 16, 5);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_str_reg_gen_aarch64_instrs_memory_single_general_register(Rt, Rn, S, option_name, Rm, opc, size)
}

val decode_strb_reg_aarch64_instrs_memory_single_general_register : (bits(5), bits(5), bits(1), bits(3), bits(5), bits(2), bits(2)) -> unit

function decode_strb_reg_aarch64_instrs_memory_single_general_register (Rt, Rn, S, option_name, Rm, opc, size) = {
    wback : bool = false;
    let postindex : bool = false;
    let 'scale = UInt(size);
    if [option_name[1]] == 0b0 then {
        throw(Error_Undefined())
    };
    let extend_type : ExtendType = DecodeRegExtend(option_name);
    let 'shift = if S == 0b1 then scale else 0;
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 'm = UInt(Rm);
    let nontemporal : bool = false;
    memop : MemOp = undefined;
    is_signed : bool = undefined;
    regsize : {32, 64} = 32;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        is_signed = false
    } else {
        if size == 0b11 then {
            memop = MemOp_PREFETCH;
            if [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            };
            ()
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            };
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            is_signed = true
        }
    };
    let 'regsize = regsize;
    let 'datasize = (8 << scale);
    let tagchecked : bool = memop != MemOp_PREFETCH;
    wb_unknown : bool = false;
    rt_unknown : bool = false;
    c : Constraint = undefined;
    if ((memop == MemOp_LOAD & wback) & n == t) & n != 31 then {
        c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
        assert(c == Constraint_WBSUPPRESS | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_WBSUPPRESS => {
              wback = false
          },
          Constraint_UNKNOWN => {
              wb_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    if ((memop == MemOp_STORE & wback) & n == t) & n != 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
        assert(c == Constraint_NONE | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_NONE => {
              rt_unknown = false
          },
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    execute_aarch64_instrs_memory_single_general_register(datasize, extend_type, m, memop, n, nontemporal, postindex, regsize, rt_unknown, shift, is_signed, t, tagchecked, wb_unknown, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 663) = {
    SEE = 663;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let S = Slice(__opcode, 12, 1);
    let option_name = Slice(__opcode, 13, 3);
    let Rm = Slice(__opcode, 16, 5);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_strb_reg_aarch64_instrs_memory_single_general_register(Rt, Rn, S, option_name, Rm, opc, size)
}

val decode_strh_reg_aarch64_instrs_memory_single_general_register : (bits(5), bits(5), bits(1), bits(3), bits(5), bits(2), bits(2)) -> unit

function decode_strh_reg_aarch64_instrs_memory_single_general_register (Rt, Rn, S, option_name, Rm, opc, size) = {
    wback : bool = false;
    let postindex : bool = false;
    let 'scale = UInt(size);
    if [option_name[1]] == 0b0 then {
        throw(Error_Undefined())
    };
    let extend_type : ExtendType = DecodeRegExtend(option_name);
    let 'shift = if S == 0b1 then scale else 0;
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 'm = UInt(Rm);
    let nontemporal : bool = false;
    memop : MemOp = undefined;
    is_signed : bool = undefined;
    regsize : {32, 64} = 32;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        is_signed = false
    } else {
        if size == 0b11 then {
            memop = MemOp_PREFETCH;
            if [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            };
            ()
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            };
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            is_signed = true
        }
    };
    let 'regsize = regsize;
    let 'datasize = (8 << scale);
    let tagchecked : bool = memop != MemOp_PREFETCH;
    wb_unknown : bool = false;
    rt_unknown : bool = false;
    c : Constraint = undefined;
    if ((memop == MemOp_LOAD & wback) & n == t) & n != 31 then {
        c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
        assert(c == Constraint_WBSUPPRESS | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_WBSUPPRESS => {
              wback = false
          },
          Constraint_UNKNOWN => {
              wb_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    if ((memop == MemOp_STORE & wback) & n == t) & n != 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
        assert(c == Constraint_NONE | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_NONE => {
              rt_unknown = false
          },
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    execute_aarch64_instrs_memory_single_general_register(datasize, extend_type, m, memop, n, nontemporal, postindex, regsize, rt_unknown, shift, is_signed, t, tagchecked, wb_unknown, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 664) = {
    SEE = 664;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let S = Slice(__opcode, 12, 1);
    let option_name = Slice(__opcode, 13, 3);
    let Rm = Slice(__opcode, 16, 5);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_strh_reg_aarch64_instrs_memory_single_general_register(Rt, Rn, S, option_name, Rm, opc, size)
}

val execute_aarch64_instrs_memory_single_simdfp_register : forall 'datasize 'm 'n ('nontemporal : Bool) ('postindex : Bool) 'shift 't ('tagchecked : Bool) ('wback : Bool),
  (0 <= 't & 't <= 31 & 'shift in {0, 1, 2, 3, 4, 5, 6, 7} & 0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'datasize in {8, 16, 32, 64, 128, 256, 512, 1024}).
  (int('datasize), ExtendType, int('m), MemOp, int('n), bool('nontemporal), bool('postindex), int('shift), int('t), bool('tagchecked), bool('wback)) -> unit

function execute_aarch64_instrs_memory_single_simdfp_register (datasize, extend_type, m, memop, n, nontemporal, postindex, shift, t, tagchecked, wback) = {
    let offset : bits(64) = ExtendReg(m, extend_type, shift, 64);
    CheckFPEnabled64();
    address : bits(64) = undefined;
    data : bits('datasize) = undefined;
    let accdesc : AccessDescriptor = CreateAccDescASIMD(memop, nontemporal, tagchecked);
    if n == 31 then {
        CheckSPAlignment();
        address = SP_read()
    } else {
        address = X_read(n, 64)
    };
    if not_bool(postindex) then {
        address = address + offset
    };
    match memop {
      MemOp_STORE => {
          assert(constraint('datasize in {8, 16, 32, 64, 128}));
          let data : bits('datasize) = V_read(t, datasize);
          Mem_set(address, DIV(datasize, 8), accdesc) = data
      },
      MemOp_LOAD => {
          let data : bits('datasize) = Mem_read(address, DIV(datasize, 8), accdesc);
          assert(constraint('datasize in {8, 16, 32, 64, 128}));
          V_set(t, datasize) = data
      },
      _ => ()
    };
    if wback then {
        if postindex then {
            address = address + offset
        };
        if n == 31 then {
            SP_set() = address
        } else {
            X_set(n, 64) = address
        }
    };
    if SPESampleInFlight then {
        SPESampleSIMDFPLoadStore()
    };
    ()
}

val decode_ldr_reg_fpsimd_aarch64_instrs_memory_single_simdfp_register : (bits(5), bits(5), bits(1), bits(3), bits(5), bits(2), bits(2)) -> unit

function decode_ldr_reg_fpsimd_aarch64_instrs_memory_single_simdfp_register (Rt, Rn, S, option_name, Rm, opc, size) = {
    let wback : bool = false;
    let postindex : bool = false;
    let 'scale = UInt([opc[1]] @ size);
    if scale > 4 then {
        throw(Error_Undefined())
    };
    if [option_name[1]] == 0b0 then {
        throw(Error_Undefined())
    };
    let extend_type : ExtendType = DecodeRegExtend(option_name);
    let 'shift = if S == 0b1 then scale else 0;
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 'm = UInt(Rm);
    let nontemporal : bool = false;
    let memop : MemOp = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'datasize = (8 << scale);
    let tagchecked : bool = memop != MemOp_PREFETCH;
    assert(constraint('datasize in {8, 16, 32, 64, 128, 256, 512, 1024}));
    execute_aarch64_instrs_memory_single_simdfp_register(datasize, extend_type, m, memop, n, nontemporal, postindex, shift, t, tagchecked, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([_, _, bitone, bitone, bitone, bitone, bitzero, bitzero, _, bitone, bitone, _, _, _, _, _, _, _, _, _, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 665) = {
    SEE = 665;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let S = Slice(__opcode, 12, 1);
    let option_name = Slice(__opcode, 13, 3);
    let Rm = Slice(__opcode, 16, 5);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_ldr_reg_fpsimd_aarch64_instrs_memory_single_simdfp_register(Rt, Rn, S, option_name, Rm, opc, size)
}

val decode_str_reg_fpsimd_aarch64_instrs_memory_single_simdfp_register : (bits(5), bits(5), bits(1), bits(3), bits(5), bits(2), bits(2)) -> unit

function decode_str_reg_fpsimd_aarch64_instrs_memory_single_simdfp_register (Rt, Rn, S, option_name, Rm, opc, size) = {
    let wback : bool = false;
    let postindex : bool = false;
    let 'scale = UInt([opc[1]] @ size);
    if scale > 4 then {
        throw(Error_Undefined())
    };
    if [option_name[1]] == 0b0 then {
        throw(Error_Undefined())
    };
    let extend_type : ExtendType = DecodeRegExtend(option_name);
    let 'shift = if S == 0b1 then scale else 0;
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 'm = UInt(Rm);
    let nontemporal : bool = false;
    let memop : MemOp = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'datasize = (8 << scale);
    let tagchecked : bool = memop != MemOp_PREFETCH;
    assert(constraint('datasize in {8, 16, 32, 64, 128, 256, 512, 1024}));
    execute_aarch64_instrs_memory_single_simdfp_register(datasize, extend_type, m, memop, n, nontemporal, postindex, shift, t, tagchecked, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([_, _, bitone, bitone, bitone, bitone, bitzero, bitzero, _, bitzero, bitone, _, _, _, _, _, _, _, _, _, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 666) = {
    SEE = 666;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let S = Slice(__opcode, 12, 1);
    let option_name = Slice(__opcode, 13, 3);
    let Rm = Slice(__opcode, 16, 5);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_str_reg_fpsimd_aarch64_instrs_memory_single_simdfp_register(Rt, Rn, S, option_name, Rm, opc, size)
}

val execute_aarch64_instrs_memory_single_general_immediate_signed_pac : forall 'n ('nontemporal : Bool) 't ('tagchecked : Bool) ('use_key_a : Bool) ('wback : Bool),
  (0 <= 't & 't <= 31 & 0 <= 'n & 'n <= 31).
  (MemOp, int('n), bool('nontemporal), bits(64), int('t), bool('tagchecked), bool('use_key_a), bool('wback)) -> unit

function execute_aarch64_instrs_memory_single_general_immediate_signed_pac (memop, n, nontemporal, offset, t, tagchecked, use_key_a, wback__arg) = {
    wback : bool = wback__arg;
    address : bits(64) = undefined;
    let privileged : bool = PSTATE.EL != EL0;
    wb_unknown : bool = false;
    let auth_then_branch : bool = true;
    let accdesc : AccessDescriptor = CreateAccDescGPR(memop, nontemporal, privileged, tagchecked);
    if (wback & n == t) & n != 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
        assert(c == Constraint_WBSUPPRESS | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_WBSUPPRESS => {
              wback = false
          },
          Constraint_UNKNOWN => {
              wb_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    if n == 31 then {
        address = SP_read()
    } else {
        address = X_read(n, 64)
    };
    if not_bool(wback) then {
        AArch64_SetLSInstructionSyndrome(8, false, t, true, false)
    };
    if use_key_a then {
        address = AuthDA(address, X_read(31, 64), auth_then_branch)
    } else {
        address = AuthDB(address, X_read(31, 64), auth_then_branch)
    };
    if n == 31 then {
        CheckSPAlignment()
    };
    address : bits(64) = address + offset;
    let data : bits(64) = Mem_read(address, 8, accdesc);
    X_set(t, 64) = data;
    if wback then {
        if wb_unknown then {
            address = __UNKNOWN_bits(64)
        };
        if n == 31 then {
            SP_set() = address
        } else {
            X_set(n, 64) = address
        }
    };
    if SPESampleInFlight then {
        SPESampleGeneralPurposeLoadStore()
    };
    ()
}

val decode_ldra_aarch64_instrs_memory_single_general_immediate_signed_pac : (bits(5), bits(5), bits(1), bits(9), bits(1), bits(1), bits(2)) -> unit

function decode_ldra_aarch64_instrs_memory_single_general_immediate_signed_pac (Rt, Rn, W, imm9, S, M, size) = {
    if not_bool(HavePACExt()) | size != 0b11 then {
        throw(Error_Undefined())
    };
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let wback : bool = W == 0b1;
    let use_key_a : bool = M == 0b0;
    let S10 : bits(10) = S @ imm9;
    let 'scale = 3;
    let offset : bits(64) = LSL(SignExtend(S10, 64), scale);
    let nontemporal : bool = false;
    let memop : MemOp = MemOp_LOAD;
    let tagchecked : bool = wback | n != 31;
    execute_aarch64_instrs_memory_single_general_immediate_signed_pac(memop, n, nontemporal, offset, t, tagchecked, use_key_a, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, _, _, bitone, _, _, _, _, _, _, _, _, _, _, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 667) = {
    SEE = 667;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let W = Slice(__opcode, 11, 1);
    let imm9 = Slice(__opcode, 12, 9);
    let S = Slice(__opcode, 22, 1);
    let M = Slice(__opcode, 23, 1);
    let size = Slice(__opcode, 30, 2);
    decode_ldra_aarch64_instrs_memory_single_general_immediate_signed_pac(Rt, Rn, W, imm9, S, M, size)
}

val execute_aarch64_instrs_memory_atomicops_ld_128_ldsetp : forall ('acquire : Bool) 'n ('release : Bool) 't 't2 ('tagchecked : Bool),
  (0 <= 't2 & 't2 <= 31 & 0 <= 't & 't <= 31 & 0 <= 'n & 'n <= 31).
  (bool('acquire), int('n), MemAtomicOp, bool('release), int('t), int('t2), bool('tagchecked)) -> unit

function execute_aarch64_instrs_memory_atomicops_ld_128_ldsetp (acquire, n, op, release, t, t2, tagchecked) = {
    address : bits(64) = undefined;
    let value1_name : bits(64) = X_read(t, 64);
    let value2_name : bits(64) = X_read(t2, 64);
    let accdesc : AccessDescriptor = CreateAccDescAtomicOp(op, acquire, release, tagchecked);
    if n == 31 then {
        CheckSPAlignment();
        address = SP_read()
    } else {
        address = X_read(n, 64)
    };
    let store_value : bits(128) = if BigEndian(accdesc.acctype) then
      value1_name @ value2_name
    else
      value2_name @ value1_name;
    let comparevalue : bits(128) = __UNKNOWN_bits(128);
    let data : bits(128) = MemAtomic(address, comparevalue, store_value, accdesc);
    if BigEndian(accdesc.acctype) then {
        X_set(t, 64) = data[127 .. 64];
        X_set(t2, 64) = data[63 .. 0]
    } else {
        X_set(t, 64) = data[63 .. 0];
        X_set(t2, 64) = data[127 .. 64]
    }
}

val decode_ldsetp_aarch64_instrs_memory_atomicops_ld_128_ldsetp : (bits(5), bits(5), bits(3), bits(1), bits(5), bits(1), bits(1), bits(1)) -> unit

function decode_ldsetp_aarch64_instrs_memory_atomicops_ld_128_ldsetp (Rt, Rn, opc, o3, Rt2, R, A, S) = {
    if not_bool(HaveLSE128()) then {
        throw(Error_Undefined())
    };
    if Rt == 0b11111 then {
        throw(Error_Undefined())
    };
    if Rt2 == 0b11111 then {
        throw(Error_Undefined())
    };
    let 't = UInt(Rt);
    let 't2 = UInt(Rt2);
    let 'n = UInt(Rn);
    op : MemAtomicOp = undefined;
    match opc {
      0b001 => {
          op = MemAtomicOp_BIC
      },
      0b011 => {
          op = MemAtomicOp_ORR
      },
      _ => ()
    };
    let acquire : bool = A == 0b1;
    let release : bool = R == 0b1;
    let tagchecked : bool = n != 31;
    execute_aarch64_instrs_memory_atomicops_ld_128_ldsetp(acquire, n, op, release, t, t2, tagchecked)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitone, _, _, bitone, _, _, _, _, _, bitzero, bitzero, bitone, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 668) = {
    SEE = 668;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let opc = Slice(__opcode, 12, 3);
    let o3 = Slice(__opcode, 15, 1);
    let Rt2 = Slice(__opcode, 16, 5);
    let R = Slice(__opcode, 22, 1);
    let A = Slice(__opcode, 23, 1);
    let S = Slice(__opcode, 30, 1);
    decode_ldsetp_aarch64_instrs_memory_atomicops_ld_128_ldsetp(Rt, Rn, opc, o3, Rt2, R, A, S)
}

val execute_aarch64_instrs_memory_single_general_immediate_signed_offset_unpriv : forall 'datasize ('is_signed : Bool) 'n ('nontemporal : Bool) ('postindex : Bool) 'regsize ('rt_unknown : Bool) 't ('tagchecked : Bool) ('wb_unknown : Bool) ('wback : Bool),
  (0 <= 't & 't <= 31 & 'regsize in {32, 64} & 0 <= 'n & 'n <= 31 & 'datasize in {8, 16, 32, 64}).
  (int('datasize), MemOp, int('n), bool('nontemporal), bits(64), bool('postindex), int('regsize), bool('rt_unknown), bool('is_signed), int('t), bool('tagchecked), bool('wb_unknown), bool('wback)) -> unit

function execute_aarch64_instrs_memory_single_general_immediate_signed_offset_unpriv (datasize, memop, n, nontemporal, offset, postindex, regsize, rt_unknown, is_signed, t, tagchecked, wb_unknown, wback) = {
    address : bits(64) = undefined;
    data : bits('datasize) = undefined;
    let privileged : bool = AArch64_IsUnprivAccessPriv();
    let accdesc : AccessDescriptor = CreateAccDescGPR(memop, nontemporal, privileged, tagchecked);
    if n == 31 then {
        if memop != MemOp_PREFETCH then {
            CheckSPAlignment()
        };
        address = SP_read()
    } else {
        address = X_read(n, 64)
    };
    if not_bool(postindex) then {
        address = address + offset
    };
    match memop {
      MemOp_STORE => {
          if rt_unknown then {
              data = __UNKNOWN_bits(datasize)
          } else {
              data = X_read(t, datasize)
          };
          if not_bool(wback) then {
              AArch64_SetLSInstructionSyndrome(DIV(datasize, 8), false, t, regsize == 64, false)
          };
          Mem_set(address, DIV(datasize, 8), accdesc) = data
      },
      MemOp_LOAD => {
          if not_bool(wback) then {
              AArch64_SetLSInstructionSyndrome(DIV(datasize, 8), is_signed, t, regsize == 64, false)
          };
          let data : bits('datasize) = Mem_read(address, DIV(datasize, 8), accdesc);
          if is_signed then {
              assert(constraint(('datasize > 0 & 'regsize >= 'datasize)));
              X_set(t, regsize) = SignExtend(data, regsize)
          } else {
              assert(constraint(('datasize >= 0 & 'regsize >= 'datasize)));
              X_set(t, regsize) = ZeroExtend(data, regsize)
          }
      },
      MemOp_PREFETCH => {
          Prefetch(address, t[4 .. 0])
      }
    };
    if wback then {
        if wb_unknown then {
            address = __UNKNOWN_bits(64)
        } else if postindex then {
            address = address + offset
        } else ();
        if n == 31 then {
            SP_set() = address
        } else {
            X_set(n, 64) = address
        }
    };
    if SPESampleInFlight then {
        SPESampleGeneralPurposeLoadStore()
    };
    ()
}

val decode_ldtr_aarch64_instrs_memory_single_general_immediate_signed_offset_unpriv : (bits(5), bits(5), bits(9), bits(2), bits(2)) -> unit

function decode_ldtr_aarch64_instrs_memory_single_general_immediate_signed_offset_unpriv (Rt, Rn, imm9, opc, size) = {
    wback : bool = false;
    let postindex : bool = false;
    let 'scale = UInt(size);
    let offset : bits(64) = SignExtend(imm9, 64);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let nontemporal : bool = false;
    memop : MemOp = undefined;
    is_signed : bool = undefined;
    regsize : {32, 64} = 32;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        is_signed = false
    } else {
        if size == 0b11 then {
            throw(Error_Undefined())
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            };
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            is_signed = true
        }
    };
    let 'regsize = regsize;
    let 'datasize = (8 << scale);
    let tagchecked : bool = memop != MemOp_PREFETCH & (wback | n != 31);
    wb_unknown : bool = false;
    rt_unknown : bool = false;
    c : Constraint = undefined;
    if ((memop == MemOp_LOAD & wback) & n == t) & n != 31 then {
        c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
        assert(c == Constraint_WBSUPPRESS | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_WBSUPPRESS => {
              wback = false
          },
          Constraint_UNKNOWN => {
              wb_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    if ((memop == MemOp_STORE & wback) & n == t) & n != 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
        assert(c == Constraint_NONE | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_NONE => {
              rt_unknown = false
          },
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    execute_aarch64_instrs_memory_single_general_immediate_signed_offset_unpriv(datasize, memop, n, nontemporal, offset, postindex, regsize, rt_unknown, is_signed, t, tagchecked, wb_unknown, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([bitone, _, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 669) = {
    SEE = 669;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm9 = Slice(__opcode, 12, 9);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_ldtr_aarch64_instrs_memory_single_general_immediate_signed_offset_unpriv(Rt, Rn, imm9, opc, size)
}

val decode_ldtrb_aarch64_instrs_memory_single_general_immediate_signed_offset_unpriv : (bits(5), bits(5), bits(9), bits(2), bits(2)) -> unit

function decode_ldtrb_aarch64_instrs_memory_single_general_immediate_signed_offset_unpriv (Rt, Rn, imm9, opc, size) = {
    wback : bool = false;
    let postindex : bool = false;
    let 'scale = UInt(size);
    let offset : bits(64) = SignExtend(imm9, 64);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let nontemporal : bool = false;
    memop : MemOp = undefined;
    is_signed : bool = undefined;
    regsize : {32, 64} = 32;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        is_signed = false
    } else {
        if size == 0b11 then {
            throw(Error_Undefined())
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            };
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            is_signed = true
        }
    };
    let 'regsize = regsize;
    let 'datasize = (8 << scale);
    let tagchecked : bool = memop != MemOp_PREFETCH & (wback | n != 31);
    wb_unknown : bool = false;
    rt_unknown : bool = false;
    c : Constraint = undefined;
    if ((memop == MemOp_LOAD & wback) & n == t) & n != 31 then {
        c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
        assert(c == Constraint_WBSUPPRESS | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_WBSUPPRESS => {
              wback = false
          },
          Constraint_UNKNOWN => {
              wb_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    if ((memop == MemOp_STORE & wback) & n == t) & n != 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
        assert(c == Constraint_NONE | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_NONE => {
              rt_unknown = false
          },
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    execute_aarch64_instrs_memory_single_general_immediate_signed_offset_unpriv(datasize, memop, n, nontemporal, offset, postindex, regsize, rt_unknown, is_signed, t, tagchecked, wb_unknown, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 670) = {
    SEE = 670;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm9 = Slice(__opcode, 12, 9);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_ldtrb_aarch64_instrs_memory_single_general_immediate_signed_offset_unpriv(Rt, Rn, imm9, opc, size)
}

val decode_ldtrh_aarch64_instrs_memory_single_general_immediate_signed_offset_unpriv : (bits(5), bits(5), bits(9), bits(2), bits(2)) -> unit

function decode_ldtrh_aarch64_instrs_memory_single_general_immediate_signed_offset_unpriv (Rt, Rn, imm9, opc, size) = {
    wback : bool = false;
    let postindex : bool = false;
    let 'scale = UInt(size);
    let offset : bits(64) = SignExtend(imm9, 64);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let nontemporal : bool = false;
    memop : MemOp = undefined;
    is_signed : bool = undefined;
    regsize : {32, 64} = 32;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        is_signed = false
    } else {
        if size == 0b11 then {
            throw(Error_Undefined())
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            };
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            is_signed = true
        }
    };
    let 'regsize = regsize;
    let 'datasize = (8 << scale);
    let tagchecked : bool = memop != MemOp_PREFETCH & (wback | n != 31);
    wb_unknown : bool = false;
    rt_unknown : bool = false;
    c : Constraint = undefined;
    if ((memop == MemOp_LOAD & wback) & n == t) & n != 31 then {
        c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
        assert(c == Constraint_WBSUPPRESS | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_WBSUPPRESS => {
              wback = false
          },
          Constraint_UNKNOWN => {
              wb_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    if ((memop == MemOp_STORE & wback) & n == t) & n != 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
        assert(c == Constraint_NONE | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_NONE => {
              rt_unknown = false
          },
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    execute_aarch64_instrs_memory_single_general_immediate_signed_offset_unpriv(datasize, memop, n, nontemporal, offset, postindex, regsize, rt_unknown, is_signed, t, tagchecked, wb_unknown, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 671) = {
    SEE = 671;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm9 = Slice(__opcode, 12, 9);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_ldtrh_aarch64_instrs_memory_single_general_immediate_signed_offset_unpriv(Rt, Rn, imm9, opc, size)
}

val decode_ldtrsb_aarch64_instrs_memory_single_general_immediate_signed_offset_unpriv : (bits(5), bits(5), bits(9), bits(2), bits(2)) -> unit

function decode_ldtrsb_aarch64_instrs_memory_single_general_immediate_signed_offset_unpriv (Rt, Rn, imm9, opc, size) = {
    wback : bool = false;
    let postindex : bool = false;
    let 'scale = UInt(size);
    let offset : bits(64) = SignExtend(imm9, 64);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let nontemporal : bool = false;
    memop : MemOp = undefined;
    is_signed : bool = undefined;
    regsize : {32, 64} = 32;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        is_signed = false
    } else {
        if size == 0b11 then {
            throw(Error_Undefined())
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            };
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            is_signed = true
        }
    };
    let 'regsize = regsize;
    let 'datasize = (8 << scale);
    let tagchecked : bool = memop != MemOp_PREFETCH & (wback | n != 31);
    wb_unknown : bool = false;
    rt_unknown : bool = false;
    c : Constraint = undefined;
    if ((memop == MemOp_LOAD & wback) & n == t) & n != 31 then {
        c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
        assert(c == Constraint_WBSUPPRESS | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_WBSUPPRESS => {
              wback = false
          },
          Constraint_UNKNOWN => {
              wb_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    if ((memop == MemOp_STORE & wback) & n == t) & n != 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
        assert(c == Constraint_NONE | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_NONE => {
              rt_unknown = false
          },
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    execute_aarch64_instrs_memory_single_general_immediate_signed_offset_unpriv(datasize, memop, n, nontemporal, offset, postindex, regsize, rt_unknown, is_signed, t, tagchecked, wb_unknown, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitone, _, bitzero, _, _, _, _, _, _, _, _, _, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 672) = {
    SEE = 672;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm9 = Slice(__opcode, 12, 9);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_ldtrsb_aarch64_instrs_memory_single_general_immediate_signed_offset_unpriv(Rt, Rn, imm9, opc, size)
}

val decode_ldtrsh_aarch64_instrs_memory_single_general_immediate_signed_offset_unpriv : (bits(5), bits(5), bits(9), bits(2), bits(2)) -> unit

function decode_ldtrsh_aarch64_instrs_memory_single_general_immediate_signed_offset_unpriv (Rt, Rn, imm9, opc, size) = {
    wback : bool = false;
    let postindex : bool = false;
    let 'scale = UInt(size);
    let offset : bits(64) = SignExtend(imm9, 64);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let nontemporal : bool = false;
    memop : MemOp = undefined;
    is_signed : bool = undefined;
    regsize : {32, 64} = 32;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        is_signed = false
    } else {
        if size == 0b11 then {
            throw(Error_Undefined())
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            };
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            is_signed = true
        }
    };
    let 'regsize = regsize;
    let 'datasize = (8 << scale);
    let tagchecked : bool = memop != MemOp_PREFETCH & (wback | n != 31);
    wb_unknown : bool = false;
    rt_unknown : bool = false;
    c : Constraint = undefined;
    if ((memop == MemOp_LOAD & wback) & n == t) & n != 31 then {
        c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
        assert(c == Constraint_WBSUPPRESS | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_WBSUPPRESS => {
              wback = false
          },
          Constraint_UNKNOWN => {
              wb_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    if ((memop == MemOp_STORE & wback) & n == t) & n != 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
        assert(c == Constraint_NONE | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_NONE => {
              rt_unknown = false
          },
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    execute_aarch64_instrs_memory_single_general_immediate_signed_offset_unpriv(datasize, memop, n, nontemporal, offset, postindex, regsize, rt_unknown, is_signed, t, tagchecked, wb_unknown, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitone, _, bitzero, _, _, _, _, _, _, _, _, _, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 673) = {
    SEE = 673;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm9 = Slice(__opcode, 12, 9);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_ldtrsh_aarch64_instrs_memory_single_general_immediate_signed_offset_unpriv(Rt, Rn, imm9, opc, size)
}

val decode_ldtrsw_aarch64_instrs_memory_single_general_immediate_signed_offset_unpriv : (bits(5), bits(5), bits(9), bits(2), bits(2)) -> unit

function decode_ldtrsw_aarch64_instrs_memory_single_general_immediate_signed_offset_unpriv (Rt, Rn, imm9, opc, size) = {
    wback : bool = false;
    let postindex : bool = false;
    let 'scale = UInt(size);
    let offset : bits(64) = SignExtend(imm9, 64);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let nontemporal : bool = false;
    memop : MemOp = undefined;
    is_signed : bool = undefined;
    regsize : {32, 64} = 32;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        is_signed = false
    } else {
        if size == 0b11 then {
            throw(Error_Undefined())
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            };
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            is_signed = true
        }
    };
    let 'regsize = regsize;
    let 'datasize = (8 << scale);
    let tagchecked : bool = memop != MemOp_PREFETCH & (wback | n != 31);
    wb_unknown : bool = false;
    rt_unknown : bool = false;
    c : Constraint = undefined;
    if ((memop == MemOp_LOAD & wback) & n == t) & n != 31 then {
        c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
        assert(c == Constraint_WBSUPPRESS | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_WBSUPPRESS => {
              wback = false
          },
          Constraint_UNKNOWN => {
              wb_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    if ((memop == MemOp_STORE & wback) & n == t) & n != 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
        assert(c == Constraint_NONE | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_NONE => {
              rt_unknown = false
          },
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    execute_aarch64_instrs_memory_single_general_immediate_signed_offset_unpriv(datasize, memop, n, nontemporal, offset, postindex, regsize, rt_unknown, is_signed, t, tagchecked, wb_unknown, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([bitone, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 674) = {
    SEE = 674;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm9 = Slice(__opcode, 12, 9);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_ldtrsw_aarch64_instrs_memory_single_general_immediate_signed_offset_unpriv(Rt, Rn, imm9, opc, size)
}

val decode_sttr_aarch64_instrs_memory_single_general_immediate_signed_offset_unpriv : (bits(5), bits(5), bits(9), bits(2), bits(2)) -> unit

function decode_sttr_aarch64_instrs_memory_single_general_immediate_signed_offset_unpriv (Rt, Rn, imm9, opc, size) = {
    wback : bool = false;
    let postindex : bool = false;
    let 'scale = UInt(size);
    let offset : bits(64) = SignExtend(imm9, 64);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let nontemporal : bool = false;
    memop : MemOp = undefined;
    is_signed : bool = undefined;
    regsize : {32, 64} = 32;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        is_signed = false
    } else {
        if size == 0b11 then {
            throw(Error_Undefined())
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            };
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            is_signed = true
        }
    };
    let 'regsize = regsize;
    let 'datasize = (8 << scale);
    let tagchecked : bool = memop != MemOp_PREFETCH & (wback | n != 31);
    wb_unknown : bool = false;
    rt_unknown : bool = false;
    c : Constraint = undefined;
    if ((memop == MemOp_LOAD & wback) & n == t) & n != 31 then {
        c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
        assert(c == Constraint_WBSUPPRESS | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_WBSUPPRESS => {
              wback = false
          },
          Constraint_UNKNOWN => {
              wb_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    if ((memop == MemOp_STORE & wback) & n == t) & n != 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
        assert(c == Constraint_NONE | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_NONE => {
              rt_unknown = false
          },
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    execute_aarch64_instrs_memory_single_general_immediate_signed_offset_unpriv(datasize, memop, n, nontemporal, offset, postindex, regsize, rt_unknown, is_signed, t, tagchecked, wb_unknown, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([bitone, _, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 675) = {
    SEE = 675;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm9 = Slice(__opcode, 12, 9);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_sttr_aarch64_instrs_memory_single_general_immediate_signed_offset_unpriv(Rt, Rn, imm9, opc, size)
}

val decode_sttrb_aarch64_instrs_memory_single_general_immediate_signed_offset_unpriv : (bits(5), bits(5), bits(9), bits(2), bits(2)) -> unit

function decode_sttrb_aarch64_instrs_memory_single_general_immediate_signed_offset_unpriv (Rt, Rn, imm9, opc, size) = {
    wback : bool = false;
    let postindex : bool = false;
    let 'scale = UInt(size);
    let offset : bits(64) = SignExtend(imm9, 64);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let nontemporal : bool = false;
    memop : MemOp = undefined;
    is_signed : bool = undefined;
    regsize : {32, 64} = 32;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        is_signed = false
    } else {
        if size == 0b11 then {
            throw(Error_Undefined())
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            };
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            is_signed = true
        }
    };
    let 'regsize = regsize;
    let 'datasize = (8 << scale);
    let tagchecked : bool = memop != MemOp_PREFETCH & (wback | n != 31);
    wb_unknown : bool = false;
    rt_unknown : bool = false;
    c : Constraint = undefined;
    if ((memop == MemOp_LOAD & wback) & n == t) & n != 31 then {
        c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
        assert(c == Constraint_WBSUPPRESS | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_WBSUPPRESS => {
              wback = false
          },
          Constraint_UNKNOWN => {
              wb_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    if ((memop == MemOp_STORE & wback) & n == t) & n != 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
        assert(c == Constraint_NONE | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_NONE => {
              rt_unknown = false
          },
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    execute_aarch64_instrs_memory_single_general_immediate_signed_offset_unpriv(datasize, memop, n, nontemporal, offset, postindex, regsize, rt_unknown, is_signed, t, tagchecked, wb_unknown, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 676) = {
    SEE = 676;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm9 = Slice(__opcode, 12, 9);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_sttrb_aarch64_instrs_memory_single_general_immediate_signed_offset_unpriv(Rt, Rn, imm9, opc, size)
}

val decode_sttrh_aarch64_instrs_memory_single_general_immediate_signed_offset_unpriv : (bits(5), bits(5), bits(9), bits(2), bits(2)) -> unit

function decode_sttrh_aarch64_instrs_memory_single_general_immediate_signed_offset_unpriv (Rt, Rn, imm9, opc, size) = {
    wback : bool = false;
    let postindex : bool = false;
    let 'scale = UInt(size);
    let offset : bits(64) = SignExtend(imm9, 64);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let nontemporal : bool = false;
    memop : MemOp = undefined;
    is_signed : bool = undefined;
    regsize : {32, 64} = 32;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        is_signed = false
    } else {
        if size == 0b11 then {
            throw(Error_Undefined())
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            };
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            is_signed = true
        }
    };
    let 'regsize = regsize;
    let 'datasize = (8 << scale);
    let tagchecked : bool = memop != MemOp_PREFETCH & (wback | n != 31);
    wb_unknown : bool = false;
    rt_unknown : bool = false;
    c : Constraint = undefined;
    if ((memop == MemOp_LOAD & wback) & n == t) & n != 31 then {
        c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
        assert(c == Constraint_WBSUPPRESS | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_WBSUPPRESS => {
              wback = false
          },
          Constraint_UNKNOWN => {
              wb_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    if ((memop == MemOp_STORE & wback) & n == t) & n != 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
        assert(c == Constraint_NONE | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_NONE => {
              rt_unknown = false
          },
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    execute_aarch64_instrs_memory_single_general_immediate_signed_offset_unpriv(datasize, memop, n, nontemporal, offset, postindex, regsize, rt_unknown, is_signed, t, tagchecked, wb_unknown, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 677) = {
    SEE = 677;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm9 = Slice(__opcode, 12, 9);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_sttrh_aarch64_instrs_memory_single_general_immediate_signed_offset_unpriv(Rt, Rn, imm9, opc, size)
}

val execute_aarch64_instrs_memory_single_simdfp_immediate_signed_offset_normal : forall 'datasize 'n ('nontemporal : Bool) ('postindex : Bool) 't ('tagchecked : Bool) ('wback : Bool),
  (0 <= 't & 't <= 31 & 0 <= 'n & 'n <= 31 & 'datasize in {8, 16, 32, 64, 128, 256, 512, 1024}).
  (int('datasize), MemOp, int('n), bool('nontemporal), bits(64), bool('postindex), int('t), bool('tagchecked), bool('wback)) -> unit

function execute_aarch64_instrs_memory_single_simdfp_immediate_signed_offset_normal (datasize, memop, n, nontemporal, offset, postindex, t, tagchecked, wback) = {
    CheckFPEnabled64();
    address : bits(64) = undefined;
    data : bits('datasize) = undefined;
    let accdesc : AccessDescriptor = CreateAccDescASIMD(memop, nontemporal, tagchecked);
    if n == 31 then {
        CheckSPAlignment();
        address = SP_read()
    } else {
        address = X_read(n, 64)
    };
    if not_bool(postindex) then {
        address = address + offset
    };
    match memop {
      MemOp_STORE => {
          assert(constraint('datasize in {8, 16, 32, 64, 128}));
          let data : bits('datasize) = V_read(t, datasize);
          Mem_set(address, DIV(datasize, 8), accdesc) = data
      },
      MemOp_LOAD => {
          let data : bits('datasize) = Mem_read(address, DIV(datasize, 8), accdesc);
          assert(constraint('datasize in {8, 16, 32, 64, 128}));
          V_set(t, datasize) = data
      },
      _ => ()
    };
    if wback then {
        if postindex then {
            address = address + offset
        };
        if n == 31 then {
            SP_set() = address
        } else {
            X_set(n, 64) = address
        }
    };
    if SPESampleInFlight then {
        SPESampleSIMDFPLoadStore()
    };
    ()
}

val decode_ldur_fpsimd_aarch64_instrs_memory_single_simdfp_immediate_signed_offset_normal : (bits(5), bits(5), bits(9), bits(2), bits(2)) -> unit

function decode_ldur_fpsimd_aarch64_instrs_memory_single_simdfp_immediate_signed_offset_normal (Rt, Rn, imm9, opc, size) = {
    let wback : bool = false;
    let postindex : bool = false;
    let 'scale = UInt([opc[1]] @ size);
    if scale > 4 then {
        throw(Error_Undefined())
    };
    let offset : bits(64) = SignExtend(imm9, 64);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let nontemporal : bool = false;
    let memop : MemOp = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'datasize = (8 << scale);
    let tagchecked : bool = memop != MemOp_PREFETCH & (wback | n != 31);
    assert(constraint('datasize in {8, 16, 32, 64, 128, 256, 512, 1024}));
    execute_aarch64_instrs_memory_single_simdfp_immediate_signed_offset_normal(datasize, memop, n, nontemporal, offset, postindex, t, tagchecked, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([_, _, bitone, bitone, bitone, bitone, bitzero, bitzero, _, bitone, bitzero, _, _, _, _, _, _, _, _, _, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 678) = {
    SEE = 678;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm9 = Slice(__opcode, 12, 9);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_ldur_fpsimd_aarch64_instrs_memory_single_simdfp_immediate_signed_offset_normal(Rt, Rn, imm9, opc, size)
}

val decode_stur_fpsimd_aarch64_instrs_memory_single_simdfp_immediate_signed_offset_normal : (bits(5), bits(5), bits(9), bits(2), bits(2)) -> unit

function decode_stur_fpsimd_aarch64_instrs_memory_single_simdfp_immediate_signed_offset_normal (Rt, Rn, imm9, opc, size) = {
    let wback : bool = false;
    let postindex : bool = false;
    let 'scale = UInt([opc[1]] @ size);
    if scale > 4 then {
        throw(Error_Undefined())
    };
    let offset : bits(64) = SignExtend(imm9, 64);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let nontemporal : bool = false;
    let memop : MemOp = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'datasize = (8 << scale);
    let tagchecked : bool = memop != MemOp_PREFETCH & (wback | n != 31);
    assert(constraint('datasize in {8, 16, 32, 64, 128, 256, 512, 1024}));
    execute_aarch64_instrs_memory_single_simdfp_immediate_signed_offset_normal(datasize, memop, n, nontemporal, offset, postindex, t, tagchecked, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([_, _, bitone, bitone, bitone, bitone, bitzero, bitzero, _, bitzero, bitzero, _, _, _, _, _, _, _, _, _, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 679) = {
    SEE = 679;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm9 = Slice(__opcode, 12, 9);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_stur_fpsimd_aarch64_instrs_memory_single_simdfp_immediate_signed_offset_normal(Rt, Rn, imm9, opc, size)
}

val execute_aarch64_instrs_memory_single_general_immediate_signed_offset_normal : forall 'datasize ('is_signed : Bool) 'n ('nontemporal : Bool) ('postindex : Bool) 'regsize ('rt_unknown : Bool) 't ('tagchecked : Bool) ('wb_unknown : Bool) ('wback : Bool),
  (0 <= 't & 't <= 31 & 'regsize in {32, 64} & 0 <= 'n & 'n <= 31 & 'datasize in {8, 16, 32, 64}).
  (int('datasize), MemOp, int('n), bool('nontemporal), bits(64), bool('postindex), int('regsize), bool('rt_unknown), bool('is_signed), int('t), bool('tagchecked), bool('wb_unknown), bool('wback)) -> unit

function execute_aarch64_instrs_memory_single_general_immediate_signed_offset_normal (datasize, memop, n, nontemporal, offset, postindex, regsize, rt_unknown, is_signed, t, tagchecked, wb_unknown, wback) = {
    address : bits(64) = undefined;
    data : bits('datasize) = undefined;
    let privileged : bool = PSTATE.EL != EL0;
    let accdesc : AccessDescriptor = CreateAccDescGPR(memop, nontemporal, privileged, tagchecked);
    if n == 31 then {
        if memop != MemOp_PREFETCH then {
            CheckSPAlignment()
        };
        address = SP_read()
    } else {
        address = X_read(n, 64)
    };
    if not_bool(postindex) then {
        address = address + offset
    };
    match memop {
      MemOp_STORE => {
          if rt_unknown then {
              data = __UNKNOWN_bits(datasize)
          } else {
              data = X_read(t, datasize)
          };
          if not_bool(wback) then {
              AArch64_SetLSInstructionSyndrome(DIV(datasize, 8), false, t, regsize == 64, false)
          };
          Mem_set(address, DIV(datasize, 8), accdesc) = data
      },
      MemOp_LOAD => {
          if not_bool(wback) then {
              AArch64_SetLSInstructionSyndrome(DIV(datasize, 8), is_signed, t, regsize == 64, false)
          };
          let data : bits('datasize) = Mem_read(address, DIV(datasize, 8), accdesc);
          if is_signed then {
              assert(constraint(('datasize > 0 & 'regsize >= 'datasize)));
              X_set(t, regsize) = SignExtend(data, regsize)
          } else {
              assert(constraint(('datasize >= 0 & 'regsize >= 'datasize)));
              X_set(t, regsize) = ZeroExtend(data, regsize)
          }
      },
      MemOp_PREFETCH => {
          Prefetch(address, t[4 .. 0])
      }
    };
    if wback then {
        if wb_unknown then {
            address = __UNKNOWN_bits(64)
        } else if postindex then {
            address = address + offset
        } else ();
        if n == 31 then {
            SP_set() = address
        } else {
            X_set(n, 64) = address
        }
    };
    if SPESampleInFlight then {
        SPESampleGeneralPurposeLoadStore()
    };
    ()
}

val decode_ldur_gen_aarch64_instrs_memory_single_general_immediate_signed_offset_normal : (bits(5), bits(5), bits(9), bits(2), bits(2)) -> unit

function decode_ldur_gen_aarch64_instrs_memory_single_general_immediate_signed_offset_normal (Rt, Rn, imm9, opc, size) = {
    wback : bool = false;
    let postindex : bool = false;
    let 'scale = UInt(size);
    let offset : bits(64) = SignExtend(imm9, 64);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let nontemporal : bool = false;
    memop : MemOp = undefined;
    is_signed : bool = undefined;
    regsize : {32, 64} = 32;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        is_signed = false
    } else {
        if size == 0b11 then {
            memop = MemOp_PREFETCH;
            if [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            };
            ()
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            };
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            is_signed = true
        }
    };
    let 'regsize = regsize;
    let 'datasize = (8 << scale);
    let tagchecked : bool = memop != MemOp_PREFETCH & (wback | n != 31);
    wb_unknown : bool = false;
    rt_unknown : bool = false;
    c : Constraint = undefined;
    if ((memop == MemOp_LOAD & wback) & n == t) & n != 31 then {
        c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
        assert(c == Constraint_WBSUPPRESS | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_WBSUPPRESS => {
              wback = false
          },
          Constraint_UNKNOWN => {
              wb_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    if ((memop == MemOp_STORE & wback) & n == t) & n != 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
        assert(c == Constraint_NONE | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_NONE => {
              rt_unknown = false
          },
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    execute_aarch64_instrs_memory_single_general_immediate_signed_offset_normal(datasize, memop, n, nontemporal, offset, postindex, regsize, rt_unknown, is_signed, t, tagchecked, wb_unknown, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([bitone, _, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 680) = {
    SEE = 680;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm9 = Slice(__opcode, 12, 9);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_ldur_gen_aarch64_instrs_memory_single_general_immediate_signed_offset_normal(Rt, Rn, imm9, opc, size)
}

val decode_ldurb_aarch64_instrs_memory_single_general_immediate_signed_offset_normal : (bits(5), bits(5), bits(9), bits(2), bits(2)) -> unit

function decode_ldurb_aarch64_instrs_memory_single_general_immediate_signed_offset_normal (Rt, Rn, imm9, opc, size) = {
    wback : bool = false;
    let postindex : bool = false;
    let 'scale = UInt(size);
    let offset : bits(64) = SignExtend(imm9, 64);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let nontemporal : bool = false;
    memop : MemOp = undefined;
    is_signed : bool = undefined;
    regsize : {32, 64} = 32;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        is_signed = false
    } else {
        if size == 0b11 then {
            memop = MemOp_PREFETCH;
            if [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            };
            ()
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            };
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            is_signed = true
        }
    };
    let 'regsize = regsize;
    let 'datasize = (8 << scale);
    let tagchecked : bool = memop != MemOp_PREFETCH & (wback | n != 31);
    wb_unknown : bool = false;
    rt_unknown : bool = false;
    c : Constraint = undefined;
    if ((memop == MemOp_LOAD & wback) & n == t) & n != 31 then {
        c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
        assert(c == Constraint_WBSUPPRESS | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_WBSUPPRESS => {
              wback = false
          },
          Constraint_UNKNOWN => {
              wb_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    if ((memop == MemOp_STORE & wback) & n == t) & n != 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
        assert(c == Constraint_NONE | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_NONE => {
              rt_unknown = false
          },
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    execute_aarch64_instrs_memory_single_general_immediate_signed_offset_normal(datasize, memop, n, nontemporal, offset, postindex, regsize, rt_unknown, is_signed, t, tagchecked, wb_unknown, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 681) = {
    SEE = 681;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm9 = Slice(__opcode, 12, 9);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_ldurb_aarch64_instrs_memory_single_general_immediate_signed_offset_normal(Rt, Rn, imm9, opc, size)
}

val decode_ldurh_aarch64_instrs_memory_single_general_immediate_signed_offset_normal : (bits(5), bits(5), bits(9), bits(2), bits(2)) -> unit

function decode_ldurh_aarch64_instrs_memory_single_general_immediate_signed_offset_normal (Rt, Rn, imm9, opc, size) = {
    wback : bool = false;
    let postindex : bool = false;
    let 'scale = UInt(size);
    let offset : bits(64) = SignExtend(imm9, 64);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let nontemporal : bool = false;
    memop : MemOp = undefined;
    is_signed : bool = undefined;
    regsize : {32, 64} = 32;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        is_signed = false
    } else {
        if size == 0b11 then {
            memop = MemOp_PREFETCH;
            if [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            };
            ()
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            };
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            is_signed = true
        }
    };
    let 'regsize = regsize;
    let 'datasize = (8 << scale);
    let tagchecked : bool = memop != MemOp_PREFETCH & (wback | n != 31);
    wb_unknown : bool = false;
    rt_unknown : bool = false;
    c : Constraint = undefined;
    if ((memop == MemOp_LOAD & wback) & n == t) & n != 31 then {
        c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
        assert(c == Constraint_WBSUPPRESS | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_WBSUPPRESS => {
              wback = false
          },
          Constraint_UNKNOWN => {
              wb_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    if ((memop == MemOp_STORE & wback) & n == t) & n != 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
        assert(c == Constraint_NONE | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_NONE => {
              rt_unknown = false
          },
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    execute_aarch64_instrs_memory_single_general_immediate_signed_offset_normal(datasize, memop, n, nontemporal, offset, postindex, regsize, rt_unknown, is_signed, t, tagchecked, wb_unknown, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 682) = {
    SEE = 682;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm9 = Slice(__opcode, 12, 9);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_ldurh_aarch64_instrs_memory_single_general_immediate_signed_offset_normal(Rt, Rn, imm9, opc, size)
}

val decode_ldursb_aarch64_instrs_memory_single_general_immediate_signed_offset_normal : (bits(5), bits(5), bits(9), bits(2), bits(2)) -> unit

function decode_ldursb_aarch64_instrs_memory_single_general_immediate_signed_offset_normal (Rt, Rn, imm9, opc, size) = {
    wback : bool = false;
    let postindex : bool = false;
    let 'scale = UInt(size);
    let offset : bits(64) = SignExtend(imm9, 64);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let nontemporal : bool = false;
    memop : MemOp = undefined;
    is_signed : bool = undefined;
    regsize : {32, 64} = 32;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        is_signed = false
    } else {
        if size == 0b11 then {
            memop = MemOp_PREFETCH;
            if [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            };
            ()
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            };
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            is_signed = true
        }
    };
    let 'regsize = regsize;
    let 'datasize = (8 << scale);
    let tagchecked : bool = memop != MemOp_PREFETCH & (wback | n != 31);
    wb_unknown : bool = false;
    rt_unknown : bool = false;
    c : Constraint = undefined;
    if ((memop == MemOp_LOAD & wback) & n == t) & n != 31 then {
        c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
        assert(c == Constraint_WBSUPPRESS | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_WBSUPPRESS => {
              wback = false
          },
          Constraint_UNKNOWN => {
              wb_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    if ((memop == MemOp_STORE & wback) & n == t) & n != 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
        assert(c == Constraint_NONE | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_NONE => {
              rt_unknown = false
          },
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    execute_aarch64_instrs_memory_single_general_immediate_signed_offset_normal(datasize, memop, n, nontemporal, offset, postindex, regsize, rt_unknown, is_signed, t, tagchecked, wb_unknown, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitone, _, bitzero, _, _, _, _, _, _, _, _, _, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 683) = {
    SEE = 683;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm9 = Slice(__opcode, 12, 9);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_ldursb_aarch64_instrs_memory_single_general_immediate_signed_offset_normal(Rt, Rn, imm9, opc, size)
}

val decode_ldursh_aarch64_instrs_memory_single_general_immediate_signed_offset_normal : (bits(5), bits(5), bits(9), bits(2), bits(2)) -> unit

function decode_ldursh_aarch64_instrs_memory_single_general_immediate_signed_offset_normal (Rt, Rn, imm9, opc, size) = {
    wback : bool = false;
    let postindex : bool = false;
    let 'scale = UInt(size);
    let offset : bits(64) = SignExtend(imm9, 64);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let nontemporal : bool = false;
    memop : MemOp = undefined;
    is_signed : bool = undefined;
    regsize : {32, 64} = 32;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        is_signed = false
    } else {
        if size == 0b11 then {
            memop = MemOp_PREFETCH;
            if [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            };
            ()
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            };
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            is_signed = true
        }
    };
    let 'regsize = regsize;
    let 'datasize = (8 << scale);
    let tagchecked : bool = memop != MemOp_PREFETCH & (wback | n != 31);
    wb_unknown : bool = false;
    rt_unknown : bool = false;
    c : Constraint = undefined;
    if ((memop == MemOp_LOAD & wback) & n == t) & n != 31 then {
        c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
        assert(c == Constraint_WBSUPPRESS | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_WBSUPPRESS => {
              wback = false
          },
          Constraint_UNKNOWN => {
              wb_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    if ((memop == MemOp_STORE & wback) & n == t) & n != 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
        assert(c == Constraint_NONE | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_NONE => {
              rt_unknown = false
          },
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    execute_aarch64_instrs_memory_single_general_immediate_signed_offset_normal(datasize, memop, n, nontemporal, offset, postindex, regsize, rt_unknown, is_signed, t, tagchecked, wb_unknown, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitone, _, bitzero, _, _, _, _, _, _, _, _, _, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 684) = {
    SEE = 684;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm9 = Slice(__opcode, 12, 9);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_ldursh_aarch64_instrs_memory_single_general_immediate_signed_offset_normal(Rt, Rn, imm9, opc, size)
}

val decode_ldursw_aarch64_instrs_memory_single_general_immediate_signed_offset_normal : (bits(5), bits(5), bits(9), bits(2), bits(2)) -> unit

function decode_ldursw_aarch64_instrs_memory_single_general_immediate_signed_offset_normal (Rt, Rn, imm9, opc, size) = {
    wback : bool = false;
    let postindex : bool = false;
    let 'scale = UInt(size);
    let offset : bits(64) = SignExtend(imm9, 64);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let nontemporal : bool = false;
    memop : MemOp = undefined;
    is_signed : bool = undefined;
    regsize : {32, 64} = 32;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        is_signed = false
    } else {
        if size == 0b11 then {
            memop = MemOp_PREFETCH;
            if [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            };
            ()
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            };
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            is_signed = true
        }
    };
    let 'regsize = regsize;
    let 'datasize = (8 << scale);
    let tagchecked : bool = memop != MemOp_PREFETCH & (wback | n != 31);
    wb_unknown : bool = false;
    rt_unknown : bool = false;
    c : Constraint = undefined;
    if ((memop == MemOp_LOAD & wback) & n == t) & n != 31 then {
        c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
        assert(c == Constraint_WBSUPPRESS | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_WBSUPPRESS => {
              wback = false
          },
          Constraint_UNKNOWN => {
              wb_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    if ((memop == MemOp_STORE & wback) & n == t) & n != 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
        assert(c == Constraint_NONE | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_NONE => {
              rt_unknown = false
          },
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    execute_aarch64_instrs_memory_single_general_immediate_signed_offset_normal(datasize, memop, n, nontemporal, offset, postindex, regsize, rt_unknown, is_signed, t, tagchecked, wb_unknown, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([bitone, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 685) = {
    SEE = 685;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm9 = Slice(__opcode, 12, 9);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_ldursw_aarch64_instrs_memory_single_general_immediate_signed_offset_normal(Rt, Rn, imm9, opc, size)
}

val decode_prfum_aarch64_instrs_memory_single_general_immediate_signed_offset_normal : (bits(5), bits(5), bits(9), bits(2), bits(2)) -> unit

function decode_prfum_aarch64_instrs_memory_single_general_immediate_signed_offset_normal (Rt, Rn, imm9, opc, size) = {
    wback : bool = false;
    let postindex : bool = false;
    let 'scale = UInt(size);
    let offset : bits(64) = SignExtend(imm9, 64);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let nontemporal : bool = false;
    memop : MemOp = undefined;
    is_signed : bool = undefined;
    regsize : {32, 64} = 32;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        is_signed = false
    } else {
        if size == 0b11 then {
            memop = MemOp_PREFETCH;
            if [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            };
            ()
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            };
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            is_signed = true
        }
    };
    let 'regsize = regsize;
    let 'datasize = (8 << scale);
    let tagchecked : bool = memop != MemOp_PREFETCH & (wback | n != 31);
    wb_unknown : bool = false;
    rt_unknown : bool = false;
    c : Constraint = undefined;
    if ((memop == MemOp_LOAD & wback) & n == t) & n != 31 then {
        c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
        assert(c == Constraint_WBSUPPRESS | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_WBSUPPRESS => {
              wback = false
          },
          Constraint_UNKNOWN => {
              wb_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    if ((memop == MemOp_STORE & wback) & n == t) & n != 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
        assert(c == Constraint_NONE | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_NONE => {
              rt_unknown = false
          },
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    execute_aarch64_instrs_memory_single_general_immediate_signed_offset_normal(datasize, memop, n, nontemporal, offset, postindex, regsize, rt_unknown, is_signed, t, tagchecked, wb_unknown, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 686) = {
    SEE = 686;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm9 = Slice(__opcode, 12, 9);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_prfum_aarch64_instrs_memory_single_general_immediate_signed_offset_normal(Rt, Rn, imm9, opc, size)
}

val decode_stur_gen_aarch64_instrs_memory_single_general_immediate_signed_offset_normal : (bits(5), bits(5), bits(9), bits(2), bits(2)) -> unit

function decode_stur_gen_aarch64_instrs_memory_single_general_immediate_signed_offset_normal (Rt, Rn, imm9, opc, size) = {
    wback : bool = false;
    let postindex : bool = false;
    let 'scale = UInt(size);
    let offset : bits(64) = SignExtend(imm9, 64);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let nontemporal : bool = false;
    memop : MemOp = undefined;
    is_signed : bool = undefined;
    regsize : {32, 64} = 32;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        is_signed = false
    } else {
        if size == 0b11 then {
            memop = MemOp_PREFETCH;
            if [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            };
            ()
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            };
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            is_signed = true
        }
    };
    let 'regsize = regsize;
    let 'datasize = (8 << scale);
    let tagchecked : bool = memop != MemOp_PREFETCH & (wback | n != 31);
    wb_unknown : bool = false;
    rt_unknown : bool = false;
    c : Constraint = undefined;
    if ((memop == MemOp_LOAD & wback) & n == t) & n != 31 then {
        c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
        assert(c == Constraint_WBSUPPRESS | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_WBSUPPRESS => {
              wback = false
          },
          Constraint_UNKNOWN => {
              wb_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    if ((memop == MemOp_STORE & wback) & n == t) & n != 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
        assert(c == Constraint_NONE | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_NONE => {
              rt_unknown = false
          },
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    execute_aarch64_instrs_memory_single_general_immediate_signed_offset_normal(datasize, memop, n, nontemporal, offset, postindex, regsize, rt_unknown, is_signed, t, tagchecked, wb_unknown, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([bitone, _, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 687) = {
    SEE = 687;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm9 = Slice(__opcode, 12, 9);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_stur_gen_aarch64_instrs_memory_single_general_immediate_signed_offset_normal(Rt, Rn, imm9, opc, size)
}

val decode_sturb_aarch64_instrs_memory_single_general_immediate_signed_offset_normal : (bits(5), bits(5), bits(9), bits(2), bits(2)) -> unit

function decode_sturb_aarch64_instrs_memory_single_general_immediate_signed_offset_normal (Rt, Rn, imm9, opc, size) = {
    wback : bool = false;
    let postindex : bool = false;
    let 'scale = UInt(size);
    let offset : bits(64) = SignExtend(imm9, 64);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let nontemporal : bool = false;
    memop : MemOp = undefined;
    is_signed : bool = undefined;
    regsize : {32, 64} = 32;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        is_signed = false
    } else {
        if size == 0b11 then {
            memop = MemOp_PREFETCH;
            if [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            };
            ()
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            };
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            is_signed = true
        }
    };
    let 'regsize = regsize;
    let 'datasize = (8 << scale);
    let tagchecked : bool = memop != MemOp_PREFETCH & (wback | n != 31);
    wb_unknown : bool = false;
    rt_unknown : bool = false;
    c : Constraint = undefined;
    if ((memop == MemOp_LOAD & wback) & n == t) & n != 31 then {
        c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
        assert(c == Constraint_WBSUPPRESS | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_WBSUPPRESS => {
              wback = false
          },
          Constraint_UNKNOWN => {
              wb_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    if ((memop == MemOp_STORE & wback) & n == t) & n != 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
        assert(c == Constraint_NONE | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_NONE => {
              rt_unknown = false
          },
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    execute_aarch64_instrs_memory_single_general_immediate_signed_offset_normal(datasize, memop, n, nontemporal, offset, postindex, regsize, rt_unknown, is_signed, t, tagchecked, wb_unknown, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 688) = {
    SEE = 688;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm9 = Slice(__opcode, 12, 9);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_sturb_aarch64_instrs_memory_single_general_immediate_signed_offset_normal(Rt, Rn, imm9, opc, size)
}

val decode_sturh_aarch64_instrs_memory_single_general_immediate_signed_offset_normal : (bits(5), bits(5), bits(9), bits(2), bits(2)) -> unit

function decode_sturh_aarch64_instrs_memory_single_general_immediate_signed_offset_normal (Rt, Rn, imm9, opc, size) = {
    wback : bool = false;
    let postindex : bool = false;
    let 'scale = UInt(size);
    let offset : bits(64) = SignExtend(imm9, 64);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let nontemporal : bool = false;
    memop : MemOp = undefined;
    is_signed : bool = undefined;
    regsize : {32, 64} = 32;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        is_signed = false
    } else {
        if size == 0b11 then {
            memop = MemOp_PREFETCH;
            if [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            };
            ()
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            };
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            is_signed = true
        }
    };
    let 'regsize = regsize;
    let 'datasize = (8 << scale);
    let tagchecked : bool = memop != MemOp_PREFETCH & (wback | n != 31);
    wb_unknown : bool = false;
    rt_unknown : bool = false;
    c : Constraint = undefined;
    if ((memop == MemOp_LOAD & wback) & n == t) & n != 31 then {
        c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
        assert(c == Constraint_WBSUPPRESS | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_WBSUPPRESS => {
              wback = false
          },
          Constraint_UNKNOWN => {
              wb_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    if ((memop == MemOp_STORE & wback) & n == t) & n != 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
        assert(c == Constraint_NONE | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_NONE => {
              rt_unknown = false
          },
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    execute_aarch64_instrs_memory_single_general_immediate_signed_offset_normal(datasize, memop, n, nontemporal, offset, postindex, regsize, rt_unknown, is_signed, t, tagchecked, wb_unknown, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 689) = {
    SEE = 689;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm9 = Slice(__opcode, 12, 9);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_sturh_aarch64_instrs_memory_single_general_immediate_signed_offset_normal(Rt, Rn, imm9, opc, size)
}

val execute_aarch64_instrs_integer_arithmetic_mul_uniform_add_sub : forall 'a 'd 'datasize 'destsize 'm 'n ('sub_op : Bool),
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'destsize in {32, 64} & 'datasize in {32, 64} & 0 <= 'd & 'd <= 31 & 0 <= 'a & 'a <= 31).
  (int('a), int('d), int('datasize), int('destsize), int('m), int('n), bool('sub_op)) -> unit

function execute_aarch64_instrs_integer_arithmetic_mul_uniform_add_sub (a, d, datasize, destsize, m, n, sub_op) = {
    let operand1 : bits('datasize) = X_read(n, datasize);
    let operand2 : bits('datasize) = X_read(m, datasize);
    let operand3 : bits('destsize) = X_read(a, destsize);
    result : int = undefined;
    if sub_op then {
        result = UInt(operand3) - UInt(operand1) * UInt(operand2)
    } else {
        result = UInt(operand3) + UInt(operand1) * UInt(operand2)
    };
    let 'result = result;
    X_set(d, destsize) = result[destsize - 1 .. 0]
}

val decode_madd_aarch64_instrs_integer_arithmetic_mul_uniform_add_sub : (bits(5), bits(5), bits(5), bits(1), bits(5), bits(1)) -> unit

function decode_madd_aarch64_instrs_integer_arithmetic_mul_uniform_add_sub (Rd, Rn, Ra, o0, Rm, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'a = UInt(Ra);
    let 'destsize = if sf == 0b1 then 64 else 32;
    let 'datasize = destsize;
    let sub_op : bool = o0 == 0b1;
    execute_aarch64_instrs_integer_arithmetic_mul_uniform_add_sub(a, d, datasize, destsize, m, n, sub_op)
}

function clause __DecodeA64_DataProcReg ((pc, ([_, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitzero, _, _, _, _, _, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 690) = {
    SEE = 690;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Ra = Slice(__opcode, 10, 5);
    let o0 = Slice(__opcode, 15, 1);
    let Rm = Slice(__opcode, 16, 5);
    let sf = Slice(__opcode, 31, 1);
    decode_madd_aarch64_instrs_integer_arithmetic_mul_uniform_add_sub(Rd, Rn, Ra, o0, Rm, sf)
}

val decode_msub_aarch64_instrs_integer_arithmetic_mul_uniform_add_sub : (bits(5), bits(5), bits(5), bits(1), bits(5), bits(1)) -> unit

function decode_msub_aarch64_instrs_integer_arithmetic_mul_uniform_add_sub (Rd, Rn, Ra, o0, Rm, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'a = UInt(Ra);
    let 'destsize = if sf == 0b1 then 64 else 32;
    let 'datasize = destsize;
    let sub_op : bool = o0 == 0b1;
    execute_aarch64_instrs_integer_arithmetic_mul_uniform_add_sub(a, d, datasize, destsize, m, n, sub_op)
}

function clause __DecodeA64_DataProcReg ((pc, ([_, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitzero, _, _, _, _, _, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 691) = {
    SEE = 691;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Ra = Slice(__opcode, 10, 5);
    let o0 = Slice(__opcode, 15, 1);
    let Rm = Slice(__opcode, 16, 5);
    let sf = Slice(__opcode, 31, 1);
    decode_msub_aarch64_instrs_integer_arithmetic_mul_uniform_add_sub(Rd, Rn, Ra, o0, Rm, sf)
}

val execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_accum : forall 'd 'datasize 'elements 'esize 'm 'n ('sub_op : Bool),
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'esize in {8, 16, 32, 64} & 'datasize in {64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('m), int('n), bool('sub_op)) -> unit

function execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_accum (d, datasize, elements, esize, m, n, sub_op) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = V_read(n, datasize);
    let operand2 : bits('datasize) = V_read(m, datasize);
    let operand3 : bits('datasize) = V_read(d, datasize);
    result : bits('datasize) = undefined;
    element1 : bits('esize) = undefined;
    element2 : bits('esize) = undefined;
    product : bits('esize) = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element1 = Elem_read(operand1, e, esize);
        element2 = Elem_read(operand2, e, esize);
        product = (UInt(element1) * UInt(element2))[esize - 1 .. 0];
        if sub_op then {
            result = Elem_set(result, e, esize, Elem_read(operand3, e, esize) - product)
        } else {
            result = Elem_set(result, e, esize, Elem_read(operand3, e, esize) + product)
        }
    };
    V_set(d, datasize) = result
}

val decode_mla_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_accum : (bits(5), bits(5), bits(5), bits(2), bits(1), bits(1)) -> unit

function decode_mla_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_accum (Rd, Rn, Rm, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let sub_op : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_accum(d, datasize, elements, esize, m, n, sub_op)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitone, bitzero, bitzero, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 692) = {
    SEE = 692;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_mla_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_accum(Rd, Rn, Rm, size, U, Q)
}

val decode_mls_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_accum : (bits(5), bits(5), bits(5), bits(2), bits(1), bits(1)) -> unit

function decode_mls_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_accum (Rd, Rn, Rm, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let sub_op : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_accum(d, datasize, elements, esize, m, n, sub_op)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitone, bitzero, bitzero, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 693) = {
    SEE = 693;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_mls_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_accum(Rd, Rn, Rm, size, U, Q)
}

val execute_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_int : forall 'd 'datasize 'elements 'esize 'idxdsize 'index 'm 'n ('sub_op : Bool),
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'index in {0, 1, 2, 3, 4, 5, 6, 7} & 'idxdsize in {64, 128} & 'esize in {8, 16, 32, 64} & 'datasize in {64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('idxdsize), int('index), int('m), int('n), bool('sub_op)) -> unit

function execute_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_int (d, datasize, elements, esize, idxdsize, index, m, n, sub_op) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = V_read(n, datasize);
    let operand2 : bits('idxdsize) = V_read(m, idxdsize);
    let operand3 : bits('datasize) = V_read(d, datasize);
    result : bits('datasize) = undefined;
    element1 : int = undefined;
    product : bits('esize) = undefined;
    let 'element2 = UInt(Elem_read(operand2, index, esize));
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element1 = UInt(Elem_read(operand1, e, esize));
        product = (element1 * element2)[esize - 1 .. 0];
        if sub_op then {
            result = Elem_set(result, e, esize, Elem_read(operand3, e, esize) - product)
        } else {
            result = Elem_set(result, e, esize, Elem_read(operand3, e, esize) + product)
        }
    };
    V_set(d, datasize) = result
}

val decode_mla_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_int : (bits(5), bits(5), bits(1), bits(1), bits(4), bits(1), bits(1), bits(2), bits(1)) -> unit

function decode_mla_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_int (Rd, Rn, H, o2, Rm, M, L, size, Q) = {
    let 'idxdsize = if H == 0b1 then 128 else 64;
    index : range(0, 7) = undefined;
    Rmhi : bits(1) = undefined;
    match size {
      0b01 => {
          index = UInt((H @ L) @ M);
          Rmhi = 0b0
      },
      0b10 => {
          index = UInt(H @ L);
          Rmhi = M
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let Rmhi = Rmhi;
    let 'index = index;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rmhi @ Rm);
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let sub_op : bool = o2 == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_int(d, datasize, elements, esize, idxdsize, index, m, n, sub_op)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, bitzero, bitzero, bitzero, bitzero, _, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 694) = {
    SEE = 694;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let H = Slice(__opcode, 11, 1);
    let o2 = Slice(__opcode, 14, 1);
    let Rm = Slice(__opcode, 16, 4);
    let M = Slice(__opcode, 20, 1);
    let L = Slice(__opcode, 21, 1);
    let size = Slice(__opcode, 22, 2);
    let Q = Slice(__opcode, 30, 1);
    decode_mla_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_int(Rd, Rn, H, o2, Rm, M, L, size, Q)
}

val decode_mls_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_int : (bits(5), bits(5), bits(1), bits(1), bits(4), bits(1), bits(1), bits(2), bits(1)) -> unit

function decode_mls_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_int (Rd, Rn, H, o2, Rm, M, L, size, Q) = {
    let 'idxdsize = if H == 0b1 then 128 else 64;
    index : range(0, 7) = undefined;
    Rmhi : bits(1) = undefined;
    match size {
      0b01 => {
          index = UInt((H @ L) @ M);
          Rmhi = 0b0
      },
      0b10 => {
          index = UInt(H @ L);
          Rmhi = M
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let Rmhi = Rmhi;
    let 'index = index;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rmhi @ Rm);
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let sub_op : bool = o2 == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_int(d, datasize, elements, esize, idxdsize, index, m, n, sub_op)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, bitzero, bitone, bitzero, bitzero, _, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 695) = {
    SEE = 695;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let H = Slice(__opcode, 11, 1);
    let o2 = Slice(__opcode, 14, 1);
    let Rm = Slice(__opcode, 16, 4);
    let M = Slice(__opcode, 20, 1);
    let L = Slice(__opcode, 21, 1);
    let size = Slice(__opcode, 22, 2);
    let Q = Slice(__opcode, 30, 1);
    decode_mls_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_int(Rd, Rn, H, o2, Rm, M, L, size, Q)
}

val execute_aarch64_instrs_integer_ins_ext_insert_movewide : forall 'd 'datasize 'pos,
  (0 <= 'pos & 'pos <= 63 & 'datasize in {32, 64} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), bits(16), MoveWideOp, int('pos)) -> unit

function execute_aarch64_instrs_integer_ins_ext_insert_movewide (d, datasize, imm, opcode, pos) = {
    result : bits('datasize) = undefined;
    if opcode == MoveWideOp_K then {
        result = X_read(d, datasize)
    } else {
        result = Zeros(datasize)
    };
    assert(constraint('pos + 15 < 'datasize));
    result[pos + 15 .. pos] = imm;
    if opcode == MoveWideOp_N then {
        result = not_vec(result)
    };
    let result = result;
    X_set(d, datasize) = result
}

val decode_movk_aarch64_instrs_integer_ins_ext_insert_movewide : (bits(5), bits(16), bits(2), bits(2), bits(1)) -> unit

function decode_movk_aarch64_instrs_integer_ins_ext_insert_movewide (Rd, imm16, hw, opc, sf) = {
    let 'd = UInt(Rd);
    let 'datasize = if sf == 0b1 then 64 else 32;
    let imm : bits(16) = imm16;
    opcode : MoveWideOp = undefined;
    match opc {
      0b00 => {
          opcode = MoveWideOp_N
      },
      0b10 => {
          opcode = MoveWideOp_Z
      },
      0b11 => {
          opcode = MoveWideOp_K
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let opcode = opcode;
    if sf == 0b0 & [hw[1]] == 0b1 then {
        throw(Error_Undefined())
    };
    let 'pos = UInt(hw @ 0b0000);
    execute_aarch64_instrs_integer_ins_ext_insert_movewide(d, datasize, imm, opcode, pos)
}

function clause __DecodeA64_DataProcImm ((pc, ([_, bitone, bitone, bitone, bitzero, bitzero, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 696) = {
    SEE = 696;
    let Rd = Slice(__opcode, 0, 5);
    let imm16 = Slice(__opcode, 5, 16);
    let hw = Slice(__opcode, 21, 2);
    let opc = Slice(__opcode, 29, 2);
    let sf = Slice(__opcode, 31, 1);
    decode_movk_aarch64_instrs_integer_ins_ext_insert_movewide(Rd, imm16, hw, opc, sf)
}

val decode_movn_aarch64_instrs_integer_ins_ext_insert_movewide : (bits(5), bits(16), bits(2), bits(2), bits(1)) -> unit

function decode_movn_aarch64_instrs_integer_ins_ext_insert_movewide (Rd, imm16, hw, opc, sf) = {
    let 'd = UInt(Rd);
    let 'datasize = if sf == 0b1 then 64 else 32;
    let imm : bits(16) = imm16;
    opcode : MoveWideOp = undefined;
    match opc {
      0b00 => {
          opcode = MoveWideOp_N
      },
      0b10 => {
          opcode = MoveWideOp_Z
      },
      0b11 => {
          opcode = MoveWideOp_K
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let opcode = opcode;
    if sf == 0b0 & [hw[1]] == 0b1 then {
        throw(Error_Undefined())
    };
    let 'pos = UInt(hw @ 0b0000);
    execute_aarch64_instrs_integer_ins_ext_insert_movewide(d, datasize, imm, opcode, pos)
}

function clause __DecodeA64_DataProcImm ((pc, ([_, bitzero, bitzero, bitone, bitzero, bitzero, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 697) = {
    SEE = 697;
    let Rd = Slice(__opcode, 0, 5);
    let imm16 = Slice(__opcode, 5, 16);
    let hw = Slice(__opcode, 21, 2);
    let opc = Slice(__opcode, 29, 2);
    let sf = Slice(__opcode, 31, 1);
    decode_movn_aarch64_instrs_integer_ins_ext_insert_movewide(Rd, imm16, hw, opc, sf)
}

val decode_movz_aarch64_instrs_integer_ins_ext_insert_movewide : (bits(5), bits(16), bits(2), bits(2), bits(1)) -> unit

function decode_movz_aarch64_instrs_integer_ins_ext_insert_movewide (Rd, imm16, hw, opc, sf) = {
    let 'd = UInt(Rd);
    let 'datasize = if sf == 0b1 then 64 else 32;
    let imm : bits(16) = imm16;
    opcode : MoveWideOp = undefined;
    match opc {
      0b00 => {
          opcode = MoveWideOp_N
      },
      0b10 => {
          opcode = MoveWideOp_Z
      },
      0b11 => {
          opcode = MoveWideOp_K
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let opcode = opcode;
    if sf == 0b0 & [hw[1]] == 0b1 then {
        throw(Error_Undefined())
    };
    let 'pos = UInt(hw @ 0b0000);
    execute_aarch64_instrs_integer_ins_ext_insert_movewide(d, datasize, imm, opcode, pos)
}

function clause __DecodeA64_DataProcImm ((pc, ([_, bitone, bitzero, bitone, bitzero, bitzero, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 698) = {
    SEE = 698;
    let Rd = Slice(__opcode, 0, 5);
    let imm16 = Slice(__opcode, 5, 16);
    let hw = Slice(__opcode, 21, 2);
    let opc = Slice(__opcode, 29, 2);
    let sf = Slice(__opcode, 31, 1);
    decode_movz_aarch64_instrs_integer_ins_ext_insert_movewide(Rd, imm16, hw, opc, sf)
}

val execute_aarch64_instrs_system_register_system_128 : forall ('read : Bool) 'sys_crm 'sys_crn 'sys_op0 'sys_op1 'sys_op2 't 't2,
  (0 <= 't2 & 't2 <= 31 & 0 <= 't & 't <= 31 & 'sys_op2 in {0, 1, 2, 3, 4, 5, 6, 7} & 'sys_op1 in {0, 1, 2, 3, 4, 5, 6, 7} & 'sys_op0 in {2, 3} & 0 <= 'sys_crn & 'sys_crn <= 15 & 0 <= 'sys_crm & 'sys_crm <= 15).
  (bool('read), int('sys_crm), int('sys_crn), int('sys_op0), int('sys_op1), int('sys_op2), int('t), int('t2)) -> unit

function execute_aarch64_instrs_system_register_system_128 (read, sys_crm, sys_crn, sys_op0, sys_op1, sys_op2, t, t2) = {
    if read then {
        AArch64_SysRegRead128(sys_op0, sys_op1, sys_crn, sys_crm, sys_op2, t, t2)
    } else {
        AArch64_SysRegWrite128(sys_op0, sys_op1, sys_crn, sys_crm, sys_op2, t, t2)
    }
}

val decode_mrrs_aarch64_instrs_system_register_system_128 : (bits(5), bits(3), bits(4), bits(4), bits(3), bits(1), bits(1)) -> unit

function decode_mrrs_aarch64_instrs_system_register_system_128 (Rt, op2, CRm, CRn, op1, o0, L) = {
    if not_bool(HaveSysReg128()) then {
        throw(Error_Undefined())
    };
    if [Rt[0]] == 0b1 then {
        throw(Error_Undefined())
    };
    AArch64_CheckSystemAccess(0b1 @ o0, op1, CRn, CRm, op2, Rt, L);
    let 't = UInt(Rt);
    let 't2 = UInt(Rt + 1);
    let 'sys_op0 = 2 + UInt(o0);
    let 'sys_op1 = UInt(op1);
    let 'sys_op2 = UInt(op2);
    let 'sys_crn = UInt(CRn);
    let 'sys_crm = UInt(CRm);
    let read : bool = L == 0b1;
    execute_aarch64_instrs_system_register_system_128(read, sys_crm, sys_crn, sys_op0, sys_op1, sys_op2, t, t2)
}

function clause __DecodeA64_BranchExcSys ((pc, ([bitone, bitone, bitzero, bitone, bitzero, bitone, bitzero, bitone, bitzero, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 699) = {
    SEE = 699;
    let Rt = Slice(__opcode, 0, 5);
    let op2 = Slice(__opcode, 5, 3);
    let CRm = Slice(__opcode, 8, 4);
    let CRn = Slice(__opcode, 12, 4);
    let op1 = Slice(__opcode, 16, 3);
    let o0 = Slice(__opcode, 19, 1);
    let L = Slice(__opcode, 21, 1);
    decode_mrrs_aarch64_instrs_system_register_system_128(Rt, op2, CRm, CRn, op1, o0, L)
}

val decode_msrr_aarch64_instrs_system_register_system_128 : (bits(5), bits(3), bits(4), bits(4), bits(3), bits(1), bits(1)) -> unit

function decode_msrr_aarch64_instrs_system_register_system_128 (Rt, op2, CRm, CRn, op1, o0, L) = {
    if not_bool(HaveSysReg128()) then {
        throw(Error_Undefined())
    };
    if [Rt[0]] == 0b1 then {
        throw(Error_Undefined())
    };
    AArch64_CheckSystemAccess(0b1 @ o0, op1, CRn, CRm, op2, Rt, L);
    let 't = UInt(Rt);
    let 't2 = UInt(Rt + 1);
    let 'sys_op0 = 2 + UInt(o0);
    let 'sys_op1 = UInt(op1);
    let 'sys_op2 = UInt(op2);
    let 'sys_crn = UInt(CRn);
    let 'sys_crm = UInt(CRm);
    let read : bool = L == 0b1;
    execute_aarch64_instrs_system_register_system_128(read, sys_crm, sys_crn, sys_op0, sys_op1, sys_op2, t, t2)
}

function clause __DecodeA64_BranchExcSys ((pc, ([bitone, bitone, bitzero, bitone, bitzero, bitone, bitzero, bitone, bitzero, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 700) = {
    SEE = 700;
    let Rt = Slice(__opcode, 0, 5);
    let op2 = Slice(__opcode, 5, 3);
    let CRm = Slice(__opcode, 8, 4);
    let CRn = Slice(__opcode, 12, 4);
    let op1 = Slice(__opcode, 16, 3);
    let o0 = Slice(__opcode, 19, 1);
    let L = Slice(__opcode, 21, 1);
    decode_msrr_aarch64_instrs_system_register_system_128(Rt, op2, CRm, CRn, op1, o0, L)
}

val execute_aarch64_instrs_system_register_system : forall ('read : Bool) 'sys_crm 'sys_crn 'sys_op0 'sys_op1 'sys_op2 't,
  (0 <= 't & 't <= 31 & 'sys_op2 in {0, 1, 2, 3, 4, 5, 6, 7} & 'sys_op1 in {0, 1, 2, 3, 4, 5, 6, 7} & 'sys_op0 in {2, 3} & 0 <= 'sys_crn & 'sys_crn <= 15 & 0 <= 'sys_crm & 'sys_crm <= 15).
  (bool('read), int('sys_crm), int('sys_crn), int('sys_op0), int('sys_op1), int('sys_op2), int('t)) -> unit

function execute_aarch64_instrs_system_register_system (read, sys_crm, sys_crn, sys_op0, sys_op1, sys_op2, t) = {
    if read then {
        AArch64_SysRegRead(sys_op0, sys_op1, sys_crn, sys_crm, sys_op2, t)
    } else {
        AArch64_SysRegWrite(sys_op0, sys_op1, sys_crn, sys_crm, sys_op2, t)
    }
}

val decode_mrs_aarch64_instrs_system_register_system : (bits(5), bits(3), bits(4), bits(4), bits(3), bits(1), bits(1)) -> unit

function decode_mrs_aarch64_instrs_system_register_system (Rt, op2, CRm, CRn, op1, o0, L) = {
    AArch64_CheckSystemAccess(0b1 @ o0, op1, CRn, CRm, op2, Rt, L);
    let 't = UInt(Rt);
    let 'sys_op0 = 2 + UInt(o0);
    let 'sys_op1 = UInt(op1);
    let 'sys_op2 = UInt(op2);
    let 'sys_crn = UInt(CRn);
    let 'sys_crm = UInt(CRm);
    let read : bool = L == 0b1;
    execute_aarch64_instrs_system_register_system(read, sys_crm, sys_crn, sys_op0, sys_op1, sys_op2, t)
}

function clause __DecodeA64_BranchExcSys ((pc, ([bitone, bitone, bitzero, bitone, bitzero, bitone, bitzero, bitone, bitzero, bitzero, bitone, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 701) = {
    SEE = 701;
    let Rt = Slice(__opcode, 0, 5);
    let op2 = Slice(__opcode, 5, 3);
    let CRm = Slice(__opcode, 8, 4);
    let CRn = Slice(__opcode, 12, 4);
    let op1 = Slice(__opcode, 16, 3);
    let o0 = Slice(__opcode, 19, 1);
    let L = Slice(__opcode, 21, 1);
    decode_mrs_aarch64_instrs_system_register_system(Rt, op2, CRm, CRn, op1, o0, L)
}

val decode_msr_reg_aarch64_instrs_system_register_system : (bits(5), bits(3), bits(4), bits(4), bits(3), bits(1), bits(1)) -> unit

function decode_msr_reg_aarch64_instrs_system_register_system (Rt, op2, CRm, CRn, op1, o0, L) = {
    AArch64_CheckSystemAccess(0b1 @ o0, op1, CRn, CRm, op2, Rt, L);
    let 't = UInt(Rt);
    let 'sys_op0 = 2 + UInt(o0);
    let 'sys_op1 = UInt(op1);
    let 'sys_op2 = UInt(op2);
    let 'sys_crn = UInt(CRn);
    let 'sys_crm = UInt(CRm);
    let read : bool = L == 0b1;
    execute_aarch64_instrs_system_register_system(read, sys_crm, sys_crn, sys_op0, sys_op1, sys_op2, t)
}

function clause __DecodeA64_BranchExcSys ((pc, ([bitone, bitone, bitzero, bitone, bitzero, bitone, bitzero, bitone, bitzero, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 702) = {
    SEE = 702;
    let Rt = Slice(__opcode, 0, 5);
    let op2 = Slice(__opcode, 5, 3);
    let CRm = Slice(__opcode, 8, 4);
    let CRn = Slice(__opcode, 12, 4);
    let op1 = Slice(__opcode, 16, 3);
    let o0 = Slice(__opcode, 19, 1);
    let L = Slice(__opcode, 21, 1);
    decode_msr_reg_aarch64_instrs_system_register_system(Rt, op2, CRm, CRn, op1, o0, L)
}

val execute_aarch64_instrs_system_register_cpsr : (PSTATEField, bits(4)) -> unit

function execute_aarch64_instrs_system_register_cpsr (field, operand) = {
    match field {
      PSTATEField_SSBS => {
          PSTATE.SSBS = [operand[0]]
      },
      PSTATEField_SP => {
          PSTATE.SP = [operand[0]]
      },
      PSTATEField_DAIFSet => {
          PSTATE.D = PSTATE.D | [operand[3]];
          PSTATE.A = PSTATE.A | [operand[2]];
          PSTATE.I = PSTATE.I | [operand[1]];
          PSTATE.F = PSTATE.F | [operand[0]]
      },
      PSTATEField_DAIFClr => {
          PSTATE.D = PSTATE.D & not_vec([operand[3]]);
          PSTATE.A = PSTATE.A & not_vec([operand[2]]);
          PSTATE.I = PSTATE.I & not_vec([operand[1]]);
          PSTATE.F = PSTATE.F & not_vec([operand[0]])
      },
      PSTATEField_PAN => {
          PSTATE.PAN = [operand[0]]
      },
      PSTATEField_UAO => {
          PSTATE.UAO = [operand[0]]
      },
      PSTATEField_DIT => {
          PSTATE.DIT = [operand[0]]
      },
      PSTATEField_TCO => {
          PSTATE.TCO = [operand[0]]
      },
      PSTATEField_ALLINT => {
          if ((PSTATE.EL == EL1 & IsHCRXEL2Enabled()) & HCRX_EL2[TALLINT] == 0b1) & [operand[0]] == 0b1 then {
              AArch64_SystemAccessTrap(EL2, UInt(0x18))
          };
          PSTATE.ALLINT = [operand[0]]
      },
      PSTATEField_SVCRSM => {
          CheckSMEAccess();
          SetPSTATE_SM([operand[0]])
      },
      PSTATEField_SVCRZA => {
          CheckSMEAccess();
          SetPSTATE_ZA([operand[0]])
      },
      PSTATEField_SVCRSMZA => {
          CheckSMEAccess();
          SetPSTATE_SM([operand[0]]);
          SetPSTATE_ZA([operand[0]])
      },
      PSTATEField_PM => {
          PSTATE.PM = [operand[0]]
      }
    }
}

val decode_msr_imm_aarch64_instrs_system_register_cpsr : (bits(3), bits(4), bits(3)) -> unit

function decode_msr_imm_aarch64_instrs_system_register_cpsr (op2, CRm, op1) = {
    if op1 == 0b000 & op2 == 0b000 then {
        throw(Error_See("CFINV"))
    };
    if op1 == 0b000 & op2 == 0b001 then {
        throw(Error_See("XAFLAG"))
    };
    if op1 == 0b000 & op2 == 0b010 then {
        throw(Error_See("AXFLAG"))
    };
    AArch64_CheckSystemAccess(0b00, op1, 0b0100, CRm, op2, 0b11111, 0b0);
    min_EL : bits(2) = undefined;
    need_secure : bool = false;
    match op1 {
      [bitzero, bitzero, _] => {
          min_EL = EL1
      },
      0b010 => {
          min_EL = EL1
      },
      0b011 => {
          min_EL = EL0
      },
      0b100 => {
          min_EL = EL2
      },
      0b101 => {
          if not_bool(HaveVirtHostExt()) then {
              throw(Error_Undefined())
          };
          min_EL = EL2
      },
      0b110 => {
          min_EL = EL3
      },
      0b111 => {
          min_EL = EL1;
          need_secure = true
      }
    };
    let min_EL = min_EL;
    if UInt(PSTATE.EL) < UInt(min_EL) | need_secure & CurrentSecurityState() != SS_Secure then {
        throw(Error_Undefined())
    };
    let operand : bits(4) = CRm;
    field : PSTATEField = undefined;
    match op1 @ op2 {
      0b000011 => {
          if not_bool(HaveUAOExt()) then {
              throw(Error_Undefined())
          };
          field = PSTATEField_UAO
      },
      0b000100 => {
          if not_bool(HavePANExt()) then {
              throw(Error_Undefined())
          };
          field = PSTATEField_PAN
      },
      0b000101 => {
          field = PSTATEField_SP
      },
      0b001000 => {
          match CRm {
            [bitzero, bitzero, bitzero, _] => {
                if not_bool(HaveFeatNMI()) then {
                    throw(Error_Undefined())
                };
                field = PSTATEField_ALLINT
            },
            [bitzero, bitzero, bitone, _] => {
                if not_bool(HaveFeatEBEP()) then {
                    throw(Error_Undefined())
                };
                field = PSTATEField_PM
            },
            _ => {
                throw(Error_Undefined())
            }
          }
      },
      0b011010 => {
          if not_bool(HaveDITExt()) then {
              throw(Error_Undefined())
          };
          field = PSTATEField_DIT
      },
      0b011011 => {
          match CRm {
            [bitzero, bitzero, bitone, _] => {
                if not_bool(HaveSME()) then {
                    throw(Error_Undefined())
                };
                field = PSTATEField_SVCRSM
            },
            [bitzero, bitone, bitzero, _] => {
                if not_bool(HaveSME()) then {
                    throw(Error_Undefined())
                };
                field = PSTATEField_SVCRZA
            },
            [bitzero, bitone, bitone, _] => {
                if not_bool(HaveSME()) then {
                    throw(Error_Undefined())
                };
                field = PSTATEField_SVCRSMZA
            },
            _ => {
                throw(Error_Undefined())
            }
          }
      },
      0b011100 => {
          if not_bool(HaveMTEExt()) then {
              throw(Error_Undefined())
          };
          field = PSTATEField_TCO
      },
      0b011110 => {
          field = PSTATEField_DAIFSet
      },
      0b011111 => {
          field = PSTATEField_DAIFClr
      },
      0b011001 => {
          if not_bool(HaveSSBSExt()) then {
              throw(Error_Undefined())
          };
          field = PSTATEField_SSBS
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    if PSTATE.EL == EL0 & (field == PSTATEField_DAIFSet | field == PSTATEField_DAIFClr) then {
        if IsInHost() | SCTLR_EL1[UMA] == 0b0 then {
            if EL2Enabled() & HCR_EL2[TGE] == 0b1 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            }
        };
        ()
    };
    execute_aarch64_instrs_system_register_cpsr(field, operand)
}

function clause __DecodeA64_BranchExcSys ((pc, ([bitone, bitone, bitzero, bitone, bitzero, bitone, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, _, _, bitone, bitone, bitone, bitone, bitone] as __opcode)) if SEE < 703) = {
    SEE = 703;
    let op2 = Slice(__opcode, 5, 3);
    let CRm = Slice(__opcode, 8, 4);
    let op1 = Slice(__opcode, 16, 3);
    decode_msr_imm_aarch64_instrs_system_register_cpsr(op2, CRm, op1)
}

val execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_product : forall 'd 'datasize 'elements 'esize 'm 'n ('poly : Bool),
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'esize in {8, 16, 32, 64} & 'datasize in {64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('m), int('n), bool('poly)) -> unit

function execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_product (d, datasize, elements, esize, m, n, poly) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = V_read(n, datasize);
    let operand2 : bits('datasize) = V_read(m, datasize);
    result : bits('datasize) = undefined;
    element1 : bits('esize) = undefined;
    element2 : bits('esize) = undefined;
    product : bits('esize) = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element1 = Elem_read(operand1, e, esize);
        element2 = Elem_read(operand2, e, esize);
        if poly then {
            product = PolynomialMult(element1, element2)[esize - 1 .. 0]
        } else {
            product = (UInt(element1) * UInt(element2))[esize - 1 .. 0]
        };
        result = Elem_set(result, e, esize, product)
    };
    V_set(d, datasize) = result
}

val decode_mul_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_product : (bits(5), bits(5), bits(5), bits(2), bits(1), bits(1)) -> unit

function decode_mul_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_product (Rd, Rn, Rm, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if U == 0b1 & size != 0b00 then {
        throw(Error_Undefined())
    };
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let poly : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_product(d, datasize, elements, esize, m, n, poly)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitone, bitzero, bitzero, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 704) = {
    SEE = 704;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_mul_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_product(Rd, Rn, Rm, size, U, Q)
}

val decode_pmul_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_product : (bits(5), bits(5), bits(5), bits(2), bits(1), bits(1)) -> unit

function decode_pmul_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_product (Rd, Rn, Rm, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if U == 0b1 & size != 0b00 then {
        throw(Error_Undefined())
    };
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let poly : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_product(d, datasize, elements, esize, m, n, poly)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitone, bitzero, bitzero, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 705) = {
    SEE = 705;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_pmul_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_product(Rd, Rn, Rm, size, U, Q)
}

val execute_aarch64_instrs_vector_arithmetic_binary_element_mul_int : forall 'd 'datasize 'elements 'esize 'idxdsize 'index 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'index in {0, 1, 2, 3, 4, 5, 6, 7} & 'idxdsize in {64, 128} & 'esize in {8, 16, 32, 64} & 'datasize in {64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('idxdsize), int('index), int('m), int('n)) -> unit

function execute_aarch64_instrs_vector_arithmetic_binary_element_mul_int (d, datasize, elements, esize, idxdsize, index, m, n) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = V_read(n, datasize);
    let operand2 : bits('idxdsize) = V_read(m, idxdsize);
    result : bits('datasize) = undefined;
    element1 : int = undefined;
    product : bits('esize) = undefined;
    let 'element2 = UInt(Elem_read(operand2, index, esize));
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element1 = UInt(Elem_read(operand1, e, esize));
        product = (element1 * element2)[esize - 1 .. 0];
        result = Elem_set(result, e, esize, product)
    };
    V_set(d, datasize) = result
}

val decode_mul_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_int : (bits(5), bits(5), bits(1), bits(4), bits(1), bits(1), bits(2), bits(1)) -> unit

function decode_mul_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_int (Rd, Rn, H, Rm, M, L, size, Q) = {
    let 'idxdsize = if H == 0b1 then 128 else 64;
    index : range(0, 7) = undefined;
    Rmhi : bits(1) = undefined;
    match size {
      0b01 => {
          index = UInt((H @ L) @ M);
          Rmhi = 0b0
      },
      0b10 => {
          index = UInt(H @ L);
          Rmhi = M
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let Rmhi = Rmhi;
    let 'index = index;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rmhi @ Rm);
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    execute_aarch64_instrs_vector_arithmetic_binary_element_mul_int(d, datasize, elements, esize, idxdsize, index, m, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, bitone, bitzero, bitzero, bitzero, _, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 706) = {
    SEE = 706;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let H = Slice(__opcode, 11, 1);
    let Rm = Slice(__opcode, 16, 4);
    let M = Slice(__opcode, 20, 1);
    let L = Slice(__opcode, 21, 1);
    let size = Slice(__opcode, 22, 2);
    let Q = Slice(__opcode, 30, 1);
    decode_mul_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_int(Rd, Rn, H, Rm, M, L, size, Q)
}

val execute_aarch64_instrs_vector_arithmetic_unary_not : forall 'd 'datasize 'elements 'esize 'n,
  (0 <= 'n & 'n <= 31 & 'esize == 8 & 'elements in {8, 16} & 'datasize in {64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('n)) -> unit

function execute_aarch64_instrs_vector_arithmetic_unary_not (d, datasize, elements, esize, n) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('datasize) = V_read(n, datasize);
    result : bits('datasize) = undefined;
    element : bits('esize) = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element = Elem_read(operand, e, esize);
        result = Elem_set(result, e, esize, not_vec(element))
    };
    V_set(d, datasize) = result
}

val decode_not_advsimd_aarch64_instrs_vector_arithmetic_unary_not : (bits(5), bits(5), bits(1)) -> unit

function decode_not_advsimd_aarch64_instrs_vector_arithmetic_unary_not (Rd, Rn, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = 8;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, 8);
    execute_aarch64_instrs_vector_arithmetic_unary_not(d, datasize, elements, esize, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 707) = {
    SEE = 707;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Q = Slice(__opcode, 30, 1);
    decode_not_advsimd_aarch64_instrs_vector_arithmetic_unary_not(Rd, Rn, Q)
}

val execute_aarch64_instrs_integer_pac_pacda_dp_1src : forall 'd 'n ('source_is_sp : Bool),
  (0 <= 'n & 'n <= 31 & 0 <= 'd & 'd <= 31).
  (int('d), int('n), bool('source_is_sp)) -> unit

function execute_aarch64_instrs_integer_pac_pacda_dp_1src (d, n, source_is_sp) = {
    if source_is_sp then {
        X_set(d, 64) = AddPACDA(X_read(d, 64), SP_read())
    } else {
        X_set(d, 64) = AddPACDA(X_read(d, 64), X_read(n, 64))
    }
}

val decode_pacda_aarch64_instrs_integer_pac_pacda_dp_1src : (bits(5), bits(5), bits(1)) -> unit

function decode_pacda_aarch64_instrs_integer_pac_pacda_dp_1src (Rd, Rn, Z) = {
    source_is_sp : bool = false;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if not_bool(HavePACExt()) then {
        throw(Error_Undefined())
    };
    if Z == 0b0 then {
        if n == 31 then {
            source_is_sp = true
        };
        ()
    } else {
        if n != 31 then {
            throw(Error_Undefined())
        };
        ()
    };
    execute_aarch64_instrs_integer_pac_pacda_dp_1src(d, n, source_is_sp)
}

function clause __DecodeA64_DataProcReg ((pc, ([bitone, bitone, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, _, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 708) = {
    SEE = 708;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Z = Slice(__opcode, 13, 1);
    decode_pacda_aarch64_instrs_integer_pac_pacda_dp_1src(Rd, Rn, Z)
}

val execute_aarch64_instrs_integer_pac_pacdb_dp_1src : forall 'd 'n ('source_is_sp : Bool),
  (0 <= 'n & 'n <= 31 & 0 <= 'd & 'd <= 31).
  (int('d), int('n), bool('source_is_sp)) -> unit

function execute_aarch64_instrs_integer_pac_pacdb_dp_1src (d, n, source_is_sp) = {
    if source_is_sp then {
        X_set(d, 64) = AddPACDB(X_read(d, 64), SP_read())
    } else {
        X_set(d, 64) = AddPACDB(X_read(d, 64), X_read(n, 64))
    }
}

val decode_pacdb_aarch64_instrs_integer_pac_pacdb_dp_1src : (bits(5), bits(5), bits(1)) -> unit

function decode_pacdb_aarch64_instrs_integer_pac_pacdb_dp_1src (Rd, Rn, Z) = {
    source_is_sp : bool = false;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if not_bool(HavePACExt()) then {
        throw(Error_Undefined())
    };
    if Z == 0b0 then {
        if n == 31 then {
            source_is_sp = true
        };
        ()
    } else {
        if n != 31 then {
            throw(Error_Undefined())
        };
        ()
    };
    execute_aarch64_instrs_integer_pac_pacdb_dp_1src(d, n, source_is_sp)
}

function clause __DecodeA64_DataProcReg ((pc, ([bitone, bitone, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, _, bitzero, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 709) = {
    SEE = 709;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Z = Slice(__opcode, 13, 1);
    decode_pacdb_aarch64_instrs_integer_pac_pacdb_dp_1src(Rd, Rn, Z)
}

val execute_aarch64_instrs_integer_pac_pacga_dp_2src : forall 'd 'm 'n ('source_is_sp : Bool),
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 0 <= 'd & 'd <= 31).
  (int('d), int('m), int('n), bool('source_is_sp)) -> unit

function execute_aarch64_instrs_integer_pac_pacga_dp_2src (d, m, n, source_is_sp) = {
    if source_is_sp then {
        X_set(d, 64) = AddPACGA(X_read(n, 64), SP_read())
    } else {
        X_set(d, 64) = AddPACGA(X_read(n, 64), X_read(m, 64))
    }
}

val decode_pacga_aarch64_instrs_integer_pac_pacga_dp_2src : (bits(5), bits(5), bits(5)) -> unit

function decode_pacga_aarch64_instrs_integer_pac_pacga_dp_2src (Rd, Rn, Rm) = {
    source_is_sp : bool = false;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if not_bool(HavePACExt()) then {
        throw(Error_Undefined())
    };
    if m == 31 then {
        source_is_sp = true
    };
    execute_aarch64_instrs_integer_pac_pacga_dp_2src(d, m, n, source_is_sp)
}

function clause __DecodeA64_DataProcReg ((pc, ([bitone, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, bitzero, bitzero, bitone, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 710) = {
    SEE = 710;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    decode_pacga_aarch64_instrs_integer_pac_pacga_dp_2src(Rd, Rn, Rm)
}

val execute_aarch64_instrs_integer_pac_pacia_dp_1src : forall 'd 'n ('source_is_sp : Bool),
  (0 <= 'n & 'n <= 31 & 0 <= 'd & 'd <= 31).
  (int('d), int('n), bool('source_is_sp)) -> unit

function execute_aarch64_instrs_integer_pac_pacia_dp_1src (d, n, source_is_sp) = {
    if HavePACExt() then {
        if source_is_sp then {
            X_set(d, 64) = AddPACIA(X_read(d, 64), SP_read())
        } else {
            X_set(d, 64) = AddPACIA(X_read(d, 64), X_read(n, 64))
        }
    };
    ()
}

val decode_pacia_aarch64_instrs_integer_pac_pacia_dp_1src : (bits(5), bits(5), bits(1)) -> unit

function decode_pacia_aarch64_instrs_integer_pac_pacia_dp_1src (Rd, Rn, Z) = {
    source_is_sp : bool = false;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if not_bool(HavePACExt()) then {
        throw(Error_Undefined())
    };
    if Z == 0b0 then {
        if n == 31 then {
            source_is_sp = true
        };
        ()
    } else {
        if n != 31 then {
            throw(Error_Undefined())
        };
        ()
    };
    execute_aarch64_instrs_integer_pac_pacia_dp_1src(d, n, source_is_sp)
}

function clause __DecodeA64_DataProcReg ((pc, ([bitone, bitone, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, _, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 711) = {
    SEE = 711;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Z = Slice(__opcode, 13, 1);
    decode_pacia_aarch64_instrs_integer_pac_pacia_dp_1src(Rd, Rn, Z)
}

val decode_pacia_aarch64_instrs_integer_pac_pacia_hint : (bits(3), bits(4)) -> unit

function decode_pacia_aarch64_instrs_integer_pac_pacia_hint (op2, CRm) = {
    d : {17, 30} = 17;
    n : int = undefined;
    source_is_sp : bool = false;
    match CRm @ op2 {
      0b0011000 => {
          d = 30;
          n = 31
      },
      0b0011001 => {
          d = 30;
          source_is_sp = true;
          if HaveBTIExt() then {
              SetBTypeCompatible(BTypeCompatible_PACIXSP())
          };
          ()
      },
      0b0001000 => {
          d = 17;
          n = 16
      },
      0b0001010 => {
          throw(Error_See("PACIB"))
      },
      0b0001100 => {
          throw(Error_See("AUTIA"))
      },
      0b0001110 => {
          throw(Error_See("AUTIB"))
      },
      [bitzero, bitzero, bitone, bitone, bitzero, bitone, _] => {
          throw(Error_See("PACIB"))
      },
      [bitzero, bitzero, bitone, bitone, bitone, bitzero, _] => {
          throw(Error_See("AUTIA"))
      },
      [bitzero, bitzero, bitone, bitone, bitone, bitone, _] => {
          throw(Error_See("AUTIB"))
      },
      0b0000111 => {
          throw(Error_See("XPACLRI"))
      },
      _ => {
          throw(Error_See("HINT"))
      }
    };
    let 'n = n;
    let 'd = d;
    assert(constraint((0 <= 'n & 'n <= 31)));
    execute_aarch64_instrs_integer_pac_pacia_dp_1src(d, n, source_is_sp)
}

function clause __DecodeA64_BranchExcSys ((pc, ([bitone, bitone, bitzero, bitone, bitzero, bitone, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, _, bitone, bitzero, bitzero, _, bitone, bitone, bitone, bitone, bitone] as __opcode)) if SEE < 712) = {
    SEE = 712;
    let op2 = Slice(__opcode, 5, 3);
    let CRm = Slice(__opcode, 8, 4);
    decode_pacia_aarch64_instrs_integer_pac_pacia_hint(op2, CRm)
}

val execute_aarch64_instrs_integer_pac_pacib_dp_1src : forall 'd 'n ('source_is_sp : Bool),
  (0 <= 'n & 'n <= 31 & 0 <= 'd & 'd <= 31).
  (int('d), int('n), bool('source_is_sp)) -> unit

function execute_aarch64_instrs_integer_pac_pacib_dp_1src (d, n, source_is_sp) = {
    if HavePACExt() then {
        if source_is_sp then {
            X_set(d, 64) = AddPACIB(X_read(d, 64), SP_read())
        } else {
            X_set(d, 64) = AddPACIB(X_read(d, 64), X_read(n, 64))
        }
    };
    ()
}

val decode_pacib_aarch64_instrs_integer_pac_pacib_dp_1src : (bits(5), bits(5), bits(1)) -> unit

function decode_pacib_aarch64_instrs_integer_pac_pacib_dp_1src (Rd, Rn, Z) = {
    source_is_sp : bool = false;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if not_bool(HavePACExt()) then {
        throw(Error_Undefined())
    };
    if Z == 0b0 then {
        if n == 31 then {
            source_is_sp = true
        };
        ()
    } else {
        if n != 31 then {
            throw(Error_Undefined())
        };
        ()
    };
    execute_aarch64_instrs_integer_pac_pacib_dp_1src(d, n, source_is_sp)
}

function clause __DecodeA64_DataProcReg ((pc, ([bitone, bitone, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, _, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 713) = {
    SEE = 713;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Z = Slice(__opcode, 13, 1);
    decode_pacib_aarch64_instrs_integer_pac_pacib_dp_1src(Rd, Rn, Z)
}

val decode_pacib_aarch64_instrs_integer_pac_pacib_hint : (bits(3), bits(4)) -> unit

function decode_pacib_aarch64_instrs_integer_pac_pacib_hint (op2, CRm) = {
    d : {17, 30} = 17;
    n : int = undefined;
    source_is_sp : bool = false;
    match CRm @ op2 {
      0b0011010 => {
          d = 30;
          n = 31
      },
      0b0011011 => {
          d = 30;
          source_is_sp = true;
          if HaveBTIExt() then {
              SetBTypeCompatible(BTypeCompatible_PACIXSP())
          };
          ()
      },
      0b0001010 => {
          d = 17;
          n = 16
      },
      0b0001000 => {
          throw(Error_See("PACIA"))
      },
      0b0001100 => {
          throw(Error_See("AUTIA"))
      },
      0b0001110 => {
          throw(Error_See("AUTIB"))
      },
      [bitzero, bitzero, bitone, bitone, bitzero, bitzero, _] => {
          throw(Error_See("PACIA"))
      },
      [bitzero, bitzero, bitone, bitone, bitone, bitzero, _] => {
          throw(Error_See("AUTIA"))
      },
      [bitzero, bitzero, bitone, bitone, bitone, bitone, _] => {
          throw(Error_See("AUTIB"))
      },
      0b0000111 => {
          throw(Error_See("XPACLRI"))
      },
      _ => {
          throw(Error_See("HINT"))
      }
    };
    let 'n = n;
    let 'd = d;
    assert(constraint((0 <= 'n & 'n <= 31)));
    execute_aarch64_instrs_integer_pac_pacib_dp_1src(d, n, source_is_sp)
}

function clause __DecodeA64_BranchExcSys ((pc, ([bitone, bitone, bitzero, bitone, bitzero, bitone, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, _, bitone, bitzero, bitone, _, bitone, bitone, bitone, bitone, bitone] as __opcode)) if SEE < 714) = {
    SEE = 714;
    let op2 = Slice(__opcode, 5, 3);
    let CRm = Slice(__opcode, 8, 4);
    decode_pacib_aarch64_instrs_integer_pac_pacib_hint(op2, CRm)
}

val execute_aarch64_instrs_vector_arithmetic_binary_disparate_mul_poly : forall 'd 'datasize 'elements 'esize 'm 'n 'part,
  ('part in {0, 1} & 0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'esize in {8, 16, 32, 64} & 'datasize == 64 & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('m), int('n), int('part)) -> unit

function execute_aarch64_instrs_vector_arithmetic_binary_disparate_mul_poly (d, datasize, elements, esize, m, n, part) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = Vpart_read(n, part, datasize);
    let operand2 : bits('datasize) = Vpart_read(m, part, datasize);
    result : bits(2 * 'datasize) = undefined;
    element1 : bits('esize) = undefined;
    element2 : bits('esize) = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element1 = Elem_read(operand1, e, esize);
        element2 = Elem_read(operand2, e, esize);
        result = Elem_set(result, e, 2 * esize, PolynomialMult(element1, element2))
    };
    V_set(d, 2 * datasize) = result
}

val decode_pmull_advsimd_aarch64_instrs_vector_arithmetic_binary_disparate_mul_poly : (bits(5), bits(5), bits(5), bits(2), bits(1)) -> unit

function decode_pmull_advsimd_aarch64_instrs_vector_arithmetic_binary_disparate_mul_poly (Rd, Rn, Rm, size, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b01 | size == 0b10 then {
        throw(Error_Undefined())
    };
    if size == 0b11 & not_bool(HaveBit128PMULLExt()) then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    let 'datasize = 64;
    let 'part = UInt(Q);
    let 'elements = DIV(datasize, esize);
    execute_aarch64_instrs_vector_arithmetic_binary_disparate_mul_poly(d, datasize, elements, esize, m, n, part)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitone, bitone, bitone, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 715) = {
    SEE = 715;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let Q = Slice(__opcode, 30, 1);
    decode_pmull_advsimd_aarch64_instrs_vector_arithmetic_binary_disparate_mul_poly(Rd, Rn, Rm, size, Q)
}

val execute_aarch64_instrs_memory_single_general_immediate_unsigned : forall 'datasize ('is_signed : Bool) 'n ('nontemporal : Bool) ('postindex : Bool) 'regsize ('rt_unknown : Bool) 't ('tagchecked : Bool) ('wb_unknown : Bool) ('wback : Bool),
  (0 <= 't & 't <= 31 & 'regsize in {32, 64} & 0 <= 'n & 'n <= 31 & 'datasize in {8, 16, 32, 64}).
  (int('datasize), MemOp, int('n), bool('nontemporal), bits(64), bool('postindex), int('regsize), bool('rt_unknown), bool('is_signed), int('t), bool('tagchecked), bool('wb_unknown), bool('wback)) -> unit

function execute_aarch64_instrs_memory_single_general_immediate_unsigned (datasize, memop, n, nontemporal, offset, postindex, regsize, rt_unknown, is_signed, t, tagchecked, wb_unknown, wback) = {
    address : bits(64) = undefined;
    data : bits('datasize) = undefined;
    let privileged : bool = PSTATE.EL != EL0;
    let accdesc : AccessDescriptor = CreateAccDescGPR(memop, nontemporal, privileged, tagchecked);
    if n == 31 then {
        if memop != MemOp_PREFETCH then {
            CheckSPAlignment()
        };
        address = SP_read()
    } else {
        address = X_read(n, 64)
    };
    if not_bool(postindex) then {
        address = address + offset
    };
    match memop {
      MemOp_STORE => {
          if rt_unknown then {
              data = __UNKNOWN_bits(datasize)
          } else {
              data = X_read(t, datasize)
          };
          if not_bool(wback) then {
              AArch64_SetLSInstructionSyndrome(DIV(datasize, 8), false, t, regsize == 64, false)
          };
          Mem_set(address, DIV(datasize, 8), accdesc) = data
      },
      MemOp_LOAD => {
          if not_bool(wback) then {
              AArch64_SetLSInstructionSyndrome(DIV(datasize, 8), is_signed, t, regsize == 64, false)
          };
          let data : bits('datasize) = Mem_read(address, DIV(datasize, 8), accdesc);
          if is_signed then {
              assert(constraint(('datasize > 0 & 'regsize >= 'datasize)));
              X_set(t, regsize) = SignExtend(data, regsize)
          } else {
              assert(constraint(('datasize >= 0 & 'regsize >= 'datasize)));
              X_set(t, regsize) = ZeroExtend(data, regsize)
          }
      },
      MemOp_PREFETCH => {
          Prefetch(address, t[4 .. 0])
      }
    };
    if wback then {
        if wb_unknown then {
            address = __UNKNOWN_bits(64)
        } else if postindex then {
            address = address + offset
        } else ();
        if n == 31 then {
            SP_set() = address
        } else {
            X_set(n, 64) = address
        }
    };
    if SPESampleInFlight then {
        SPESampleGeneralPurposeLoadStore()
    };
    ()
}

val decode_prfm_imm_aarch64_instrs_memory_single_general_immediate_unsigned : (bits(5), bits(5), bits(12), bits(2), bits(2)) -> unit

function decode_prfm_imm_aarch64_instrs_memory_single_general_immediate_unsigned (Rt, Rn, imm12, opc, size) = {
    wback : bool = false;
    let postindex : bool = false;
    let 'scale = UInt(size);
    let offset : bits(64) = LSL(ZeroExtend(imm12, 64), scale);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let nontemporal : bool = false;
    memop : MemOp = undefined;
    is_signed : bool = undefined;
    regsize : {32, 64} = 32;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        is_signed = false
    } else {
        if size == 0b11 then {
            memop = MemOp_PREFETCH;
            if [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            };
            ()
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            };
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            is_signed = true
        }
    };
    let 'regsize = regsize;
    let 'datasize = (8 << scale);
    let tagchecked : bool = memop != MemOp_PREFETCH & (wback | n != 31);
    wb_unknown : bool = false;
    rt_unknown : bool = false;
    c : Constraint = undefined;
    if ((memop == MemOp_LOAD & wback) & n == t) & n != 31 then {
        c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
        assert(c == Constraint_WBSUPPRESS | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_WBSUPPRESS => {
              wback = false
          },
          Constraint_UNKNOWN => {
              wb_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    if ((memop == MemOp_STORE & wback) & n == t) & n != 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
        assert(c == Constraint_NONE | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_NONE => {
              rt_unknown = false
          },
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    execute_aarch64_instrs_memory_single_general_immediate_unsigned(datasize, memop, n, nontemporal, offset, postindex, regsize, rt_unknown, is_signed, t, tagchecked, wb_unknown, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 716) = {
    SEE = 716;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm12 = Slice(__opcode, 10, 12);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_prfm_imm_aarch64_instrs_memory_single_general_immediate_unsigned(Rt, Rn, imm12, opc, size)
}

val execute_aarch64_instrs_vector_crypto_sha3_rax1 : forall 'd 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 0 <= 'd & 'd <= 31).
  (int('d), int('m), int('n)) -> unit

function execute_aarch64_instrs_vector_crypto_sha3_rax1 (d, m, n) = {
    AArch64_CheckFPAdvSIMDEnabled();
    let Vm : bits(128) = V_read(m, 128);
    let Vn : bits(128) = V_read(n, 128);
    V_set(d, 128) = EOR(Vn, ROL(Vm[127 .. 64], 1) @ ROL(Vm[63 .. 0], 1))
}

val decode_rax1_advsimd_aarch64_instrs_vector_crypto_sha3_rax1 : (bits(5), bits(5), bits(5)) -> unit

function decode_rax1_advsimd_aarch64_instrs_vector_crypto_sha3_rax1 (Rd, Rn, Rm) = {
    if not_bool(HaveSHA3Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    execute_aarch64_instrs_vector_crypto_sha3_rax1(d, m, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitone, bitone, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, _, _, _, _, _, bitone, bitzero, bitzero, bitzero, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 717) = {
    SEE = 717;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    decode_rax1_advsimd_aarch64_instrs_vector_crypto_sha3_rax1(Rd, Rn, Rm)
}

val execute_aarch64_instrs_vector_arithmetic_unary_rbit : forall 'd 'datasize 'elements 'esize 'n,
  (0 <= 'n & 'n <= 31 & 'esize == 8 & 'elements in {8, 16} & 'datasize in {64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('n)) -> unit

function execute_aarch64_instrs_vector_arithmetic_unary_rbit (d, datasize, elements, esize, n) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('datasize) = V_read(n, datasize);
    result : bits('datasize) = undefined;
    element : bits('esize) = undefined;
    rev : bits('esize) = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element = Elem_read(operand, e, esize);
        foreach (i from 0 to (esize - 1) by 1 in inc) {
            rev[esize - 1 - i] = Bit([element[i]])
        };
        result = Elem_set(result, e, esize, rev)
    };
    V_set(d, datasize) = result
}

val decode_rbit_advsimd_aarch64_instrs_vector_arithmetic_unary_rbit : (bits(5), bits(5), bits(1)) -> unit

function decode_rbit_advsimd_aarch64_instrs_vector_arithmetic_unary_rbit (Rd, Rn, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = 8;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, 8);
    execute_aarch64_instrs_vector_arithmetic_unary_rbit(d, datasize, elements, esize, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 718) = {
    SEE = 718;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Q = Slice(__opcode, 30, 1);
    decode_rbit_advsimd_aarch64_instrs_vector_arithmetic_unary_rbit(Rd, Rn, Q)
}

val execute_aarch64_instrs_integer_arithmetic_rbit : forall 'd 'datasize 'n,
  (0 <= 'n & 'n <= 31 & 'datasize in {32, 64} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('n)) -> unit

function execute_aarch64_instrs_integer_arithmetic_rbit (d, datasize, n) = {
    let operand : bits('datasize) = X_read(n, datasize);
    result : bits('datasize) = undefined;
    foreach (i from 0 to (datasize - 1) by 1 in inc) {
        result[datasize - 1 - i] = Bit([operand[i]])
    };
    X_set(d, datasize) = result
}

val decode_rbit_int_aarch64_instrs_integer_arithmetic_rbit : (bits(5), bits(5), bits(1)) -> unit

function decode_rbit_int_aarch64_instrs_integer_arithmetic_rbit (Rd, Rn, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'datasize = if sf == 0b1 then 64 else 32;
    execute_aarch64_instrs_integer_arithmetic_rbit(d, datasize, n)
}

function clause __DecodeA64_DataProcReg ((pc, ([_, bitone, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 719) = {
    SEE = 719;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let sf = Slice(__opcode, 31, 1);
    decode_rbit_int_aarch64_instrs_integer_arithmetic_rbit(Rd, Rn, sf)
}

val execute_aarch64_instrs_memory_rcw_cas : forall ('acquire : Bool) 'n ('release : Bool) 's ('soft : Bool) 't ('tagchecked : Bool),
  (0 <= 't & 't <= 31 & 0 <= 's & 's <= 31 & 0 <= 'n & 'n <= 31).
  (bool('acquire), int('n), bool('release), int('s), bool('soft), int('t), bool('tagchecked)) -> unit

function execute_aarch64_instrs_memory_rcw_cas (acquire, n, release, s, soft, t, tagchecked) = {
    if IsD128Enabled(PSTATE.EL) then {
        throw(Error_Undefined())
    };
    address : bits(64) = undefined;
    let newdata : bits(64) = X_read(t, 64);
    let compdata : bits(64) = X_read(s, 64);
    readdata : bits(64) = undefined;
    nzcv : bits(4) = undefined;
    let accdesc : AccessDescriptor = CreateAccDescRCW(MemAtomicOp_CAS, soft, acquire, release, tagchecked);
    if n == 31 then {
        CheckSPAlignment();
        address = SP_read()
    } else {
        address = X_read(n, 64)
    };
    (nzcv, readdata) = MemAtomicRCW(address, compdata, newdata, accdesc);
    (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V) = nzcv;
    X_set(s, 64) = readdata
}

val decode_rcwcas_aarch64_instrs_memory_rcw_cas : (bits(5), bits(5), bits(5), bits(1), bits(1), bits(1)) -> unit

function decode_rcwcas_aarch64_instrs_memory_rcw_cas (Rt, Rn, Rs, R, A, S) = {
    if not_bool(HaveTHExt()) then {
        throw(Error_Undefined())
    };
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 's = UInt(Rs);
    let soft : bool = false;
    let acquire : bool = A == 0b1;
    let release : bool = R == 0b1;
    let tagchecked : bool = n != 31;
    execute_aarch64_instrs_memory_rcw_cas(acquire, n, release, s, soft, t, tagchecked)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitone, _, _, bitone, _, _, _, _, _, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 720) = {
    SEE = 720;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rs = Slice(__opcode, 16, 5);
    let R = Slice(__opcode, 22, 1);
    let A = Slice(__opcode, 23, 1);
    let S = Slice(__opcode, 30, 1);
    decode_rcwcas_aarch64_instrs_memory_rcw_cas(Rt, Rn, Rs, R, A, S)
}

val execute_aarch64_instrs_memory_rcw_cas_128 : forall ('acquire : Bool) 'n ('release : Bool) 's ('soft : Bool) 't ('tagchecked : Bool),
  (0 <= 't & 't <= 31 & 0 <= 's & 's <= 31 & 0 <= 'n & 'n <= 31).
  (bool('acquire), int('n), bool('release), int('s), bool('soft), int('t), bool('tagchecked)) -> unit

function execute_aarch64_instrs_memory_rcw_cas_128 (acquire, n, release, s, soft, t, tagchecked) = {
    if not_bool(IsD128Enabled(PSTATE.EL)) then {
        throw(Error_Undefined())
    };
    address : bits(64) = undefined;
    readdata : bits(128) = undefined;
    nzcv : bits(4) = undefined;
    let s1 : bits(64) = X_read(s, 64);
    let s2 : bits(64) = X_read(s + 1, 64);
    let t1 : bits(64) = X_read(t, 64);
    let t2 : bits(64) = X_read(t + 1, 64);
    let accdesc : AccessDescriptor = CreateAccDescRCW(MemAtomicOp_CAS, soft, acquire, release, tagchecked);
    let compdata : bits(128) = if BigEndian(accdesc.acctype) then s1 @ s2 else
      s2 @ s1;
    let newdata : bits(128) = if BigEndian(accdesc.acctype) then t1 @ t2 else
      t2 @ t1;
    if n == 31 then {
        CheckSPAlignment();
        address = SP_read()
    } else {
        address = X_read(n, 64)
    };
    (nzcv, readdata) = MemAtomicRCW(address, compdata, newdata, accdesc);
    (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V) = nzcv;
    if BigEndian(accdesc.acctype) then {
        X_set(s, 64) = readdata[127 .. 64];
        X_set(s + 1, 64) = readdata[63 .. 0]
    } else {
        X_set(s, 64) = readdata[63 .. 0];
        X_set(s + 1, 64) = readdata[127 .. 64]
    }
}

val decode_rcwcasp_aarch64_instrs_memory_rcw_cas_128 : (bits(5), bits(5), bits(5), bits(1), bits(1), bits(1)) -> unit

function decode_rcwcasp_aarch64_instrs_memory_rcw_cas_128 (Rt, Rn, Rs, R, A, S) = {
    if not_bool(Have128BitDescriptorExt()) | not_bool(HaveTHExt()) then {
        throw(Error_Undefined())
    };
    if [Rs[0]] == 0b1 then {
        throw(Error_Undefined())
    };
    if [Rt[0]] == 0b1 then {
        throw(Error_Undefined())
    };
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 's = UInt(Rs);
    let soft : bool = false;
    let acquire : bool = A == 0b1;
    let release : bool = R == 0b1;
    let tagchecked : bool = n != 31;
    execute_aarch64_instrs_memory_rcw_cas_128(acquire, n, release, s, soft, t, tagchecked)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitone, _, _, bitone, _, _, _, _, _, bitzero, bitzero, bitzero, bitzero, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 721) = {
    SEE = 721;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rs = Slice(__opcode, 16, 5);
    let R = Slice(__opcode, 22, 1);
    let A = Slice(__opcode, 23, 1);
    let S = Slice(__opcode, 30, 1);
    decode_rcwcasp_aarch64_instrs_memory_rcw_cas_128(Rt, Rn, Rs, R, A, S)
}

val execute_aarch64_instrs_memory_rcw_ld_rcwclr : forall ('acquire : Bool) 'n ('release : Bool) 's ('soft : Bool) 't ('tagchecked : Bool),
  (0 <= 't & 't <= 31 & 0 <= 's & 's <= 31 & 0 <= 'n & 'n <= 31).
  (bool('acquire), int('n), MemAtomicOp, bool('release), int('s), bool('soft), int('t), bool('tagchecked)) -> unit

function execute_aarch64_instrs_memory_rcw_ld_rcwclr (acquire, n, op, release, s, soft, t, tagchecked) = {
    if IsD128Enabled(PSTATE.EL) then {
        throw(Error_Undefined())
    };
    address : bits(64) = undefined;
    let newdata : bits(64) = X_read(s, 64);
    readdata : bits(64) = undefined;
    nzcv : bits(4) = undefined;
    let accdesc : AccessDescriptor = CreateAccDescRCW(op, soft, acquire, release, tagchecked);
    if n == 31 then {
        CheckSPAlignment();
        address = SP_read()
    } else {
        address = X_read(n, 64)
    };
    let compdata : bits(64) = __UNKNOWN_bits(64);
    (nzcv, readdata) = MemAtomicRCW(address, compdata, newdata, accdesc);
    (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V) = nzcv;
    X_set(t, 64) = readdata
}

val decode_rcwclr_aarch64_instrs_memory_rcw_ld_rcwclr : (bits(5), bits(5), bits(3), bits(1), bits(5), bits(1), bits(1), bits(1)) -> unit

function decode_rcwclr_aarch64_instrs_memory_rcw_ld_rcwclr (Rt, Rn, opc, o3, Rs, R, A, S) = {
    if not_bool(HaveTHExt()) then {
        throw(Error_Undefined())
    };
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 's = UInt(Rs);
    let soft : bool = false;
    let acquire : bool = A == 0b1 & Rt != 0b11111;
    let release : bool = R == 0b1;
    let op : MemAtomicOp = if opc == 0b001 then MemAtomicOp_BIC else
      MemAtomicOp_ORR;
    let tagchecked : bool = n != 31;
    execute_aarch64_instrs_memory_rcw_ld_rcwclr(acquire, n, op, release, s, soft, t, tagchecked)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitzero, _, _, bitone, _, _, _, _, _, bitone, bitzero, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 722) = {
    SEE = 722;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let opc = Slice(__opcode, 12, 3);
    let o3 = Slice(__opcode, 15, 1);
    let Rs = Slice(__opcode, 16, 5);
    let R = Slice(__opcode, 22, 1);
    let A = Slice(__opcode, 23, 1);
    let S = Slice(__opcode, 30, 1);
    decode_rcwclr_aarch64_instrs_memory_rcw_ld_rcwclr(Rt, Rn, opc, o3, Rs, R, A, S)
}

val execute_aarch64_instrs_memory_rcw_ld_128_rcwclrp : forall ('acquire : Bool) 'n ('release : Bool) ('soft : Bool) 't 't2 ('tagchecked : Bool),
  (0 <= 't2 & 't2 <= 31 & 0 <= 't & 't <= 31 & 0 <= 'n & 'n <= 31).
  (bool('acquire), int('n), MemAtomicOp, bool('release), bool('soft), int('t), int('t2), bool('tagchecked)) -> unit

function execute_aarch64_instrs_memory_rcw_ld_128_rcwclrp (acquire, n, op, release, soft, t, t2, tagchecked) = {
    if not_bool(IsD128Enabled(PSTATE.EL)) then {
        throw(Error_Undefined())
    };
    address : bits(64) = undefined;
    readdata : bits(128) = undefined;
    nzcv : bits(4) = undefined;
    let accdesc : AccessDescriptor = CreateAccDescRCW(op, soft, acquire, release, tagchecked);
    if n == 31 then {
        CheckSPAlignment();
        address = SP_read()
    } else {
        address = X_read(n, 64)
    };
    let value1_name : bits(64) = X_read(t, 64);
    let value2_name : bits(64) = X_read(t2, 64);
    let newdata : bits(128) = if BigEndian(accdesc.acctype) then
      value1_name @ value2_name
    else
      value2_name @ value1_name;
    let compdata : bits(128) = __UNKNOWN_bits(128);
    (nzcv, readdata) = MemAtomicRCW(address, compdata, newdata, accdesc);
    (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V) = nzcv;
    if BigEndian(accdesc.acctype) then {
        X_set(t, 64) = readdata[127 .. 64];
        X_set(t2, 64) = readdata[63 .. 0]
    } else {
        X_set(t, 64) = readdata[63 .. 0];
        X_set(t2, 64) = readdata[127 .. 64]
    }
}

val decode_rcwclrp_aarch64_instrs_memory_rcw_ld_128_rcwclrp : (bits(5), bits(5), bits(3), bits(1), bits(5), bits(1), bits(1), bits(1)) -> unit

function decode_rcwclrp_aarch64_instrs_memory_rcw_ld_128_rcwclrp (Rt, Rn, opc, o3, Rt2, R, A, S) = {
    if not_bool(Have128BitDescriptorExt()) | not_bool(HaveTHExt()) then {
        throw(Error_Undefined())
    };
    if Rt == 0b11111 then {
        throw(Error_Undefined())
    };
    if Rt2 == 0b11111 then {
        throw(Error_Undefined())
    };
    let 't = UInt(Rt);
    let 't2 = UInt(Rt2);
    let 'n = UInt(Rn);
    let soft : bool = false;
    let acquire : bool = A == 0b1;
    let release : bool = R == 0b1;
    let op : MemAtomicOp = if opc == 0b001 then MemAtomicOp_BIC else
      MemAtomicOp_ORR;
    let tagchecked : bool = n != 31;
    execute_aarch64_instrs_memory_rcw_ld_128_rcwclrp(acquire, n, op, release, soft, t, t2, tagchecked)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitone, _, _, bitone, _, _, _, _, _, bitone, bitzero, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 723) = {
    SEE = 723;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let opc = Slice(__opcode, 12, 3);
    let o3 = Slice(__opcode, 15, 1);
    let Rt2 = Slice(__opcode, 16, 5);
    let R = Slice(__opcode, 22, 1);
    let A = Slice(__opcode, 23, 1);
    let S = Slice(__opcode, 30, 1);
    decode_rcwclrp_aarch64_instrs_memory_rcw_ld_128_rcwclrp(Rt, Rn, opc, o3, Rt2, R, A, S)
}

val execute_aarch64_instrs_memory_rcws_cas : forall ('acquire : Bool) 'n ('release : Bool) 's ('soft : Bool) 't ('tagchecked : Bool),
  (0 <= 't & 't <= 31 & 0 <= 's & 's <= 31 & 0 <= 'n & 'n <= 31).
  (bool('acquire), int('n), bool('release), int('s), bool('soft), int('t), bool('tagchecked)) -> unit

function execute_aarch64_instrs_memory_rcws_cas (acquire, n, release, s, soft, t, tagchecked) = {
    if IsD128Enabled(PSTATE.EL) then {
        throw(Error_Undefined())
    };
    address : bits(64) = undefined;
    let newdata : bits(64) = X_read(t, 64);
    let compdata : bits(64) = X_read(s, 64);
    readdata : bits(64) = undefined;
    nzcv : bits(4) = undefined;
    let accdesc : AccessDescriptor = CreateAccDescRCW(MemAtomicOp_CAS, soft, acquire, release, tagchecked);
    if n == 31 then {
        CheckSPAlignment();
        address = SP_read()
    } else {
        address = X_read(n, 64)
    };
    (nzcv, readdata) = MemAtomicRCW(address, compdata, newdata, accdesc);
    (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V) = nzcv;
    X_set(s, 64) = readdata
}

val decode_rcwscas_aarch64_instrs_memory_rcws_cas : (bits(5), bits(5), bits(5), bits(1), bits(1), bits(1)) -> unit

function decode_rcwscas_aarch64_instrs_memory_rcws_cas (Rt, Rn, Rs, R, A, S) = {
    if not_bool(HaveTHExt()) then {
        throw(Error_Undefined())
    };
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 's = UInt(Rs);
    let soft : bool = true;
    let acquire : bool = A == 0b1;
    let release : bool = R == 0b1;
    let tagchecked : bool = n != 31;
    execute_aarch64_instrs_memory_rcws_cas(acquire, n, release, s, soft, t, tagchecked)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitone, _, _, bitone, _, _, _, _, _, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 724) = {
    SEE = 724;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rs = Slice(__opcode, 16, 5);
    let R = Slice(__opcode, 22, 1);
    let A = Slice(__opcode, 23, 1);
    let S = Slice(__opcode, 30, 1);
    decode_rcwscas_aarch64_instrs_memory_rcws_cas(Rt, Rn, Rs, R, A, S)
}

val execute_aarch64_instrs_memory_rcws_cas_128 : forall ('acquire : Bool) 'n ('release : Bool) 's ('soft : Bool) 't ('tagchecked : Bool),
  (0 <= 't & 't <= 31 & 0 <= 's & 's <= 31 & 0 <= 'n & 'n <= 31).
  (bool('acquire), int('n), bool('release), int('s), bool('soft), int('t), bool('tagchecked)) -> unit

function execute_aarch64_instrs_memory_rcws_cas_128 (acquire, n, release, s, soft, t, tagchecked) = {
    if not_bool(IsD128Enabled(PSTATE.EL)) then {
        throw(Error_Undefined())
    };
    address : bits(64) = undefined;
    readdata : bits(128) = undefined;
    nzcv : bits(4) = undefined;
    let s1 : bits(64) = X_read(s, 64);
    let s2 : bits(64) = X_read(s + 1, 64);
    let t1 : bits(64) = X_read(t, 64);
    let t2 : bits(64) = X_read(t + 1, 64);
    let accdesc : AccessDescriptor = CreateAccDescRCW(MemAtomicOp_CAS, soft, acquire, release, tagchecked);
    let compdata : bits(128) = if BigEndian(accdesc.acctype) then s1 @ s2 else
      s2 @ s1;
    let newdata : bits(128) = if BigEndian(accdesc.acctype) then t1 @ t2 else
      t2 @ t1;
    if n == 31 then {
        CheckSPAlignment();
        address = SP_read()
    } else {
        address = X_read(n, 64)
    };
    (nzcv, readdata) = MemAtomicRCW(address, compdata, newdata, accdesc);
    (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V) = nzcv;
    if BigEndian(accdesc.acctype) then {
        X_set(s, 64) = readdata[127 .. 64];
        X_set(s + 1, 64) = readdata[63 .. 0]
    } else {
        X_set(s, 64) = readdata[63 .. 0];
        X_set(s + 1, 64) = readdata[127 .. 64]
    }
}

val decode_rcwscasp_aarch64_instrs_memory_rcws_cas_128 : (bits(5), bits(5), bits(5), bits(1), bits(1), bits(1)) -> unit

function decode_rcwscasp_aarch64_instrs_memory_rcws_cas_128 (Rt, Rn, Rs, R, A, S) = {
    if not_bool(Have128BitDescriptorExt()) | not_bool(HaveTHExt()) then {
        throw(Error_Undefined())
    };
    if [Rs[0]] == 0b1 then {
        throw(Error_Undefined())
    };
    if [Rt[0]] == 0b1 then {
        throw(Error_Undefined())
    };
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 's = UInt(Rs);
    let soft : bool = true;
    let acquire : bool = A == 0b1;
    let release : bool = R == 0b1;
    let tagchecked : bool = n != 31;
    execute_aarch64_instrs_memory_rcws_cas_128(acquire, n, release, s, soft, t, tagchecked)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitone, _, _, bitone, _, _, _, _, _, bitzero, bitzero, bitzero, bitzero, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 725) = {
    SEE = 725;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rs = Slice(__opcode, 16, 5);
    let R = Slice(__opcode, 22, 1);
    let A = Slice(__opcode, 23, 1);
    let S = Slice(__opcode, 30, 1);
    decode_rcwscasp_aarch64_instrs_memory_rcws_cas_128(Rt, Rn, Rs, R, A, S)
}

val execute_aarch64_instrs_memory_rcws_ld_rcwsclr : forall ('acquire : Bool) 'n ('release : Bool) 's ('soft : Bool) 't ('tagchecked : Bool),
  (0 <= 't & 't <= 31 & 0 <= 's & 's <= 31 & 0 <= 'n & 'n <= 31).
  (bool('acquire), int('n), MemAtomicOp, bool('release), int('s), bool('soft), int('t), bool('tagchecked)) -> unit

function execute_aarch64_instrs_memory_rcws_ld_rcwsclr (acquire, n, op, release, s, soft, t, tagchecked) = {
    if IsD128Enabled(PSTATE.EL) then {
        throw(Error_Undefined())
    };
    address : bits(64) = undefined;
    let newdata : bits(64) = X_read(s, 64);
    readdata : bits(64) = undefined;
    nzcv : bits(4) = undefined;
    let accdesc : AccessDescriptor = CreateAccDescRCW(op, soft, acquire, release, tagchecked);
    if n == 31 then {
        CheckSPAlignment();
        address = SP_read()
    } else {
        address = X_read(n, 64)
    };
    let compdata : bits(64) = __UNKNOWN_bits(64);
    (nzcv, readdata) = MemAtomicRCW(address, compdata, newdata, accdesc);
    (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V) = nzcv;
    X_set(t, 64) = readdata
}

val decode_rcwsclr_aarch64_instrs_memory_rcws_ld_rcwsclr : (bits(5), bits(5), bits(3), bits(1), bits(5), bits(1), bits(1), bits(1)) -> unit

function decode_rcwsclr_aarch64_instrs_memory_rcws_ld_rcwsclr (Rt, Rn, opc, o3, Rs, R, A, S) = {
    if not_bool(HaveTHExt()) then {
        throw(Error_Undefined())
    };
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 's = UInt(Rs);
    let soft : bool = true;
    let acquire : bool = A == 0b1 & Rt != 0b11111;
    let release : bool = R == 0b1;
    let op : MemAtomicOp = if opc == 0b001 then MemAtomicOp_BIC else
      MemAtomicOp_ORR;
    let tagchecked : bool = n != 31;
    execute_aarch64_instrs_memory_rcws_ld_rcwsclr(acquire, n, op, release, s, soft, t, tagchecked)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, _, _, bitone, _, _, _, _, _, bitone, bitzero, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 726) = {
    SEE = 726;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let opc = Slice(__opcode, 12, 3);
    let o3 = Slice(__opcode, 15, 1);
    let Rs = Slice(__opcode, 16, 5);
    let R = Slice(__opcode, 22, 1);
    let A = Slice(__opcode, 23, 1);
    let S = Slice(__opcode, 30, 1);
    decode_rcwsclr_aarch64_instrs_memory_rcws_ld_rcwsclr(Rt, Rn, opc, o3, Rs, R, A, S)
}

val execute_aarch64_instrs_memory_rcws_ld_128_rcwsclrp : forall ('acquire : Bool) 'n ('release : Bool) ('soft : Bool) 't 't2 ('tagchecked : Bool),
  (0 <= 't2 & 't2 <= 31 & 0 <= 't & 't <= 31 & 0 <= 'n & 'n <= 31).
  (bool('acquire), int('n), MemAtomicOp, bool('release), bool('soft), int('t), int('t2), bool('tagchecked)) -> unit

function execute_aarch64_instrs_memory_rcws_ld_128_rcwsclrp (acquire, n, op, release, soft, t, t2, tagchecked) = {
    if not_bool(IsD128Enabled(PSTATE.EL)) then {
        throw(Error_Undefined())
    };
    address : bits(64) = undefined;
    readdata : bits(128) = undefined;
    nzcv : bits(4) = undefined;
    let accdesc : AccessDescriptor = CreateAccDescRCW(op, soft, acquire, release, tagchecked);
    if n == 31 then {
        CheckSPAlignment();
        address = SP_read()
    } else {
        address = X_read(n, 64)
    };
    let value1_name : bits(64) = X_read(t, 64);
    let value2_name : bits(64) = X_read(t2, 64);
    let newdata : bits(128) = if BigEndian(accdesc.acctype) then
      value1_name @ value2_name
    else
      value2_name @ value1_name;
    let compdata : bits(128) = __UNKNOWN_bits(128);
    (nzcv, readdata) = MemAtomicRCW(address, compdata, newdata, accdesc);
    (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V) = nzcv;
    if BigEndian(accdesc.acctype) then {
        X_set(t, 64) = readdata[127 .. 64];
        X_set(t2, 64) = readdata[63 .. 0]
    } else {
        X_set(t, 64) = readdata[63 .. 0];
        X_set(t2, 64) = readdata[127 .. 64]
    }
}

val decode_rcwsclrp_aarch64_instrs_memory_rcws_ld_128_rcwsclrp : (bits(5), bits(5), bits(3), bits(1), bits(5), bits(1), bits(1), bits(1)) -> unit

function decode_rcwsclrp_aarch64_instrs_memory_rcws_ld_128_rcwsclrp (Rt, Rn, opc, o3, Rt2, R, A, S) = {
    if not_bool(Have128BitDescriptorExt()) | not_bool(HaveTHExt()) then {
        throw(Error_Undefined())
    };
    if Rt == 0b11111 then {
        throw(Error_Undefined())
    };
    if Rt2 == 0b11111 then {
        throw(Error_Undefined())
    };
    let 't = UInt(Rt);
    let 't2 = UInt(Rt2);
    let 'n = UInt(Rn);
    let soft : bool = true;
    let acquire : bool = A == 0b1;
    let release : bool = R == 0b1;
    let op : MemAtomicOp = if opc == 0b001 then MemAtomicOp_BIC else
      MemAtomicOp_ORR;
    let tagchecked : bool = n != 31;
    execute_aarch64_instrs_memory_rcws_ld_128_rcwsclrp(acquire, n, op, release, soft, t, t2, tagchecked)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitone, _, _, bitone, _, _, _, _, _, bitone, bitzero, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 727) = {
    SEE = 727;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let opc = Slice(__opcode, 12, 3);
    let o3 = Slice(__opcode, 15, 1);
    let Rt2 = Slice(__opcode, 16, 5);
    let R = Slice(__opcode, 22, 1);
    let A = Slice(__opcode, 23, 1);
    let S = Slice(__opcode, 30, 1);
    decode_rcwsclrp_aarch64_instrs_memory_rcws_ld_128_rcwsclrp(Rt, Rn, opc, o3, Rt2, R, A, S)
}

val execute_aarch64_instrs_memory_rcw_ld_rcwset : forall ('acquire : Bool) 'n ('release : Bool) 's ('soft : Bool) 't ('tagchecked : Bool),
  (0 <= 't & 't <= 31 & 0 <= 's & 's <= 31 & 0 <= 'n & 'n <= 31).
  (bool('acquire), int('n), MemAtomicOp, bool('release), int('s), bool('soft), int('t), bool('tagchecked)) -> unit

function execute_aarch64_instrs_memory_rcw_ld_rcwset (acquire, n, op, release, s, soft, t, tagchecked) = {
    if IsD128Enabled(PSTATE.EL) then {
        throw(Error_Undefined())
    };
    address : bits(64) = undefined;
    let newdata : bits(64) = X_read(s, 64);
    readdata : bits(64) = undefined;
    nzcv : bits(4) = undefined;
    let accdesc : AccessDescriptor = CreateAccDescRCW(op, soft, acquire, release, tagchecked);
    if n == 31 then {
        CheckSPAlignment();
        address = SP_read()
    } else {
        address = X_read(n, 64)
    };
    let compdata : bits(64) = __UNKNOWN_bits(64);
    (nzcv, readdata) = MemAtomicRCW(address, compdata, newdata, accdesc);
    (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V) = nzcv;
    X_set(t, 64) = readdata
}

val decode_rcwset_aarch64_instrs_memory_rcw_ld_rcwset : (bits(5), bits(5), bits(3), bits(1), bits(5), bits(1), bits(1), bits(1)) -> unit

function decode_rcwset_aarch64_instrs_memory_rcw_ld_rcwset (Rt, Rn, opc, o3, Rs, R, A, S) = {
    if not_bool(HaveTHExt()) then {
        throw(Error_Undefined())
    };
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 's = UInt(Rs);
    let soft : bool = false;
    let acquire : bool = A == 0b1 & Rt != 0b11111;
    let release : bool = R == 0b1;
    let op : MemAtomicOp = if opc == 0b001 then MemAtomicOp_BIC else
      MemAtomicOp_ORR;
    let tagchecked : bool = n != 31;
    execute_aarch64_instrs_memory_rcw_ld_rcwset(acquire, n, op, release, s, soft, t, tagchecked)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitzero, _, _, bitone, _, _, _, _, _, bitone, bitzero, bitone, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 728) = {
    SEE = 728;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let opc = Slice(__opcode, 12, 3);
    let o3 = Slice(__opcode, 15, 1);
    let Rs = Slice(__opcode, 16, 5);
    let R = Slice(__opcode, 22, 1);
    let A = Slice(__opcode, 23, 1);
    let S = Slice(__opcode, 30, 1);
    decode_rcwset_aarch64_instrs_memory_rcw_ld_rcwset(Rt, Rn, opc, o3, Rs, R, A, S)
}

val execute_aarch64_instrs_memory_rcw_ld_128_rcwsetp : forall ('acquire : Bool) 'n ('release : Bool) ('soft : Bool) 't 't2 ('tagchecked : Bool),
  (0 <= 't2 & 't2 <= 31 & 0 <= 't & 't <= 31 & 0 <= 'n & 'n <= 31).
  (bool('acquire), int('n), MemAtomicOp, bool('release), bool('soft), int('t), int('t2), bool('tagchecked)) -> unit

function execute_aarch64_instrs_memory_rcw_ld_128_rcwsetp (acquire, n, op, release, soft, t, t2, tagchecked) = {
    if not_bool(IsD128Enabled(PSTATE.EL)) then {
        throw(Error_Undefined())
    };
    address : bits(64) = undefined;
    readdata : bits(128) = undefined;
    nzcv : bits(4) = undefined;
    let accdesc : AccessDescriptor = CreateAccDescRCW(op, soft, acquire, release, tagchecked);
    if n == 31 then {
        CheckSPAlignment();
        address = SP_read()
    } else {
        address = X_read(n, 64)
    };
    let value1_name : bits(64) = X_read(t, 64);
    let value2_name : bits(64) = X_read(t2, 64);
    let newdata : bits(128) = if BigEndian(accdesc.acctype) then
      value1_name @ value2_name
    else
      value2_name @ value1_name;
    let compdata : bits(128) = __UNKNOWN_bits(128);
    (nzcv, readdata) = MemAtomicRCW(address, compdata, newdata, accdesc);
    (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V) = nzcv;
    if BigEndian(accdesc.acctype) then {
        X_set(t, 64) = readdata[127 .. 64];
        X_set(t2, 64) = readdata[63 .. 0]
    } else {
        X_set(t, 64) = readdata[63 .. 0];
        X_set(t2, 64) = readdata[127 .. 64]
    }
}

val decode_rcwsetp_aarch64_instrs_memory_rcw_ld_128_rcwsetp : (bits(5), bits(5), bits(3), bits(1), bits(5), bits(1), bits(1), bits(1)) -> unit

function decode_rcwsetp_aarch64_instrs_memory_rcw_ld_128_rcwsetp (Rt, Rn, opc, o3, Rt2, R, A, S) = {
    if not_bool(Have128BitDescriptorExt()) | not_bool(HaveTHExt()) then {
        throw(Error_Undefined())
    };
    if Rt == 0b11111 then {
        throw(Error_Undefined())
    };
    if Rt2 == 0b11111 then {
        throw(Error_Undefined())
    };
    let 't = UInt(Rt);
    let 't2 = UInt(Rt2);
    let 'n = UInt(Rn);
    let soft : bool = false;
    let acquire : bool = A == 0b1;
    let release : bool = R == 0b1;
    let op : MemAtomicOp = if opc == 0b001 then MemAtomicOp_BIC else
      MemAtomicOp_ORR;
    let tagchecked : bool = n != 31;
    execute_aarch64_instrs_memory_rcw_ld_128_rcwsetp(acquire, n, op, release, soft, t, t2, tagchecked)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitone, _, _, bitone, _, _, _, _, _, bitone, bitzero, bitone, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 729) = {
    SEE = 729;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let opc = Slice(__opcode, 12, 3);
    let o3 = Slice(__opcode, 15, 1);
    let Rt2 = Slice(__opcode, 16, 5);
    let R = Slice(__opcode, 22, 1);
    let A = Slice(__opcode, 23, 1);
    let S = Slice(__opcode, 30, 1);
    decode_rcwsetp_aarch64_instrs_memory_rcw_ld_128_rcwsetp(Rt, Rn, opc, o3, Rt2, R, A, S)
}

val execute_aarch64_instrs_memory_rcws_ld_rcwsset : forall ('acquire : Bool) 'n ('release : Bool) 's ('soft : Bool) 't ('tagchecked : Bool),
  (0 <= 't & 't <= 31 & 0 <= 's & 's <= 31 & 0 <= 'n & 'n <= 31).
  (bool('acquire), int('n), MemAtomicOp, bool('release), int('s), bool('soft), int('t), bool('tagchecked)) -> unit

function execute_aarch64_instrs_memory_rcws_ld_rcwsset (acquire, n, op, release, s, soft, t, tagchecked) = {
    if IsD128Enabled(PSTATE.EL) then {
        throw(Error_Undefined())
    };
    address : bits(64) = undefined;
    let newdata : bits(64) = X_read(s, 64);
    readdata : bits(64) = undefined;
    nzcv : bits(4) = undefined;
    let accdesc : AccessDescriptor = CreateAccDescRCW(op, soft, acquire, release, tagchecked);
    if n == 31 then {
        CheckSPAlignment();
        address = SP_read()
    } else {
        address = X_read(n, 64)
    };
    let compdata : bits(64) = __UNKNOWN_bits(64);
    (nzcv, readdata) = MemAtomicRCW(address, compdata, newdata, accdesc);
    (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V) = nzcv;
    X_set(t, 64) = readdata
}

val decode_rcwsset_aarch64_instrs_memory_rcws_ld_rcwsset : (bits(5), bits(5), bits(3), bits(1), bits(5), bits(1), bits(1), bits(1)) -> unit

function decode_rcwsset_aarch64_instrs_memory_rcws_ld_rcwsset (Rt, Rn, opc, o3, Rs, R, A, S) = {
    if not_bool(HaveTHExt()) then {
        throw(Error_Undefined())
    };
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 's = UInt(Rs);
    let soft : bool = true;
    let acquire : bool = A == 0b1 & Rt != 0b11111;
    let release : bool = R == 0b1;
    let op : MemAtomicOp = if opc == 0b001 then MemAtomicOp_BIC else
      MemAtomicOp_ORR;
    let tagchecked : bool = n != 31;
    execute_aarch64_instrs_memory_rcws_ld_rcwsset(acquire, n, op, release, s, soft, t, tagchecked)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, _, _, bitone, _, _, _, _, _, bitone, bitzero, bitone, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 730) = {
    SEE = 730;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let opc = Slice(__opcode, 12, 3);
    let o3 = Slice(__opcode, 15, 1);
    let Rs = Slice(__opcode, 16, 5);
    let R = Slice(__opcode, 22, 1);
    let A = Slice(__opcode, 23, 1);
    let S = Slice(__opcode, 30, 1);
    decode_rcwsset_aarch64_instrs_memory_rcws_ld_rcwsset(Rt, Rn, opc, o3, Rs, R, A, S)
}

val execute_aarch64_instrs_memory_rcws_ld_128_rcwssetp : forall ('acquire : Bool) 'n ('release : Bool) ('soft : Bool) 't 't2 ('tagchecked : Bool),
  (0 <= 't2 & 't2 <= 31 & 0 <= 't & 't <= 31 & 0 <= 'n & 'n <= 31).
  (bool('acquire), int('n), MemAtomicOp, bool('release), bool('soft), int('t), int('t2), bool('tagchecked)) -> unit

function execute_aarch64_instrs_memory_rcws_ld_128_rcwssetp (acquire, n, op, release, soft, t, t2, tagchecked) = {
    if not_bool(IsD128Enabled(PSTATE.EL)) then {
        throw(Error_Undefined())
    };
    address : bits(64) = undefined;
    readdata : bits(128) = undefined;
    nzcv : bits(4) = undefined;
    let accdesc : AccessDescriptor = CreateAccDescRCW(op, soft, acquire, release, tagchecked);
    if n == 31 then {
        CheckSPAlignment();
        address = SP_read()
    } else {
        address = X_read(n, 64)
    };
    let value1_name : bits(64) = X_read(t, 64);
    let value2_name : bits(64) = X_read(t2, 64);
    let newdata : bits(128) = if BigEndian(accdesc.acctype) then
      value1_name @ value2_name
    else
      value2_name @ value1_name;
    let compdata : bits(128) = __UNKNOWN_bits(128);
    (nzcv, readdata) = MemAtomicRCW(address, compdata, newdata, accdesc);
    (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V) = nzcv;
    if BigEndian(accdesc.acctype) then {
        X_set(t, 64) = readdata[127 .. 64];
        X_set(t2, 64) = readdata[63 .. 0]
    } else {
        X_set(t, 64) = readdata[63 .. 0];
        X_set(t2, 64) = readdata[127 .. 64]
    }
}

val decode_rcwssetp_aarch64_instrs_memory_rcws_ld_128_rcwssetp : (bits(5), bits(5), bits(3), bits(1), bits(5), bits(1), bits(1), bits(1)) -> unit

function decode_rcwssetp_aarch64_instrs_memory_rcws_ld_128_rcwssetp (Rt, Rn, opc, o3, Rt2, R, A, S) = {
    if not_bool(Have128BitDescriptorExt()) | not_bool(HaveTHExt()) then {
        throw(Error_Undefined())
    };
    if Rt == 0b11111 then {
        throw(Error_Undefined())
    };
    if Rt2 == 0b11111 then {
        throw(Error_Undefined())
    };
    let 't = UInt(Rt);
    let 't2 = UInt(Rt2);
    let 'n = UInt(Rn);
    let soft : bool = true;
    let acquire : bool = A == 0b1;
    let release : bool = R == 0b1;
    let op : MemAtomicOp = if opc == 0b001 then MemAtomicOp_BIC else
      MemAtomicOp_ORR;
    let tagchecked : bool = n != 31;
    execute_aarch64_instrs_memory_rcws_ld_128_rcwssetp(acquire, n, op, release, soft, t, t2, tagchecked)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitone, _, _, bitone, _, _, _, _, _, bitone, bitzero, bitone, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 731) = {
    SEE = 731;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let opc = Slice(__opcode, 12, 3);
    let o3 = Slice(__opcode, 15, 1);
    let Rt2 = Slice(__opcode, 16, 5);
    let R = Slice(__opcode, 22, 1);
    let A = Slice(__opcode, 23, 1);
    let S = Slice(__opcode, 30, 1);
    decode_rcwssetp_aarch64_instrs_memory_rcws_ld_128_rcwssetp(Rt, Rn, opc, o3, Rt2, R, A, S)
}

val execute_aarch64_instrs_memory_rcws_swp : forall ('acquire : Bool) 'n ('release : Bool) 's ('soft : Bool) 't ('tagchecked : Bool),
  (0 <= 't & 't <= 31 & 0 <= 's & 's <= 31 & 0 <= 'n & 'n <= 31).
  (bool('acquire), int('n), bool('release), int('s), bool('soft), int('t), bool('tagchecked)) -> unit

function execute_aarch64_instrs_memory_rcws_swp (acquire, n, release, s, soft, t, tagchecked) = {
    if IsD128Enabled(PSTATE.EL) then {
        throw(Error_Undefined())
    };
    address : bits(64) = undefined;
    let newdata : bits(64) = X_read(s, 64);
    readdata : bits(64) = undefined;
    nzcv : bits(4) = undefined;
    let accdesc : AccessDescriptor = CreateAccDescRCW(MemAtomicOp_SWP, soft, acquire, release, tagchecked);
    if n == 31 then {
        CheckSPAlignment();
        address = SP_read()
    } else {
        address = X_read(n, 64)
    };
    let compdata : bits(64) = __UNKNOWN_bits(64);
    (nzcv, readdata) = MemAtomicRCW(address, compdata, newdata, accdesc);
    (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V) = nzcv;
    X_set(t, 64) = readdata
}

val decode_rcwsswp_aarch64_instrs_memory_rcws_swp : (bits(5), bits(5), bits(3), bits(1), bits(5), bits(1), bits(1), bits(1)) -> unit

function decode_rcwsswp_aarch64_instrs_memory_rcws_swp (Rt, Rn, opc, o3, Rs, R, A, S) = {
    if not_bool(HaveTHExt()) then {
        throw(Error_Undefined())
    };
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 's = UInt(Rs);
    let soft : bool = true;
    let acquire : bool = A == 0b1 & Rt != 0b11111;
    let release : bool = R == 0b1;
    let tagchecked : bool = n != 31;
    execute_aarch64_instrs_memory_rcws_swp(acquire, n, release, s, soft, t, tagchecked)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, _, _, bitone, _, _, _, _, _, bitone, bitzero, bitone, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 732) = {
    SEE = 732;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let opc = Slice(__opcode, 12, 3);
    let o3 = Slice(__opcode, 15, 1);
    let Rs = Slice(__opcode, 16, 5);
    let R = Slice(__opcode, 22, 1);
    let A = Slice(__opcode, 23, 1);
    let S = Slice(__opcode, 30, 1);
    decode_rcwsswp_aarch64_instrs_memory_rcws_swp(Rt, Rn, opc, o3, Rs, R, A, S)
}

val execute_aarch64_instrs_memory_rcws_swp_128 : forall ('acquire : Bool) 'n ('release : Bool) ('soft : Bool) 't 't2 ('tagchecked : Bool),
  (0 <= 't2 & 't2 <= 31 & 0 <= 't & 't <= 31 & 0 <= 'n & 'n <= 31).
  (bool('acquire), int('n), bool('release), bool('soft), int('t), int('t2), bool('tagchecked)) -> unit

function execute_aarch64_instrs_memory_rcws_swp_128 (acquire, n, release, soft, t, t2, tagchecked) = {
    if not_bool(IsD128Enabled(PSTATE.EL)) then {
        throw(Error_Undefined())
    };
    address : bits(64) = undefined;
    readdata : bits(128) = undefined;
    nzcv : bits(4) = undefined;
    let accdesc : AccessDescriptor = CreateAccDescRCW(MemAtomicOp_SWP, soft, acquire, release, tagchecked);
    if n == 31 then {
        CheckSPAlignment();
        address = SP_read()
    } else {
        address = X_read(n, 64)
    };
    let value1_name : bits(64) = X_read(t, 64);
    let value2_name : bits(64) = X_read(t2, 64);
    let newdata : bits(128) = if BigEndian(accdesc.acctype) then
      value1_name @ value2_name
    else
      value2_name @ value1_name;
    let compdata : bits(128) = __UNKNOWN_bits(128);
    (nzcv, readdata) = MemAtomicRCW(address, compdata, newdata, accdesc);
    (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V) = nzcv;
    if BigEndian(accdesc.acctype) then {
        X_set(t, 64) = readdata[127 .. 64];
        X_set(t2, 64) = readdata[63 .. 0]
    } else {
        X_set(t, 64) = readdata[63 .. 0];
        X_set(t2, 64) = readdata[127 .. 64]
    }
}

val decode_rcwsswpp_aarch64_instrs_memory_rcws_swp_128 : (bits(5), bits(5), bits(3), bits(1), bits(5), bits(1), bits(1), bits(1)) -> unit

function decode_rcwsswpp_aarch64_instrs_memory_rcws_swp_128 (Rt, Rn, opc, o3, Rt2, R, A, S) = {
    if not_bool(Have128BitDescriptorExt()) | not_bool(HaveTHExt()) then {
        throw(Error_Undefined())
    };
    if Rt == 0b11111 then {
        throw(Error_Undefined())
    };
    if Rt2 == 0b11111 then {
        throw(Error_Undefined())
    };
    let 't = UInt(Rt);
    let 't2 = UInt(Rt2);
    let 'n = UInt(Rn);
    let soft : bool = true;
    let acquire : bool = A == 0b1;
    let release : bool = R == 0b1;
    let tagchecked : bool = n != 31;
    execute_aarch64_instrs_memory_rcws_swp_128(acquire, n, release, soft, t, t2, tagchecked)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitone, _, _, bitone, _, _, _, _, _, bitone, bitzero, bitone, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 733) = {
    SEE = 733;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let opc = Slice(__opcode, 12, 3);
    let o3 = Slice(__opcode, 15, 1);
    let Rt2 = Slice(__opcode, 16, 5);
    let R = Slice(__opcode, 22, 1);
    let A = Slice(__opcode, 23, 1);
    let S = Slice(__opcode, 30, 1);
    decode_rcwsswpp_aarch64_instrs_memory_rcws_swp_128(Rt, Rn, opc, o3, Rt2, R, A, S)
}

val execute_aarch64_instrs_memory_rcw_swp : forall ('acquire : Bool) 'n ('release : Bool) 's ('soft : Bool) 't ('tagchecked : Bool),
  (0 <= 't & 't <= 31 & 0 <= 's & 's <= 31 & 0 <= 'n & 'n <= 31).
  (bool('acquire), int('n), bool('release), int('s), bool('soft), int('t), bool('tagchecked)) -> unit

function execute_aarch64_instrs_memory_rcw_swp (acquire, n, release, s, soft, t, tagchecked) = {
    if IsD128Enabled(PSTATE.EL) then {
        throw(Error_Undefined())
    };
    address : bits(64) = undefined;
    let newdata : bits(64) = X_read(s, 64);
    readdata : bits(64) = undefined;
    nzcv : bits(4) = undefined;
    let accdesc : AccessDescriptor = CreateAccDescRCW(MemAtomicOp_SWP, soft, acquire, release, tagchecked);
    if n == 31 then {
        CheckSPAlignment();
        address = SP_read()
    } else {
        address = X_read(n, 64)
    };
    let compdata : bits(64) = __UNKNOWN_bits(64);
    (nzcv, readdata) = MemAtomicRCW(address, compdata, newdata, accdesc);
    (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V) = nzcv;
    X_set(t, 64) = readdata
}

val decode_rcwswp_aarch64_instrs_memory_rcw_swp : (bits(5), bits(5), bits(3), bits(1), bits(5), bits(1), bits(1), bits(1)) -> unit

function decode_rcwswp_aarch64_instrs_memory_rcw_swp (Rt, Rn, opc, o3, Rs, R, A, S) = {
    if not_bool(HaveTHExt()) then {
        throw(Error_Undefined())
    };
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 's = UInt(Rs);
    let soft : bool = false;
    let acquire : bool = A == 0b1 & Rt != 0b11111;
    let release : bool = R == 0b1;
    let tagchecked : bool = n != 31;
    execute_aarch64_instrs_memory_rcw_swp(acquire, n, release, s, soft, t, tagchecked)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitzero, _, _, bitone, _, _, _, _, _, bitone, bitzero, bitone, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 734) = {
    SEE = 734;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let opc = Slice(__opcode, 12, 3);
    let o3 = Slice(__opcode, 15, 1);
    let Rs = Slice(__opcode, 16, 5);
    let R = Slice(__opcode, 22, 1);
    let A = Slice(__opcode, 23, 1);
    let S = Slice(__opcode, 30, 1);
    decode_rcwswp_aarch64_instrs_memory_rcw_swp(Rt, Rn, opc, o3, Rs, R, A, S)
}

val execute_aarch64_instrs_memory_rcw_swp_128 : forall ('acquire : Bool) 'n ('release : Bool) ('soft : Bool) 't 't2 ('tagchecked : Bool),
  (0 <= 't2 & 't2 <= 31 & 0 <= 't & 't <= 31 & 0 <= 'n & 'n <= 31).
  (bool('acquire), int('n), bool('release), bool('soft), int('t), int('t2), bool('tagchecked)) -> unit

function execute_aarch64_instrs_memory_rcw_swp_128 (acquire, n, release, soft, t, t2, tagchecked) = {
    if not_bool(IsD128Enabled(PSTATE.EL)) then {
        throw(Error_Undefined())
    };
    address : bits(64) = undefined;
    readdata : bits(128) = undefined;
    nzcv : bits(4) = undefined;
    let accdesc : AccessDescriptor = CreateAccDescRCW(MemAtomicOp_SWP, soft, acquire, release, tagchecked);
    if n == 31 then {
        CheckSPAlignment();
        address = SP_read()
    } else {
        address = X_read(n, 64)
    };
    let value1_name : bits(64) = X_read(t, 64);
    let value2_name : bits(64) = X_read(t2, 64);
    let newdata : bits(128) = if BigEndian(accdesc.acctype) then
      value1_name @ value2_name
    else
      value2_name @ value1_name;
    let compdata : bits(128) = __UNKNOWN_bits(128);
    (nzcv, readdata) = MemAtomicRCW(address, compdata, newdata, accdesc);
    (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V) = nzcv;
    if BigEndian(accdesc.acctype) then {
        X_set(t, 64) = readdata[127 .. 64];
        X_set(t2, 64) = readdata[63 .. 0]
    } else {
        X_set(t, 64) = readdata[63 .. 0];
        X_set(t2, 64) = readdata[127 .. 64]
    }
}

val decode_rcwswpp_aarch64_instrs_memory_rcw_swp_128 : (bits(5), bits(5), bits(3), bits(1), bits(5), bits(1), bits(1), bits(1)) -> unit

function decode_rcwswpp_aarch64_instrs_memory_rcw_swp_128 (Rt, Rn, opc, o3, Rt2, R, A, S) = {
    if not_bool(Have128BitDescriptorExt()) | not_bool(HaveTHExt()) then {
        throw(Error_Undefined())
    };
    if Rt == 0b11111 then {
        throw(Error_Undefined())
    };
    if Rt2 == 0b11111 then {
        throw(Error_Undefined())
    };
    let 't = UInt(Rt);
    let 't2 = UInt(Rt2);
    let 'n = UInt(Rn);
    let soft : bool = false;
    let acquire : bool = A == 0b1;
    let release : bool = R == 0b1;
    let tagchecked : bool = n != 31;
    execute_aarch64_instrs_memory_rcw_swp_128(acquire, n, release, soft, t, t2, tagchecked)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitone, _, _, bitone, _, _, _, _, _, bitone, bitzero, bitone, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 735) = {
    SEE = 735;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let opc = Slice(__opcode, 12, 3);
    let o3 = Slice(__opcode, 15, 1);
    let Rt2 = Slice(__opcode, 16, 5);
    let R = Slice(__opcode, 22, 1);
    let A = Slice(__opcode, 23, 1);
    let S = Slice(__opcode, 30, 1);
    decode_rcwswpp_aarch64_instrs_memory_rcw_swp_128(Rt, Rn, opc, o3, Rt2, R, A, S)
}

val execute_aarch64_instrs_integer_arithmetic_rev : forall 'container_size 'd 'datasize 'n,
  (0 <= 'n & 'n <= 31 & 'datasize in {32, 64} & 0 <= 'd & 'd <= 31 & 'container_size in {16, 32, 64}).
  (int('container_size), int('d), int('datasize), int('n)) -> unit

function execute_aarch64_instrs_integer_arithmetic_rev (container_size, d, datasize, n) = {
    let operand : bits('datasize) = X_read(n, datasize);
    result : bits('datasize) = undefined;
    let 'containers = DIV(datasize, container_size);
    let 'elements_per_container = DIV(container_size, 8);
    index : int = 0;
    rev_index : int = undefined;
    foreach (c from 0 to (containers - 1) by 1 in inc) {
        rev_index = index + (elements_per_container - 1) * 8;
        foreach (e from 0 to (elements_per_container - 1) by 1 in inc) {
            let 'rev_index = rev_index in
              {
                  let 'index = index;
                  assert(constraint((0 <= 'rev_index & 'rev_index + 7 < 'datasize)));
                  assert(constraint((0 <= 'index & 'index + 7 < 'datasize)));
                  result[rev_index + 7 .. rev_index] = operand[index + 7 .. index]
              };
            index = index + 8;
            rev_index = rev_index - 8
        }
    };
    X_set(d, datasize) = result
}

val decode_rev_aarch64_instrs_integer_arithmetic_rev : (bits(5), bits(5), bits(2), bits(1)) -> unit

function decode_rev_aarch64_instrs_integer_arithmetic_rev (Rd, Rn, opc, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'datasize = if sf == 0b1 then 64 else 32;
    container_size : {16, 32, 64} = 16;
    match opc {
      0b00 => {
          Unreachable()
      },
      0b01 => {
          container_size = 16
      },
      0b10 => {
          container_size = 32
      },
      0b11 => {
          if sf == 0b0 then {
              throw(Error_Undefined())
          };
          container_size = 64
      }
    };
    let 'container_size = container_size;
    execute_aarch64_instrs_integer_arithmetic_rev(container_size, d, datasize, n)
}

function clause __DecodeA64_DataProcReg ((pc, ([_, bitone, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 736) = {
    SEE = 736;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let opc = Slice(__opcode, 10, 2);
    let sf = Slice(__opcode, 31, 1);
    decode_rev_aarch64_instrs_integer_arithmetic_rev(Rd, Rn, opc, sf)
}

val decode_rev16_int_aarch64_instrs_integer_arithmetic_rev : (bits(5), bits(5), bits(2), bits(1)) -> unit

function decode_rev16_int_aarch64_instrs_integer_arithmetic_rev (Rd, Rn, opc, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'datasize = if sf == 0b1 then 64 else 32;
    container_size : {16, 32, 64} = 16;
    match opc {
      0b00 => {
          Unreachable()
      },
      0b01 => {
          container_size = 16
      },
      0b10 => {
          container_size = 32
      },
      0b11 => {
          if sf == 0b0 then {
              throw(Error_Undefined())
          };
          container_size = 64
      }
    };
    let 'container_size = container_size;
    execute_aarch64_instrs_integer_arithmetic_rev(container_size, d, datasize, n)
}

function clause __DecodeA64_DataProcReg ((pc, ([_, bitone, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 737) = {
    SEE = 737;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let opc = Slice(__opcode, 10, 2);
    let sf = Slice(__opcode, 31, 1);
    decode_rev16_int_aarch64_instrs_integer_arithmetic_rev(Rd, Rn, opc, sf)
}

val decode_rev32_int_aarch64_instrs_integer_arithmetic_rev : (bits(5), bits(5), bits(2), bits(1)) -> unit

function decode_rev32_int_aarch64_instrs_integer_arithmetic_rev (Rd, Rn, opc, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'datasize = if sf == 0b1 then 64 else 32;
    container_size : {16, 32, 64} = 16;
    match opc {
      0b00 => {
          Unreachable()
      },
      0b01 => {
          container_size = 16
      },
      0b10 => {
          container_size = 32
      },
      0b11 => {
          if sf == 0b0 then {
              throw(Error_Undefined())
          };
          container_size = 64
      }
    };
    let 'container_size = container_size;
    execute_aarch64_instrs_integer_arithmetic_rev(container_size, d, datasize, n)
}

function clause __DecodeA64_DataProcReg ((pc, ([bitone, bitone, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 738) = {
    SEE = 738;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let opc = Slice(__opcode, 10, 2);
    let sf = Slice(__opcode, 31, 1);
    decode_rev32_int_aarch64_instrs_integer_arithmetic_rev(Rd, Rn, opc, sf)
}

val execute_aarch64_instrs_vector_arithmetic_unary_rev : forall 'containers 'd 'datasize 'elements_per_container 'esize 'n,
  (0 <= 'n & 'n <= 31 & 'esize in {8, 16, 32, 64} & 'datasize in {64, 128} & 0 <= 'd & 'd <= 31).
  (int('containers), int('d), int('datasize), int('elements_per_container), int('esize), int('n)) -> unit

function execute_aarch64_instrs_vector_arithmetic_unary_rev (containers, d, datasize, elements_per_container, esize, n) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('datasize) = V_read(n, datasize);
    result : bits('datasize) = undefined;
    element : int = 0;
    rev_element : int = undefined;
    foreach (c from 0 to (containers - 1) by 1 in inc) {
        rev_element = element + elements_per_container - 1;
        foreach (e from 0 to (elements_per_container - 1) by 1 in inc) {
            let 'rev_element = rev_element in
              {
                  let 'element = element;
                  result = Elem_set(result, rev_element, esize, Elem_read(operand, element, esize))
              };
            element = element + 1;
            rev_element = rev_element - 1
        }
    };
    V_set(d, datasize) = result
}

val decode_rev16_advsimd_aarch64_instrs_vector_arithmetic_unary_rev : (bits(5), bits(5), bits(1), bits(2), bits(1), bits(1)) -> unit

function decode_rev16_advsimd_aarch64_instrs_vector_arithmetic_unary_rev (Rd, Rn, o0, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let op : bits(2) = o0 @ U;
    if UInt(op) + UInt(size) >= 3 then {
        throw(Error_Undefined())
    };
    container_size : {16, 32, 64} = 16;
    match op {
      0b10 => {
          container_size = 16
      },
      0b01 => {
          container_size = 32
      },
      0b00 => {
          container_size = 64
      },
      _ => ()
    };
    let 'container_size = container_size;
    let 'containers = DIV(datasize, container_size);
    let 'elements_per_container = DIV(container_size, esize);
    execute_aarch64_instrs_vector_arithmetic_unary_rev(containers, d, datasize, elements_per_container, esize, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 739) = {
    SEE = 739;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o0 = Slice(__opcode, 12, 1);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_rev16_advsimd_aarch64_instrs_vector_arithmetic_unary_rev(Rd, Rn, o0, size, U, Q)
}

val decode_rev32_advsimd_aarch64_instrs_vector_arithmetic_unary_rev : (bits(5), bits(5), bits(1), bits(2), bits(1), bits(1)) -> unit

function decode_rev32_advsimd_aarch64_instrs_vector_arithmetic_unary_rev (Rd, Rn, o0, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let op : bits(2) = o0 @ U;
    if UInt(op) + UInt(size) >= 3 then {
        throw(Error_Undefined())
    };
    container_size : {16, 32, 64} = 16;
    match op {
      0b10 => {
          container_size = 16
      },
      0b01 => {
          container_size = 32
      },
      0b00 => {
          container_size = 64
      },
      _ => ()
    };
    let 'container_size = container_size;
    let 'containers = DIV(datasize, container_size);
    let 'elements_per_container = DIV(container_size, esize);
    execute_aarch64_instrs_vector_arithmetic_unary_rev(containers, d, datasize, elements_per_container, esize, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 740) = {
    SEE = 740;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o0 = Slice(__opcode, 12, 1);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_rev32_advsimd_aarch64_instrs_vector_arithmetic_unary_rev(Rd, Rn, o0, size, U, Q)
}

val decode_rev64_advsimd_aarch64_instrs_vector_arithmetic_unary_rev : (bits(5), bits(5), bits(1), bits(2), bits(1), bits(1)) -> unit

function decode_rev64_advsimd_aarch64_instrs_vector_arithmetic_unary_rev (Rd, Rn, o0, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let op : bits(2) = o0 @ U;
    if UInt(op) + UInt(size) >= 3 then {
        throw(Error_Undefined())
    };
    container_size : {16, 32, 64} = 16;
    match op {
      0b10 => {
          container_size = 16
      },
      0b01 => {
          container_size = 32
      },
      0b00 => {
          container_size = 64
      },
      _ => ()
    };
    let 'container_size = container_size;
    let 'containers = DIV(datasize, container_size);
    let 'elements_per_container = DIV(container_size, esize);
    execute_aarch64_instrs_vector_arithmetic_unary_rev(containers, d, datasize, elements_per_container, esize, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 741) = {
    SEE = 741;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o0 = Slice(__opcode, 12, 1);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_rev64_advsimd_aarch64_instrs_vector_arithmetic_unary_rev(Rd, Rn, o0, size, U, Q)
}

val execute_aarch64_instrs_integer_flags_rmif : forall 'lsb 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'lsb & 'lsb <= 63).
  (int('lsb), bits(4), int('n)) -> unit

function execute_aarch64_instrs_integer_flags_rmif (lsb, mask, n) = {
    let tmpreg : bits(64) = X_read(n, 64);
    let tmp : bits(4) = (tmpreg @ tmpreg)[lsb + 3 .. lsb];
    if [mask[3]] == 0b1 then {
        PSTATE.N = [tmp[3]]
    };
    if [mask[2]] == 0b1 then {
        PSTATE.Z = [tmp[2]]
    };
    if [mask[1]] == 0b1 then {
        PSTATE.C = [tmp[1]]
    };
    if [mask[0]] == 0b1 then {
        PSTATE.V = [tmp[0]]
    };
    ()
}

val decode_rmif_aarch64_instrs_integer_flags_rmif : (bits(4), bits(5), bits(6), bits(1)) -> unit

function decode_rmif_aarch64_instrs_integer_flags_rmif (mask, Rn, imm6, sf) = {
    if not_bool(HaveFlagManipulateExt()) | sf != 0b1 then {
        throw(Error_Undefined())
    };
    let 'lsb = UInt(imm6);
    let 'n = UInt(Rn);
    execute_aarch64_instrs_integer_flags_rmif(lsb, mask, n)
}

function clause __DecodeA64_DataProcReg ((pc, ([bitone, bitzero, bitone, bitone, bitone, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, bitzero, bitzero, bitzero, bitzero, bitone, _, _, _, _, _, bitzero, _, _, _, _] as __opcode)) if SEE < 742) = {
    SEE = 742;
    let mask = Slice(__opcode, 0, 4);
    let Rn = Slice(__opcode, 5, 5);
    let imm6 = Slice(__opcode, 15, 6);
    let sf = Slice(__opcode, 31, 1);
    decode_rmif_aarch64_instrs_integer_flags_rmif(mask, Rn, imm6, sf)
}

val execute_aarch64_instrs_memory_single_general_range : forall 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31).
  (int('m), int('n), bits(6)) -> unit

function execute_aarch64_instrs_memory_single_general_range (m, n, operation) = {
    let address : bits(64) = if n == 31 then SP_read() else X_read(n, 64);
    let metadata : bits(64) = X_read(m, 64);
    let 'stride = SInt(metadata[59 .. 38]);
    let 'count = UInt(metadata[37 .. 22]) + 1;
    let 'length = SInt(metadata[21 .. 0]);
    reuse : int = undefined;
    if metadata[63 .. 60] == 0b0000 then {
        reuse = negate(1)
    } else {
        reuse = (32768 << (15 - UInt(metadata[63 .. 60])))
    };
    let 'reuse = reuse;
    Hint_RangePrefetch(address, length, stride, count, reuse, operation)
}

val decode_rprfm_reg_aarch64_instrs_memory_single_general_range : (bits(5), bits(5), bits(1), bits(3), bits(5), bits(2), bits(2)) -> unit

function decode_rprfm_reg_aarch64_instrs_memory_single_general_range (Rt, Rn, S, option_name, Rm, opc, size) = {
    let operation : bits(6) = (([option_name[2]] @ [option_name[0]]) @ S) @ Rt[2 .. 0];
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    execute_aarch64_instrs_memory_single_general_range(m, n, operation)
}

function clause __DecodeA64_LoadStore ((pc, ([bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitone, _, _, _, _, _, _, bitone, _, _, bitone, bitzero, _, _, _, _, _, bitone, bitone, _, _, _] as __opcode)) if SEE < 743) = {
    SEE = 743;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let S = Slice(__opcode, 12, 1);
    let option_name = Slice(__opcode, 13, 3);
    let Rm = Slice(__opcode, 16, 5);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_rprfm_reg_aarch64_instrs_memory_single_general_range(Rt, Rn, S, option_name, Rm, opc, size)
}

val execute_aarch64_instrs_vector_shift_right_narrow_logical : forall 'd 'datasize 'elements 'esize 'n 'part ('round : Bool) 'shift,
  ('part in {0, 1} & 0 <= 'n & 'n <= 31 & 'esize in {4, 8, 16, 32, 64} & 'datasize == 64 & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('n), int('part), bool('round), int('shift)) -> unit

function execute_aarch64_instrs_vector_shift_right_narrow_logical (d, datasize, elements, esize, n, part, round, shift) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('datasize * 2) = V_read(n, datasize * 2);
    result : bits('datasize) = undefined;
    element : int = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element = RShr(UInt(Elem_read(operand, e, 2 * esize)), shift, round);
        result = Elem_set(result, e, esize, element[esize - 1 .. 0])
    };
    Vpart_set(d, part, datasize) = result
}

val decode_rshrn_advsimd_aarch64_instrs_vector_shift_right_narrow_logical : (bits(5), bits(5), bits(1), bits(3), bits(4), bits(1)) -> unit

function decode_rshrn_advsimd_aarch64_instrs_vector_shift_right_narrow_logical (Rd, Rn, op, immb, immh, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if immh == 0b0000 then {
        throw(Error_See("asimdimm"))
    };
    if [immh[3]] == 0b1 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << HighestSetBit(immh));
    let 'datasize = 64;
    let 'part = UInt(Q);
    let 'elements = DIV(datasize, esize);
    let 'shift = 2 * esize - UInt(immh @ immb);
    let round : bool = op == 0b1;
    assert(constraint('esize in {4, 8, 16, 32, 64}));
    execute_aarch64_instrs_vector_shift_right_narrow_logical(d, datasize, elements, esize, n, part, round, shift)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, bitone, bitzero, bitzero, bitzero, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 744) = {
    SEE = 744;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 11, 1);
    let immb = Slice(__opcode, 16, 3);
    let immh = Slice(__opcode, 19, 4);
    let Q = Slice(__opcode, 30, 1);
    decode_rshrn_advsimd_aarch64_instrs_vector_shift_right_narrow_logical(Rd, Rn, op, immb, immh, Q)
}

val decode_shrn_advsimd_aarch64_instrs_vector_shift_right_narrow_logical : (bits(5), bits(5), bits(1), bits(3), bits(4), bits(1)) -> unit

function decode_shrn_advsimd_aarch64_instrs_vector_shift_right_narrow_logical (Rd, Rn, op, immb, immh, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if immh == 0b0000 then {
        throw(Error_See("asimdimm"))
    };
    if [immh[3]] == 0b1 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << HighestSetBit(immh));
    let 'datasize = 64;
    let 'part = UInt(Q);
    let 'elements = DIV(datasize, esize);
    let 'shift = 2 * esize - UInt(immh @ immb);
    let round : bool = op == 0b1;
    assert(constraint('esize in {4, 8, 16, 32, 64}));
    execute_aarch64_instrs_vector_shift_right_narrow_logical(d, datasize, elements, esize, n, part, round, shift)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 745) = {
    SEE = 745;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 11, 1);
    let immb = Slice(__opcode, 16, 3);
    let immh = Slice(__opcode, 19, 4);
    let Q = Slice(__opcode, 30, 1);
    decode_shrn_advsimd_aarch64_instrs_vector_shift_right_narrow_logical(Rd, Rn, op, immb, immh, Q)
}

val execute_aarch64_instrs_vector_arithmetic_binary_uniform_diff : forall ('accumulate : Bool) 'd 'datasize 'elements 'esize ('is_unsigned : Bool) 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'esize in {8, 16, 32, 64} & 'datasize in {64, 128} & 0 <= 'd & 'd <= 31).
  (bool('accumulate), int('d), int('datasize), int('elements), int('esize), int('m), int('n), bool('is_unsigned)) -> unit

function execute_aarch64_instrs_vector_arithmetic_binary_uniform_diff (accumulate, d, datasize, elements, esize, m, n, is_unsigned) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = V_read(n, datasize);
    let operand2 : bits('datasize) = V_read(m, datasize);
    element1 : int = undefined;
    element2 : int = undefined;
    absdiff : bits('esize) = undefined;
    result : bits('datasize) = if accumulate then V_read(d, datasize) else
      Zeros(datasize);
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element1 = asl_Int(Elem_read(operand1, e, esize), is_unsigned);
        element2 = asl_Int(Elem_read(operand2, e, esize), is_unsigned);
        absdiff = Abs(element1 - element2)[esize - 1 .. 0];
        result = Elem_set(result, e, esize, Elem_read(result, e, esize) + absdiff)
    };
    V_set(d, datasize) = result
}

val decode_saba_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_diff : (bits(5), bits(5), bits(1), bits(5), bits(2), bits(1), bits(1)) -> unit

function decode_saba_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_diff (Rd, Rn, ac, Rm, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let is_unsigned : bool = U == 0b1;
    let accumulate : bool = ac == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_diff(accumulate, d, datasize, elements, esize, m, n, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 746) = {
    SEE = 746;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let ac = Slice(__opcode, 11, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_saba_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_diff(Rd, Rn, ac, Rm, size, U, Q)
}

val decode_sabd_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_diff : (bits(5), bits(5), bits(1), bits(5), bits(2), bits(1), bits(1)) -> unit

function decode_sabd_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_diff (Rd, Rn, ac, Rm, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let is_unsigned : bool = U == 0b1;
    let accumulate : bool = ac == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_diff(accumulate, d, datasize, elements, esize, m, n, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitone, bitone, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 747) = {
    SEE = 747;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let ac = Slice(__opcode, 11, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_sabd_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_diff(Rd, Rn, ac, Rm, size, U, Q)
}

val decode_uaba_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_diff : (bits(5), bits(5), bits(1), bits(5), bits(2), bits(1), bits(1)) -> unit

function decode_uaba_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_diff (Rd, Rn, ac, Rm, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let is_unsigned : bool = U == 0b1;
    let accumulate : bool = ac == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_diff(accumulate, d, datasize, elements, esize, m, n, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 748) = {
    SEE = 748;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let ac = Slice(__opcode, 11, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_uaba_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_diff(Rd, Rn, ac, Rm, size, U, Q)
}

val decode_uabd_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_diff : (bits(5), bits(5), bits(1), bits(5), bits(2), bits(1), bits(1)) -> unit

function decode_uabd_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_diff (Rd, Rn, ac, Rm, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let is_unsigned : bool = U == 0b1;
    let accumulate : bool = ac == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_diff(accumulate, d, datasize, elements, esize, m, n, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitone, bitone, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 749) = {
    SEE = 749;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let ac = Slice(__opcode, 11, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_uabd_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_diff(Rd, Rn, ac, Rm, size, U, Q)
}

val execute_aarch64_instrs_vector_arithmetic_binary_disparate_diff : forall ('accumulate : Bool) 'd 'datasize 'elements 'esize ('is_unsigned : Bool) 'm 'n 'part,
  ('part in {0, 1} & 0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'esize in {8, 16, 32, 64} & 'datasize == 64 & 0 <= 'd & 'd <= 31).
  (bool('accumulate), int('d), int('datasize), int('elements), int('esize), int('m), int('n), int('part), bool('is_unsigned)) -> unit

function execute_aarch64_instrs_vector_arithmetic_binary_disparate_diff (accumulate, d, datasize, elements, esize, m, n, part, is_unsigned) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = Vpart_read(n, part, datasize);
    let operand2 : bits('datasize) = Vpart_read(m, part, datasize);
    element1 : int = undefined;
    element2 : int = undefined;
    absdiff : bits(2 * 'esize) = undefined;
    result : bits(2 * 'datasize) = if accumulate then V_read(d, 2 * datasize)
    else
      Zeros(2 * datasize);
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element1 = asl_Int(Elem_read(operand1, e, esize), is_unsigned);
        element2 = asl_Int(Elem_read(operand2, e, esize), is_unsigned);
        absdiff = Abs(element1 - element2)[2 * esize - 1 .. 0];
        result = Elem_set(result, e, 2 * esize, Elem_read(result, e, 2 * esize) + absdiff)
    };
    V_set(d, 2 * datasize) = result
}

val decode_sabal_advsimd_aarch64_instrs_vector_arithmetic_binary_disparate_diff : (bits(5), bits(5), bits(1), bits(5), bits(2), bits(1), bits(1)) -> unit

function decode_sabal_advsimd_aarch64_instrs_vector_arithmetic_binary_disparate_diff (Rd, Rn, op, Rm, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    let 'datasize = 64;
    let 'part = UInt(Q);
    let 'elements = DIV(datasize, esize);
    let accumulate : bool = op == 0b0;
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_disparate_diff(accumulate, d, datasize, elements, esize, m, n, part, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitone, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 750) = {
    SEE = 750;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 13, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_sabal_advsimd_aarch64_instrs_vector_arithmetic_binary_disparate_diff(Rd, Rn, op, Rm, size, U, Q)
}

val decode_sabdl_advsimd_aarch64_instrs_vector_arithmetic_binary_disparate_diff : (bits(5), bits(5), bits(1), bits(5), bits(2), bits(1), bits(1)) -> unit

function decode_sabdl_advsimd_aarch64_instrs_vector_arithmetic_binary_disparate_diff (Rd, Rn, op, Rm, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    let 'datasize = 64;
    let 'part = UInt(Q);
    let 'elements = DIV(datasize, esize);
    let accumulate : bool = op == 0b0;
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_disparate_diff(accumulate, d, datasize, elements, esize, m, n, part, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitone, bitone, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 751) = {
    SEE = 751;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 13, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_sabdl_advsimd_aarch64_instrs_vector_arithmetic_binary_disparate_diff(Rd, Rn, op, Rm, size, U, Q)
}

val decode_uabal_advsimd_aarch64_instrs_vector_arithmetic_binary_disparate_diff : (bits(5), bits(5), bits(1), bits(5), bits(2), bits(1), bits(1)) -> unit

function decode_uabal_advsimd_aarch64_instrs_vector_arithmetic_binary_disparate_diff (Rd, Rn, op, Rm, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    let 'datasize = 64;
    let 'part = UInt(Q);
    let 'elements = DIV(datasize, esize);
    let accumulate : bool = op == 0b0;
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_disparate_diff(accumulate, d, datasize, elements, esize, m, n, part, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitone, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 752) = {
    SEE = 752;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 13, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_uabal_advsimd_aarch64_instrs_vector_arithmetic_binary_disparate_diff(Rd, Rn, op, Rm, size, U, Q)
}

val decode_uabdl_advsimd_aarch64_instrs_vector_arithmetic_binary_disparate_diff : (bits(5), bits(5), bits(1), bits(5), bits(2), bits(1), bits(1)) -> unit

function decode_uabdl_advsimd_aarch64_instrs_vector_arithmetic_binary_disparate_diff (Rd, Rn, op, Rm, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    let 'datasize = 64;
    let 'part = UInt(Q);
    let 'elements = DIV(datasize, esize);
    let accumulate : bool = op == 0b0;
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_disparate_diff(accumulate, d, datasize, elements, esize, m, n, part, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitone, bitone, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 753) = {
    SEE = 753;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 13, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_uabdl_advsimd_aarch64_instrs_vector_arithmetic_binary_disparate_diff(Rd, Rn, op, Rm, size, U, Q)
}

val execute_aarch64_instrs_vector_arithmetic_unary_add_pairwise : forall ('acc : Bool) 'd 'datasize 'elements 'esize ('is_unsigned : Bool) 'n,
  (0 <= 'n & 'n <= 31 & 'esize in {8, 16, 32, 64} & 'datasize in {64, 128} & 0 <= 'd & 'd <= 31).
  (bool('acc), int('d), int('datasize), int('elements), int('esize), int('n), bool('is_unsigned)) -> unit

function execute_aarch64_instrs_vector_arithmetic_unary_add_pairwise (acc, d, datasize, elements, esize, n, is_unsigned) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('datasize) = V_read(n, datasize);
    result : bits('datasize) = undefined;
    sum : bits(2 * 'esize) = undefined;
    op1 : int = undefined;
    op2 : int = undefined;
    if acc then {
        result = V_read(d, datasize)
    };
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        op1 = asl_Int(Elem_read(operand, 2 * e + 0, esize), is_unsigned);
        op2 = asl_Int(Elem_read(operand, 2 * e + 1, esize), is_unsigned);
        sum = (op1 + op2)[2 * esize - 1 .. 0];
        if acc then {
            result = Elem_set(result, e, 2 * esize, Elem_read(result, e, 2 * esize) + sum)
        } else {
            result = Elem_set(result, e, 2 * esize, sum)
        }
    };
    V_set(d, datasize) = result
}

val decode_sadalp_advsimd_aarch64_instrs_vector_arithmetic_unary_add_pairwise : (bits(5), bits(5), bits(1), bits(2), bits(1), bits(1)) -> unit

function decode_sadalp_advsimd_aarch64_instrs_vector_arithmetic_unary_add_pairwise (Rd, Rn, op, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, 2 * esize);
    let acc : bool = op == 0b1;
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_add_pairwise(acc, d, datasize, elements, esize, n, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 754) = {
    SEE = 754;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 14, 1);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_sadalp_advsimd_aarch64_instrs_vector_arithmetic_unary_add_pairwise(Rd, Rn, op, size, U, Q)
}

val decode_saddlp_advsimd_aarch64_instrs_vector_arithmetic_unary_add_pairwise : (bits(5), bits(5), bits(1), bits(2), bits(1), bits(1)) -> unit

function decode_saddlp_advsimd_aarch64_instrs_vector_arithmetic_unary_add_pairwise (Rd, Rn, op, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, 2 * esize);
    let acc : bool = op == 0b1;
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_add_pairwise(acc, d, datasize, elements, esize, n, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 755) = {
    SEE = 755;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 14, 1);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_saddlp_advsimd_aarch64_instrs_vector_arithmetic_unary_add_pairwise(Rd, Rn, op, size, U, Q)
}

val decode_uadalp_advsimd_aarch64_instrs_vector_arithmetic_unary_add_pairwise : (bits(5), bits(5), bits(1), bits(2), bits(1), bits(1)) -> unit

function decode_uadalp_advsimd_aarch64_instrs_vector_arithmetic_unary_add_pairwise (Rd, Rn, op, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, 2 * esize);
    let acc : bool = op == 0b1;
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_add_pairwise(acc, d, datasize, elements, esize, n, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 756) = {
    SEE = 756;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 14, 1);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_uadalp_advsimd_aarch64_instrs_vector_arithmetic_unary_add_pairwise(Rd, Rn, op, size, U, Q)
}

val decode_uaddlp_advsimd_aarch64_instrs_vector_arithmetic_unary_add_pairwise : (bits(5), bits(5), bits(1), bits(2), bits(1), bits(1)) -> unit

function decode_uaddlp_advsimd_aarch64_instrs_vector_arithmetic_unary_add_pairwise (Rd, Rn, op, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, 2 * esize);
    let acc : bool = op == 0b1;
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_add_pairwise(acc, d, datasize, elements, esize, n, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 757) = {
    SEE = 757;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 14, 1);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_uaddlp_advsimd_aarch64_instrs_vector_arithmetic_unary_add_pairwise(Rd, Rn, op, size, U, Q)
}

val execute_aarch64_instrs_vector_arithmetic_binary_disparate_add_sub_long : forall 'd 'datasize 'elements 'esize ('is_unsigned : Bool) 'm 'n 'part ('sub_op : Bool),
  ('part in {0, 1} & 0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'esize in {8, 16, 32, 64} & 'datasize == 64 & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('m), int('n), int('part), bool('sub_op), bool('is_unsigned)) -> unit

function execute_aarch64_instrs_vector_arithmetic_binary_disparate_add_sub_long (d, datasize, elements, esize, m, n, part, sub_op, is_unsigned) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = Vpart_read(n, part, datasize);
    let operand2 : bits('datasize) = Vpart_read(m, part, datasize);
    result : bits(2 * 'datasize) = undefined;
    element1 : int = undefined;
    element2 : int = undefined;
    sum : int = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element1 = asl_Int(Elem_read(operand1, e, esize), is_unsigned);
        element2 = asl_Int(Elem_read(operand2, e, esize), is_unsigned);
        if sub_op then {
            sum = element1 - element2
        } else {
            sum = element1 + element2
        };
        result = Elem_set(result, e, 2 * esize, sum[2 * esize - 1 .. 0])
    };
    V_set(d, 2 * datasize) = result
}

val decode_saddl_advsimd_aarch64_instrs_vector_arithmetic_binary_disparate_add_sub_long : (bits(5), bits(5), bits(1), bits(5), bits(2), bits(1), bits(1)) -> unit

function decode_saddl_advsimd_aarch64_instrs_vector_arithmetic_binary_disparate_add_sub_long (Rd, Rn, o1, Rm, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    let 'datasize = 64;
    let 'part = UInt(Q);
    let 'elements = DIV(datasize, esize);
    let sub_op : bool = o1 == 0b1;
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_disparate_add_sub_long(d, datasize, elements, esize, m, n, part, sub_op, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 758) = {
    SEE = 758;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 13, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_saddl_advsimd_aarch64_instrs_vector_arithmetic_binary_disparate_add_sub_long(Rd, Rn, o1, Rm, size, U, Q)
}

val decode_ssubl_advsimd_aarch64_instrs_vector_arithmetic_binary_disparate_add_sub_long : (bits(5), bits(5), bits(1), bits(5), bits(2), bits(1), bits(1)) -> unit

function decode_ssubl_advsimd_aarch64_instrs_vector_arithmetic_binary_disparate_add_sub_long (Rd, Rn, o1, Rm, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    let 'datasize = 64;
    let 'part = UInt(Q);
    let 'elements = DIV(datasize, esize);
    let sub_op : bool = o1 == 0b1;
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_disparate_add_sub_long(d, datasize, elements, esize, m, n, part, sub_op, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 759) = {
    SEE = 759;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 13, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_ssubl_advsimd_aarch64_instrs_vector_arithmetic_binary_disparate_add_sub_long(Rd, Rn, o1, Rm, size, U, Q)
}

val decode_uaddl_advsimd_aarch64_instrs_vector_arithmetic_binary_disparate_add_sub_long : (bits(5), bits(5), bits(1), bits(5), bits(2), bits(1), bits(1)) -> unit

function decode_uaddl_advsimd_aarch64_instrs_vector_arithmetic_binary_disparate_add_sub_long (Rd, Rn, o1, Rm, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    let 'datasize = 64;
    let 'part = UInt(Q);
    let 'elements = DIV(datasize, esize);
    let sub_op : bool = o1 == 0b1;
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_disparate_add_sub_long(d, datasize, elements, esize, m, n, part, sub_op, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 760) = {
    SEE = 760;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 13, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_uaddl_advsimd_aarch64_instrs_vector_arithmetic_binary_disparate_add_sub_long(Rd, Rn, o1, Rm, size, U, Q)
}

val decode_usubl_advsimd_aarch64_instrs_vector_arithmetic_binary_disparate_add_sub_long : (bits(5), bits(5), bits(1), bits(5), bits(2), bits(1), bits(1)) -> unit

function decode_usubl_advsimd_aarch64_instrs_vector_arithmetic_binary_disparate_add_sub_long (Rd, Rn, o1, Rm, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    let 'datasize = 64;
    let 'part = UInt(Q);
    let 'elements = DIV(datasize, esize);
    let sub_op : bool = o1 == 0b1;
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_disparate_add_sub_long(d, datasize, elements, esize, m, n, part, sub_op, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 761) = {
    SEE = 761;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 13, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_usubl_advsimd_aarch64_instrs_vector_arithmetic_binary_disparate_add_sub_long(Rd, Rn, o1, Rm, size, U, Q)
}

val execute_aarch64_instrs_vector_reduce_add_long : forall 'd 'datasize 'elements 'esize ('is_unsigned : Bool) 'n,
  (0 <= 'n & 'n <= 31 & 'esize in {8, 16, 32, 64} & 'datasize in {64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('n), bool('is_unsigned)) -> unit

function execute_aarch64_instrs_vector_reduce_add_long (d, datasize, elements, esize, n, is_unsigned) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('datasize) = V_read(n, datasize);
    sum : int = asl_Int(Elem_read(operand, 0, esize), is_unsigned);
    foreach (e from 1 to (elements - 1) by 1 in inc) {
        sum = sum + asl_Int(Elem_read(operand, e, esize), is_unsigned)
    };
    let 'sum = sum;
    V_set(d, 2 * esize) = sum[2 * esize - 1 .. 0]
}

val decode_saddlv_advsimd_aarch64_instrs_vector_reduce_add_long : (bits(5), bits(5), bits(2), bits(1), bits(1)) -> unit

function decode_saddlv_advsimd_aarch64_instrs_vector_reduce_add_long (Rd, Rn, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (size @ Q) == 0b100 then {
        throw(Error_Undefined())
    };
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_reduce_add_long(d, datasize, elements, esize, n, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 762) = {
    SEE = 762;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_saddlv_advsimd_aarch64_instrs_vector_reduce_add_long(Rd, Rn, size, U, Q)
}

val decode_uaddlv_advsimd_aarch64_instrs_vector_reduce_add_long : (bits(5), bits(5), bits(2), bits(1), bits(1)) -> unit

function decode_uaddlv_advsimd_aarch64_instrs_vector_reduce_add_long (Rd, Rn, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (size @ Q) == 0b100 then {
        throw(Error_Undefined())
    };
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_reduce_add_long(d, datasize, elements, esize, n, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 763) = {
    SEE = 763;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_uaddlv_advsimd_aarch64_instrs_vector_reduce_add_long(Rd, Rn, size, U, Q)
}

val execute_aarch64_instrs_vector_arithmetic_binary_disparate_add_sub_wide : forall 'd 'datasize 'elements 'esize ('is_unsigned : Bool) 'm 'n 'part ('sub_op : Bool),
  ('part in {0, 1} & 0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'esize in {8, 16, 32, 64} & 'datasize == 64 & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('m), int('n), int('part), bool('sub_op), bool('is_unsigned)) -> unit

function execute_aarch64_instrs_vector_arithmetic_binary_disparate_add_sub_wide (d, datasize, elements, esize, m, n, part, sub_op, is_unsigned) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits(2 * 'datasize) = V_read(n, 2 * datasize);
    let operand2 : bits('datasize) = Vpart_read(m, part, datasize);
    result : bits(2 * 'datasize) = undefined;
    element1 : int = undefined;
    element2 : int = undefined;
    sum : int = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element1 = asl_Int(Elem_read(operand1, e, 2 * esize), is_unsigned);
        element2 = asl_Int(Elem_read(operand2, e, esize), is_unsigned);
        if sub_op then {
            sum = element1 - element2
        } else {
            sum = element1 + element2
        };
        result = Elem_set(result, e, 2 * esize, sum[2 * esize - 1 .. 0])
    };
    V_set(d, 2 * datasize) = result
}

val decode_saddw_advsimd_aarch64_instrs_vector_arithmetic_binary_disparate_add_sub_wide : (bits(5), bits(5), bits(1), bits(5), bits(2), bits(1), bits(1)) -> unit

function decode_saddw_advsimd_aarch64_instrs_vector_arithmetic_binary_disparate_add_sub_wide (Rd, Rn, o1, Rm, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    let 'datasize = 64;
    let 'part = UInt(Q);
    let 'elements = DIV(datasize, esize);
    let sub_op : bool = o1 == 0b1;
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_disparate_add_sub_wide(d, datasize, elements, esize, m, n, part, sub_op, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 764) = {
    SEE = 764;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 13, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_saddw_advsimd_aarch64_instrs_vector_arithmetic_binary_disparate_add_sub_wide(Rd, Rn, o1, Rm, size, U, Q)
}

val decode_ssubw_advsimd_aarch64_instrs_vector_arithmetic_binary_disparate_add_sub_wide : (bits(5), bits(5), bits(1), bits(5), bits(2), bits(1), bits(1)) -> unit

function decode_ssubw_advsimd_aarch64_instrs_vector_arithmetic_binary_disparate_add_sub_wide (Rd, Rn, o1, Rm, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    let 'datasize = 64;
    let 'part = UInt(Q);
    let 'elements = DIV(datasize, esize);
    let sub_op : bool = o1 == 0b1;
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_disparate_add_sub_wide(d, datasize, elements, esize, m, n, part, sub_op, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitzero, bitone, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 765) = {
    SEE = 765;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 13, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_ssubw_advsimd_aarch64_instrs_vector_arithmetic_binary_disparate_add_sub_wide(Rd, Rn, o1, Rm, size, U, Q)
}

val decode_uaddw_advsimd_aarch64_instrs_vector_arithmetic_binary_disparate_add_sub_wide : (bits(5), bits(5), bits(1), bits(5), bits(2), bits(1), bits(1)) -> unit

function decode_uaddw_advsimd_aarch64_instrs_vector_arithmetic_binary_disparate_add_sub_wide (Rd, Rn, o1, Rm, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    let 'datasize = 64;
    let 'part = UInt(Q);
    let 'elements = DIV(datasize, esize);
    let sub_op : bool = o1 == 0b1;
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_disparate_add_sub_wide(d, datasize, elements, esize, m, n, part, sub_op, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 766) = {
    SEE = 766;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 13, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_uaddw_advsimd_aarch64_instrs_vector_arithmetic_binary_disparate_add_sub_wide(Rd, Rn, o1, Rm, size, U, Q)
}

val decode_usubw_advsimd_aarch64_instrs_vector_arithmetic_binary_disparate_add_sub_wide : (bits(5), bits(5), bits(1), bits(5), bits(2), bits(1), bits(1)) -> unit

function decode_usubw_advsimd_aarch64_instrs_vector_arithmetic_binary_disparate_add_sub_wide (Rd, Rn, o1, Rm, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    let 'datasize = 64;
    let 'part = UInt(Q);
    let 'elements = DIV(datasize, esize);
    let sub_op : bool = o1 == 0b1;
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_disparate_add_sub_wide(d, datasize, elements, esize, m, n, part, sub_op, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitzero, bitone, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 767) = {
    SEE = 767;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 13, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_usubw_advsimd_aarch64_instrs_vector_arithmetic_binary_disparate_add_sub_wide(Rd, Rn, o1, Rm, size, U, Q)
}

val execute_aarch64_instrs_system_barriers_sb : unit -> unit

function execute_aarch64_instrs_system_barriers_sb () = {
    SpeculationBarrier()
}

val decode_sb_aarch64_instrs_system_barriers_sb : (bits(2), bits(4)) -> unit

function decode_sb_aarch64_instrs_system_barriers_sb (opc, CRm) = {
    if not_bool(HaveSBExt()) then {
        throw(Error_Undefined())
    };
    execute_aarch64_instrs_system_barriers_sb()
}

function clause __DecodeA64_BranchExcSys ((pc, (0b11010101000000110011000011111111 as __opcode)) if SEE < 768) = {
    SEE = 768;
    let opc = Slice(__opcode, 5, 2);
    let CRm = Slice(__opcode, 8, 4);
    if (([__opcode[8]] != 0b0 | [__opcode[9]] != 0b0) | [__opcode[10]] != 0b0) | [__opcode[11]] != 0b0 then {
        throw(Error_ConstrainedUnpredictable())
    } else {
        decode_sb_aarch64_instrs_system_barriers_sb(opc, CRm)
    }
}

val execute_aarch64_instrs_vector_shift_conv_int_sisd : forall 'd 'datasize 'elements 'esize 'fracbits ('is_unsigned : Bool) 'n,
  (0 <= 'n & 'n <= 31 & 'esize in {16, 32, 64} & 'datasize in {16, 32, 64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('fracbits), int('n), FPRounding, bool('is_unsigned)) -> unit

function execute_aarch64_instrs_vector_shift_conv_int_sisd (d, datasize, elements, esize, fracbits, n, rounding, is_unsigned) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('datasize) = V_read(n, datasize);
    element : bits('esize) = undefined;
    let fpcr : FPCRType = FPCR_read();
    let merge : bool = elements == 1 & IsMerging(fpcr);
    result : bits(128) = if merge then V_read(d, 128) else Zeros(128);
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element = Elem_read(operand, e, esize);
        result = Elem_set(result, e, esize, FixedToFP(element, fracbits, is_unsigned, fpcr, rounding, esize))
    };
    V_set(d, 128) = result
}

val decode_scvtf_advsimd_fix_aarch64_instrs_vector_shift_conv_int_sisd : (bits(5), bits(5), bits(3), bits(4), bits(1)) -> unit

function decode_scvtf_advsimd_fix_aarch64_instrs_vector_shift_conv_int_sisd (Rd, Rn, immb, immh, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (match immh {
      [bitzero, bitzero, bitzero, _] => true,
      _ => false
    }) : bool | (match immh {
      [bitzero, bitzero, bitone, _] => true,
      _ => false
    }) : bool & not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'esize = if (match immh {
      [bitone, _, _, _] => true,
      _ => false
    }) : bool then
      64
    else
      if (match immh {
        [bitzero, bitone, _, _] => true,
        _ => false
      }) : bool then
        32
      else
        16;
    let 'datasize = esize;
    let 'elements = 1;
    let 'fracbits = esize * 2 - UInt(immh @ immb);
    let is_unsigned : bool = U == 0b1;
    let rounding : FPRounding = FPRoundingMode(FPCR_read());
    execute_aarch64_instrs_vector_shift_conv_int_sisd(d, datasize, elements, esize, fracbits, n, rounding, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, bitone, bitone, bitone, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 769) = {
    SEE = 769;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let immb = Slice(__opcode, 16, 3);
    let immh = Slice(__opcode, 19, 4);
    let U = Slice(__opcode, 29, 1);
    decode_scvtf_advsimd_fix_aarch64_instrs_vector_shift_conv_int_sisd(Rd, Rn, immb, immh, U)
}

val decode_scvtf_advsimd_fix_aarch64_instrs_vector_shift_conv_int_simd : (bits(5), bits(5), bits(3), bits(4), bits(1), bits(1)) -> unit

function decode_scvtf_advsimd_fix_aarch64_instrs_vector_shift_conv_int_simd (Rd, Rn, immb, immh, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if immh == 0b0000 then {
        throw(Error_See("asimdimm"))
    };
    if (match immh {
      [bitzero, bitzero, bitzero, _] => true,
      _ => false
    }) : bool | (match immh {
      [bitzero, bitzero, bitone, _] => true,
      _ => false
    }) : bool & not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    if ([immh[3]] @ Q) == 0b10 then {
        throw(Error_Undefined())
    };
    let 'esize = if (match immh {
      [bitone, _, _, _] => true,
      _ => false
    }) : bool then
      64
    else
      if (match immh {
        [bitzero, bitone, _, _] => true,
        _ => false
      }) : bool then
        32
      else
        16;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let 'fracbits = esize * 2 - UInt(immh @ immb);
    let is_unsigned : bool = U == 0b1;
    let rounding : FPRounding = FPRoundingMode(FPCR_read());
    execute_aarch64_instrs_vector_shift_conv_int_sisd(d, datasize, elements, esize, fracbits, n, rounding, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, bitone, bitone, bitone, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 770) = {
    SEE = 770;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let immb = Slice(__opcode, 16, 3);
    let immh = Slice(__opcode, 19, 4);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_scvtf_advsimd_fix_aarch64_instrs_vector_shift_conv_int_simd(Rd, Rn, immb, immh, U, Q)
}

val decode_ucvtf_advsimd_fix_aarch64_instrs_vector_shift_conv_int_sisd : (bits(5), bits(5), bits(3), bits(4), bits(1)) -> unit

function decode_ucvtf_advsimd_fix_aarch64_instrs_vector_shift_conv_int_sisd (Rd, Rn, immb, immh, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (match immh {
      [bitzero, bitzero, bitzero, _] => true,
      _ => false
    }) : bool | (match immh {
      [bitzero, bitzero, bitone, _] => true,
      _ => false
    }) : bool & not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'esize = if (match immh {
      [bitone, _, _, _] => true,
      _ => false
    }) : bool then
      64
    else
      if (match immh {
        [bitzero, bitone, _, _] => true,
        _ => false
      }) : bool then
        32
      else
        16;
    let 'datasize = esize;
    let 'elements = 1;
    let 'fracbits = esize * 2 - UInt(immh @ immb);
    let is_unsigned : bool = U == 0b1;
    let rounding : FPRounding = FPRoundingMode(FPCR_read());
    execute_aarch64_instrs_vector_shift_conv_int_sisd(d, datasize, elements, esize, fracbits, n, rounding, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, bitone, bitone, bitone, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 771) = {
    SEE = 771;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let immb = Slice(__opcode, 16, 3);
    let immh = Slice(__opcode, 19, 4);
    let U = Slice(__opcode, 29, 1);
    decode_ucvtf_advsimd_fix_aarch64_instrs_vector_shift_conv_int_sisd(Rd, Rn, immb, immh, U)
}

val decode_ucvtf_advsimd_fix_aarch64_instrs_vector_shift_conv_int_simd : (bits(5), bits(5), bits(3), bits(4), bits(1), bits(1)) -> unit

function decode_ucvtf_advsimd_fix_aarch64_instrs_vector_shift_conv_int_simd (Rd, Rn, immb, immh, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if immh == 0b0000 then {
        throw(Error_See("asimdimm"))
    };
    if (match immh {
      [bitzero, bitzero, bitzero, _] => true,
      _ => false
    }) : bool | (match immh {
      [bitzero, bitzero, bitone, _] => true,
      _ => false
    }) : bool & not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    if ([immh[3]] @ Q) == 0b10 then {
        throw(Error_Undefined())
    };
    let 'esize = if (match immh {
      [bitone, _, _, _] => true,
      _ => false
    }) : bool then
      64
    else
      if (match immh {
        [bitzero, bitone, _, _] => true,
        _ => false
      }) : bool then
        32
      else
        16;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let 'fracbits = esize * 2 - UInt(immh @ immb);
    let is_unsigned : bool = U == 0b1;
    let rounding : FPRounding = FPRoundingMode(FPCR_read());
    execute_aarch64_instrs_vector_shift_conv_int_sisd(d, datasize, elements, esize, fracbits, n, rounding, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, bitone, bitone, bitone, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 772) = {
    SEE = 772;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let immb = Slice(__opcode, 16, 3);
    let immh = Slice(__opcode, 19, 4);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_ucvtf_advsimd_fix_aarch64_instrs_vector_shift_conv_int_simd(Rd, Rn, immb, immh, U, Q)
}

val execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_int_sisd : forall 'd 'datasize 'elements 'esize ('is_unsigned : Bool) 'n,
  (0 <= 'n & 'n <= 31 & 'esize in {16, 32, 64} & 'datasize in {16, 32, 64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('n), bool('is_unsigned)) -> unit

function execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_int_sisd (d, datasize, elements, esize, n, is_unsigned) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('datasize) = V_read(n, datasize);
    let fpcr : FPCRType = FPCR_read();
    let merge : bool = elements == 1 & IsMerging(fpcr);
    result : bits(128) = if merge then V_read(d, 128) else Zeros(128);
    let rounding : FPRounding = FPRoundingMode(fpcr);
    element : bits('esize) = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element = Elem_read(operand, e, esize);
        result = Elem_set(result, e, esize, FixedToFP(element, 0, is_unsigned, fpcr, rounding, esize))
    };
    V_set(d, 128) = result
}

val decode_scvtf_advsimd_int_aarch64_instrs_vector_arithmetic_unary_fp16_conv_int_sisd : (bits(5), bits(5), bits(1)) -> unit

function decode_scvtf_advsimd_int_aarch64_instrs_vector_arithmetic_unary_fp16_conv_int_sisd (Rd, Rn, U) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = 16;
    let 'datasize = esize;
    let 'elements = 1;
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_int_sisd(d, datasize, elements, esize, n, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 773) = {
    SEE = 773;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let U = Slice(__opcode, 29, 1);
    decode_scvtf_advsimd_int_aarch64_instrs_vector_arithmetic_unary_fp16_conv_int_sisd(Rd, Rn, U)
}

val decode_scvtf_advsimd_int_aarch64_instrs_vector_arithmetic_unary_float_conv_int_sisd : (bits(5), bits(5), bits(1), bits(1)) -> unit

function decode_scvtf_advsimd_int_aarch64_instrs_vector_arithmetic_unary_float_conv_int_sisd (Rd, Rn, sz, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = (32 << UInt(sz));
    let 'datasize = esize;
    let 'elements = 1;
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_int_sisd(d, datasize, elements, esize, n, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 774) = {
    SEE = 774;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let sz = Slice(__opcode, 22, 1);
    let U = Slice(__opcode, 29, 1);
    decode_scvtf_advsimd_int_aarch64_instrs_vector_arithmetic_unary_float_conv_int_sisd(Rd, Rn, sz, U)
}

val decode_scvtf_advsimd_int_aarch64_instrs_vector_arithmetic_unary_fp16_conv_int_simd : (bits(5), bits(5), bits(1), bits(1)) -> unit

function decode_scvtf_advsimd_int_aarch64_instrs_vector_arithmetic_unary_fp16_conv_int_simd (Rd, Rn, U, Q) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = 16;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_int_sisd(d, datasize, elements, esize, n, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 775) = {
    SEE = 775;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_scvtf_advsimd_int_aarch64_instrs_vector_arithmetic_unary_fp16_conv_int_simd(Rd, Rn, U, Q)
}

val decode_scvtf_advsimd_int_aarch64_instrs_vector_arithmetic_unary_float_conv_int_simd : (bits(5), bits(5), bits(1), bits(1), bits(1)) -> unit

function decode_scvtf_advsimd_int_aarch64_instrs_vector_arithmetic_unary_float_conv_int_simd (Rd, Rn, sz, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    };
    let 'esize = (32 << UInt(sz));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_int_sisd(d, datasize, elements, esize, n, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 776) = {
    SEE = 776;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let sz = Slice(__opcode, 22, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_scvtf_advsimd_int_aarch64_instrs_vector_arithmetic_unary_float_conv_int_simd(Rd, Rn, sz, U, Q)
}

val decode_ucvtf_advsimd_int_aarch64_instrs_vector_arithmetic_unary_fp16_conv_int_sisd : (bits(5), bits(5), bits(1)) -> unit

function decode_ucvtf_advsimd_int_aarch64_instrs_vector_arithmetic_unary_fp16_conv_int_sisd (Rd, Rn, U) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = 16;
    let 'datasize = esize;
    let 'elements = 1;
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_int_sisd(d, datasize, elements, esize, n, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 777) = {
    SEE = 777;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let U = Slice(__opcode, 29, 1);
    decode_ucvtf_advsimd_int_aarch64_instrs_vector_arithmetic_unary_fp16_conv_int_sisd(Rd, Rn, U)
}

val decode_ucvtf_advsimd_int_aarch64_instrs_vector_arithmetic_unary_float_conv_int_sisd : (bits(5), bits(5), bits(1), bits(1)) -> unit

function decode_ucvtf_advsimd_int_aarch64_instrs_vector_arithmetic_unary_float_conv_int_sisd (Rd, Rn, sz, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = (32 << UInt(sz));
    let 'datasize = esize;
    let 'elements = 1;
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_int_sisd(d, datasize, elements, esize, n, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 778) = {
    SEE = 778;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let sz = Slice(__opcode, 22, 1);
    let U = Slice(__opcode, 29, 1);
    decode_ucvtf_advsimd_int_aarch64_instrs_vector_arithmetic_unary_float_conv_int_sisd(Rd, Rn, sz, U)
}

val decode_ucvtf_advsimd_int_aarch64_instrs_vector_arithmetic_unary_fp16_conv_int_simd : (bits(5), bits(5), bits(1), bits(1)) -> unit

function decode_ucvtf_advsimd_int_aarch64_instrs_vector_arithmetic_unary_fp16_conv_int_simd (Rd, Rn, U, Q) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = 16;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_int_sisd(d, datasize, elements, esize, n, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 779) = {
    SEE = 779;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_ucvtf_advsimd_int_aarch64_instrs_vector_arithmetic_unary_fp16_conv_int_simd(Rd, Rn, U, Q)
}

val decode_ucvtf_advsimd_int_aarch64_instrs_vector_arithmetic_unary_float_conv_int_simd : (bits(5), bits(5), bits(1), bits(1), bits(1)) -> unit

function decode_ucvtf_advsimd_int_aarch64_instrs_vector_arithmetic_unary_float_conv_int_simd (Rd, Rn, sz, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    };
    let 'esize = (32 << UInt(sz));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_int_sisd(d, datasize, elements, esize, n, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, bitzero, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 780) = {
    SEE = 780;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let sz = Slice(__opcode, 22, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_ucvtf_advsimd_int_aarch64_instrs_vector_arithmetic_unary_float_conv_int_simd(Rd, Rn, sz, U, Q)
}

val execute_aarch64_instrs_integer_arithmetic_div : forall 'd 'datasize ('is_unsigned : Bool) 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'datasize in {32, 64} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('m), int('n), bool('is_unsigned)) -> unit

function execute_aarch64_instrs_integer_arithmetic_div (d, datasize, m, n, is_unsigned) = {
    let operand1 : bits('datasize) = X_read(n, datasize);
    let operand2 : bits('datasize) = X_read(m, datasize);
    result : int = undefined;
    if IsZero(operand2) then {
        result = 0
    } else {
        result = RoundTowardsZero(Real(asl_Int(operand1, is_unsigned)) / Real(asl_Int(operand2, is_unsigned)))
    };
    let 'result = result;
    X_set(d, datasize) = result[datasize - 1 .. 0]
}

val decode_sdiv_aarch64_instrs_integer_arithmetic_div : (bits(5), bits(5), bits(1), bits(5), bits(1)) -> unit

function decode_sdiv_aarch64_instrs_integer_arithmetic_div (Rd, Rn, o1, Rm, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'datasize = if sf == 0b1 then 64 else 32;
    let is_unsigned : bool = o1 == 0b0;
    execute_aarch64_instrs_integer_arithmetic_div(d, datasize, m, n, is_unsigned)
}

function clause __DecodeA64_DataProcReg ((pc, ([_, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, bitzero, bitzero, bitzero, bitzero, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 781) = {
    SEE = 781;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 10, 1);
    let Rm = Slice(__opcode, 16, 5);
    let sf = Slice(__opcode, 31, 1);
    decode_sdiv_aarch64_instrs_integer_arithmetic_div(Rd, Rn, o1, Rm, sf)
}

val decode_udiv_aarch64_instrs_integer_arithmetic_div : (bits(5), bits(5), bits(1), bits(5), bits(1)) -> unit

function decode_udiv_aarch64_instrs_integer_arithmetic_div (Rd, Rn, o1, Rm, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'datasize = if sf == 0b1 then 64 else 32;
    let is_unsigned : bool = o1 == 0b0;
    execute_aarch64_instrs_integer_arithmetic_div(d, datasize, m, n, is_unsigned)
}

function clause __DecodeA64_DataProcReg ((pc, ([_, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 782) = {
    SEE = 782;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 10, 1);
    let Rm = Slice(__opcode, 16, 5);
    let sf = Slice(__opcode, 31, 1);
    decode_udiv_aarch64_instrs_integer_arithmetic_div(Rd, Rn, o1, Rm, sf)
}

val execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_dotp : forall 'd 'datasize 'elements 'esize ('is_signed : Bool) 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'esize in {8, 16, 32, 64} & 'datasize in {64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('m), int('n), bool('is_signed)) -> unit

function execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_dotp (d, datasize, elements, esize, m, n, is_signed) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = V_read(n, datasize);
    let operand2 : bits('datasize) = V_read(m, datasize);
    result : bits('datasize) = V_read(d, datasize);
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        res : int = 0;
        element1 : int = undefined;
        element2 : int = undefined;
        foreach (i from 0 to 3 by 1 in inc) {
            if is_signed then {
                element1 = SInt(Elem_read(operand1, 4 * e + i, DIV(esize, 4)));
                element2 = SInt(Elem_read(operand2, 4 * e + i, DIV(esize, 4)))
            } else {
                element1 = UInt(Elem_read(operand1, 4 * e + i, DIV(esize, 4)));
                element2 = UInt(Elem_read(operand2, 4 * e + i, DIV(esize, 4)))
            };
            res = res + element1 * element2
        };
        let 'res = res;
        result = Elem_set(result, e, esize, Elem_read(result, e, esize) + res)
    };
    V_set(d, datasize) = result
}

val decode_sdot_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_dotp : (bits(5), bits(5), bits(5), bits(2), bits(1), bits(1)) -> unit

function decode_sdot_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_dotp (Rd, Rn, Rm, size, U, Q) = {
    if not_bool(HaveDOTPExt()) then {
        throw(Error_Undefined())
    };
    if size != 0b10 then {
        throw(Error_Undefined())
    };
    let is_signed : bool = U == 0b0;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_dotp(d, datasize, elements, esize, m, n, is_signed)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, bitzero, _, _, _, _, _, bitone, bitzero, bitzero, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 783) = {
    SEE = 783;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_sdot_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_dotp(Rd, Rn, Rm, size, U, Q)
}

val decode_udot_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_dotp : (bits(5), bits(5), bits(5), bits(2), bits(1), bits(1)) -> unit

function decode_udot_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_dotp (Rd, Rn, Rm, size, U, Q) = {
    if not_bool(HaveDOTPExt()) then {
        throw(Error_Undefined())
    };
    if size != 0b10 then {
        throw(Error_Undefined())
    };
    let is_signed : bool = U == 0b0;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_dotp(d, datasize, elements, esize, m, n, is_signed)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, bitzero, _, _, _, _, _, bitone, bitzero, bitzero, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 784) = {
    SEE = 784;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_udot_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_dotp(Rd, Rn, Rm, size, U, Q)
}

val execute_aarch64_instrs_vector_arithmetic_binary_element_dotp : forall 'd 'datasize 'elements 'esize 'index ('is_signed : Bool) 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'index in {0, 1, 2, 3} & 'esize in {8, 16, 32, 64} & 'datasize in {64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('index), int('m), int('n), bool('is_signed)) -> unit

function execute_aarch64_instrs_vector_arithmetic_binary_element_dotp (d, datasize, elements, esize, index, m, n, is_signed) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = V_read(n, datasize);
    let operand2 : bits(128) = V_read(m, 128);
    result : bits('datasize) = V_read(d, datasize);
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        res : int = 0;
        element1 : int = undefined;
        element2 : int = undefined;
        foreach (i from 0 to 3 by 1 in inc) {
            if is_signed then {
                element1 = SInt(Elem_read(operand1, 4 * e + i, DIV(esize, 4)));
                element2 = SInt(Elem_read(operand2, 4 * index + i, DIV(esize, 4)))
            } else {
                element1 = UInt(Elem_read(operand1, 4 * e + i, DIV(esize, 4)));
                element2 = UInt(Elem_read(operand2, 4 * index + i, DIV(esize, 4)))
            };
            res = res + element1 * element2
        };
        let 'res = res;
        result = Elem_set(result, e, esize, Elem_read(result, e, esize) + res)
    };
    V_set(d, datasize) = result
}

val decode_sdot_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_dotp : (bits(5), bits(5), bits(1), bits(4), bits(1), bits(1), bits(2), bits(1), bits(1)) -> unit

function decode_sdot_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_dotp (Rd, Rn, H, Rm, M, L, size, U, Q) = {
    if not_bool(HaveDOTPExt()) then {
        throw(Error_Undefined())
    };
    if size != 0b10 then {
        throw(Error_Undefined())
    };
    let is_signed : bool = U == 0b0;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(M @ Rm);
    let 'index = UInt(H @ L);
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    execute_aarch64_instrs_vector_arithmetic_binary_element_dotp(d, datasize, elements, esize, index, m, n, is_signed)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, bitone, bitone, bitone, bitzero, _, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 785) = {
    SEE = 785;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let H = Slice(__opcode, 11, 1);
    let Rm = Slice(__opcode, 16, 4);
    let M = Slice(__opcode, 20, 1);
    let L = Slice(__opcode, 21, 1);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_sdot_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_dotp(Rd, Rn, H, Rm, M, L, size, U, Q)
}

val decode_udot_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_dotp : (bits(5), bits(5), bits(1), bits(4), bits(1), bits(1), bits(2), bits(1), bits(1)) -> unit

function decode_udot_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_dotp (Rd, Rn, H, Rm, M, L, size, U, Q) = {
    if not_bool(HaveDOTPExt()) then {
        throw(Error_Undefined())
    };
    if size != 0b10 then {
        throw(Error_Undefined())
    };
    let is_signed : bool = U == 0b0;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(M @ Rm);
    let 'index = UInt(H @ L);
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    execute_aarch64_instrs_vector_arithmetic_binary_element_dotp(d, datasize, elements, esize, index, m, n, is_signed)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, bitone, bitone, bitone, bitzero, _, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 786) = {
    SEE = 786;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let H = Slice(__opcode, 11, 1);
    let Rm = Slice(__opcode, 16, 4);
    let M = Slice(__opcode, 20, 1);
    let L = Slice(__opcode, 21, 1);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_udot_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_dotp(Rd, Rn, H, Rm, M, L, size, U, Q)
}

val execute_aarch64_instrs_memory_mcpymset_set : forall 'd 'n 's,
  (0 <= 's & 's <= 31 & 0 <= 'n & 'n <= 31 & 0 <= 'd & 'd <= 31).
  (int('d), int('n), bits(2), int('s), MOPSStage) -> unit

function execute_aarch64_instrs_memory_mcpymset_set (d, n, options_name, s, stage) = {
    toaddress : bits(64) = X_read(d, 64);
    setsize : bits(64) = X_read(n, 64);
    let data : bits(8) = X_read(s, 8);
    nzcv : bits(4) = PSTATE.N @ (PSTATE.Z @ (PSTATE.C @ PSTATE.V));
    stagesetsize : bits(64) = undefined;
    let is_setg : bool = false;
    B : int = undefined;
    let supports_option_a : bool = SETOptionA();
    let privileged : bool = if [options_name[0]] == 0b1 then
      AArch64_IsUnprivAccessPriv()
    else
      PSTATE.EL != EL0;
    let nontemporal : bool = [options_name[1]] == 0b1;
    let accdesc : AccessDescriptor = CreateAccDescMOPS(MemOp_STORE, privileged, nontemporal);
    if stage == MOPSStage_Prologue then {
        if [setsize[63]] == 0b1 then {
            setsize = 0x7FFFFFFFFFFFFFFF
        };
        if supports_option_a then {
            nzcv = 0b0000;
            toaddress = toaddress + setsize;
            setsize = Zeros(64) - setsize
        } else {
            nzcv = 0b0010
        };
        stagesetsize = SETPreSizeChoice(toaddress, setsize, is_setg);
        assert([stagesetsize[63]] == [setsize[63]] | stagesetsize == Zeros(64));
        if SInt(setsize) > 0 then {
            assert(SInt(stagesetsize) <= SInt(setsize))
        } else {
            assert(SInt(stagesetsize) >= SInt(setsize))
        }
    } else {
        let postsize : bits(64) = SETPostSizeChoice(toaddress, setsize, is_setg);
        assert([postsize[63]] == [setsize[63]] | postsize == Zeros(64));
        let zero_size_exceptions : bool = MemSetZeroSizeCheck();
        if zero_size_exceptions | SInt(setsize) != 0 then {
            if supports_option_a then {
                if [nzcv[1]] == 0b1 then {
                    let wrong_option : bool = true;
                    let from_epilogue : bool = stage == MOPSStage_Epilogue;
                    MismatchedMemSetException(supports_option_a, d, s, n, wrong_option, from_epilogue, options_name, is_setg)
                };
                ()
            } else {
                if [nzcv[1]] == 0b0 then {
                    let wrong_option : bool = true;
                    let from_epilogue : bool = stage == MOPSStage_Epilogue;
                    MismatchedMemSetException(supports_option_a, d, s, n, wrong_option, from_epilogue, options_name, is_setg)
                };
                ()
            }
        };
        if stage == MOPSStage_Main then {
            stagesetsize = setsize - postsize;
            if MemSetParametersIllformedM(toaddress, setsize, is_setg) then {
                let wrong_option : bool = false;
                let from_epilogue : bool = false;
                MismatchedMemSetException(supports_option_a, d, s, n, wrong_option, from_epilogue, options_name, is_setg)
            };
            ()
        } else {
            stagesetsize = postsize;
            if setsize != postsize | MemSetParametersIllformedE(toaddress, setsize, is_setg) then {
                let wrong_option : bool = false;
                let from_epilogue : bool = true;
                MismatchedMemSetException(supports_option_a, d, s, n, wrong_option, from_epilogue, options_name, is_setg)
            };
            ()
        }
    };
    if SPESampleInFlight then {
        SPESampleMemSet()
    };
    if supports_option_a then {
        while SInt(stagesetsize) < 0 do {
            B = SETSizeChoice(toaddress, setsize, 1);
            assert(B <= negate(1) * SInt(stagesetsize));
            let 'B = B in
              {
                  assert(constraint('B * 8 >= 0));
                  Mem_set(toaddress + setsize, B, accdesc) = Replicate(data, B)
              };
            setsize = setsize + B;
            stagesetsize = stagesetsize + B;
            if stage != MOPSStage_Prologue then {
                X_set(n, 64) = setsize
            };
            ()
        }
    } else {
        while UInt(stagesetsize) > 0 do {
            B = SETSizeChoice(toaddress, setsize, 1);
            assert(B <= UInt(stagesetsize));
            let 'B = B in
              {
                  assert(constraint('B * 8 >= 0));
                  Mem_set(toaddress, B, accdesc) = Replicate(data, B)
              };
            toaddress = toaddress + B;
            setsize = setsize - B;
            stagesetsize = stagesetsize - B;
            if stage != MOPSStage_Prologue then {
                X_set(n, 64) = setsize;
                X_set(d, 64) = toaddress
            };
            ()
        }
    };
    if stage == MOPSStage_Prologue then {
        X_set(n, 64) = setsize;
        X_set(d, 64) = toaddress;
        (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V) = nzcv
    };
    ()
}

val decode_setp_aarch64_instrs_memory_mcpymset_set : (bits(5), bits(5), bits(4), bits(5), bits(2)) -> unit

function decode_setp_aarch64_instrs_memory_mcpymset_set (Rd, Rn, op2, Rs, sz) = {
    if not_bool(HaveFeatMOPS()) then {
        throw(Error_Undefined())
    };
    if sz != 0b00 then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 's = UInt(Rs);
    let 'n = UInt(Rn);
    let options_name : bits(2) = op2[1 .. 0];
    stage : MOPSStage = undefined;
    match op2[3 .. 2] {
      0b00 => {
          stage = MOPSStage_Prologue
      },
      0b01 => {
          stage = MOPSStage_Main
      },
      0b10 => {
          stage = MOPSStage_Epilogue
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let stage = stage;
    CheckMOPSEnabled();
    if (((s == n | s == d) | n == d) | d == 31) | n == 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_MOPSOVERLAP31);
        assert(c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    execute_aarch64_instrs_memory_mcpymset_set(d, n, options_name, s, stage)
}

function clause __DecodeA64_LoadStore ((pc, ([_, _, bitzero, bitone, bitone, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, bitzero, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 787) = {
    SEE = 787;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op2 = Slice(__opcode, 12, 4);
    let Rs = Slice(__opcode, 16, 5);
    let sz = Slice(__opcode, 30, 2);
    decode_setp_aarch64_instrs_memory_mcpymset_set(Rd, Rn, op2, Rs, sz)
}

val decode_setpn_aarch64_instrs_memory_mcpymset_set : (bits(5), bits(5), bits(4), bits(5), bits(2)) -> unit

function decode_setpn_aarch64_instrs_memory_mcpymset_set (Rd, Rn, op2, Rs, sz) = {
    if not_bool(HaveFeatMOPS()) then {
        throw(Error_Undefined())
    };
    if sz != 0b00 then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 's = UInt(Rs);
    let 'n = UInt(Rn);
    let options_name : bits(2) = op2[1 .. 0];
    stage : MOPSStage = undefined;
    match op2[3 .. 2] {
      0b00 => {
          stage = MOPSStage_Prologue
      },
      0b01 => {
          stage = MOPSStage_Main
      },
      0b10 => {
          stage = MOPSStage_Epilogue
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let stage = stage;
    CheckMOPSEnabled();
    if (((s == n | s == d) | n == d) | d == 31) | n == 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_MOPSOVERLAP31);
        assert(c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    execute_aarch64_instrs_memory_mcpymset_set(d, n, options_name, s, stage)
}

function clause __DecodeA64_LoadStore ((pc, ([_, _, bitzero, bitone, bitone, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, bitone, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 788) = {
    SEE = 788;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op2 = Slice(__opcode, 12, 4);
    let Rs = Slice(__opcode, 16, 5);
    let sz = Slice(__opcode, 30, 2);
    decode_setpn_aarch64_instrs_memory_mcpymset_set(Rd, Rn, op2, Rs, sz)
}

val decode_setpt_aarch64_instrs_memory_mcpymset_set : (bits(5), bits(5), bits(4), bits(5), bits(2)) -> unit

function decode_setpt_aarch64_instrs_memory_mcpymset_set (Rd, Rn, op2, Rs, sz) = {
    if not_bool(HaveFeatMOPS()) then {
        throw(Error_Undefined())
    };
    if sz != 0b00 then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 's = UInt(Rs);
    let 'n = UInt(Rn);
    let options_name : bits(2) = op2[1 .. 0];
    stage : MOPSStage = undefined;
    match op2[3 .. 2] {
      0b00 => {
          stage = MOPSStage_Prologue
      },
      0b01 => {
          stage = MOPSStage_Main
      },
      0b10 => {
          stage = MOPSStage_Epilogue
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let stage = stage;
    CheckMOPSEnabled();
    if (((s == n | s == d) | n == d) | d == 31) | n == 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_MOPSOVERLAP31);
        assert(c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    execute_aarch64_instrs_memory_mcpymset_set(d, n, options_name, s, stage)
}

function clause __DecodeA64_LoadStore ((pc, ([_, _, bitzero, bitone, bitone, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, bitzero, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 789) = {
    SEE = 789;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op2 = Slice(__opcode, 12, 4);
    let Rs = Slice(__opcode, 16, 5);
    let sz = Slice(__opcode, 30, 2);
    decode_setpt_aarch64_instrs_memory_mcpymset_set(Rd, Rn, op2, Rs, sz)
}

val decode_setptn_aarch64_instrs_memory_mcpymset_set : (bits(5), bits(5), bits(4), bits(5), bits(2)) -> unit

function decode_setptn_aarch64_instrs_memory_mcpymset_set (Rd, Rn, op2, Rs, sz) = {
    if not_bool(HaveFeatMOPS()) then {
        throw(Error_Undefined())
    };
    if sz != 0b00 then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 's = UInt(Rs);
    let 'n = UInt(Rn);
    let options_name : bits(2) = op2[1 .. 0];
    stage : MOPSStage = undefined;
    match op2[3 .. 2] {
      0b00 => {
          stage = MOPSStage_Prologue
      },
      0b01 => {
          stage = MOPSStage_Main
      },
      0b10 => {
          stage = MOPSStage_Epilogue
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let stage = stage;
    CheckMOPSEnabled();
    if (((s == n | s == d) | n == d) | d == 31) | n == 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_MOPSOVERLAP31);
        assert(c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    execute_aarch64_instrs_memory_mcpymset_set(d, n, options_name, s, stage)
}

function clause __DecodeA64_LoadStore ((pc, ([_, _, bitzero, bitone, bitone, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, bitone, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 790) = {
    SEE = 790;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op2 = Slice(__opcode, 12, 4);
    let Rs = Slice(__opcode, 16, 5);
    let sz = Slice(__opcode, 30, 2);
    decode_setptn_aarch64_instrs_memory_mcpymset_set(Rd, Rn, op2, Rs, sz)
}

val execute_aarch64_instrs_integer_flags_setf : forall 'msb 'n,
  (0 <= 'n & 'n <= 31 & 'msb in {7, 15}).
  (int('msb), int('n)) -> unit

function execute_aarch64_instrs_integer_flags_setf (msb, n) = {
    let tmpreg : bits(32) = X_read(n, 32);
    PSTATE.N = [tmpreg[msb]];
    PSTATE.Z = if tmpreg[msb .. 0] == Zeros(msb + 1) then 0b1 else 0b0;
    PSTATE.V = EOR([tmpreg[msb + 1]], [tmpreg[msb]])
}

val decode_setf_aarch64_instrs_integer_flags_setf : (bits(5), bits(1), bits(1)) -> unit

function decode_setf_aarch64_instrs_integer_flags_setf (Rn, sz, sf) = {
    if not_bool(HaveFlagManipulateExt()) | sf != 0b0 then {
        throw(Error_Undefined())
    };
    let 'msb = if sz == 0b1 then 15 else 7;
    let 'n = UInt(Rn);
    execute_aarch64_instrs_integer_flags_setf(msb, n)
}

function clause __DecodeA64_DataProcReg ((pc, ([bitzero, bitzero, bitone, bitone, bitone, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, _, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, bitzero, bitone, bitone, bitzero, bitone] as __opcode)) if SEE < 791) = {
    SEE = 791;
    let Rn = Slice(__opcode, 5, 5);
    let sz = Slice(__opcode, 14, 1);
    let sf = Slice(__opcode, 31, 1);
    decode_setf_aarch64_instrs_integer_flags_setf(Rn, sz, sf)
}

val execute_aarch64_instrs_memory_mcpymset_setg : forall 'd 'n 's,
  (0 <= 's & 's <= 31 & 0 <= 'n & 'n <= 31 & 0 <= 'd & 'd <= 31).
  (int('d), int('n), bits(2), int('s), MOPSStage) -> unit

function execute_aarch64_instrs_memory_mcpymset_setg (d, n, options_name, s, stage) = {
    toaddress : bits(64) = X_read(d, 64);
    setsize : bits(64) = X_read(n, 64);
    let data : bits(8) = X_read(s, 8);
    nzcv : bits(4) = PSTATE.N @ (PSTATE.Z @ (PSTATE.C @ PSTATE.V));
    stagesetsize : bits(64) = undefined;
    let is_setg : bool = true;
    B : int = undefined;
    let supports_option_a : bool = SETGOptionA();
    let privileged : bool = if [options_name[0]] == 0b1 then
      AArch64_IsUnprivAccessPriv()
    else
      PSTATE.EL != EL0;
    let nontemporal : bool = [options_name[1]] == 0b1;
    let accdesc : AccessDescriptor = CreateAccDescSTGMOPS(privileged, nontemporal);
    if stage == MOPSStage_Prologue then {
        if [setsize[63]] == 0b1 then {
            setsize = 0x7FFFFFFFFFFFFFF0
        };
        if setsize != Zeros(64) & not_bool(IsAligned__1(toaddress, TAG_GRANULE)) then {
            AArch64_Abort(toaddress, AlignmentFault(accdesc))
        };
        if not_bool(IsAligned__1(setsize, TAG_GRANULE)) then {
            AArch64_Abort(toaddress, AlignmentFault(accdesc))
        };
        if supports_option_a then {
            nzcv = 0b0000;
            toaddress = toaddress + setsize;
            setsize = Zeros(64) - setsize
        } else {
            nzcv = 0b0010
        };
        stagesetsize = SETPreSizeChoice(toaddress, setsize, is_setg);
        assert([stagesetsize[63]] == [setsize[63]] | stagesetsize == Zeros(64));
        assert(stagesetsize[3 .. 0] == 0b0000);
        if SInt(setsize) > 0 then {
            assert(SInt(stagesetsize) <= SInt(setsize))
        } else {
            assert(SInt(stagesetsize) >= SInt(setsize))
        }
    } else {
        let postsize : bits(64) = SETPostSizeChoice(toaddress, setsize, is_setg);
        assert([postsize[63]] == [setsize[63]] | postsize == Zeros(64));
        assert(postsize[3 .. 0] == 0b0000);
        let zero_size_exceptions : bool = MemSetZeroSizeCheck();
        if zero_size_exceptions | SInt(setsize) != 0 then {
            if supports_option_a then {
                if [nzcv[1]] == 0b1 then {
                    let wrong_option : bool = true;
                    let from_epilogue : bool = stage == MOPSStage_Epilogue;
                    MismatchedMemSetException(supports_option_a, d, s, n, wrong_option, from_epilogue, options_name, is_setg)
                };
                ()
            } else {
                if [nzcv[1]] == 0b0 then {
                    let wrong_option : bool = true;
                    let from_epilogue : bool = stage == MOPSStage_Epilogue;
                    MismatchedMemSetException(supports_option_a, d, s, n, wrong_option, from_epilogue, options_name, is_setg)
                };
                ()
            }
        };
        if stage == MOPSStage_Main then {
            stagesetsize = setsize - postsize;
            if MemSetParametersIllformedM(toaddress, setsize, is_setg) then {
                let wrong_option : bool = false;
                let from_epilogue : bool = false;
                MismatchedMemSetException(supports_option_a, d, s, n, wrong_option, from_epilogue, options_name, is_setg)
            };
            ()
        } else {
            stagesetsize = postsize;
            if setsize != postsize | MemSetParametersIllformedE(toaddress, setsize, is_setg) then {
                let wrong_option : bool = false;
                let from_epilogue : bool = true;
                MismatchedMemSetException(supports_option_a, d, s, n, wrong_option, from_epilogue, options_name, is_setg)
            };
            ()
        };
        if setsize != Zeros(64) & not_bool(IsAligned__1(toaddress, TAG_GRANULE)) then {
            AArch64_Abort(toaddress, AlignmentFault(accdesc))
        };
        if not_bool(IsAligned__1(setsize, TAG_GRANULE)) then {
            AArch64_Abort(toaddress, AlignmentFault(accdesc))
        };
        ()
    };
    tagstep : int = undefined;
    tag : bits(4) = undefined;
    tagaddr : bits(64) = undefined;
    if SPESampleInFlight then {
        SPESampleMemSet()
    };
    if supports_option_a then {
        while SInt(stagesetsize) < 0 do {
            B = SETSizeChoice(toaddress, setsize, 16);
            assert(B <= negate(1) * SInt(stagesetsize));
            assert(B[3 .. 0] == 0b0000);
            let 'B = B in
              {
                  assert(constraint('B * 8 >= 0));
                  Mem_set(toaddress + setsize, B, accdesc) = Replicate(data, B)
              };
            tagstep = DIV(B, 16);
            tag = AArch64_AllocationTagFromAddress(toaddress + setsize);
            while tagstep > 0 do {
                tagaddr = toaddress + setsize + (tagstep - 1) * 16;
                AArch64_MemTag_set(tagaddr, accdesc) = tag;
                tagstep = tagstep - 1
            };
            setsize = setsize + B;
            stagesetsize = stagesetsize + B;
            if stage != MOPSStage_Prologue then {
                X_set(n, 64) = setsize
            };
            ()
        }
    } else {
        while UInt(stagesetsize) > 0 do {
            B = SETSizeChoice(toaddress, setsize, 16);
            assert(B <= UInt(stagesetsize));
            assert(B[3 .. 0] == 0b0000);
            let 'B = B in
              {
                  assert(constraint('B * 8 >= 0));
                  Mem_set(toaddress, B, accdesc) = Replicate(data, B)
              };
            tagstep = DIV(B, 16);
            tag = AArch64_AllocationTagFromAddress(toaddress);
            while tagstep > 0 do {
                tagaddr = toaddress + (tagstep - 1) * 16;
                AArch64_MemTag_set(tagaddr, accdesc) = tag;
                tagstep = tagstep - 1
            };
            toaddress = toaddress + B;
            setsize = setsize - B;
            stagesetsize = stagesetsize - B;
            if stage != MOPSStage_Prologue then {
                X_set(n, 64) = setsize;
                X_set(d, 64) = toaddress
            };
            ()
        }
    };
    if stage == MOPSStage_Prologue then {
        X_set(n, 64) = setsize;
        X_set(d, 64) = toaddress;
        (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V) = nzcv
    };
    ()
}

val decode_setgp_aarch64_instrs_memory_mcpymset_setg : (bits(5), bits(5), bits(4), bits(5), bits(2)) -> unit

function decode_setgp_aarch64_instrs_memory_mcpymset_setg (Rd, Rn, op2, Rs, sz) = {
    if not_bool(HaveFeatMOPS()) then {
        throw(Error_Undefined())
    };
    if not_bool(HaveMTEExt()) then {
        throw(Error_Undefined())
    };
    if sz != 0b00 then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 's = UInt(Rs);
    let 'n = UInt(Rn);
    let options_name : bits(2) = op2[1 .. 0];
    stage : MOPSStage = undefined;
    match op2[3 .. 2] {
      0b00 => {
          stage = MOPSStage_Prologue
      },
      0b01 => {
          stage = MOPSStage_Main
      },
      0b10 => {
          stage = MOPSStage_Epilogue
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let stage = stage;
    CheckMOPSEnabled();
    if (((s == n | s == d) | n == d) | d == 31) | n == 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_MOPSOVERLAP31);
        assert(c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    execute_aarch64_instrs_memory_mcpymset_setg(d, n, options_name, s, stage)
}

function clause __DecodeA64_LoadStore ((pc, ([_, _, bitzero, bitone, bitone, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, bitzero, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 792) = {
    SEE = 792;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op2 = Slice(__opcode, 12, 4);
    let Rs = Slice(__opcode, 16, 5);
    let sz = Slice(__opcode, 30, 2);
    decode_setgp_aarch64_instrs_memory_mcpymset_setg(Rd, Rn, op2, Rs, sz)
}

val decode_setgpn_aarch64_instrs_memory_mcpymset_setg : (bits(5), bits(5), bits(4), bits(5), bits(2)) -> unit

function decode_setgpn_aarch64_instrs_memory_mcpymset_setg (Rd, Rn, op2, Rs, sz) = {
    if not_bool(HaveFeatMOPS()) then {
        throw(Error_Undefined())
    };
    if not_bool(HaveMTEExt()) then {
        throw(Error_Undefined())
    };
    if sz != 0b00 then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 's = UInt(Rs);
    let 'n = UInt(Rn);
    let options_name : bits(2) = op2[1 .. 0];
    stage : MOPSStage = undefined;
    match op2[3 .. 2] {
      0b00 => {
          stage = MOPSStage_Prologue
      },
      0b01 => {
          stage = MOPSStage_Main
      },
      0b10 => {
          stage = MOPSStage_Epilogue
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let stage = stage;
    CheckMOPSEnabled();
    if (((s == n | s == d) | n == d) | d == 31) | n == 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_MOPSOVERLAP31);
        assert(c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    execute_aarch64_instrs_memory_mcpymset_setg(d, n, options_name, s, stage)
}

function clause __DecodeA64_LoadStore ((pc, ([_, _, bitzero, bitone, bitone, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, bitone, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 793) = {
    SEE = 793;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op2 = Slice(__opcode, 12, 4);
    let Rs = Slice(__opcode, 16, 5);
    let sz = Slice(__opcode, 30, 2);
    decode_setgpn_aarch64_instrs_memory_mcpymset_setg(Rd, Rn, op2, Rs, sz)
}

val decode_setgpt_aarch64_instrs_memory_mcpymset_setg : (bits(5), bits(5), bits(4), bits(5), bits(2)) -> unit

function decode_setgpt_aarch64_instrs_memory_mcpymset_setg (Rd, Rn, op2, Rs, sz) = {
    if not_bool(HaveFeatMOPS()) then {
        throw(Error_Undefined())
    };
    if not_bool(HaveMTEExt()) then {
        throw(Error_Undefined())
    };
    if sz != 0b00 then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 's = UInt(Rs);
    let 'n = UInt(Rn);
    let options_name : bits(2) = op2[1 .. 0];
    stage : MOPSStage = undefined;
    match op2[3 .. 2] {
      0b00 => {
          stage = MOPSStage_Prologue
      },
      0b01 => {
          stage = MOPSStage_Main
      },
      0b10 => {
          stage = MOPSStage_Epilogue
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let stage = stage;
    CheckMOPSEnabled();
    if (((s == n | s == d) | n == d) | d == 31) | n == 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_MOPSOVERLAP31);
        assert(c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    execute_aarch64_instrs_memory_mcpymset_setg(d, n, options_name, s, stage)
}

function clause __DecodeA64_LoadStore ((pc, ([_, _, bitzero, bitone, bitone, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, bitzero, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 794) = {
    SEE = 794;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op2 = Slice(__opcode, 12, 4);
    let Rs = Slice(__opcode, 16, 5);
    let sz = Slice(__opcode, 30, 2);
    decode_setgpt_aarch64_instrs_memory_mcpymset_setg(Rd, Rn, op2, Rs, sz)
}

val decode_setgptn_aarch64_instrs_memory_mcpymset_setg : (bits(5), bits(5), bits(4), bits(5), bits(2)) -> unit

function decode_setgptn_aarch64_instrs_memory_mcpymset_setg (Rd, Rn, op2, Rs, sz) = {
    if not_bool(HaveFeatMOPS()) then {
        throw(Error_Undefined())
    };
    if not_bool(HaveMTEExt()) then {
        throw(Error_Undefined())
    };
    if sz != 0b00 then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 's = UInt(Rs);
    let 'n = UInt(Rn);
    let options_name : bits(2) = op2[1 .. 0];
    stage : MOPSStage = undefined;
    match op2[3 .. 2] {
      0b00 => {
          stage = MOPSStage_Prologue
      },
      0b01 => {
          stage = MOPSStage_Main
      },
      0b10 => {
          stage = MOPSStage_Epilogue
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let stage = stage;
    CheckMOPSEnabled();
    if (((s == n | s == d) | n == d) | d == 31) | n == 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_MOPSOVERLAP31);
        assert(c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    execute_aarch64_instrs_memory_mcpymset_setg(d, n, options_name, s, stage)
}

function clause __DecodeA64_LoadStore ((pc, ([_, _, bitzero, bitone, bitone, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, bitone, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 795) = {
    SEE = 795;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op2 = Slice(__opcode, 12, 4);
    let Rs = Slice(__opcode, 16, 5);
    let sz = Slice(__opcode, 30, 2);
    decode_setgptn_aarch64_instrs_memory_mcpymset_setg(Rd, Rn, op2, Rs, sz)
}

val execute_aarch64_instrs_vector_crypto_sha3op_sha1_hash_choose : forall 'd 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 0 <= 'd & 'd <= 31).
  (int('d), int('m), int('n)) -> unit

function execute_aarch64_instrs_vector_crypto_sha3op_sha1_hash_choose (d, m, n) = {
    AArch64_CheckFPAdvSIMDEnabled();
    x : bits(128) = V_read(d, 128);
    y : bits(32) = V_read(n, 32);
    let w : bits(128) = V_read(m, 128);
    t : bits(32) = undefined;
    foreach (e from 0 to 3 by 1 in inc) {
        t = SHAchoose(x[63 .. 32], x[95 .. 64], x[127 .. 96]);
        y = y + ROL(x[31 .. 0], 5) + t + Elem_read(w, e, 32);
        x[63 .. 32] = ROL(x[63 .. 32], 30);
        (y @ x) = ROL(y @ x, 32)
    };
    V_set(d, 128) = x
}

val decode_sha1c_advsimd_aarch64_instrs_vector_crypto_sha3op_sha1_hash_choose : (bits(5), bits(5), bits(5)) -> unit

function decode_sha1c_advsimd_aarch64_instrs_vector_crypto_sha3op_sha1_hash_choose (Rd, Rn, Rm) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if not_bool(HaveSHA1Ext()) then {
        throw(Error_Undefined())
    };
    execute_aarch64_instrs_vector_crypto_sha3op_sha1_hash_choose(d, m, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 796) = {
    SEE = 796;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    decode_sha1c_advsimd_aarch64_instrs_vector_crypto_sha3op_sha1_hash_choose(Rd, Rn, Rm)
}

val execute_aarch64_instrs_vector_crypto_sha2op_sha1_hash : forall 'd 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'd & 'd <= 31).
  (int('d), int('n)) -> unit

function execute_aarch64_instrs_vector_crypto_sha2op_sha1_hash (d, n) = {
    AArch64_CheckFPAdvSIMDEnabled();
    let operand : bits(32) = V_read(n, 32);
    V_set(d, 32) = ROL(operand, 30)
}

val decode_sha1h_advsimd_aarch64_instrs_vector_crypto_sha2op_sha1_hash : (bits(5), bits(5)) -> unit

function decode_sha1h_advsimd_aarch64_instrs_vector_crypto_sha2op_sha1_hash (Rd, Rn) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if not_bool(HaveSHA1Ext()) then {
        throw(Error_Undefined())
    };
    execute_aarch64_instrs_vector_crypto_sha2op_sha1_hash(d, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 797) = {
    SEE = 797;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    decode_sha1h_advsimd_aarch64_instrs_vector_crypto_sha2op_sha1_hash(Rd, Rn)
}

val execute_aarch64_instrs_vector_crypto_sha3op_sha1_hash_majority : forall 'd 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 0 <= 'd & 'd <= 31).
  (int('d), int('m), int('n)) -> unit

function execute_aarch64_instrs_vector_crypto_sha3op_sha1_hash_majority (d, m, n) = {
    AArch64_CheckFPAdvSIMDEnabled();
    x : bits(128) = V_read(d, 128);
    y : bits(32) = V_read(n, 32);
    let w : bits(128) = V_read(m, 128);
    t : bits(32) = undefined;
    foreach (e from 0 to 3 by 1 in inc) {
        t = SHAmajority(x[63 .. 32], x[95 .. 64], x[127 .. 96]);
        y = y + ROL(x[31 .. 0], 5) + t + Elem_read(w, e, 32);
        x[63 .. 32] = ROL(x[63 .. 32], 30);
        (y @ x) = ROL(y @ x, 32)
    };
    V_set(d, 128) = x
}

val decode_sha1m_advsimd_aarch64_instrs_vector_crypto_sha3op_sha1_hash_majority : (bits(5), bits(5), bits(5)) -> unit

function decode_sha1m_advsimd_aarch64_instrs_vector_crypto_sha3op_sha1_hash_majority (Rd, Rn, Rm) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if not_bool(HaveSHA1Ext()) then {
        throw(Error_Undefined())
    };
    execute_aarch64_instrs_vector_crypto_sha3op_sha1_hash_majority(d, m, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 798) = {
    SEE = 798;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    decode_sha1m_advsimd_aarch64_instrs_vector_crypto_sha3op_sha1_hash_majority(Rd, Rn, Rm)
}

val execute_aarch64_instrs_vector_crypto_sha3op_sha1_hash_parity : forall 'd 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 0 <= 'd & 'd <= 31).
  (int('d), int('m), int('n)) -> unit

function execute_aarch64_instrs_vector_crypto_sha3op_sha1_hash_parity (d, m, n) = {
    AArch64_CheckFPAdvSIMDEnabled();
    x : bits(128) = V_read(d, 128);
    y : bits(32) = V_read(n, 32);
    let w : bits(128) = V_read(m, 128);
    t : bits(32) = undefined;
    foreach (e from 0 to 3 by 1 in inc) {
        t = SHAparity(x[63 .. 32], x[95 .. 64], x[127 .. 96]);
        y = y + ROL(x[31 .. 0], 5) + t + Elem_read(w, e, 32);
        x[63 .. 32] = ROL(x[63 .. 32], 30);
        (y @ x) = ROL(y @ x, 32)
    };
    V_set(d, 128) = x
}

val decode_sha1p_advsimd_aarch64_instrs_vector_crypto_sha3op_sha1_hash_parity : (bits(5), bits(5), bits(5)) -> unit

function decode_sha1p_advsimd_aarch64_instrs_vector_crypto_sha3op_sha1_hash_parity (Rd, Rn, Rm) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if not_bool(HaveSHA1Ext()) then {
        throw(Error_Undefined())
    };
    execute_aarch64_instrs_vector_crypto_sha3op_sha1_hash_parity(d, m, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 799) = {
    SEE = 799;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    decode_sha1p_advsimd_aarch64_instrs_vector_crypto_sha3op_sha1_hash_parity(Rd, Rn, Rm)
}

val execute_aarch64_instrs_vector_crypto_sha3op_sha1_sched0 : forall 'd 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 0 <= 'd & 'd <= 31).
  (int('d), int('m), int('n)) -> unit

function execute_aarch64_instrs_vector_crypto_sha3op_sha1_sched0 (d, m, n) = {
    AArch64_CheckFPAdvSIMDEnabled();
    let operand1 : bits(128) = V_read(d, 128);
    let operand2 : bits(128) = V_read(n, 128);
    let operand3 : bits(128) = V_read(m, 128);
    result : bits(128) = operand2[63 .. 0] @ operand1[127 .. 64];
    let result : bits(128) = EOR(EOR(result, operand1), operand3);
    V_set(d, 128) = result
}

val decode_sha1su0_advsimd_aarch64_instrs_vector_crypto_sha3op_sha1_sched0 : (bits(5), bits(5), bits(5)) -> unit

function decode_sha1su0_advsimd_aarch64_instrs_vector_crypto_sha3op_sha1_sched0 (Rd, Rn, Rm) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if not_bool(HaveSHA1Ext()) then {
        throw(Error_Undefined())
    };
    execute_aarch64_instrs_vector_crypto_sha3op_sha1_sched0(d, m, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, bitzero, bitzero, bitone, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 800) = {
    SEE = 800;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    decode_sha1su0_advsimd_aarch64_instrs_vector_crypto_sha3op_sha1_sched0(Rd, Rn, Rm)
}

val execute_aarch64_instrs_vector_crypto_sha2op_sha1_sched1 : forall 'd 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'd & 'd <= 31).
  (int('d), int('n)) -> unit

function execute_aarch64_instrs_vector_crypto_sha2op_sha1_sched1 (d, n) = {
    AArch64_CheckFPAdvSIMDEnabled();
    let operand1 : bits(128) = V_read(d, 128);
    let operand2 : bits(128) = V_read(n, 128);
    result : bits(128) = undefined;
    let T : bits(128) = EOR(operand1, LSR(operand2, 32));
    result[31 .. 0] = ROL(T[31 .. 0], 1);
    result[63 .. 32] = ROL(T[63 .. 32], 1);
    result[95 .. 64] = ROL(T[95 .. 64], 1);
    result[127 .. 96] = EOR(ROL(T[127 .. 96], 1), ROL(T[31 .. 0], 2));
    V_set(d, 128) = result
}

val decode_sha1su1_advsimd_aarch64_instrs_vector_crypto_sha2op_sha1_sched1 : (bits(5), bits(5)) -> unit

function decode_sha1su1_advsimd_aarch64_instrs_vector_crypto_sha2op_sha1_sched1 (Rd, Rn) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if not_bool(HaveSHA1Ext()) then {
        throw(Error_Undefined())
    };
    execute_aarch64_instrs_vector_crypto_sha2op_sha1_sched1(d, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 801) = {
    SEE = 801;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    decode_sha1su1_advsimd_aarch64_instrs_vector_crypto_sha2op_sha1_sched1(Rd, Rn)
}

val execute_aarch64_instrs_vector_crypto_sha3op_sha256_hash : forall 'd 'm 'n ('part1 : Bool),
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 0 <= 'd & 'd <= 31).
  (int('d), int('m), int('n), bool('part1)) -> unit

function execute_aarch64_instrs_vector_crypto_sha3op_sha256_hash (d, m, n, part1) = {
    AArch64_CheckFPAdvSIMDEnabled();
    result : bits(128) = undefined;
    if part1 then {
        result = SHA256hash(V_read(d, 128), V_read(n, 128), V_read(m, 128), true)
    } else {
        result = SHA256hash(V_read(n, 128), V_read(d, 128), V_read(m, 128), false)
    };
    V_set(d, 128) = result
}

val decode_sha256h_advsimd_aarch64_instrs_vector_crypto_sha3op_sha256_hash : (bits(5), bits(5), bits(1), bits(5)) -> unit

function decode_sha256h_advsimd_aarch64_instrs_vector_crypto_sha3op_sha256_hash (Rd, Rn, P, Rm) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if not_bool(HaveSHA256Ext()) then {
        throw(Error_Undefined())
    };
    let part1 : bool = P == 0b0;
    execute_aarch64_instrs_vector_crypto_sha3op_sha256_hash(d, m, n, part1)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 802) = {
    SEE = 802;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let P = Slice(__opcode, 12, 1);
    let Rm = Slice(__opcode, 16, 5);
    decode_sha256h_advsimd_aarch64_instrs_vector_crypto_sha3op_sha256_hash(Rd, Rn, P, Rm)
}

val decode_sha256h2_advsimd_aarch64_instrs_vector_crypto_sha3op_sha256_hash : (bits(5), bits(5), bits(1), bits(5)) -> unit

function decode_sha256h2_advsimd_aarch64_instrs_vector_crypto_sha3op_sha256_hash (Rd, Rn, P, Rm) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if not_bool(HaveSHA256Ext()) then {
        throw(Error_Undefined())
    };
    let part1 : bool = P == 0b0;
    execute_aarch64_instrs_vector_crypto_sha3op_sha256_hash(d, m, n, part1)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, bitzero, bitone, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 803) = {
    SEE = 803;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let P = Slice(__opcode, 12, 1);
    let Rm = Slice(__opcode, 16, 5);
    decode_sha256h2_advsimd_aarch64_instrs_vector_crypto_sha3op_sha256_hash(Rd, Rn, P, Rm)
}

val execute_aarch64_instrs_vector_crypto_sha2op_sha256_sched0 : forall 'd 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'd & 'd <= 31).
  (int('d), int('n)) -> unit

function execute_aarch64_instrs_vector_crypto_sha2op_sha256_sched0 (d, n) = {
    AArch64_CheckFPAdvSIMDEnabled();
    let operand1 : bits(128) = V_read(d, 128);
    let operand2 : bits(128) = V_read(n, 128);
    result : bits(128) = undefined;
    let T : bits(128) = operand2[31 .. 0] @ operand1[127 .. 32];
    elt : bits(32) = undefined;
    foreach (e from 0 to 3 by 1 in inc) {
        elt = Elem_read(T, e, 32);
        elt = EOR(EOR(ROR(elt, 7), ROR(elt, 18)), LSR(elt, 3));
        result = Elem_set(result, e, 32, elt + Elem_read(operand1, e, 32))
    };
    V_set(d, 128) = result
}

val decode_sha256su0_advsimd_aarch64_instrs_vector_crypto_sha2op_sha256_sched0 : (bits(5), bits(5)) -> unit

function decode_sha256su0_advsimd_aarch64_instrs_vector_crypto_sha2op_sha256_sched0 (Rd, Rn) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if not_bool(HaveSHA256Ext()) then {
        throw(Error_Undefined())
    };
    execute_aarch64_instrs_vector_crypto_sha2op_sha256_sched0(d, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 804) = {
    SEE = 804;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    decode_sha256su0_advsimd_aarch64_instrs_vector_crypto_sha2op_sha256_sched0(Rd, Rn)
}

val execute_aarch64_instrs_vector_crypto_sha3op_sha256_sched1 : forall 'd 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 0 <= 'd & 'd <= 31).
  (int('d), int('m), int('n)) -> unit

function execute_aarch64_instrs_vector_crypto_sha3op_sha256_sched1 (d, m, n) = {
    AArch64_CheckFPAdvSIMDEnabled();
    let operand1 : bits(128) = V_read(d, 128);
    let operand2 : bits(128) = V_read(n, 128);
    let operand3 : bits(128) = V_read(m, 128);
    result : bits(128) = undefined;
    let T0 : bits(128) = operand3[31 .. 0] @ operand2[127 .. 32];
    elt : bits(32) = undefined;
    T1 : bits(64) = operand3[127 .. 64];
    foreach (e from 0 to 1 by 1 in inc) {
        elt = Elem_read(T1, e, 32);
        elt = EOR(EOR(ROR(elt, 17), ROR(elt, 19)), LSR(elt, 10));
        elt = elt + Elem_read(operand1, e, 32) + Elem_read(T0, e, 32);
        result = Elem_set(result, e, 32, elt)
    };
    let T1 : bits(64) = result[63 .. 0];
    foreach (e from 2 to 3 by 1 in inc) {
        elt = Elem_read(T1, e - 2, 32);
        elt = EOR(EOR(ROR(elt, 17), ROR(elt, 19)), LSR(elt, 10));
        elt = elt + Elem_read(operand1, e, 32) + Elem_read(T0, e, 32);
        result = Elem_set(result, e, 32, elt)
    };
    V_set(d, 128) = result
}

val decode_sha256su1_advsimd_aarch64_instrs_vector_crypto_sha3op_sha256_sched1 : (bits(5), bits(5), bits(5)) -> unit

function decode_sha256su1_advsimd_aarch64_instrs_vector_crypto_sha3op_sha256_sched1 (Rd, Rn, Rm) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if not_bool(HaveSHA256Ext()) then {
        throw(Error_Undefined())
    };
    execute_aarch64_instrs_vector_crypto_sha3op_sha256_sched1(d, m, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, bitzero, bitone, bitone, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 805) = {
    SEE = 805;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    decode_sha256su1_advsimd_aarch64_instrs_vector_crypto_sha3op_sha256_sched1(Rd, Rn, Rm)
}

val execute_aarch64_instrs_vector_crypto_sha512_sha512h : forall 'd 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 0 <= 'd & 'd <= 31).
  (int('d), int('m), int('n)) -> unit

function execute_aarch64_instrs_vector_crypto_sha512_sha512h (d, m, n) = {
    AArch64_CheckFPAdvSIMDEnabled();
    Vtmp : bits(128) = undefined;
    let x : bits(128) = V_read(n, 128);
    let y : bits(128) = V_read(m, 128);
    let w : bits(128) = V_read(d, 128);
    MSigma1 : bits(64) = EOR(EOR(ROR(y[127 .. 64], 14), ROR(y[127 .. 64], 18)), ROR(y[127 .. 64], 41));
    Vtmp[127 .. 64] = EOR(y[127 .. 64] & x[63 .. 0], not_vec(y[127 .. 64]) & x[127 .. 64]);
    Vtmp[127 .. 64] = Vtmp[127 .. 64] + MSigma1 + w[127 .. 64];
    let tmp : bits(64) = Vtmp[127 .. 64] + y[63 .. 0];
    let MSigma1 : bits(64) = EOR(EOR(ROR(tmp, 14), ROR(tmp, 18)), ROR(tmp, 41));
    Vtmp[63 .. 0] = EOR(tmp & y[127 .. 64], not_vec(tmp) & x[63 .. 0]);
    Vtmp[63 .. 0] = Vtmp[63 .. 0] + MSigma1 + w[63 .. 0];
    V_set(d, 128) = Vtmp
}

val decode_sha512h_advsimd_aarch64_instrs_vector_crypto_sha512_sha512h : (bits(5), bits(5), bits(5)) -> unit

function decode_sha512h_advsimd_aarch64_instrs_vector_crypto_sha512_sha512h (Rd, Rn, Rm) = {
    if not_bool(HaveSHA512Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    execute_aarch64_instrs_vector_crypto_sha512_sha512h(d, m, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitone, bitone, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, _, _, _, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 806) = {
    SEE = 806;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    decode_sha512h_advsimd_aarch64_instrs_vector_crypto_sha512_sha512h(Rd, Rn, Rm)
}

val execute_aarch64_instrs_vector_crypto_sha512_sha512h2 : forall 'd 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 0 <= 'd & 'd <= 31).
  (int('d), int('m), int('n)) -> unit

function execute_aarch64_instrs_vector_crypto_sha512_sha512h2 (d, m, n) = {
    AArch64_CheckFPAdvSIMDEnabled();
    Vtmp : bits(128) = undefined;
    let x : bits(128) = V_read(n, 128);
    let y : bits(128) = V_read(m, 128);
    let w : bits(128) = V_read(d, 128);
    NSigma0 : bits(64) = EOR(EOR(ROR(y[63 .. 0], 28), ROR(y[63 .. 0], 34)), ROR(y[63 .. 0], 39));
    Vtmp[127 .. 64] = EOR(EOR(x[63 .. 0] & y[127 .. 64], x[63 .. 0] & y[63 .. 0]), y[127 .. 64] & y[63 .. 0]);
    Vtmp[127 .. 64] = Vtmp[127 .. 64] + NSigma0 + w[127 .. 64];
    let NSigma0 : bits(64) = EOR(EOR(ROR(Vtmp[127 .. 64], 28), ROR(Vtmp[127 .. 64], 34)), ROR(Vtmp[127 .. 64], 39));
    Vtmp[63 .. 0] = EOR(EOR(Vtmp[127 .. 64] & y[63 .. 0], Vtmp[127 .. 64] & y[127 .. 64]), y[127 .. 64] & y[63 .. 0]);
    Vtmp[63 .. 0] = Vtmp[63 .. 0] + NSigma0 + w[63 .. 0];
    V_set(d, 128) = Vtmp
}

val decode_sha512h2_advsimd_aarch64_instrs_vector_crypto_sha512_sha512h2 : (bits(5), bits(5), bits(5)) -> unit

function decode_sha512h2_advsimd_aarch64_instrs_vector_crypto_sha512_sha512h2 (Rd, Rn, Rm) = {
    if not_bool(HaveSHA512Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    execute_aarch64_instrs_vector_crypto_sha512_sha512h2(d, m, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitone, bitone, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, _, _, _, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 807) = {
    SEE = 807;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    decode_sha512h2_advsimd_aarch64_instrs_vector_crypto_sha512_sha512h2(Rd, Rn, Rm)
}

val execute_aarch64_instrs_vector_crypto_sha512_sha512su0 : forall 'd 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'd & 'd <= 31).
  (int('d), int('n)) -> unit

function execute_aarch64_instrs_vector_crypto_sha512_sha512su0 (d, n) = {
    AArch64_CheckFPAdvSIMDEnabled();
    Vtmp : bits(128) = undefined;
    let x : bits(128) = V_read(n, 128);
    let w : bits(128) = V_read(d, 128);
    sig0 : bits(64) = EOR(EOR(ROR(w[127 .. 64], 1), ROR(w[127 .. 64], 8)), 0b0000000 @ w[127 .. 71]);
    Vtmp[63 .. 0] = w[63 .. 0] + sig0;
    let sig0 : bits(64) = EOR(EOR(ROR(x[63 .. 0], 1), ROR(x[63 .. 0], 8)), 0b0000000 @ x[63 .. 7]);
    Vtmp[127 .. 64] = w[127 .. 64] + sig0;
    V_set(d, 128) = Vtmp
}

val decode_sha512su0_advsimd_aarch64_instrs_vector_crypto_sha512_sha512su0 : (bits(5), bits(5)) -> unit

function decode_sha512su0_advsimd_aarch64_instrs_vector_crypto_sha512_sha512su0 (Rd, Rn) = {
    if not_bool(HaveSHA512Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    execute_aarch64_instrs_vector_crypto_sha512_sha512su0(d, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitone, bitone, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 808) = {
    SEE = 808;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    decode_sha512su0_advsimd_aarch64_instrs_vector_crypto_sha512_sha512su0(Rd, Rn)
}

val execute_aarch64_instrs_vector_crypto_sha512_sha512su1 : forall 'd 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 0 <= 'd & 'd <= 31).
  (int('d), int('m), int('n)) -> unit

function execute_aarch64_instrs_vector_crypto_sha512_sha512su1 (d, m, n) = {
    AArch64_CheckFPAdvSIMDEnabled();
    Vtmp : bits(128) = undefined;
    let x : bits(128) = V_read(n, 128);
    let y : bits(128) = V_read(m, 128);
    let w : bits(128) = V_read(d, 128);
    sig1 : bits(64) = EOR(EOR(ROR(x[127 .. 64], 19), ROR(x[127 .. 64], 61)), 0b000000 @ x[127 .. 70]);
    Vtmp[127 .. 64] = w[127 .. 64] + sig1 + y[127 .. 64];
    let sig1 : bits(64) = EOR(EOR(ROR(x[63 .. 0], 19), ROR(x[63 .. 0], 61)), 0b000000 @ x[63 .. 6]);
    Vtmp[63 .. 0] = w[63 .. 0] + sig1 + y[63 .. 0];
    V_set(d, 128) = Vtmp
}

val decode_sha512su1_advsimd_aarch64_instrs_vector_crypto_sha512_sha512su1 : (bits(5), bits(5), bits(5)) -> unit

function decode_sha512su1_advsimd_aarch64_instrs_vector_crypto_sha512_sha512su1 (Rd, Rn, Rm) = {
    if not_bool(HaveSHA512Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    execute_aarch64_instrs_vector_crypto_sha512_sha512su1(d, m, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitone, bitone, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, _, _, _, _, _, bitone, bitzero, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 809) = {
    SEE = 809;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    decode_sha512su1_advsimd_aarch64_instrs_vector_crypto_sha512_sha512su1(Rd, Rn, Rm)
}

val execute_aarch64_instrs_vector_arithmetic_binary_uniform_add_halving_truncating : forall 'd 'datasize 'elements 'esize ('is_unsigned : Bool) 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'esize in {8, 16, 32, 64} & 'datasize in {64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('m), int('n), bool('is_unsigned)) -> unit

function execute_aarch64_instrs_vector_arithmetic_binary_uniform_add_halving_truncating (d, datasize, elements, esize, m, n, is_unsigned) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = V_read(n, datasize);
    let operand2 : bits('datasize) = V_read(m, datasize);
    result : bits('datasize) = undefined;
    element1 : int = undefined;
    element2 : int = undefined;
    sum : int = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element1 = asl_Int(Elem_read(operand1, e, esize), is_unsigned);
        element2 = asl_Int(Elem_read(operand2, e, esize), is_unsigned);
        sum = ((element1 + element2) >> 1);
        result = Elem_set(result, e, esize, sum[esize - 1 .. 0])
    };
    V_set(d, datasize) = result
}

val decode_shadd_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_add_halving_truncating : (bits(5), bits(5), bits(5), bits(2), bits(1), bits(1)) -> unit

function decode_shadd_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_add_halving_truncating (Rd, Rn, Rm, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_add_halving_truncating(d, datasize, elements, esize, m, n, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 810) = {
    SEE = 810;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_shadd_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_add_halving_truncating(Rd, Rn, Rm, size, U, Q)
}

val decode_uhadd_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_add_halving_truncating : (bits(5), bits(5), bits(5), bits(2), bits(1), bits(1)) -> unit

function decode_uhadd_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_add_halving_truncating (Rd, Rn, Rm, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_add_halving_truncating(d, datasize, elements, esize, m, n, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 811) = {
    SEE = 811;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_uhadd_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_add_halving_truncating(Rd, Rn, Rm, size, U, Q)
}

val execute_aarch64_instrs_vector_shift_left_sisd : forall 'd 'datasize 'elements 'esize 'n 'shift,
  (0 <= 'n & 'n <= 31 & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('n), int('shift)) -> unit

function execute_aarch64_instrs_vector_shift_left_sisd (d, datasize, elements, esize, n, shift) = {
    CheckFPAdvSIMDEnabled64();
    assert(constraint('datasize in {8, 16, 32, 64, 128}));
    let operand : bits('datasize) = V_read(n, datasize);
    result : bits('datasize) = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        assert(constraint('esize >= 0));
        assert(constraint(('loop_e * 'esize <= 'loop_e * 'esize + 'esize - 1 | not(('loop_e >= 0 & ('loop_e + 1) * 'esize <= 'datasize)) | not('datasize in {8, 16, 32, 64, 128}))));
        result = Elem_set(result, e, esize, LSL(Elem_read(operand, e, esize), shift))
    };
    V_set(d, datasize) = result
}

val decode_shl_advsimd_aarch64_instrs_vector_shift_left_sisd : (bits(5), bits(5), bits(3), bits(4)) -> unit

function decode_shl_advsimd_aarch64_instrs_vector_shift_left_sisd (Rd, Rn, immb, immh) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if [immh[3]] != 0b1 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << 3);
    let 'datasize = esize;
    let 'elements = 1;
    let 'shift = UInt(immh @ immb) - esize;
    execute_aarch64_instrs_vector_shift_left_sisd(d, datasize, elements, esize, n, shift)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, bitzero, bitone, bitzero, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 812) = {
    SEE = 812;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let immb = Slice(__opcode, 16, 3);
    let immh = Slice(__opcode, 19, 4);
    decode_shl_advsimd_aarch64_instrs_vector_shift_left_sisd(Rd, Rn, immb, immh)
}

val decode_shl_advsimd_aarch64_instrs_vector_shift_left_simd : (bits(5), bits(5), bits(3), bits(4), bits(1)) -> unit

function decode_shl_advsimd_aarch64_instrs_vector_shift_left_simd (Rd, Rn, immb, immh, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if immh == 0b0000 then {
        throw(Error_See("asimdimm"))
    };
    if ([immh[3]] @ Q) == 0b10 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << HighestSetBit(immh));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let 'shift = UInt(immh @ immb) - esize;
    execute_aarch64_instrs_vector_shift_left_sisd(d, datasize, elements, esize, n, shift)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, bitzero, bitone, bitzero, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 813) = {
    SEE = 813;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let immb = Slice(__opcode, 16, 3);
    let immh = Slice(__opcode, 19, 4);
    let Q = Slice(__opcode, 30, 1);
    decode_shl_advsimd_aarch64_instrs_vector_shift_left_simd(Rd, Rn, immb, immh, Q)
}

val execute_aarch64_instrs_vector_arithmetic_unary_shift : forall 'd 'datasize 'elements 'esize ('is_unsigned : Bool) 'n 'part 'shift,
  ('shift in {8, 16, 32, 64} & 'part in {0, 1} & 0 <= 'n & 'n <= 31 & 'esize in {8, 16, 32, 64} & 'datasize == 64 & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('n), int('part), int('shift), bool('is_unsigned)) -> unit

function execute_aarch64_instrs_vector_arithmetic_unary_shift (d, datasize, elements, esize, n, part, shift, is_unsigned) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('datasize) = Vpart_read(n, part, datasize);
    result : bits(2 * 'datasize) = undefined;
    element : int = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element = (asl_Int(Elem_read(operand, e, esize), is_unsigned) << shift);
        result = Elem_set(result, e, 2 * esize, element[2 * esize - 1 .. 0])
    };
    V_set(d, 2 * datasize) = result
}

val decode_shll_advsimd_aarch64_instrs_vector_arithmetic_unary_shift : (bits(5), bits(5), bits(2), bits(1)) -> unit

function decode_shll_advsimd_aarch64_instrs_vector_arithmetic_unary_shift (Rd, Rn, size, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    let 'datasize = 64;
    let 'part = UInt(Q);
    let 'elements = DIV(datasize, esize);
    let 'shift = esize;
    let is_unsigned : bool = false;
    execute_aarch64_instrs_vector_arithmetic_unary_shift(d, datasize, elements, esize, n, part, shift, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 814) = {
    SEE = 814;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 22, 2);
    let Q = Slice(__opcode, 30, 1);
    decode_shll_advsimd_aarch64_instrs_vector_arithmetic_unary_shift(Rd, Rn, size, Q)
}

val execute_aarch64_instrs_vector_arithmetic_binary_uniform_sub_int : forall 'd 'datasize 'elements 'esize ('is_unsigned : Bool) 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'esize in {8, 16, 32, 64} & 'datasize in {64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('m), int('n), bool('is_unsigned)) -> unit

function execute_aarch64_instrs_vector_arithmetic_binary_uniform_sub_int (d, datasize, elements, esize, m, n, is_unsigned) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = V_read(n, datasize);
    let operand2 : bits('datasize) = V_read(m, datasize);
    result : bits('datasize) = undefined;
    element1 : int = undefined;
    element2 : int = undefined;
    diff : int = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element1 = asl_Int(Elem_read(operand1, e, esize), is_unsigned);
        element2 = asl_Int(Elem_read(operand2, e, esize), is_unsigned);
        diff = ((element1 - element2) >> 1);
        result = Elem_set(result, e, esize, diff[esize - 1 .. 0])
    };
    V_set(d, datasize) = result
}

val decode_shsub_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_sub_int : (bits(5), bits(5), bits(5), bits(2), bits(1), bits(1)) -> unit

function decode_shsub_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_sub_int (Rd, Rn, Rm, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_sub_int(d, datasize, elements, esize, m, n, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitzero, bitone, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 815) = {
    SEE = 815;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_shsub_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_sub_int(Rd, Rn, Rm, size, U, Q)
}

val decode_uhsub_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_sub_int : (bits(5), bits(5), bits(5), bits(2), bits(1), bits(1)) -> unit

function decode_uhsub_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_sub_int (Rd, Rn, Rm, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_sub_int(d, datasize, elements, esize, m, n, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitzero, bitone, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 816) = {
    SEE = 816;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_uhsub_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_sub_int(Rd, Rn, Rm, size, U, Q)
}

val execute_aarch64_instrs_vector_shift_left_insert_sisd : forall 'd 'datasize 'elements 'esize 'n 'shift,
  (0 <= 'n & 'n <= 31 & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('n), int('shift)) -> unit

function execute_aarch64_instrs_vector_shift_left_insert_sisd (d, datasize, elements, esize, n, shift) = {
    CheckFPAdvSIMDEnabled64();
    assert(constraint('datasize in {8, 16, 32, 64, 128}));
    let operand : bits('datasize) = V_read(n, datasize);
    let operand2 : bits('datasize) = V_read(d, datasize);
    result : bits('datasize) = undefined;
    assert(constraint('esize >= 0));
    let mask : bits('esize) = LSL(Ones(esize), shift);
    shifted : bits('esize) = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        assert(constraint(('loop_e * 'esize <= 'loop_e * 'esize + 'esize - 1 | not(('loop_e >= 0 & ('loop_e + 1) * 'esize <= 'datasize)) | not('esize >= 0) | not('datasize in {8, 16, 32, 64, 128}))));
        shifted = LSL(Elem_read(operand, e, esize), shift);
        result = Elem_set(result, e, esize, Elem_read(operand2, e, esize) & not_vec(mask) | shifted)
    };
    V_set(d, datasize) = result
}

val decode_sli_advsimd_aarch64_instrs_vector_shift_left_insert_sisd : (bits(5), bits(5), bits(3), bits(4)) -> unit

function decode_sli_advsimd_aarch64_instrs_vector_shift_left_insert_sisd (Rd, Rn, immb, immh) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if [immh[3]] != 0b1 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << 3);
    let 'datasize = esize;
    let 'elements = 1;
    let 'shift = UInt(immh @ immb) - esize;
    execute_aarch64_instrs_vector_shift_left_insert_sisd(d, datasize, elements, esize, n, shift)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, bitzero, bitone, bitzero, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 817) = {
    SEE = 817;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let immb = Slice(__opcode, 16, 3);
    let immh = Slice(__opcode, 19, 4);
    decode_sli_advsimd_aarch64_instrs_vector_shift_left_insert_sisd(Rd, Rn, immb, immh)
}

val decode_sli_advsimd_aarch64_instrs_vector_shift_left_insert_simd : (bits(5), bits(5), bits(3), bits(4), bits(1)) -> unit

function decode_sli_advsimd_aarch64_instrs_vector_shift_left_insert_simd (Rd, Rn, immb, immh, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if immh == 0b0000 then {
        throw(Error_See("asimdimm"))
    };
    if ([immh[3]] @ Q) == 0b10 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << HighestSetBit(immh));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let 'shift = UInt(immh @ immb) - esize;
    execute_aarch64_instrs_vector_shift_left_insert_sisd(d, datasize, elements, esize, n, shift)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, bitzero, bitone, bitzero, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 818) = {
    SEE = 818;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let immb = Slice(__opcode, 16, 3);
    let immh = Slice(__opcode, 19, 4);
    let Q = Slice(__opcode, 30, 1);
    decode_sli_advsimd_aarch64_instrs_vector_shift_left_insert_simd(Rd, Rn, immb, immh, Q)
}

val execute_aarch64_instrs_vector_crypto_sm3_sm3partw1 : forall 'd 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 0 <= 'd & 'd <= 31).
  (int('d), int('m), int('n)) -> unit

function execute_aarch64_instrs_vector_crypto_sm3_sm3partw1 (d, m, n) = {
    AArch64_CheckFPAdvSIMDEnabled();
    let Vm : bits(128) = V_read(m, 128);
    let Vn : bits(128) = V_read(n, 128);
    let Vd : bits(128) = V_read(d, 128);
    result : bits(128) = undefined;
    result[95 .. 0] = EOR(EOR(Vd, Vn)[95 .. 0], (ROL(Vm[127 .. 96], 15) @ ROL(Vm[95 .. 64], 15)) @ ROL(Vm[63 .. 32], 15));
    foreach (i from 0 to 3 by 1 in inc) {
        if i == 3 then {
            result[127 .. 96] = EOR(EOR(Vd, Vn)[127 .. 96], ROL(result[31 .. 0], 15))
        };
        result[32 * i + 31 .. 32 * i] = EOR(EOR(result[32 * i + 31 .. 32 * i], ROL(result[32 * i + 31 .. 32 * i], 15)), ROL(result[32 * i + 31 .. 32 * i], 23))
    };
    V_set(d, 128) = result
}

val decode_sm3partw1_advsimd_aarch64_instrs_vector_crypto_sm3_sm3partw1 : (bits(5), bits(5), bits(5)) -> unit

function decode_sm3partw1_advsimd_aarch64_instrs_vector_crypto_sm3_sm3partw1 (Rd, Rn, Rm) = {
    if not_bool(HaveSM3Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    execute_aarch64_instrs_vector_crypto_sm3_sm3partw1(d, m, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitone, bitone, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, _, _, _, _, _, bitone, bitone, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 819) = {
    SEE = 819;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    decode_sm3partw1_advsimd_aarch64_instrs_vector_crypto_sm3_sm3partw1(Rd, Rn, Rm)
}

val execute_aarch64_instrs_vector_crypto_sm3_sm3partw2 : forall 'd 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 0 <= 'd & 'd <= 31).
  (int('d), int('m), int('n)) -> unit

function execute_aarch64_instrs_vector_crypto_sm3_sm3partw2 (d, m, n) = {
    AArch64_CheckFPAdvSIMDEnabled();
    let Vm : bits(128) = V_read(m, 128);
    let Vn : bits(128) = V_read(n, 128);
    let Vd : bits(128) = V_read(d, 128);
    result : bits(128) = undefined;
    tmp : bits(128) = undefined;
    tmp[127 .. 0] = EOR(Vn, ((ROL(Vm[127 .. 96], 7) @ ROL(Vm[95 .. 64], 7)) @ ROL(Vm[63 .. 32], 7)) @ ROL(Vm[31 .. 0], 7));
    result[127 .. 0] = EOR(Vd[127 .. 0], tmp[127 .. 0]);
    tmp2 : bits(32) = ROL(tmp[31 .. 0], 15);
    let tmp2 : bits(32) = EOR(EOR(tmp2, ROL(tmp2, 15)), ROL(tmp2, 23));
    result[127 .. 96] = EOR(result[127 .. 96], tmp2);
    V_set(d, 128) = result
}

val decode_sm3partw2_advsimd_aarch64_instrs_vector_crypto_sm3_sm3partw2 : (bits(5), bits(5), bits(5)) -> unit

function decode_sm3partw2_advsimd_aarch64_instrs_vector_crypto_sm3_sm3partw2 (Rd, Rn, Rm) = {
    if not_bool(HaveSM3Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    execute_aarch64_instrs_vector_crypto_sm3_sm3partw2(d, m, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitone, bitone, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, _, _, _, _, _, bitone, bitone, bitzero, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 820) = {
    SEE = 820;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    decode_sm3partw2_advsimd_aarch64_instrs_vector_crypto_sm3_sm3partw2(Rd, Rn, Rm)
}

val execute_aarch64_instrs_vector_crypto_sm3_sm3ss1 : forall 'a 'd 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 0 <= 'd & 'd <= 31 & 0 <= 'a & 'a <= 31).
  (int('a), int('d), int('m), int('n)) -> unit

function execute_aarch64_instrs_vector_crypto_sm3_sm3ss1 (a, d, m, n) = {
    AArch64_CheckFPAdvSIMDEnabled();
    let Vm : bits(128) = V_read(m, 128);
    let Vn : bits(128) = V_read(n, 128);
    let Va : bits(128) = V_read(a, 128);
    result : bits(128) = undefined;
    result[127 .. 96] = ROL(ROL(Vn[127 .. 96], 12) + Vm[127 .. 96] + Va[127 .. 96], 7);
    result[95 .. 0] = Zeros(96);
    V_set(d, 128) = result
}

val decode_sm3ss1_advsimd_aarch64_instrs_vector_crypto_sm3_sm3ss1 : (bits(5), bits(5), bits(5), bits(5)) -> unit

function decode_sm3ss1_advsimd_aarch64_instrs_vector_crypto_sm3_sm3ss1 (Rd, Rn, Ra, Rm) = {
    if not_bool(HaveSM3Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'a = UInt(Ra);
    execute_aarch64_instrs_vector_crypto_sm3_sm3ss1(a, d, m, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitone, bitone, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 821) = {
    SEE = 821;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Ra = Slice(__opcode, 10, 5);
    let Rm = Slice(__opcode, 16, 5);
    decode_sm3ss1_advsimd_aarch64_instrs_vector_crypto_sm3_sm3ss1(Rd, Rn, Ra, Rm)
}

val execute_aarch64_instrs_vector_crypto_sm3_sm3tt1a : forall 'd 'i 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'i in {0, 1, 2, 3} & 0 <= 'd & 'd <= 31).
  (int('d), int('i), int('m), int('n)) -> unit

function execute_aarch64_instrs_vector_crypto_sm3_sm3tt1a (d, i, m, n) = {
    AArch64_CheckFPAdvSIMDEnabled();
    let Vm : bits(128) = V_read(m, 128);
    let Vn : bits(128) = V_read(n, 128);
    let Vd : bits(128) = V_read(d, 128);
    result : bits(128) = undefined;
    let WjPrime : bits(32) = Elem_read(Vm, i, 32);
    let SS2 : bits(32) = EOR(Vn[127 .. 96], ROL(Vd[127 .. 96], 12));
    TT1 : bits(32) = EOR(Vd[63 .. 32], EOR(Vd[127 .. 96], Vd[95 .. 64]));
    let TT1 : bits(32) = (TT1 + Vd[31 .. 0] + SS2 + WjPrime)[31 .. 0];
    result[31 .. 0] = Vd[63 .. 32];
    result[63 .. 32] = ROL(Vd[95 .. 64], 9);
    result[95 .. 64] = Vd[127 .. 96];
    result[127 .. 96] = TT1;
    V_set(d, 128) = result
}

val decode_sm3tt1a_advsimd_aarch64_instrs_vector_crypto_sm3_sm3tt1a : (bits(5), bits(5), bits(2), bits(5)) -> unit

function decode_sm3tt1a_advsimd_aarch64_instrs_vector_crypto_sm3_sm3tt1a (Rd, Rn, imm2, Rm) = {
    if not_bool(HaveSM3Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'i = UInt(imm2);
    execute_aarch64_instrs_vector_crypto_sm3_sm3tt1a(d, i, m, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitone, bitone, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, bitone, bitzero, _, _, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 822) = {
    SEE = 822;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm2 = Slice(__opcode, 12, 2);
    let Rm = Slice(__opcode, 16, 5);
    decode_sm3tt1a_advsimd_aarch64_instrs_vector_crypto_sm3_sm3tt1a(Rd, Rn, imm2, Rm)
}

val execute_aarch64_instrs_vector_crypto_sm3_sm3tt1b : forall 'd 'i 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'i in {0, 1, 2, 3} & 0 <= 'd & 'd <= 31).
  (int('d), int('i), int('m), int('n)) -> unit

function execute_aarch64_instrs_vector_crypto_sm3_sm3tt1b (d, i, m, n) = {
    AArch64_CheckFPAdvSIMDEnabled();
    let Vm : bits(128) = V_read(m, 128);
    let Vn : bits(128) = V_read(n, 128);
    let Vd : bits(128) = V_read(d, 128);
    result : bits(128) = undefined;
    let WjPrime : bits(32) = Elem_read(Vm, i, 32);
    let SS2 : bits(32) = EOR(Vn[127 .. 96], ROL(Vd[127 .. 96], 12));
    TT1 : bits(32) = (Vd[127 .. 96] & Vd[63 .. 32] | Vd[127 .. 96] & Vd[95 .. 64]) | Vd[63 .. 32] & Vd[95 .. 64];
    let TT1 : bits(32) = (TT1 + Vd[31 .. 0] + SS2 + WjPrime)[31 .. 0];
    result[31 .. 0] = Vd[63 .. 32];
    result[63 .. 32] = ROL(Vd[95 .. 64], 9);
    result[95 .. 64] = Vd[127 .. 96];
    result[127 .. 96] = TT1;
    V_set(d, 128) = result
}

val decode_sm3tt1b_advsimd_aarch64_instrs_vector_crypto_sm3_sm3tt1b : (bits(5), bits(5), bits(2), bits(5)) -> unit

function decode_sm3tt1b_advsimd_aarch64_instrs_vector_crypto_sm3_sm3tt1b (Rd, Rn, imm2, Rm) = {
    if not_bool(HaveSM3Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'i = UInt(imm2);
    execute_aarch64_instrs_vector_crypto_sm3_sm3tt1b(d, i, m, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitone, bitone, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, bitone, bitzero, _, _, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 823) = {
    SEE = 823;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm2 = Slice(__opcode, 12, 2);
    let Rm = Slice(__opcode, 16, 5);
    decode_sm3tt1b_advsimd_aarch64_instrs_vector_crypto_sm3_sm3tt1b(Rd, Rn, imm2, Rm)
}

val execute_aarch64_instrs_vector_crypto_sm3_sm3tt2a : forall 'd 'i 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'i in {0, 1, 2, 3} & 0 <= 'd & 'd <= 31).
  (int('d), int('i), int('m), int('n)) -> unit

function execute_aarch64_instrs_vector_crypto_sm3_sm3tt2a (d, i, m, n) = {
    AArch64_CheckFPAdvSIMDEnabled();
    let Vm : bits(128) = V_read(m, 128);
    let Vn : bits(128) = V_read(n, 128);
    let Vd : bits(128) = V_read(d, 128);
    result : bits(128) = undefined;
    let Wj : bits(32) = Elem_read(Vm, i, 32);
    TT2 : bits(32) = EOR(Vd[63 .. 32], EOR(Vd[127 .. 96], Vd[95 .. 64]));
    let TT2 : bits(32) = (TT2 + Vd[31 .. 0] + Vn[127 .. 96] + Wj)[31 .. 0];
    result[31 .. 0] = Vd[63 .. 32];
    result[63 .. 32] = ROL(Vd[95 .. 64], 19);
    result[95 .. 64] = Vd[127 .. 96];
    result[127 .. 96] = EOR(EOR(TT2, ROL(TT2, 9)), ROL(TT2, 17));
    V_set(d, 128) = result
}

val decode_sm3tt2a_advsimd_aarch64_instrs_vector_crypto_sm3_sm3tt2a : (bits(5), bits(5), bits(2), bits(5)) -> unit

function decode_sm3tt2a_advsimd_aarch64_instrs_vector_crypto_sm3_sm3tt2a (Rd, Rn, imm2, Rm) = {
    if not_bool(HaveSM3Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'i = UInt(imm2);
    execute_aarch64_instrs_vector_crypto_sm3_sm3tt2a(d, i, m, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitone, bitone, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, bitone, bitzero, _, _, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 824) = {
    SEE = 824;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm2 = Slice(__opcode, 12, 2);
    let Rm = Slice(__opcode, 16, 5);
    decode_sm3tt2a_advsimd_aarch64_instrs_vector_crypto_sm3_sm3tt2a(Rd, Rn, imm2, Rm)
}

val execute_aarch64_instrs_vector_crypto_sm3_sm3tt2b : forall 'd 'i 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'i in {0, 1, 2, 3} & 0 <= 'd & 'd <= 31).
  (int('d), int('i), int('m), int('n)) -> unit

function execute_aarch64_instrs_vector_crypto_sm3_sm3tt2b (d, i, m, n) = {
    AArch64_CheckFPAdvSIMDEnabled();
    let Vm : bits(128) = V_read(m, 128);
    let Vn : bits(128) = V_read(n, 128);
    let Vd : bits(128) = V_read(d, 128);
    result : bits(128) = undefined;
    let Wj : bits(32) = Elem_read(Vm, i, 32);
    TT2 : bits(32) = Vd[127 .. 96] & Vd[95 .. 64] | not_vec(Vd[127 .. 96]) & Vd[63 .. 32];
    let TT2 : bits(32) = (TT2 + Vd[31 .. 0] + Vn[127 .. 96] + Wj)[31 .. 0];
    result[31 .. 0] = Vd[63 .. 32];
    result[63 .. 32] = ROL(Vd[95 .. 64], 19);
    result[95 .. 64] = Vd[127 .. 96];
    result[127 .. 96] = EOR(EOR(TT2, ROL(TT2, 9)), ROL(TT2, 17));
    V_set(d, 128) = result
}

val decode_sm3tt2b_advsimd_aarch64_instrs_vector_crypto_sm3_sm3tt2b : (bits(5), bits(5), bits(2), bits(5)) -> unit

function decode_sm3tt2b_advsimd_aarch64_instrs_vector_crypto_sm3_sm3tt2b (Rd, Rn, imm2, Rm) = {
    if not_bool(HaveSM3Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'i = UInt(imm2);
    execute_aarch64_instrs_vector_crypto_sm3_sm3tt2b(d, i, m, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitone, bitone, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, bitone, bitzero, _, _, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 825) = {
    SEE = 825;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm2 = Slice(__opcode, 12, 2);
    let Rm = Slice(__opcode, 16, 5);
    decode_sm3tt2b_advsimd_aarch64_instrs_vector_crypto_sm3_sm3tt2b(Rd, Rn, imm2, Rm)
}

val execute_aarch64_instrs_vector_crypto_sm4_sm4enc : forall 'd 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'd & 'd <= 31).
  (int('d), int('n)) -> unit

function execute_aarch64_instrs_vector_crypto_sm4_sm4enc (d, n) = {
    AArch64_CheckFPAdvSIMDEnabled();
    let Vn : bits(128) = V_read(n, 128);
    intval : bits(32) = undefined;
    roundkey : bits(32) = undefined;
    roundresult : bits(128) = V_read(d, 128);
    foreach (index from 0 to 3 by 1 in inc) {
        roundkey = Elem_read(Vn, index, 32);
        intval = EOR(EOR(EOR(roundresult[127 .. 96], roundresult[95 .. 64]), roundresult[63 .. 32]), roundkey);
        foreach (i from 0 to 3 by 1 in inc) {
            intval = Elem_set(intval, i, 8, Sbox(Elem_read(intval, i, 8)))
        };
        intval = EOR(EOR(EOR(EOR(intval, ROL(intval, 2)), ROL(intval, 10)), ROL(intval, 18)), ROL(intval, 24));
        intval = EOR(intval, roundresult[31 .. 0]);
        roundresult[31 .. 0] = roundresult[63 .. 32];
        roundresult[63 .. 32] = roundresult[95 .. 64];
        roundresult[95 .. 64] = roundresult[127 .. 96];
        roundresult[127 .. 96] = intval
    };
    V_set(d, 128) = roundresult
}

val decode_sm4e_advsimd_aarch64_instrs_vector_crypto_sm4_sm4enc : (bits(5), bits(5)) -> unit

function decode_sm4e_advsimd_aarch64_instrs_vector_crypto_sm4_sm4enc (Rd, Rn) = {
    if not_bool(HaveSM4Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    execute_aarch64_instrs_vector_crypto_sm4_sm4enc(d, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitone, bitone, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 826) = {
    SEE = 826;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    decode_sm4e_advsimd_aarch64_instrs_vector_crypto_sm4_sm4enc(Rd, Rn)
}

val execute_aarch64_instrs_vector_crypto_sm4_sm4enckey : forall 'd 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 0 <= 'd & 'd <= 31).
  (int('d), int('m), int('n)) -> unit

function execute_aarch64_instrs_vector_crypto_sm4_sm4enckey (d, m, n) = {
    AArch64_CheckFPAdvSIMDEnabled();
    let Vm : bits(128) = V_read(m, 128);
    intval : bits(32) = undefined;
    const : bits(32) = undefined;
    roundresult : bits(128) = V_read(n, 128);
    foreach (index from 0 to 3 by 1 in inc) {
        const = Elem_read(Vm, index, 32);
        intval = EOR(EOR(EOR(roundresult[127 .. 96], roundresult[95 .. 64]), roundresult[63 .. 32]), const);
        foreach (i from 0 to 3 by 1 in inc) {
            intval = Elem_set(intval, i, 8, Sbox(Elem_read(intval, i, 8)))
        };
        intval = EOR(EOR(intval, ROL(intval, 13)), ROL(intval, 23));
        intval = EOR(intval, roundresult[31 .. 0]);
        roundresult[31 .. 0] = roundresult[63 .. 32];
        roundresult[63 .. 32] = roundresult[95 .. 64];
        roundresult[95 .. 64] = roundresult[127 .. 96];
        roundresult[127 .. 96] = intval
    };
    V_set(d, 128) = roundresult
}

val decode_sm4ekey_advsimd_aarch64_instrs_vector_crypto_sm4_sm4enckey : (bits(5), bits(5), bits(5)) -> unit

function decode_sm4ekey_advsimd_aarch64_instrs_vector_crypto_sm4_sm4enckey (Rd, Rn, Rm) = {
    if not_bool(HaveSM4Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    execute_aarch64_instrs_vector_crypto_sm4_sm4enckey(d, m, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitone, bitone, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, _, _, _, _, _, bitone, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 827) = {
    SEE = 827;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    decode_sm4ekey_advsimd_aarch64_instrs_vector_crypto_sm4_sm4enckey(Rd, Rn, Rm)
}

val execute_aarch64_instrs_integer_arithmetic_mul_widening_32_64 : forall 'a 'd 'datasize 'destsize ('is_unsigned : Bool) 'm 'n ('sub_op : Bool),
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'destsize == 64 & 'datasize == 32 & 0 <= 'd & 'd <= 31 & 0 <= 'a & 'a <= 31).
  (int('a), int('d), int('datasize), int('destsize), int('m), int('n), bool('sub_op), bool('is_unsigned)) -> unit

function execute_aarch64_instrs_integer_arithmetic_mul_widening_32_64 (a, d, datasize, destsize, m, n, sub_op, is_unsigned) = {
    let operand1 : bits('datasize) = X_read(n, datasize);
    let operand2 : bits('datasize) = X_read(m, datasize);
    let operand3 : bits('destsize) = X_read(a, destsize);
    result : int = undefined;
    if sub_op then {
        result = asl_Int(operand3, is_unsigned) - asl_Int(operand1, is_unsigned) * asl_Int(operand2, is_unsigned)
    } else {
        result = asl_Int(operand3, is_unsigned) + asl_Int(operand1, is_unsigned) * asl_Int(operand2, is_unsigned)
    };
    let 'result = result;
    X_set(d, 64) = result[63 .. 0]
}

val decode_smaddl_aarch64_instrs_integer_arithmetic_mul_widening_32_64 : (bits(5), bits(5), bits(5), bits(1), bits(5), bits(1)) -> unit

function decode_smaddl_aarch64_instrs_integer_arithmetic_mul_widening_32_64 (Rd, Rn, Ra, o0, Rm, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'a = UInt(Ra);
    let 'destsize = 64;
    let 'datasize = 32;
    let sub_op : bool = o0 == 0b1;
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_integer_arithmetic_mul_widening_32_64(a, d, datasize, destsize, m, n, sub_op, is_unsigned)
}

function clause __DecodeA64_DataProcReg ((pc, ([bitone, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitone, _, _, _, _, _, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 828) = {
    SEE = 828;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Ra = Slice(__opcode, 10, 5);
    let o0 = Slice(__opcode, 15, 1);
    let Rm = Slice(__opcode, 16, 5);
    let U = Slice(__opcode, 23, 1);
    decode_smaddl_aarch64_instrs_integer_arithmetic_mul_widening_32_64(Rd, Rn, Ra, o0, Rm, U)
}

val decode_smsubl_aarch64_instrs_integer_arithmetic_mul_widening_32_64 : (bits(5), bits(5), bits(5), bits(1), bits(5), bits(1)) -> unit

function decode_smsubl_aarch64_instrs_integer_arithmetic_mul_widening_32_64 (Rd, Rn, Ra, o0, Rm, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'a = UInt(Ra);
    let 'destsize = 64;
    let 'datasize = 32;
    let sub_op : bool = o0 == 0b1;
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_integer_arithmetic_mul_widening_32_64(a, d, datasize, destsize, m, n, sub_op, is_unsigned)
}

function clause __DecodeA64_DataProcReg ((pc, ([bitone, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitone, _, _, _, _, _, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 829) = {
    SEE = 829;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Ra = Slice(__opcode, 10, 5);
    let o0 = Slice(__opcode, 15, 1);
    let Rm = Slice(__opcode, 16, 5);
    let U = Slice(__opcode, 23, 1);
    decode_smsubl_aarch64_instrs_integer_arithmetic_mul_widening_32_64(Rd, Rn, Ra, o0, Rm, U)
}

val decode_umaddl_aarch64_instrs_integer_arithmetic_mul_widening_32_64 : (bits(5), bits(5), bits(5), bits(1), bits(5), bits(1)) -> unit

function decode_umaddl_aarch64_instrs_integer_arithmetic_mul_widening_32_64 (Rd, Rn, Ra, o0, Rm, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'a = UInt(Ra);
    let 'destsize = 64;
    let 'datasize = 32;
    let sub_op : bool = o0 == 0b1;
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_integer_arithmetic_mul_widening_32_64(a, d, datasize, destsize, m, n, sub_op, is_unsigned)
}

function clause __DecodeA64_DataProcReg ((pc, ([bitone, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitone, bitone, bitzero, bitone, _, _, _, _, _, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 830) = {
    SEE = 830;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Ra = Slice(__opcode, 10, 5);
    let o0 = Slice(__opcode, 15, 1);
    let Rm = Slice(__opcode, 16, 5);
    let U = Slice(__opcode, 23, 1);
    decode_umaddl_aarch64_instrs_integer_arithmetic_mul_widening_32_64(Rd, Rn, Ra, o0, Rm, U)
}

val decode_umsubl_aarch64_instrs_integer_arithmetic_mul_widening_32_64 : (bits(5), bits(5), bits(5), bits(1), bits(5), bits(1)) -> unit

function decode_umsubl_aarch64_instrs_integer_arithmetic_mul_widening_32_64 (Rd, Rn, Ra, o0, Rm, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'a = UInt(Ra);
    let 'destsize = 64;
    let 'datasize = 32;
    let sub_op : bool = o0 == 0b1;
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_integer_arithmetic_mul_widening_32_64(a, d, datasize, destsize, m, n, sub_op, is_unsigned)
}

function clause __DecodeA64_DataProcReg ((pc, ([bitone, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitone, bitone, bitzero, bitone, _, _, _, _, _, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 831) = {
    SEE = 831;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Ra = Slice(__opcode, 10, 5);
    let o0 = Slice(__opcode, 15, 1);
    let Rm = Slice(__opcode, 16, 5);
    let U = Slice(__opcode, 23, 1);
    decode_umsubl_aarch64_instrs_integer_arithmetic_mul_widening_32_64(Rd, Rn, Ra, o0, Rm, U)
}

val execute_aarch64_instrs_integer_arithmetic_max_min_smax_imm : forall 'd 'datasize 'imm 'n,
  (0 <= 'n & 'n <= 31 & 'datasize in {32, 64} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('imm), int('n)) -> unit

function execute_aarch64_instrs_integer_arithmetic_max_min_smax_imm (d, datasize, imm, n) = {
    let operand1 : bits('datasize) = X_read(n, datasize);
    let 'result = Max(SInt(operand1), imm);
    X_set(d, datasize) = result[datasize - 1 .. 0]
}

val decode_smax_imm_aarch64_instrs_integer_arithmetic_max_min_smax_imm : (bits(5), bits(5), bits(8), bits(1)) -> unit

function decode_smax_imm_aarch64_instrs_integer_arithmetic_max_min_smax_imm (Rd, Rn, imm8, sf) = {
    if not_bool(HaveCSSC()) then {
        throw(Error_Undefined())
    };
    let 'datasize = (32 << UInt(sf));
    let 'n = UInt(Rn);
    let 'd = UInt(Rd);
    let 'imm = SInt(imm8);
    execute_aarch64_instrs_integer_arithmetic_max_min_smax_imm(d, datasize, imm, n)
}

function clause __DecodeA64_DataProcImm ((pc, ([_, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 832) = {
    SEE = 832;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm8 = Slice(__opcode, 10, 8);
    let sf = Slice(__opcode, 31, 1);
    decode_smax_imm_aarch64_instrs_integer_arithmetic_max_min_smax_imm(Rd, Rn, imm8, sf)
}

val execute_aarch64_instrs_integer_arithmetic_max_min_smax_reg : forall 'd 'datasize 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'datasize in {32, 64} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('m), int('n)) -> unit

function execute_aarch64_instrs_integer_arithmetic_max_min_smax_reg (d, datasize, m, n) = {
    let operand1 : bits('datasize) = X_read(n, datasize);
    let operand2 : bits('datasize) = X_read(m, datasize);
    let 'result = Max(SInt(operand1), SInt(operand2));
    X_set(d, datasize) = result[datasize - 1 .. 0]
}

val decode_smax_reg_aarch64_instrs_integer_arithmetic_max_min_smax_reg : (bits(5), bits(5), bits(5), bits(1)) -> unit

function decode_smax_reg_aarch64_instrs_integer_arithmetic_max_min_smax_reg (Rd, Rn, Rm, sf) = {
    if not_bool(HaveCSSC()) then {
        throw(Error_Undefined())
    };
    let 'datasize = (32 << UInt(sf));
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'd = UInt(Rd);
    execute_aarch64_instrs_integer_arithmetic_max_min_smax_reg(d, datasize, m, n)
}

function clause __DecodeA64_DataProcReg ((pc, ([_, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, bitzero, bitone, bitone, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 833) = {
    SEE = 833;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let sf = Slice(__opcode, 31, 1);
    decode_smax_reg_aarch64_instrs_integer_arithmetic_max_min_smax_reg(Rd, Rn, Rm, sf)
}

val execute_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_single : forall 'd 'datasize 'elements 'esize ('is_unsigned : Bool) 'm ('minimum : Bool) 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'esize in {8, 16, 32, 64} & 'datasize in {64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('m), bool('minimum), int('n), bool('is_unsigned)) -> unit

function execute_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_single (d, datasize, elements, esize, m, minimum, n, is_unsigned) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = V_read(n, datasize);
    let operand2 : bits('datasize) = V_read(m, datasize);
    result : bits('datasize) = undefined;
    element1 : int = undefined;
    element2 : int = undefined;
    maxmin : int = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element1 = asl_Int(Elem_read(operand1, e, esize), is_unsigned);
        element2 = asl_Int(Elem_read(operand2, e, esize), is_unsigned);
        maxmin = if minimum then Min(element1, element2) else
          Max(element1, element2);
        result = Elem_set(result, e, esize, maxmin[esize - 1 .. 0])
    };
    V_set(d, datasize) = result
}

val decode_smax_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_single : (bits(5), bits(5), bits(1), bits(5), bits(2), bits(1), bits(1)) -> unit

function decode_smax_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_single (Rd, Rn, o1, Rm, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let is_unsigned : bool = U == 0b1;
    let minimum : bool = o1 == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_single(d, datasize, elements, esize, m, minimum, n, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitone, bitone, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 834) = {
    SEE = 834;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 11, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_smax_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_single(Rd, Rn, o1, Rm, size, U, Q)
}

val decode_smin_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_single : (bits(5), bits(5), bits(1), bits(5), bits(2), bits(1), bits(1)) -> unit

function decode_smin_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_single (Rd, Rn, o1, Rm, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let is_unsigned : bool = U == 0b1;
    let minimum : bool = o1 == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_single(d, datasize, elements, esize, m, minimum, n, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitone, bitone, bitzero, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 835) = {
    SEE = 835;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 11, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_smin_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_single(Rd, Rn, o1, Rm, size, U, Q)
}

val decode_umax_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_single : (bits(5), bits(5), bits(1), bits(5), bits(2), bits(1), bits(1)) -> unit

function decode_umax_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_single (Rd, Rn, o1, Rm, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let is_unsigned : bool = U == 0b1;
    let minimum : bool = o1 == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_single(d, datasize, elements, esize, m, minimum, n, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitone, bitone, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 836) = {
    SEE = 836;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 11, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_umax_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_single(Rd, Rn, o1, Rm, size, U, Q)
}

val decode_umin_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_single : (bits(5), bits(5), bits(1), bits(5), bits(2), bits(1), bits(1)) -> unit

function decode_umin_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_single (Rd, Rn, o1, Rm, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let is_unsigned : bool = U == 0b1;
    let minimum : bool = o1 == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_single(d, datasize, elements, esize, m, minimum, n, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitone, bitone, bitzero, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 837) = {
    SEE = 837;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 11, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_umin_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_single(Rd, Rn, o1, Rm, size, U, Q)
}

val execute_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_pair : forall 'd 'datasize 'elements 'esize ('is_unsigned : Bool) 'm ('minimum : Bool) 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'esize in {8, 16, 32, 64} & 'datasize in {64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('m), bool('minimum), int('n), bool('is_unsigned)) -> unit

function execute_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_pair (d, datasize, elements, esize, m, minimum, n, is_unsigned) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = V_read(n, datasize);
    let operand2 : bits('datasize) = V_read(m, datasize);
    result : bits('datasize) = undefined;
    let concat : bits(2 * 'datasize) = operand2 @ operand1;
    element1 : int = undefined;
    element2 : int = undefined;
    maxmin : int = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element1 = asl_Int(Elem_read(concat, 2 * e, esize), is_unsigned);
        element2 = asl_Int(Elem_read(concat, 2 * e + 1, esize), is_unsigned);
        maxmin = if minimum then Min(element1, element2) else
          Max(element1, element2);
        result = Elem_set(result, e, esize, maxmin[esize - 1 .. 0])
    };
    V_set(d, datasize) = result
}

val decode_smaxp_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_pair : (bits(5), bits(5), bits(1), bits(5), bits(2), bits(1), bits(1)) -> unit

function decode_smaxp_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_pair (Rd, Rn, o1, Rm, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let is_unsigned : bool = U == 0b1;
    let minimum : bool = o1 == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_pair(d, datasize, elements, esize, m, minimum, n, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitone, bitzero, bitone, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 838) = {
    SEE = 838;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 11, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_smaxp_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_pair(Rd, Rn, o1, Rm, size, U, Q)
}

val decode_sminp_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_pair : (bits(5), bits(5), bits(1), bits(5), bits(2), bits(1), bits(1)) -> unit

function decode_sminp_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_pair (Rd, Rn, o1, Rm, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let is_unsigned : bool = U == 0b1;
    let minimum : bool = o1 == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_pair(d, datasize, elements, esize, m, minimum, n, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitone, bitzero, bitone, bitzero, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 839) = {
    SEE = 839;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 11, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_sminp_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_pair(Rd, Rn, o1, Rm, size, U, Q)
}

val decode_umaxp_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_pair : (bits(5), bits(5), bits(1), bits(5), bits(2), bits(1), bits(1)) -> unit

function decode_umaxp_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_pair (Rd, Rn, o1, Rm, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let is_unsigned : bool = U == 0b1;
    let minimum : bool = o1 == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_pair(d, datasize, elements, esize, m, minimum, n, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitone, bitzero, bitone, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 840) = {
    SEE = 840;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 11, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_umaxp_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_pair(Rd, Rn, o1, Rm, size, U, Q)
}

val decode_uminp_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_pair : (bits(5), bits(5), bits(1), bits(5), bits(2), bits(1), bits(1)) -> unit

function decode_uminp_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_pair (Rd, Rn, o1, Rm, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let is_unsigned : bool = U == 0b1;
    let minimum : bool = o1 == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_pair(d, datasize, elements, esize, m, minimum, n, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitone, bitzero, bitone, bitzero, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 841) = {
    SEE = 841;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 11, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_uminp_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_pair(Rd, Rn, o1, Rm, size, U, Q)
}

val execute_aarch64_instrs_vector_reduce_int_max : forall 'd 'datasize 'elements 'esize ('is_unsigned : Bool) ('min : Bool) 'n,
  (0 <= 'n & 'n <= 31 & 'esize in {8, 16, 32, 64} & 'datasize in {64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), bool('min), int('n), bool('is_unsigned)) -> unit

function execute_aarch64_instrs_vector_reduce_int_max (d, datasize, elements, esize, min, n, is_unsigned) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('datasize) = V_read(n, datasize);
    element : int = undefined;
    maxmin : int = asl_Int(Elem_read(operand, 0, esize), is_unsigned);
    foreach (e from 1 to (elements - 1) by 1 in inc) {
        element = asl_Int(Elem_read(operand, e, esize), is_unsigned);
        maxmin = if min then Min(maxmin, element) else Max(maxmin, element)
    };
    let 'maxmin = maxmin;
    V_set(d, esize) = maxmin[esize - 1 .. 0]
}

val decode_smaxv_advsimd_aarch64_instrs_vector_reduce_int_max : (bits(5), bits(5), bits(1), bits(2), bits(1), bits(1)) -> unit

function decode_smaxv_advsimd_aarch64_instrs_vector_reduce_int_max (Rd, Rn, op, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (size @ Q) == 0b100 then {
        throw(Error_Undefined())
    };
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let is_unsigned : bool = U == 0b1;
    let min : bool = op == 0b1;
    execute_aarch64_instrs_vector_reduce_int_max(d, datasize, elements, esize, min, n, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 842) = {
    SEE = 842;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 16, 1);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_smaxv_advsimd_aarch64_instrs_vector_reduce_int_max(Rd, Rn, op, size, U, Q)
}

val decode_sminv_advsimd_aarch64_instrs_vector_reduce_int_max : (bits(5), bits(5), bits(1), bits(2), bits(1), bits(1)) -> unit

function decode_sminv_advsimd_aarch64_instrs_vector_reduce_int_max (Rd, Rn, op, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (size @ Q) == 0b100 then {
        throw(Error_Undefined())
    };
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let is_unsigned : bool = U == 0b1;
    let min : bool = op == 0b1;
    execute_aarch64_instrs_vector_reduce_int_max(d, datasize, elements, esize, min, n, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 843) = {
    SEE = 843;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 16, 1);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_sminv_advsimd_aarch64_instrs_vector_reduce_int_max(Rd, Rn, op, size, U, Q)
}

val decode_umaxv_advsimd_aarch64_instrs_vector_reduce_int_max : (bits(5), bits(5), bits(1), bits(2), bits(1), bits(1)) -> unit

function decode_umaxv_advsimd_aarch64_instrs_vector_reduce_int_max (Rd, Rn, op, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (size @ Q) == 0b100 then {
        throw(Error_Undefined())
    };
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let is_unsigned : bool = U == 0b1;
    let min : bool = op == 0b1;
    execute_aarch64_instrs_vector_reduce_int_max(d, datasize, elements, esize, min, n, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 844) = {
    SEE = 844;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 16, 1);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_umaxv_advsimd_aarch64_instrs_vector_reduce_int_max(Rd, Rn, op, size, U, Q)
}

val decode_uminv_advsimd_aarch64_instrs_vector_reduce_int_max : (bits(5), bits(5), bits(1), bits(2), bits(1), bits(1)) -> unit

function decode_uminv_advsimd_aarch64_instrs_vector_reduce_int_max (Rd, Rn, op, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (size @ Q) == 0b100 then {
        throw(Error_Undefined())
    };
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let is_unsigned : bool = U == 0b1;
    let min : bool = op == 0b1;
    execute_aarch64_instrs_vector_reduce_int_max(d, datasize, elements, esize, min, n, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 845) = {
    SEE = 845;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 16, 1);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_uminv_advsimd_aarch64_instrs_vector_reduce_int_max(Rd, Rn, op, size, U, Q)
}

val execute_aarch64_instrs_system_exceptions_runtime_smc : bits(16) -> unit

function execute_aarch64_instrs_system_exceptions_runtime_smc imm = {
    AArch64_CheckForSMCUndefOrTrap(imm);
    AArch64_CallSecureMonitor(imm)
}

val decode_smc_aarch64_instrs_system_exceptions_runtime_smc : bits(16) -> unit

function decode_smc_aarch64_instrs_system_exceptions_runtime_smc imm16 = {
    let imm : bits(16) = imm16;
    execute_aarch64_instrs_system_exceptions_runtime_smc(imm)
}

function clause __DecodeA64_BranchExcSys ((pc, ([bitone, bitone, bitzero, bitone, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, bitzero, bitzero, bitzero, bitone, bitone] as __opcode)) if SEE < 846) = {
    SEE = 846;
    let imm16 = Slice(__opcode, 5, 16);
    decode_smc_aarch64_instrs_system_exceptions_runtime_smc(imm16)
}

val execute_aarch64_instrs_integer_arithmetic_max_min_smin_imm : forall 'd 'datasize 'imm 'n,
  (0 <= 'n & 'n <= 31 & 'datasize in {32, 64} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('imm), int('n)) -> unit

function execute_aarch64_instrs_integer_arithmetic_max_min_smin_imm (d, datasize, imm, n) = {
    let operand1 : bits('datasize) = X_read(n, datasize);
    let 'result = Min(SInt(operand1), imm);
    X_set(d, datasize) = result[datasize - 1 .. 0]
}

val decode_smin_imm_aarch64_instrs_integer_arithmetic_max_min_smin_imm : (bits(5), bits(5), bits(8), bits(1)) -> unit

function decode_smin_imm_aarch64_instrs_integer_arithmetic_max_min_smin_imm (Rd, Rn, imm8, sf) = {
    if not_bool(HaveCSSC()) then {
        throw(Error_Undefined())
    };
    let 'datasize = (32 << UInt(sf));
    let 'n = UInt(Rn);
    let 'd = UInt(Rd);
    let 'imm = SInt(imm8);
    execute_aarch64_instrs_integer_arithmetic_max_min_smin_imm(d, datasize, imm, n)
}

function clause __DecodeA64_DataProcImm ((pc, ([_, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 847) = {
    SEE = 847;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm8 = Slice(__opcode, 10, 8);
    let sf = Slice(__opcode, 31, 1);
    decode_smin_imm_aarch64_instrs_integer_arithmetic_max_min_smin_imm(Rd, Rn, imm8, sf)
}

val execute_aarch64_instrs_integer_arithmetic_max_min_smin_reg : forall 'd 'datasize 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'datasize in {32, 64} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('m), int('n)) -> unit

function execute_aarch64_instrs_integer_arithmetic_max_min_smin_reg (d, datasize, m, n) = {
    let operand1 : bits('datasize) = X_read(n, datasize);
    let operand2 : bits('datasize) = X_read(m, datasize);
    let 'result = Min(SInt(operand1), SInt(operand2));
    X_set(d, datasize) = result[datasize - 1 .. 0]
}

val decode_smin_reg_aarch64_instrs_integer_arithmetic_max_min_smin_reg : (bits(5), bits(5), bits(5), bits(1)) -> unit

function decode_smin_reg_aarch64_instrs_integer_arithmetic_max_min_smin_reg (Rd, Rn, Rm, sf) = {
    if not_bool(HaveCSSC()) then {
        throw(Error_Undefined())
    };
    let 'datasize = (32 << UInt(sf));
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'd = UInt(Rd);
    execute_aarch64_instrs_integer_arithmetic_max_min_smin_reg(d, datasize, m, n)
}

function clause __DecodeA64_DataProcReg ((pc, ([_, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, bitzero, bitone, bitone, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 848) = {
    SEE = 848;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let sf = Slice(__opcode, 31, 1);
    decode_smin_reg_aarch64_instrs_integer_arithmetic_max_min_smin_reg(Rd, Rn, Rm, sf)
}

val execute_aarch64_instrs_vector_arithmetic_binary_disparate_mul_accum : forall 'd 'datasize 'elements 'esize ('is_unsigned : Bool) 'm 'n 'part ('sub_op : Bool),
  ('part in {0, 1} & 0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'esize in {8, 16, 32, 64} & 'datasize == 64 & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('m), int('n), int('part), bool('sub_op), bool('is_unsigned)) -> unit

function execute_aarch64_instrs_vector_arithmetic_binary_disparate_mul_accum (d, datasize, elements, esize, m, n, part, sub_op, is_unsigned) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = Vpart_read(n, part, datasize);
    let operand2 : bits('datasize) = Vpart_read(m, part, datasize);
    let operand3 : bits(2 * 'datasize) = V_read(d, 2 * datasize);
    result : bits(2 * 'datasize) = undefined;
    element1 : int = undefined;
    element2 : int = undefined;
    product : bits(2 * 'esize) = undefined;
    accum : bits(2 * 'esize) = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element1 = asl_Int(Elem_read(operand1, e, esize), is_unsigned);
        element2 = asl_Int(Elem_read(operand2, e, esize), is_unsigned);
        product = (element1 * element2)[2 * esize - 1 .. 0];
        if sub_op then {
            accum = Elem_read(operand3, e, 2 * esize) - product
        } else {
            accum = Elem_read(operand3, e, 2 * esize) + product
        };
        result = Elem_set(result, e, 2 * esize, accum)
    };
    V_set(d, 2 * datasize) = result
}

val decode_smlal_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_disparate_mul_accum : (bits(5), bits(5), bits(1), bits(5), bits(2), bits(1), bits(1)) -> unit

function decode_smlal_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_disparate_mul_accum (Rd, Rn, o1, Rm, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    let 'datasize = 64;
    let 'part = UInt(Q);
    let 'elements = DIV(datasize, esize);
    let sub_op : bool = o1 == 0b1;
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_disparate_mul_accum(d, datasize, elements, esize, m, n, part, sub_op, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 849) = {
    SEE = 849;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 13, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_smlal_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_disparate_mul_accum(Rd, Rn, o1, Rm, size, U, Q)
}

val decode_smlsl_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_disparate_mul_accum : (bits(5), bits(5), bits(1), bits(5), bits(2), bits(1), bits(1)) -> unit

function decode_smlsl_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_disparate_mul_accum (Rd, Rn, o1, Rm, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    let 'datasize = 64;
    let 'part = UInt(Q);
    let 'elements = DIV(datasize, esize);
    let sub_op : bool = o1 == 0b1;
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_disparate_mul_accum(d, datasize, elements, esize, m, n, part, sub_op, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitone, bitzero, bitone, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 850) = {
    SEE = 850;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 13, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_smlsl_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_disparate_mul_accum(Rd, Rn, o1, Rm, size, U, Q)
}

val decode_umlal_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_disparate_mul_accum : (bits(5), bits(5), bits(1), bits(5), bits(2), bits(1), bits(1)) -> unit

function decode_umlal_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_disparate_mul_accum (Rd, Rn, o1, Rm, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    let 'datasize = 64;
    let 'part = UInt(Q);
    let 'elements = DIV(datasize, esize);
    let sub_op : bool = o1 == 0b1;
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_disparate_mul_accum(d, datasize, elements, esize, m, n, part, sub_op, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 851) = {
    SEE = 851;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 13, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_umlal_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_disparate_mul_accum(Rd, Rn, o1, Rm, size, U, Q)
}

val decode_umlsl_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_disparate_mul_accum : (bits(5), bits(5), bits(1), bits(5), bits(2), bits(1), bits(1)) -> unit

function decode_umlsl_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_disparate_mul_accum (Rd, Rn, o1, Rm, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    let 'datasize = 64;
    let 'part = UInt(Q);
    let 'elements = DIV(datasize, esize);
    let sub_op : bool = o1 == 0b1;
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_disparate_mul_accum(d, datasize, elements, esize, m, n, part, sub_op, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitone, bitzero, bitone, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 852) = {
    SEE = 852;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 13, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_umlsl_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_disparate_mul_accum(Rd, Rn, o1, Rm, size, U, Q)
}

val execute_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_long : forall 'd 'datasize 'elements 'esize 'idxdsize 'index ('is_unsigned : Bool) 'm 'n 'part ('sub_op : Bool),
  ('part in {0, 1} & 0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'index in {0, 1, 2, 3, 4, 5, 6, 7} & 'idxdsize in {64, 128} & 'esize in {8, 16, 32, 64} & 'datasize == 64 & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('idxdsize), int('index), int('m), int('n), int('part), bool('sub_op), bool('is_unsigned)) -> unit

function execute_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_long (d, datasize, elements, esize, idxdsize, index, m, n, part, sub_op, is_unsigned) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = Vpart_read(n, part, datasize);
    let operand2 : bits('idxdsize) = V_read(m, idxdsize);
    let operand3 : bits(2 * 'datasize) = V_read(d, 2 * datasize);
    result : bits(2 * 'datasize) = undefined;
    element1 : int = undefined;
    product : bits(2 * 'esize) = undefined;
    let 'element2 = asl_Int(Elem_read(operand2, index, esize), is_unsigned);
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element1 = asl_Int(Elem_read(operand1, e, esize), is_unsigned);
        product = (element1 * element2)[2 * esize - 1 .. 0];
        if sub_op then {
            result = Elem_set(result, e, 2 * esize, Elem_read(operand3, e, 2 * esize) - product)
        } else {
            result = Elem_set(result, e, 2 * esize, Elem_read(operand3, e, 2 * esize) + product)
        }
    };
    V_set(d, 2 * datasize) = result
}

val decode_smlal_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_long : (bits(5), bits(5), bits(1), bits(1), bits(4), bits(1), bits(1), bits(2), bits(1), bits(1)) -> unit

function decode_smlal_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_long (Rd, Rn, H, o2, Rm, M, L, size, U, Q) = {
    let 'idxdsize = if H == 0b1 then 128 else 64;
    index : range(0, 7) = undefined;
    Rmhi : bits(1) = undefined;
    match size {
      0b01 => {
          index = UInt((H @ L) @ M);
          Rmhi = 0b0
      },
      0b10 => {
          index = UInt(H @ L);
          Rmhi = M
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let Rmhi = Rmhi;
    let 'index = index;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rmhi @ Rm);
    let 'esize = (8 << UInt(size));
    let 'datasize = 64;
    let 'part = UInt(Q);
    let 'elements = DIV(datasize, esize);
    let is_unsigned : bool = U == 0b1;
    let sub_op : bool = o2 == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_long(d, datasize, elements, esize, idxdsize, index, m, n, part, sub_op, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, bitzero, bitzero, bitone, bitzero, _, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 853) = {
    SEE = 853;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let H = Slice(__opcode, 11, 1);
    let o2 = Slice(__opcode, 14, 1);
    let Rm = Slice(__opcode, 16, 4);
    let M = Slice(__opcode, 20, 1);
    let L = Slice(__opcode, 21, 1);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_smlal_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_long(Rd, Rn, H, o2, Rm, M, L, size, U, Q)
}

val decode_smlsl_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_long : (bits(5), bits(5), bits(1), bits(1), bits(4), bits(1), bits(1), bits(2), bits(1), bits(1)) -> unit

function decode_smlsl_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_long (Rd, Rn, H, o2, Rm, M, L, size, U, Q) = {
    let 'idxdsize = if H == 0b1 then 128 else 64;
    index : range(0, 7) = undefined;
    Rmhi : bits(1) = undefined;
    match size {
      0b01 => {
          index = UInt((H @ L) @ M);
          Rmhi = 0b0
      },
      0b10 => {
          index = UInt(H @ L);
          Rmhi = M
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let Rmhi = Rmhi;
    let 'index = index;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rmhi @ Rm);
    let 'esize = (8 << UInt(size));
    let 'datasize = 64;
    let 'part = UInt(Q);
    let 'elements = DIV(datasize, esize);
    let is_unsigned : bool = U == 0b1;
    let sub_op : bool = o2 == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_long(d, datasize, elements, esize, idxdsize, index, m, n, part, sub_op, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, bitzero, bitone, bitone, bitzero, _, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 854) = {
    SEE = 854;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let H = Slice(__opcode, 11, 1);
    let o2 = Slice(__opcode, 14, 1);
    let Rm = Slice(__opcode, 16, 4);
    let M = Slice(__opcode, 20, 1);
    let L = Slice(__opcode, 21, 1);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_smlsl_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_long(Rd, Rn, H, o2, Rm, M, L, size, U, Q)
}

val decode_umlal_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_long : (bits(5), bits(5), bits(1), bits(1), bits(4), bits(1), bits(1), bits(2), bits(1), bits(1)) -> unit

function decode_umlal_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_long (Rd, Rn, H, o2, Rm, M, L, size, U, Q) = {
    let 'idxdsize = if H == 0b1 then 128 else 64;
    index : range(0, 7) = undefined;
    Rmhi : bits(1) = undefined;
    match size {
      0b01 => {
          index = UInt((H @ L) @ M);
          Rmhi = 0b0
      },
      0b10 => {
          index = UInt(H @ L);
          Rmhi = M
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let Rmhi = Rmhi;
    let 'index = index;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rmhi @ Rm);
    let 'esize = (8 << UInt(size));
    let 'datasize = 64;
    let 'part = UInt(Q);
    let 'elements = DIV(datasize, esize);
    let is_unsigned : bool = U == 0b1;
    let sub_op : bool = o2 == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_long(d, datasize, elements, esize, idxdsize, index, m, n, part, sub_op, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, bitzero, bitzero, bitone, bitzero, _, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 855) = {
    SEE = 855;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let H = Slice(__opcode, 11, 1);
    let o2 = Slice(__opcode, 14, 1);
    let Rm = Slice(__opcode, 16, 4);
    let M = Slice(__opcode, 20, 1);
    let L = Slice(__opcode, 21, 1);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_umlal_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_long(Rd, Rn, H, o2, Rm, M, L, size, U, Q)
}

val decode_umlsl_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_long : (bits(5), bits(5), bits(1), bits(1), bits(4), bits(1), bits(1), bits(2), bits(1), bits(1)) -> unit

function decode_umlsl_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_long (Rd, Rn, H, o2, Rm, M, L, size, U, Q) = {
    let 'idxdsize = if H == 0b1 then 128 else 64;
    index : range(0, 7) = undefined;
    Rmhi : bits(1) = undefined;
    match size {
      0b01 => {
          index = UInt((H @ L) @ M);
          Rmhi = 0b0
      },
      0b10 => {
          index = UInt(H @ L);
          Rmhi = M
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let Rmhi = Rmhi;
    let 'index = index;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rmhi @ Rm);
    let 'esize = (8 << UInt(size));
    let 'datasize = 64;
    let 'part = UInt(Q);
    let 'elements = DIV(datasize, esize);
    let is_unsigned : bool = U == 0b1;
    let sub_op : bool = o2 == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_long(d, datasize, elements, esize, idxdsize, index, m, n, part, sub_op, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, bitzero, bitone, bitone, bitzero, _, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 856) = {
    SEE = 856;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let H = Slice(__opcode, 11, 1);
    let o2 = Slice(__opcode, 14, 1);
    let Rm = Slice(__opcode, 16, 4);
    let M = Slice(__opcode, 20, 1);
    let L = Slice(__opcode, 21, 1);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_umlsl_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_long(Rd, Rn, H, o2, Rm, M, L, size, U, Q)
}

val execute_aarch64_instrs_vector_arithmetic_binary_uniform_mat_mul_int_mla : forall 'd 'm 'n ('op1_unsigned : Bool) ('op2_unsigned : Bool),
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 0 <= 'd & 'd <= 31).
  (int('d), int('m), int('n), bool('op1_unsigned), bool('op2_unsigned)) -> unit

function execute_aarch64_instrs_vector_arithmetic_binary_uniform_mat_mul_int_mla (d, m, n, op1_unsigned, op2_unsigned) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits(128) = V_read(n, 128);
    let operand2 : bits(128) = V_read(m, 128);
    let addend : bits(128) = V_read(d, 128);
    V_set(d, 128) = MatMulAdd(addend, operand1, operand2, op1_unsigned, op2_unsigned)
}

val decode_smmla_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mat_mul_int_mla : (bits(5), bits(5), bits(1), bits(5), bits(1)) -> unit

function decode_smmla_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mat_mul_int_mla (Rd, Rn, B, Rm, U) = {
    if not_bool(HaveInt8MatMulExt()) then {
        throw(Error_Undefined())
    };
    op1_unsigned : bool = undefined;
    op2_unsigned : bool = undefined;
    match B @ U {
      0b00 => {
          op1_unsigned = false;
          op2_unsigned = false
      },
      0b01 => {
          op1_unsigned = true;
          op2_unsigned = true
      },
      0b10 => {
          op1_unsigned = true;
          op2_unsigned = false
      },
      0b11 => {
          throw(Error_Undefined())
      }
    };
    let op2_unsigned = op2_unsigned;
    let op1_unsigned = op1_unsigned;
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'd = UInt(Rd);
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_mat_mul_int_mla(d, m, n, op1_unsigned, op2_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, bitone, bitzero, bitone, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 857) = {
    SEE = 857;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let B = Slice(__opcode, 11, 1);
    let Rm = Slice(__opcode, 16, 5);
    let U = Slice(__opcode, 29, 1);
    decode_smmla_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mat_mul_int_mla(Rd, Rn, B, Rm, U)
}

val decode_ummla_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mat_mul_int_mla : (bits(5), bits(5), bits(1), bits(5), bits(1)) -> unit

function decode_ummla_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mat_mul_int_mla (Rd, Rn, B, Rm, U) = {
    if not_bool(HaveInt8MatMulExt()) then {
        throw(Error_Undefined())
    };
    op1_unsigned : bool = undefined;
    op2_unsigned : bool = undefined;
    match B @ U {
      0b00 => {
          op1_unsigned = false;
          op2_unsigned = false
      },
      0b01 => {
          op1_unsigned = true;
          op2_unsigned = true
      },
      0b10 => {
          op1_unsigned = true;
          op2_unsigned = false
      },
      0b11 => {
          throw(Error_Undefined())
      }
    };
    let op2_unsigned = op2_unsigned;
    let op1_unsigned = op1_unsigned;
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'd = UInt(Rd);
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_mat_mul_int_mla(d, m, n, op1_unsigned, op2_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitone, bitzero, bitone, bitone, bitone, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, bitone, bitzero, bitone, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 858) = {
    SEE = 858;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let B = Slice(__opcode, 11, 1);
    let Rm = Slice(__opcode, 16, 5);
    let U = Slice(__opcode, 29, 1);
    decode_ummla_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mat_mul_int_mla(Rd, Rn, B, Rm, U)
}

val decode_usmmla_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mat_mul_int_mla : (bits(5), bits(5), bits(1), bits(5), bits(1)) -> unit

function decode_usmmla_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mat_mul_int_mla (Rd, Rn, B, Rm, U) = {
    if not_bool(HaveInt8MatMulExt()) then {
        throw(Error_Undefined())
    };
    op1_unsigned : bool = undefined;
    op2_unsigned : bool = undefined;
    match B @ U {
      0b00 => {
          op1_unsigned = false;
          op2_unsigned = false
      },
      0b01 => {
          op1_unsigned = true;
          op2_unsigned = true
      },
      0b10 => {
          op1_unsigned = true;
          op2_unsigned = false
      },
      0b11 => {
          throw(Error_Undefined())
      }
    };
    let op2_unsigned = op2_unsigned;
    let op1_unsigned = op1_unsigned;
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'd = UInt(Rd);
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_mat_mul_int_mla(d, m, n, op1_unsigned, op2_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, bitone, bitzero, bitone, bitzero, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 859) = {
    SEE = 859;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let B = Slice(__opcode, 11, 1);
    let Rm = Slice(__opcode, 16, 5);
    let U = Slice(__opcode, 29, 1);
    decode_usmmla_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mat_mul_int_mla(Rd, Rn, B, Rm, U)
}

val execute_aarch64_instrs_vector_transfer_integer_move_signed : forall 'd 'datasize 'esize 'idxdsize 'index 'n,
  (0 <= 'n & 'n <= 31 & 'idxdsize in {64, 128} & 'esize in {8, 16, 32} & 'datasize in {32, 64} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('esize), int('idxdsize), int('index), int('n)) -> unit

function execute_aarch64_instrs_vector_transfer_integer_move_signed (d, datasize, esize, idxdsize, index, n) = {
    if index == 0 then {
        CheckFPEnabled64()
    } else {
        CheckFPAdvSIMDEnabled64()
    };
    let operand : bits('idxdsize) = V_read(n, idxdsize);
    X_set(d, datasize) = SignExtend(Elem_read(operand, index, esize), datasize)
}

val decode_smov_advsimd_aarch64_instrs_vector_transfer_integer_move_signed : (bits(5), bits(5), bits(5), bits(1)) -> unit

function decode_smov_advsimd_aarch64_instrs_vector_transfer_integer_move_signed (Rd, Rn, imm5, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    size : {0, 1, 2} = 0;
    match Q @ imm5 {
      [_, _, _, _, _, bitone] => {
          size = 0
      },
      [_, _, _, _, bitone, bitzero] => {
          size = 1
      },
      [bitone, _, _, bitone, bitzero, bitzero] => {
          size = 2
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let 'size = size;
    let 'idxdsize = if [imm5[4]] == 0b1 then 128 else 64;
    let 'index = UInt(imm5[4 .. size + 1]);
    let 'esize = (8 << size);
    let 'datasize = if Q == 0b1 then 64 else 32;
    assert(constraint('esize in {8, 16, 32}));
    execute_aarch64_instrs_vector_transfer_integer_move_signed(d, datasize, esize, idxdsize, index, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, bitzero, bitzero, bitone, bitzero, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 860) = {
    SEE = 860;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm5 = Slice(__opcode, 16, 5);
    let Q = Slice(__opcode, 30, 1);
    decode_smov_advsimd_aarch64_instrs_vector_transfer_integer_move_signed(Rd, Rn, imm5, Q)
}

val execute_aarch64_instrs_integer_arithmetic_mul_widening_64_128hi : forall 'd 'datasize ('is_unsigned : Bool) 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'datasize == 64 & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('m), int('n), bool('is_unsigned)) -> unit

function execute_aarch64_instrs_integer_arithmetic_mul_widening_64_128hi (d, datasize, m, n, is_unsigned) = {
    let operand1 : bits('datasize) = X_read(n, datasize);
    let operand2 : bits('datasize) = X_read(m, datasize);
    let 'result = asl_Int(operand1, is_unsigned) * asl_Int(operand2, is_unsigned);
    X_set(d, 64) = result[127 .. 64]
}

val decode_smulh_aarch64_instrs_integer_arithmetic_mul_widening_64_128hi : (bits(5), bits(5), bits(5), bits(5), bits(1)) -> unit

function decode_smulh_aarch64_instrs_integer_arithmetic_mul_widening_64_128hi (Rd, Rn, Ra, Rm, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'a = UInt(Ra);
    let 'destsize = 64;
    let 'datasize = destsize;
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_integer_arithmetic_mul_widening_64_128hi(d, datasize, m, n, is_unsigned)
}

function clause __DecodeA64_DataProcReg ((pc, ([bitone, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitone, bitzero, bitone, bitzero, _, _, _, _, _, bitzero, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 861) = {
    SEE = 861;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Ra = Slice(__opcode, 10, 5);
    let Rm = Slice(__opcode, 16, 5);
    let U = Slice(__opcode, 23, 1);
    if ((([__opcode[10]] != 0b1 | [__opcode[11]] != 0b1) | [__opcode[12]] != 0b1) | [__opcode[13]] != 0b1) | [__opcode[14]] != 0b1 then {
        throw(Error_ConstrainedUnpredictable())
    } else {
        decode_smulh_aarch64_instrs_integer_arithmetic_mul_widening_64_128hi(Rd, Rn, Ra, Rm, U)
    }
}

val decode_umulh_aarch64_instrs_integer_arithmetic_mul_widening_64_128hi : (bits(5), bits(5), bits(5), bits(5), bits(1)) -> unit

function decode_umulh_aarch64_instrs_integer_arithmetic_mul_widening_64_128hi (Rd, Rn, Ra, Rm, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'a = UInt(Ra);
    let 'destsize = 64;
    let 'datasize = destsize;
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_integer_arithmetic_mul_widening_64_128hi(d, datasize, m, n, is_unsigned)
}

function clause __DecodeA64_DataProcReg ((pc, ([bitone, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, bitzero, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 862) = {
    SEE = 862;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Ra = Slice(__opcode, 10, 5);
    let Rm = Slice(__opcode, 16, 5);
    let U = Slice(__opcode, 23, 1);
    if ((([__opcode[10]] != 0b1 | [__opcode[11]] != 0b1) | [__opcode[12]] != 0b1) | [__opcode[13]] != 0b1) | [__opcode[14]] != 0b1 then {
        throw(Error_ConstrainedUnpredictable())
    } else {
        decode_umulh_aarch64_instrs_integer_arithmetic_mul_widening_64_128hi(Rd, Rn, Ra, Rm, U)
    }
}

val execute_aarch64_instrs_vector_arithmetic_binary_disparate_mul_product : forall 'd 'datasize 'elements 'esize ('is_unsigned : Bool) 'm 'n 'part,
  ('part in {0, 1} & 0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'esize in {8, 16, 32, 64} & 'datasize == 64 & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('m), int('n), int('part), bool('is_unsigned)) -> unit

function execute_aarch64_instrs_vector_arithmetic_binary_disparate_mul_product (d, datasize, elements, esize, m, n, part, is_unsigned) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = Vpart_read(n, part, datasize);
    let operand2 : bits('datasize) = Vpart_read(m, part, datasize);
    result : bits(2 * 'datasize) = undefined;
    element1 : int = undefined;
    element2 : int = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element1 = asl_Int(Elem_read(operand1, e, esize), is_unsigned);
        element2 = asl_Int(Elem_read(operand2, e, esize), is_unsigned);
        result = Elem_set(result, e, 2 * esize, (element1 * element2)[2 * esize - 1 .. 0])
    };
    V_set(d, 2 * datasize) = result
}

val decode_smull_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_disparate_mul_product : (bits(5), bits(5), bits(5), bits(2), bits(1), bits(1)) -> unit

function decode_smull_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_disparate_mul_product (Rd, Rn, Rm, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    let 'datasize = 64;
    let 'part = UInt(Q);
    let 'elements = DIV(datasize, esize);
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_disparate_mul_product(d, datasize, elements, esize, m, n, part, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitone, bitone, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 863) = {
    SEE = 863;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_smull_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_disparate_mul_product(Rd, Rn, Rm, size, U, Q)
}

val decode_umull_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_disparate_mul_product : (bits(5), bits(5), bits(5), bits(2), bits(1), bits(1)) -> unit

function decode_umull_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_disparate_mul_product (Rd, Rn, Rm, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    let 'datasize = 64;
    let 'part = UInt(Q);
    let 'elements = DIV(datasize, esize);
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_disparate_mul_product(d, datasize, elements, esize, m, n, part, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitone, bitone, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 864) = {
    SEE = 864;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_umull_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_disparate_mul_product(Rd, Rn, Rm, size, U, Q)
}

val execute_aarch64_instrs_vector_arithmetic_binary_element_mul_long : forall 'd 'datasize 'elements 'esize 'idxdsize 'index ('is_unsigned : Bool) 'm 'n 'part,
  ('part in {0, 1} & 0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'index in {0, 1, 2, 3, 4, 5, 6, 7} & 'idxdsize in {64, 128} & 'esize in {8, 16, 32, 64} & 'datasize == 64 & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('idxdsize), int('index), int('m), int('n), int('part), bool('is_unsigned)) -> unit

function execute_aarch64_instrs_vector_arithmetic_binary_element_mul_long (d, datasize, elements, esize, idxdsize, index, m, n, part, is_unsigned) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = Vpart_read(n, part, datasize);
    let operand2 : bits('idxdsize) = V_read(m, idxdsize);
    result : bits(2 * 'datasize) = undefined;
    element1 : int = undefined;
    product : bits(2 * 'esize) = undefined;
    let 'element2 = asl_Int(Elem_read(operand2, index, esize), is_unsigned);
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element1 = asl_Int(Elem_read(operand1, e, esize), is_unsigned);
        product = (element1 * element2)[2 * esize - 1 .. 0];
        result = Elem_set(result, e, 2 * esize, product)
    };
    V_set(d, 2 * datasize) = result
}

val decode_smull_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_long : (bits(5), bits(5), bits(1), bits(4), bits(1), bits(1), bits(2), bits(1), bits(1)) -> unit

function decode_smull_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_long (Rd, Rn, H, Rm, M, L, size, U, Q) = {
    let 'idxdsize = if H == 0b1 then 128 else 64;
    index : range(0, 7) = undefined;
    Rmhi : bits(1) = undefined;
    match size {
      0b01 => {
          index = UInt((H @ L) @ M);
          Rmhi = 0b0
      },
      0b10 => {
          index = UInt(H @ L);
          Rmhi = M
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let Rmhi = Rmhi;
    let 'index = index;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rmhi @ Rm);
    let 'esize = (8 << UInt(size));
    let 'datasize = 64;
    let 'part = UInt(Q);
    let 'elements = DIV(datasize, esize);
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_element_mul_long(d, datasize, elements, esize, idxdsize, index, m, n, part, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, bitone, bitzero, bitone, bitzero, _, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 865) = {
    SEE = 865;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let H = Slice(__opcode, 11, 1);
    let Rm = Slice(__opcode, 16, 4);
    let M = Slice(__opcode, 20, 1);
    let L = Slice(__opcode, 21, 1);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_smull_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_long(Rd, Rn, H, Rm, M, L, size, U, Q)
}

val decode_umull_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_long : (bits(5), bits(5), bits(1), bits(4), bits(1), bits(1), bits(2), bits(1), bits(1)) -> unit

function decode_umull_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_long (Rd, Rn, H, Rm, M, L, size, U, Q) = {
    let 'idxdsize = if H == 0b1 then 128 else 64;
    index : range(0, 7) = undefined;
    Rmhi : bits(1) = undefined;
    match size {
      0b01 => {
          index = UInt((H @ L) @ M);
          Rmhi = 0b0
      },
      0b10 => {
          index = UInt(H @ L);
          Rmhi = M
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let Rmhi = Rmhi;
    let 'index = index;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rmhi @ Rm);
    let 'esize = (8 << UInt(size));
    let 'datasize = 64;
    let 'part = UInt(Q);
    let 'elements = DIV(datasize, esize);
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_element_mul_long(d, datasize, elements, esize, idxdsize, index, m, n, part, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, bitone, bitzero, bitone, bitzero, _, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 866) = {
    SEE = 866;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let H = Slice(__opcode, 11, 1);
    let Rm = Slice(__opcode, 16, 4);
    let M = Slice(__opcode, 20, 1);
    let L = Slice(__opcode, 21, 1);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_umull_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_long(Rd, Rn, H, Rm, M, L, size, U, Q)
}

val execute_aarch64_instrs_vector_arithmetic_unary_diff_neg_sat_sisd : forall 'd 'datasize 'elements 'esize 'n ('neg : Bool),
  (0 <= 'n & 'n <= 31 & 'esize in {8, 16, 32, 64} & 'datasize in {8, 16, 32, 64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('n), bool('neg)) -> unit

function execute_aarch64_instrs_vector_arithmetic_unary_diff_neg_sat_sisd (d, datasize, elements, esize, n, neg) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('datasize) = V_read(n, datasize);
    result : bits('datasize) = undefined;
    element : int = undefined;
    sat : bool = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element = SInt(Elem_read(operand, e, esize));
        if neg then {
            element = negate(element)
        } else {
            element = Abs(element)
        };
        let (__tup_0 : bits('esize), __tup_1 : bool) =
          SignedSatQ(element, esize)
        in
          {
              result = Elem_set(result, e, esize, __tup_0);
              sat = __tup_1
          };
        if sat then {
            FPSR[QC] = 0b1
        };
        ()
    };
    V_set(d, datasize) = result
}

val decode_sqabs_advsimd_aarch64_instrs_vector_arithmetic_unary_diff_neg_sat_sisd : (bits(5), bits(5), bits(2), bits(1)) -> unit

function decode_sqabs_advsimd_aarch64_instrs_vector_arithmetic_unary_diff_neg_sat_sisd (Rd, Rn, size, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = (8 << UInt(size));
    let 'datasize = esize;
    let 'elements = 1;
    let neg : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_diff_neg_sat_sisd(d, datasize, elements, esize, n, neg)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 867) = {
    SEE = 867;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    decode_sqabs_advsimd_aarch64_instrs_vector_arithmetic_unary_diff_neg_sat_sisd(Rd, Rn, size, U)
}

val decode_sqabs_advsimd_aarch64_instrs_vector_arithmetic_unary_diff_neg_sat_simd : (bits(5), bits(5), bits(2), bits(1), bits(1)) -> unit

function decode_sqabs_advsimd_aarch64_instrs_vector_arithmetic_unary_diff_neg_sat_simd (Rd, Rn, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (size @ Q) == 0b110 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let neg : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_diff_neg_sat_sisd(d, datasize, elements, esize, n, neg)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 868) = {
    SEE = 868;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_sqabs_advsimd_aarch64_instrs_vector_arithmetic_unary_diff_neg_sat_simd(Rd, Rn, size, U, Q)
}

val decode_sqneg_advsimd_aarch64_instrs_vector_arithmetic_unary_diff_neg_sat_sisd : (bits(5), bits(5), bits(2), bits(1)) -> unit

function decode_sqneg_advsimd_aarch64_instrs_vector_arithmetic_unary_diff_neg_sat_sisd (Rd, Rn, size, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = (8 << UInt(size));
    let 'datasize = esize;
    let 'elements = 1;
    let neg : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_diff_neg_sat_sisd(d, datasize, elements, esize, n, neg)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 869) = {
    SEE = 869;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    decode_sqneg_advsimd_aarch64_instrs_vector_arithmetic_unary_diff_neg_sat_sisd(Rd, Rn, size, U)
}

val decode_sqneg_advsimd_aarch64_instrs_vector_arithmetic_unary_diff_neg_sat_simd : (bits(5), bits(5), bits(2), bits(1), bits(1)) -> unit

function decode_sqneg_advsimd_aarch64_instrs_vector_arithmetic_unary_diff_neg_sat_simd (Rd, Rn, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (size @ Q) == 0b110 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let neg : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_diff_neg_sat_sisd(d, datasize, elements, esize, n, neg)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 870) = {
    SEE = 870;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_sqneg_advsimd_aarch64_instrs_vector_arithmetic_unary_diff_neg_sat_simd(Rd, Rn, size, U, Q)
}

val execute_aarch64_instrs_vector_arithmetic_binary_uniform_add_saturating_sisd : forall 'd 'datasize 'elements 'esize ('is_unsigned : Bool) 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'esize in {8, 16, 32, 64} & 'datasize in {8, 16, 32, 64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('m), int('n), bool('is_unsigned)) -> unit

function execute_aarch64_instrs_vector_arithmetic_binary_uniform_add_saturating_sisd (d, datasize, elements, esize, m, n, is_unsigned) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = V_read(n, datasize);
    let operand2 : bits('datasize) = V_read(m, datasize);
    result : bits('datasize) = undefined;
    element1 : int = undefined;
    element2 : int = undefined;
    sum : int = undefined;
    sat : bool = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element1 = asl_Int(Elem_read(operand1, e, esize), is_unsigned);
        element2 = asl_Int(Elem_read(operand2, e, esize), is_unsigned);
        sum = element1 + element2;
        let (__tup_0 : bits('esize), __tup_1 : bool) =
          SatQ(sum, esize, is_unsigned)
        in
          {
              result = Elem_set(result, e, esize, __tup_0);
              sat = __tup_1
          };
        if sat then {
            FPSR[QC] = 0b1
        };
        ()
    };
    V_set(d, datasize) = result
}

val decode_sqadd_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_add_saturating_sisd : (bits(5), bits(5), bits(5), bits(2), bits(1)) -> unit

function decode_sqadd_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_add_saturating_sisd (Rd, Rn, Rm, size, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = (8 << UInt(size));
    let 'datasize = esize;
    let 'elements = 1;
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_add_saturating_sisd(d, datasize, elements, esize, m, n, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitzero, bitzero, bitzero, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 871) = {
    SEE = 871;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    decode_sqadd_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_add_saturating_sisd(Rd, Rn, Rm, size, U)
}

val decode_sqadd_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_add_saturating_simd : (bits(5), bits(5), bits(5), bits(2), bits(1), bits(1)) -> unit

function decode_sqadd_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_add_saturating_simd (Rd, Rn, Rm, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if (size @ Q) == 0b110 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_add_saturating_sisd(d, datasize, elements, esize, m, n, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitzero, bitzero, bitzero, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 872) = {
    SEE = 872;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_sqadd_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_add_saturating_simd(Rd, Rn, Rm, size, U, Q)
}

val decode_uqadd_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_add_saturating_sisd : (bits(5), bits(5), bits(5), bits(2), bits(1)) -> unit

function decode_uqadd_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_add_saturating_sisd (Rd, Rn, Rm, size, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = (8 << UInt(size));
    let 'datasize = esize;
    let 'elements = 1;
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_add_saturating_sisd(d, datasize, elements, esize, m, n, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitzero, bitzero, bitzero, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 873) = {
    SEE = 873;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    decode_uqadd_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_add_saturating_sisd(Rd, Rn, Rm, size, U)
}

val decode_uqadd_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_add_saturating_simd : (bits(5), bits(5), bits(5), bits(2), bits(1), bits(1)) -> unit

function decode_uqadd_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_add_saturating_simd (Rd, Rn, Rm, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if (size @ Q) == 0b110 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_add_saturating_sisd(d, datasize, elements, esize, m, n, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitzero, bitzero, bitzero, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 874) = {
    SEE = 874;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_uqadd_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_add_saturating_simd(Rd, Rn, Rm, size, U, Q)
}

val execute_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_double_sisd : forall 'd 'datasize 'elements 'esize 'idxdsize 'index 'm 'n 'part ('sub_op : Bool),
  ('part in {0, 1} & 0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'index in {0, 1, 2, 3, 4, 5, 6, 7} & 'idxdsize in {64, 128} & 'esize in {8, 16, 32, 64} & 'datasize in {8, 16, 32, 64} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('idxdsize), int('index), int('m), int('n), int('part), bool('sub_op)) -> unit

function execute_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_double_sisd (d, datasize, elements, esize, idxdsize, index, m, n, part, sub_op) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = Vpart_read(n, part, datasize);
    let operand2 : bits('idxdsize) = V_read(m, idxdsize);
    let operand3 : bits(2 * 'datasize) = V_read(d, 2 * datasize);
    result : bits(2 * 'datasize) = undefined;
    element1 : int = undefined;
    product : bits(2 * 'esize) = undefined;
    accum : int = undefined;
    sat1 : bool = undefined;
    sat2 : bool = undefined;
    let 'element2 = SInt(Elem_read(operand2, index, esize));
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element1 = SInt(Elem_read(operand1, e, esize));
        (product, sat1) = SignedSatQ(2 * element1 * element2, 2 * esize);
        if sub_op then {
            accum = SInt(Elem_read(operand3, e, 2 * esize)) - SInt(product)
        } else {
            accum = SInt(Elem_read(operand3, e, 2 * esize)) + SInt(product)
        };
        let (__tup_0 : bits(2 * 'esize), __tup_1 : bool) =
          SignedSatQ(accum, 2 * esize)
        in
          {
              result = Elem_set(result, e, 2 * esize, __tup_0);
              sat2 = __tup_1
          };
        if sat1 | sat2 then {
            FPSR[QC] = 0b1
        };
        ()
    };
    V_set(d, 2 * datasize) = result
}

val decode_sqdmlal_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_double_sisd : (bits(5), bits(5), bits(1), bits(1), bits(4), bits(1), bits(1), bits(2)) -> unit

function decode_sqdmlal_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_double_sisd (Rd, Rn, H, o2, Rm, M, L, size) = {
    let 'idxdsize = if H == 0b1 then 128 else 64;
    index : range(0, 7) = undefined;
    Rmhi : bits(1) = undefined;
    match size {
      0b01 => {
          index = UInt((H @ L) @ M);
          Rmhi = 0b0
      },
      0b10 => {
          index = UInt(H @ L);
          Rmhi = M
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let Rmhi = Rmhi;
    let 'index = index;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rmhi @ Rm);
    let 'esize = (8 << UInt(size));
    let 'datasize = esize;
    let 'elements = 1;
    let 'part = 0;
    let sub_op : bool = o2 == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_double_sisd(d, datasize, elements, esize, idxdsize, index, m, n, part, sub_op)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, bitzero, bitzero, bitone, bitone, _, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 875) = {
    SEE = 875;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let H = Slice(__opcode, 11, 1);
    let o2 = Slice(__opcode, 14, 1);
    let Rm = Slice(__opcode, 16, 4);
    let M = Slice(__opcode, 20, 1);
    let L = Slice(__opcode, 21, 1);
    let size = Slice(__opcode, 22, 2);
    decode_sqdmlal_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_double_sisd(Rd, Rn, H, o2, Rm, M, L, size)
}

val decode_sqdmlal_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_double_simd : (bits(5), bits(5), bits(1), bits(1), bits(4), bits(1), bits(1), bits(2), bits(1)) -> unit

function decode_sqdmlal_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_double_simd (Rd, Rn, H, o2, Rm, M, L, size, Q) = {
    let 'idxdsize = if H == 0b1 then 128 else 64;
    index : range(0, 7) = undefined;
    Rmhi : bits(1) = undefined;
    match size {
      0b01 => {
          index = UInt((H @ L) @ M);
          Rmhi = 0b0
      },
      0b10 => {
          index = UInt(H @ L);
          Rmhi = M
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let Rmhi = Rmhi;
    let 'index = index;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rmhi @ Rm);
    let 'esize = (8 << UInt(size));
    let 'datasize = 64;
    let 'part = UInt(Q);
    let 'elements = DIV(datasize, esize);
    let sub_op : bool = o2 == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_double_sisd(d, datasize, elements, esize, idxdsize, index, m, n, part, sub_op)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, bitzero, bitzero, bitone, bitone, _, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 876) = {
    SEE = 876;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let H = Slice(__opcode, 11, 1);
    let o2 = Slice(__opcode, 14, 1);
    let Rm = Slice(__opcode, 16, 4);
    let M = Slice(__opcode, 20, 1);
    let L = Slice(__opcode, 21, 1);
    let size = Slice(__opcode, 22, 2);
    let Q = Slice(__opcode, 30, 1);
    decode_sqdmlal_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_double_simd(Rd, Rn, H, o2, Rm, M, L, size, Q)
}

val decode_sqdmlsl_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_double_sisd : (bits(5), bits(5), bits(1), bits(1), bits(4), bits(1), bits(1), bits(2)) -> unit

function decode_sqdmlsl_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_double_sisd (Rd, Rn, H, o2, Rm, M, L, size) = {
    let 'idxdsize = if H == 0b1 then 128 else 64;
    index : range(0, 7) = undefined;
    Rmhi : bits(1) = undefined;
    match size {
      0b01 => {
          index = UInt((H @ L) @ M);
          Rmhi = 0b0
      },
      0b10 => {
          index = UInt(H @ L);
          Rmhi = M
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let Rmhi = Rmhi;
    let 'index = index;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rmhi @ Rm);
    let 'esize = (8 << UInt(size));
    let 'datasize = esize;
    let 'elements = 1;
    let 'part = 0;
    let sub_op : bool = o2 == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_double_sisd(d, datasize, elements, esize, idxdsize, index, m, n, part, sub_op)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, bitzero, bitone, bitone, bitone, _, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 877) = {
    SEE = 877;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let H = Slice(__opcode, 11, 1);
    let o2 = Slice(__opcode, 14, 1);
    let Rm = Slice(__opcode, 16, 4);
    let M = Slice(__opcode, 20, 1);
    let L = Slice(__opcode, 21, 1);
    let size = Slice(__opcode, 22, 2);
    decode_sqdmlsl_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_double_sisd(Rd, Rn, H, o2, Rm, M, L, size)
}

val decode_sqdmlsl_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_double_simd : (bits(5), bits(5), bits(1), bits(1), bits(4), bits(1), bits(1), bits(2), bits(1)) -> unit

function decode_sqdmlsl_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_double_simd (Rd, Rn, H, o2, Rm, M, L, size, Q) = {
    let 'idxdsize = if H == 0b1 then 128 else 64;
    index : range(0, 7) = undefined;
    Rmhi : bits(1) = undefined;
    match size {
      0b01 => {
          index = UInt((H @ L) @ M);
          Rmhi = 0b0
      },
      0b10 => {
          index = UInt(H @ L);
          Rmhi = M
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let Rmhi = Rmhi;
    let 'index = index;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rmhi @ Rm);
    let 'esize = (8 << UInt(size));
    let 'datasize = 64;
    let 'part = UInt(Q);
    let 'elements = DIV(datasize, esize);
    let sub_op : bool = o2 == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_double_sisd(d, datasize, elements, esize, idxdsize, index, m, n, part, sub_op)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, bitzero, bitone, bitone, bitone, _, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 878) = {
    SEE = 878;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let H = Slice(__opcode, 11, 1);
    let o2 = Slice(__opcode, 14, 1);
    let Rm = Slice(__opcode, 16, 4);
    let M = Slice(__opcode, 20, 1);
    let L = Slice(__opcode, 21, 1);
    let size = Slice(__opcode, 22, 2);
    let Q = Slice(__opcode, 30, 1);
    decode_sqdmlsl_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_double_simd(Rd, Rn, H, o2, Rm, M, L, size, Q)
}

val execute_aarch64_instrs_vector_arithmetic_binary_disparate_mul_dmacc_sisd : forall 'd 'datasize 'elements 'esize 'm 'n 'part ('sub_op : Bool),
  ('part in {0, 1} & 0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'esize in {8, 16, 32, 64} & 'datasize in {8, 16, 32, 64} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('m), int('n), int('part), bool('sub_op)) -> unit

function execute_aarch64_instrs_vector_arithmetic_binary_disparate_mul_dmacc_sisd (d, datasize, elements, esize, m, n, part, sub_op) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = Vpart_read(n, part, datasize);
    let operand2 : bits('datasize) = Vpart_read(m, part, datasize);
    let operand3 : bits(2 * 'datasize) = V_read(d, 2 * datasize);
    result : bits(2 * 'datasize) = undefined;
    element1 : int = undefined;
    element2 : int = undefined;
    product : bits(2 * 'esize) = undefined;
    accum : int = undefined;
    sat1 : bool = undefined;
    sat2 : bool = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element1 = SInt(Elem_read(operand1, e, esize));
        element2 = SInt(Elem_read(operand2, e, esize));
        (product, sat1) = SignedSatQ(2 * element1 * element2, 2 * esize);
        if sub_op then {
            accum = SInt(Elem_read(operand3, e, 2 * esize)) - SInt(product)
        } else {
            accum = SInt(Elem_read(operand3, e, 2 * esize)) + SInt(product)
        };
        let (__tup_0 : bits(2 * 'esize), __tup_1 : bool) =
          SignedSatQ(accum, 2 * esize)
        in
          {
              result = Elem_set(result, e, 2 * esize, __tup_0);
              sat2 = __tup_1
          };
        if sat1 | sat2 then {
            FPSR[QC] = 0b1
        };
        ()
    };
    V_set(d, 2 * datasize) = result
}

val decode_sqdmlal_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_disparate_mul_dmacc_sisd : (bits(5), bits(5), bits(1), bits(5), bits(2)) -> unit

function decode_sqdmlal_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_disparate_mul_dmacc_sisd (Rd, Rn, o1, Rm, size) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b00 | size == 0b11 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    let 'datasize = esize;
    let 'elements = 1;
    let 'part = 0;
    let sub_op : bool = o1 == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_disparate_mul_dmacc_sisd(d, datasize, elements, esize, m, n, part, sub_op)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitone, bitzero, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 879) = {
    SEE = 879;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 13, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    decode_sqdmlal_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_disparate_mul_dmacc_sisd(Rd, Rn, o1, Rm, size)
}

val decode_sqdmlal_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_disparate_mul_dmacc_simd : (bits(5), bits(5), bits(1), bits(5), bits(2), bits(1)) -> unit

function decode_sqdmlal_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_disparate_mul_dmacc_simd (Rd, Rn, o1, Rm, size, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b00 | size == 0b11 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    let 'datasize = 64;
    let 'part = UInt(Q);
    let 'elements = DIV(datasize, esize);
    let sub_op : bool = o1 == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_disparate_mul_dmacc_sisd(d, datasize, elements, esize, m, n, part, sub_op)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitone, bitzero, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 880) = {
    SEE = 880;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 13, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let Q = Slice(__opcode, 30, 1);
    decode_sqdmlal_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_disparate_mul_dmacc_simd(Rd, Rn, o1, Rm, size, Q)
}

val decode_sqdmlsl_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_disparate_mul_dmacc_sisd : (bits(5), bits(5), bits(1), bits(5), bits(2)) -> unit

function decode_sqdmlsl_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_disparate_mul_dmacc_sisd (Rd, Rn, o1, Rm, size) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b00 | size == 0b11 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    let 'datasize = esize;
    let 'elements = 1;
    let 'part = 0;
    let sub_op : bool = o1 == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_disparate_mul_dmacc_sisd(d, datasize, elements, esize, m, n, part, sub_op)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitone, bitzero, bitone, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 881) = {
    SEE = 881;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 13, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    decode_sqdmlsl_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_disparate_mul_dmacc_sisd(Rd, Rn, o1, Rm, size)
}

val decode_sqdmlsl_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_disparate_mul_dmacc_simd : (bits(5), bits(5), bits(1), bits(5), bits(2), bits(1)) -> unit

function decode_sqdmlsl_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_disparate_mul_dmacc_simd (Rd, Rn, o1, Rm, size, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b00 | size == 0b11 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    let 'datasize = 64;
    let 'part = UInt(Q);
    let 'elements = DIV(datasize, esize);
    let sub_op : bool = o1 == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_disparate_mul_dmacc_sisd(d, datasize, elements, esize, m, n, part, sub_op)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitone, bitzero, bitone, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 882) = {
    SEE = 882;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 13, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let Q = Slice(__opcode, 30, 1);
    decode_sqdmlsl_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_disparate_mul_dmacc_simd(Rd, Rn, o1, Rm, size, Q)
}

val execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_doubling_sisd : forall 'd 'datasize 'elements 'esize 'm 'n ('rounding : Bool),
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'esize in {8, 16, 32, 64} & 'datasize in {8, 16, 32, 64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('m), int('n), bool('rounding)) -> unit

function execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_doubling_sisd (d, datasize, elements, esize, m, n, rounding) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = V_read(n, datasize);
    let operand2 : bits('datasize) = V_read(m, datasize);
    result : bits('datasize) = undefined;
    element1 : int = undefined;
    element2 : int = undefined;
    product : int = undefined;
    sat : bool = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element1 = SInt(Elem_read(operand1, e, esize));
        element2 = SInt(Elem_read(operand2, e, esize));
        product = 2 * element1 * element2;
        product = RShr(product, esize, rounding);
        let (__tup_0 : bits('esize), __tup_1 : bool) =
          SignedSatQ(product, esize)
        in
          {
              result = Elem_set(result, e, esize, __tup_0);
              sat = __tup_1
          };
        if sat then {
            FPSR[QC] = 0b1
        };
        ()
    };
    V_set(d, datasize) = result
}

val decode_sqdmulh_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_doubling_sisd : (bits(5), bits(5), bits(5), bits(2), bits(1)) -> unit

function decode_sqdmulh_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_doubling_sisd (Rd, Rn, Rm, size, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b11 | size == 0b00 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    let 'datasize = esize;
    let 'elements = 1;
    let rounding : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_doubling_sisd(d, datasize, elements, esize, m, n, rounding)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitone, bitzero, bitone, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 883) = {
    SEE = 883;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    decode_sqdmulh_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_doubling_sisd(Rd, Rn, Rm, size, U)
}

val decode_sqdmulh_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_doubling_simd : (bits(5), bits(5), bits(5), bits(2), bits(1), bits(1)) -> unit

function decode_sqdmulh_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_doubling_simd (Rd, Rn, Rm, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b11 | size == 0b00 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let rounding : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_doubling_sisd(d, datasize, elements, esize, m, n, rounding)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitone, bitzero, bitone, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 884) = {
    SEE = 884;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_sqdmulh_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_doubling_simd(Rd, Rn, Rm, size, U, Q)
}

val decode_sqrdmulh_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_doubling_sisd : (bits(5), bits(5), bits(5), bits(2), bits(1)) -> unit

function decode_sqrdmulh_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_doubling_sisd (Rd, Rn, Rm, size, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b11 | size == 0b00 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    let 'datasize = esize;
    let 'elements = 1;
    let rounding : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_doubling_sisd(d, datasize, elements, esize, m, n, rounding)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitone, bitzero, bitone, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 885) = {
    SEE = 885;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    decode_sqrdmulh_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_doubling_sisd(Rd, Rn, Rm, size, U)
}

val decode_sqrdmulh_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_doubling_simd : (bits(5), bits(5), bits(5), bits(2), bits(1), bits(1)) -> unit

function decode_sqrdmulh_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_doubling_simd (Rd, Rn, Rm, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b11 | size == 0b00 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let rounding : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_doubling_sisd(d, datasize, elements, esize, m, n, rounding)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitone, bitzero, bitone, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 886) = {
    SEE = 886;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_sqrdmulh_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_doubling_simd(Rd, Rn, Rm, size, U, Q)
}

val execute_aarch64_instrs_vector_arithmetic_binary_element_mul_high_sisd : forall 'd 'datasize 'elements 'esize 'idxdsize 'index 'm 'n ('round : Bool),
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'index in {0, 1, 2, 3, 4, 5, 6, 7} & 'idxdsize in {64, 128} & 'esize in {8, 16, 32, 64} & 'datasize in {8, 16, 32, 64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('idxdsize), int('index), int('m), int('n), bool('round)) -> unit

function execute_aarch64_instrs_vector_arithmetic_binary_element_mul_high_sisd (d, datasize, elements, esize, idxdsize, index, m, n, round) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = V_read(n, datasize);
    let operand2 : bits('idxdsize) = V_read(m, idxdsize);
    result : bits('datasize) = undefined;
    element1 : int = undefined;
    product : int = undefined;
    sat : bool = undefined;
    let 'element2 = SInt(Elem_read(operand2, index, esize));
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element1 = SInt(Elem_read(operand1, e, esize));
        product = 2 * element1 * element2;
        product = RShr(product, esize, round);
        let (__tup_0 : bits('esize), __tup_1 : bool) =
          SignedSatQ(product, esize)
        in
          {
              result = Elem_set(result, e, esize, __tup_0);
              sat = __tup_1
          };
        if sat then {
            FPSR[QC] = 0b1
        };
        ()
    };
    V_set(d, datasize) = result
}

val decode_sqdmulh_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_high_sisd : (bits(5), bits(5), bits(1), bits(1), bits(4), bits(1), bits(1), bits(2)) -> unit

function decode_sqdmulh_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_high_sisd (Rd, Rn, H, op, Rm, M, L, size) = {
    let 'idxdsize = if H == 0b1 then 128 else 64;
    index : range(0, 7) = undefined;
    Rmhi : bits(1) = undefined;
    match size {
      0b01 => {
          index = UInt((H @ L) @ M);
          Rmhi = 0b0
      },
      0b10 => {
          index = UInt(H @ L);
          Rmhi = M
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let Rmhi = Rmhi;
    let 'index = index;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rmhi @ Rm);
    let 'esize = (8 << UInt(size));
    let 'datasize = esize;
    let 'elements = 1;
    let round : bool = op == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_element_mul_high_sisd(d, datasize, elements, esize, idxdsize, index, m, n, round)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, bitone, bitone, bitzero, bitzero, _, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 887) = {
    SEE = 887;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let H = Slice(__opcode, 11, 1);
    let op = Slice(__opcode, 12, 1);
    let Rm = Slice(__opcode, 16, 4);
    let M = Slice(__opcode, 20, 1);
    let L = Slice(__opcode, 21, 1);
    let size = Slice(__opcode, 22, 2);
    decode_sqdmulh_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_high_sisd(Rd, Rn, H, op, Rm, M, L, size)
}

val decode_sqdmulh_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_high_simd : (bits(5), bits(5), bits(1), bits(1), bits(4), bits(1), bits(1), bits(2), bits(1)) -> unit

function decode_sqdmulh_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_high_simd (Rd, Rn, H, op, Rm, M, L, size, Q) = {
    let 'idxdsize = if H == 0b1 then 128 else 64;
    index : range(0, 7) = undefined;
    Rmhi : bits(1) = undefined;
    match size {
      0b01 => {
          index = UInt((H @ L) @ M);
          Rmhi = 0b0
      },
      0b10 => {
          index = UInt(H @ L);
          Rmhi = M
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let Rmhi = Rmhi;
    let 'index = index;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rmhi @ Rm);
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let round : bool = op == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_element_mul_high_sisd(d, datasize, elements, esize, idxdsize, index, m, n, round)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, bitone, bitone, bitzero, bitzero, _, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 888) = {
    SEE = 888;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let H = Slice(__opcode, 11, 1);
    let op = Slice(__opcode, 12, 1);
    let Rm = Slice(__opcode, 16, 4);
    let M = Slice(__opcode, 20, 1);
    let L = Slice(__opcode, 21, 1);
    let size = Slice(__opcode, 22, 2);
    let Q = Slice(__opcode, 30, 1);
    decode_sqdmulh_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_high_simd(Rd, Rn, H, op, Rm, M, L, size, Q)
}

val decode_sqrdmulh_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_high_sisd : (bits(5), bits(5), bits(1), bits(1), bits(4), bits(1), bits(1), bits(2)) -> unit

function decode_sqrdmulh_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_high_sisd (Rd, Rn, H, op, Rm, M, L, size) = {
    let 'idxdsize = if H == 0b1 then 128 else 64;
    index : range(0, 7) = undefined;
    Rmhi : bits(1) = undefined;
    match size {
      0b01 => {
          index = UInt((H @ L) @ M);
          Rmhi = 0b0
      },
      0b10 => {
          index = UInt(H @ L);
          Rmhi = M
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let Rmhi = Rmhi;
    let 'index = index;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rmhi @ Rm);
    let 'esize = (8 << UInt(size));
    let 'datasize = esize;
    let 'elements = 1;
    let round : bool = op == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_element_mul_high_sisd(d, datasize, elements, esize, idxdsize, index, m, n, round)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, bitone, bitone, bitzero, bitone, _, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 889) = {
    SEE = 889;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let H = Slice(__opcode, 11, 1);
    let op = Slice(__opcode, 12, 1);
    let Rm = Slice(__opcode, 16, 4);
    let M = Slice(__opcode, 20, 1);
    let L = Slice(__opcode, 21, 1);
    let size = Slice(__opcode, 22, 2);
    decode_sqrdmulh_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_high_sisd(Rd, Rn, H, op, Rm, M, L, size)
}

val decode_sqrdmulh_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_high_simd : (bits(5), bits(5), bits(1), bits(1), bits(4), bits(1), bits(1), bits(2), bits(1)) -> unit

function decode_sqrdmulh_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_high_simd (Rd, Rn, H, op, Rm, M, L, size, Q) = {
    let 'idxdsize = if H == 0b1 then 128 else 64;
    index : range(0, 7) = undefined;
    Rmhi : bits(1) = undefined;
    match size {
      0b01 => {
          index = UInt((H @ L) @ M);
          Rmhi = 0b0
      },
      0b10 => {
          index = UInt(H @ L);
          Rmhi = M
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let Rmhi = Rmhi;
    let 'index = index;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rmhi @ Rm);
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let round : bool = op == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_element_mul_high_sisd(d, datasize, elements, esize, idxdsize, index, m, n, round)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, bitone, bitone, bitzero, bitone, _, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 890) = {
    SEE = 890;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let H = Slice(__opcode, 11, 1);
    let op = Slice(__opcode, 12, 1);
    let Rm = Slice(__opcode, 16, 4);
    let M = Slice(__opcode, 20, 1);
    let L = Slice(__opcode, 21, 1);
    let size = Slice(__opcode, 22, 2);
    let Q = Slice(__opcode, 30, 1);
    decode_sqrdmulh_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_high_simd(Rd, Rn, H, op, Rm, M, L, size, Q)
}

val execute_aarch64_instrs_vector_arithmetic_binary_disparate_mul_double_sisd : forall 'd 'datasize 'elements 'esize 'm 'n 'part,
  ('part in {0, 1} & 0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'esize in {8, 16, 32, 64} & 'datasize in {8, 16, 32, 64} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('m), int('n), int('part)) -> unit

function execute_aarch64_instrs_vector_arithmetic_binary_disparate_mul_double_sisd (d, datasize, elements, esize, m, n, part) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = Vpart_read(n, part, datasize);
    let operand2 : bits('datasize) = Vpart_read(m, part, datasize);
    result : bits(2 * 'datasize) = undefined;
    element1 : int = undefined;
    element2 : int = undefined;
    product : bits(2 * 'esize) = undefined;
    sat : bool = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element1 = SInt(Elem_read(operand1, e, esize));
        element2 = SInt(Elem_read(operand2, e, esize));
        (product, sat) = SignedSatQ(2 * element1 * element2, 2 * esize);
        result = Elem_set(result, e, 2 * esize, product);
        if sat then {
            FPSR[QC] = 0b1
        };
        ()
    };
    V_set(d, 2 * datasize) = result
}

val decode_sqdmull_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_disparate_mul_double_sisd : (bits(5), bits(5), bits(5), bits(2)) -> unit

function decode_sqdmull_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_disparate_mul_double_sisd (Rd, Rn, Rm, size) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b00 | size == 0b11 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    let 'datasize = esize;
    let 'elements = 1;
    let 'part = 0;
    execute_aarch64_instrs_vector_arithmetic_binary_disparate_mul_double_sisd(d, datasize, elements, esize, m, n, part)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitone, bitone, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 891) = {
    SEE = 891;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    decode_sqdmull_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_disparate_mul_double_sisd(Rd, Rn, Rm, size)
}

val decode_sqdmull_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_disparate_mul_double_simd : (bits(5), bits(5), bits(5), bits(2), bits(1)) -> unit

function decode_sqdmull_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_disparate_mul_double_simd (Rd, Rn, Rm, size, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b00 | size == 0b11 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    let 'datasize = 64;
    let 'part = UInt(Q);
    let 'elements = DIV(datasize, esize);
    execute_aarch64_instrs_vector_arithmetic_binary_disparate_mul_double_sisd(d, datasize, elements, esize, m, n, part)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitone, bitone, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 892) = {
    SEE = 892;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let Q = Slice(__opcode, 30, 1);
    decode_sqdmull_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_disparate_mul_double_simd(Rd, Rn, Rm, size, Q)
}

val execute_aarch64_instrs_vector_arithmetic_binary_element_mul_double_sisd : forall 'd 'datasize 'elements 'esize 'idxdsize 'index 'm 'n 'part,
  ('part in {0, 1} & 0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'index in {0, 1, 2, 3, 4, 5, 6, 7} & 'idxdsize in {64, 128} & 'esize in {8, 16, 32, 64} & 'datasize in {8, 16, 32, 64} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('idxdsize), int('index), int('m), int('n), int('part)) -> unit

function execute_aarch64_instrs_vector_arithmetic_binary_element_mul_double_sisd (d, datasize, elements, esize, idxdsize, index, m, n, part) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = Vpart_read(n, part, datasize);
    let operand2 : bits('idxdsize) = V_read(m, idxdsize);
    result : bits(2 * 'datasize) = undefined;
    element1 : int = undefined;
    product : bits(2 * 'esize) = undefined;
    sat : bool = undefined;
    let 'element2 = SInt(Elem_read(operand2, index, esize));
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element1 = SInt(Elem_read(operand1, e, esize));
        (product, sat) = SignedSatQ(2 * element1 * element2, 2 * esize);
        result = Elem_set(result, e, 2 * esize, product);
        if sat then {
            FPSR[QC] = 0b1
        };
        ()
    };
    V_set(d, 2 * datasize) = result
}

val decode_sqdmull_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_double_sisd : (bits(5), bits(5), bits(1), bits(4), bits(1), bits(1), bits(2)) -> unit

function decode_sqdmull_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_double_sisd (Rd, Rn, H, Rm, M, L, size) = {
    let 'idxdsize = if H == 0b1 then 128 else 64;
    index : range(0, 7) = undefined;
    Rmhi : bits(1) = undefined;
    match size {
      0b01 => {
          index = UInt((H @ L) @ M);
          Rmhi = 0b0
      },
      0b10 => {
          index = UInt(H @ L);
          Rmhi = M
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let Rmhi = Rmhi;
    let 'index = index;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rmhi @ Rm);
    let 'esize = (8 << UInt(size));
    let 'datasize = esize;
    let 'elements = 1;
    let 'part = 0;
    execute_aarch64_instrs_vector_arithmetic_binary_element_mul_double_sisd(d, datasize, elements, esize, idxdsize, index, m, n, part)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, bitone, bitzero, bitone, bitone, _, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 893) = {
    SEE = 893;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let H = Slice(__opcode, 11, 1);
    let Rm = Slice(__opcode, 16, 4);
    let M = Slice(__opcode, 20, 1);
    let L = Slice(__opcode, 21, 1);
    let size = Slice(__opcode, 22, 2);
    decode_sqdmull_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_double_sisd(Rd, Rn, H, Rm, M, L, size)
}

val decode_sqdmull_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_double_simd : (bits(5), bits(5), bits(1), bits(4), bits(1), bits(1), bits(2), bits(1)) -> unit

function decode_sqdmull_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_double_simd (Rd, Rn, H, Rm, M, L, size, Q) = {
    let 'idxdsize = if H == 0b1 then 128 else 64;
    index : range(0, 7) = undefined;
    Rmhi : bits(1) = undefined;
    match size {
      0b01 => {
          index = UInt((H @ L) @ M);
          Rmhi = 0b0
      },
      0b10 => {
          index = UInt(H @ L);
          Rmhi = M
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let Rmhi = Rmhi;
    let 'index = index;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rmhi @ Rm);
    let 'esize = (8 << UInt(size));
    let 'datasize = 64;
    let 'part = UInt(Q);
    let 'elements = DIV(datasize, esize);
    execute_aarch64_instrs_vector_arithmetic_binary_element_mul_double_sisd(d, datasize, elements, esize, idxdsize, index, m, n, part)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, bitone, bitzero, bitone, bitone, _, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 894) = {
    SEE = 894;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let H = Slice(__opcode, 11, 1);
    let Rm = Slice(__opcode, 16, 4);
    let M = Slice(__opcode, 20, 1);
    let L = Slice(__opcode, 21, 1);
    let size = Slice(__opcode, 22, 2);
    let Q = Slice(__opcode, 30, 1);
    decode_sqdmull_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_double_simd(Rd, Rn, H, Rm, M, L, size, Q)
}

val execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd : forall 'd 'datasize 'elements 'esize 'm 'n ('rounding : Bool) ('sub_op : Bool),
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'esize in {8, 16, 32, 64} & 'datasize in {8, 16, 32, 64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('m), int('n), bool('rounding), bool('sub_op)) -> unit

function execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd (d, datasize, elements, esize, m, n, rounding, sub_op) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = V_read(n, datasize);
    let operand2 : bits('datasize) = V_read(m, datasize);
    let operand3 : bits('datasize) = V_read(d, datasize);
    result : bits('datasize) = undefined;
    element1 : int = undefined;
    element2 : int = undefined;
    element3 : int = undefined;
    accum : int = undefined;
    sat : bool = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element1 = SInt(Elem_read(operand1, e, esize));
        element2 = SInt(Elem_read(operand2, e, esize));
        element3 = SInt(Elem_read(operand3, e, esize));
        if sub_op then {
            accum = (element3 << esize) - 2 * (element1 * element2)
        } else {
            accum = (element3 << esize) + 2 * (element1 * element2)
        };
        accum = RShr(accum, esize, rounding);
        let (__tup_0 : bits('esize), __tup_1 : bool) = SignedSatQ(accum, esize)
        in
          {
              result = Elem_set(result, e, esize, __tup_0);
              sat = __tup_1
          };
        if sat then {
            FPSR[QC] = 0b1
        };
        ()
    };
    V_set(d, datasize) = result
}

val decode_sqrdmlah_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd : (bits(5), bits(5), bits(1), bits(5), bits(2)) -> unit

function decode_sqrdmlah_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd (Rd, Rn, S, Rm, size) = {
    if not_bool(HaveQRDMLAHExt()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b11 | size == 0b00 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    let 'datasize = esize;
    let 'elements = 1;
    let rounding : bool = true;
    let sub_op : bool = S == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd(d, datasize, elements, esize, m, n, rounding, sub_op)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, _, _, bitzero, _, _, _, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 895) = {
    SEE = 895;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let S = Slice(__opcode, 11, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    decode_sqrdmlah_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd(Rd, Rn, S, Rm, size)
}

val decode_sqrdmlah_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_doubling_accum_simd : (bits(5), bits(5), bits(1), bits(5), bits(2), bits(1)) -> unit

function decode_sqrdmlah_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_doubling_accum_simd (Rd, Rn, S, Rm, size, Q) = {
    if not_bool(HaveQRDMLAHExt()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b11 | size == 0b00 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let rounding : bool = true;
    let sub_op : bool = S == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd(d, datasize, elements, esize, m, n, rounding, sub_op)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, bitzero, _, _, _, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 896) = {
    SEE = 896;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let S = Slice(__opcode, 11, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let Q = Slice(__opcode, 30, 1);
    decode_sqrdmlah_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_doubling_accum_simd(Rd, Rn, S, Rm, size, Q)
}

val decode_sqrdmlsh_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd : (bits(5), bits(5), bits(1), bits(5), bits(2)) -> unit

function decode_sqrdmlsh_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd (Rd, Rn, S, Rm, size) = {
    if not_bool(HaveQRDMLAHExt()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b11 | size == 0b00 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    let 'datasize = esize;
    let 'elements = 1;
    let rounding : bool = true;
    let sub_op : bool = S == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd(d, datasize, elements, esize, m, n, rounding, sub_op)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, _, _, bitzero, _, _, _, _, _, bitone, bitzero, bitzero, bitzero, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 897) = {
    SEE = 897;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let S = Slice(__opcode, 11, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    decode_sqrdmlsh_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd(Rd, Rn, S, Rm, size)
}

val decode_sqrdmlsh_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_doubling_accum_simd : (bits(5), bits(5), bits(1), bits(5), bits(2), bits(1)) -> unit

function decode_sqrdmlsh_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_doubling_accum_simd (Rd, Rn, S, Rm, size, Q) = {
    if not_bool(HaveQRDMLAHExt()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b11 | size == 0b00 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let rounding : bool = true;
    let sub_op : bool = S == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd(d, datasize, elements, esize, m, n, rounding, sub_op)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, bitzero, _, _, _, _, _, bitone, bitzero, bitzero, bitzero, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 898) = {
    SEE = 898;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let S = Slice(__opcode, 11, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let Q = Slice(__opcode, 30, 1);
    decode_sqrdmlsh_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_doubling_accum_simd(Rd, Rn, S, Rm, size, Q)
}

val execute_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_high_sisd : forall 'd 'datasize 'elements 'esize 'idxdsize 'index 'm 'n ('rounding : Bool) ('sub_op : Bool),
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'index in {0, 1, 2, 3, 4, 5, 6, 7} & 'idxdsize in {64, 128} & 'esize in {8, 16, 32, 64} & 'datasize in {8, 16, 32, 64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('idxdsize), int('index), int('m), int('n), bool('rounding), bool('sub_op)) -> unit

function execute_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_high_sisd (d, datasize, elements, esize, idxdsize, index, m, n, rounding, sub_op) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = V_read(n, datasize);
    let operand2 : bits('idxdsize) = V_read(m, idxdsize);
    let operand3 : bits('datasize) = V_read(d, datasize);
    result : bits('datasize) = undefined;
    element1 : int = undefined;
    element3 : int = undefined;
    accum : int = undefined;
    sat : bool = undefined;
    let 'element2 = SInt(Elem_read(operand2, index, esize));
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element1 = SInt(Elem_read(operand1, e, esize));
        element3 = SInt(Elem_read(operand3, e, esize));
        if sub_op then {
            accum = (element3 << esize) - 2 * (element1 * element2)
        } else {
            accum = (element3 << esize) + 2 * (element1 * element2)
        };
        accum = RShr(accum, esize, rounding);
        let (__tup_0 : bits('esize), __tup_1 : bool) = SignedSatQ(accum, esize)
        in
          {
              result = Elem_set(result, e, esize, __tup_0);
              sat = __tup_1
          };
        if sat then {
            FPSR[QC] = 0b1
        };
        ()
    };
    V_set(d, datasize) = result
}

val decode_sqrdmlah_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_high_sisd : (bits(5), bits(5), bits(1), bits(1), bits(4), bits(1), bits(1), bits(2)) -> unit

function decode_sqrdmlah_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_high_sisd (Rd, Rn, H, S, Rm, M, L, size) = {
    if not_bool(HaveQRDMLAHExt()) then {
        throw(Error_Undefined())
    };
    let 'idxdsize = if H == 0b1 then 128 else 64;
    index : range(0, 7) = undefined;
    Rmhi : bits(1) = undefined;
    match size {
      0b01 => {
          index = UInt((H @ L) @ M);
          Rmhi = 0b0
      },
      0b10 => {
          index = UInt(H @ L);
          Rmhi = M
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let Rmhi = Rmhi;
    let 'index = index;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rmhi @ Rm);
    let 'esize = (8 << UInt(size));
    let 'datasize = esize;
    let 'elements = 1;
    let rounding : bool = true;
    let sub_op : bool = S == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_high_sisd(d, datasize, elements, esize, idxdsize, index, m, n, rounding, sub_op)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, bitone, bitone, bitzero, bitone, _, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 899) = {
    SEE = 899;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let H = Slice(__opcode, 11, 1);
    let S = Slice(__opcode, 13, 1);
    let Rm = Slice(__opcode, 16, 4);
    let M = Slice(__opcode, 20, 1);
    let L = Slice(__opcode, 21, 1);
    let size = Slice(__opcode, 22, 2);
    decode_sqrdmlah_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_high_sisd(Rd, Rn, H, S, Rm, M, L, size)
}

val decode_sqrdmlah_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_high_simd : (bits(5), bits(5), bits(1), bits(1), bits(4), bits(1), bits(1), bits(2), bits(1)) -> unit

function decode_sqrdmlah_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_high_simd (Rd, Rn, H, S, Rm, M, L, size, Q) = {
    if not_bool(HaveQRDMLAHExt()) then {
        throw(Error_Undefined())
    };
    let 'idxdsize = if H == 0b1 then 128 else 64;
    index : range(0, 7) = undefined;
    Rmhi : bits(1) = undefined;
    match size {
      0b01 => {
          index = UInt((H @ L) @ M);
          Rmhi = 0b0
      },
      0b10 => {
          index = UInt(H @ L);
          Rmhi = M
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let Rmhi = Rmhi;
    let 'index = index;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rmhi @ Rm);
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let rounding : bool = true;
    let sub_op : bool = S == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_high_sisd(d, datasize, elements, esize, idxdsize, index, m, n, rounding, sub_op)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, bitone, bitone, bitzero, bitone, _, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 900) = {
    SEE = 900;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let H = Slice(__opcode, 11, 1);
    let S = Slice(__opcode, 13, 1);
    let Rm = Slice(__opcode, 16, 4);
    let M = Slice(__opcode, 20, 1);
    let L = Slice(__opcode, 21, 1);
    let size = Slice(__opcode, 22, 2);
    let Q = Slice(__opcode, 30, 1);
    decode_sqrdmlah_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_high_simd(Rd, Rn, H, S, Rm, M, L, size, Q)
}

val decode_sqrdmlsh_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_high_sisd : (bits(5), bits(5), bits(1), bits(1), bits(4), bits(1), bits(1), bits(2)) -> unit

function decode_sqrdmlsh_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_high_sisd (Rd, Rn, H, S, Rm, M, L, size) = {
    if not_bool(HaveQRDMLAHExt()) then {
        throw(Error_Undefined())
    };
    let 'idxdsize = if H == 0b1 then 128 else 64;
    index : range(0, 7) = undefined;
    Rmhi : bits(1) = undefined;
    match size {
      0b01 => {
          index = UInt((H @ L) @ M);
          Rmhi = 0b0
      },
      0b10 => {
          index = UInt(H @ L);
          Rmhi = M
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let Rmhi = Rmhi;
    let 'index = index;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rmhi @ Rm);
    let 'esize = (8 << UInt(size));
    let 'datasize = esize;
    let 'elements = 1;
    let rounding : bool = true;
    let sub_op : bool = S == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_high_sisd(d, datasize, elements, esize, idxdsize, index, m, n, rounding, sub_op)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, bitone, bitone, bitone, bitone, _, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 901) = {
    SEE = 901;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let H = Slice(__opcode, 11, 1);
    let S = Slice(__opcode, 13, 1);
    let Rm = Slice(__opcode, 16, 4);
    let M = Slice(__opcode, 20, 1);
    let L = Slice(__opcode, 21, 1);
    let size = Slice(__opcode, 22, 2);
    decode_sqrdmlsh_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_high_sisd(Rd, Rn, H, S, Rm, M, L, size)
}

val decode_sqrdmlsh_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_high_simd : (bits(5), bits(5), bits(1), bits(1), bits(4), bits(1), bits(1), bits(2), bits(1)) -> unit

function decode_sqrdmlsh_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_high_simd (Rd, Rn, H, S, Rm, M, L, size, Q) = {
    if not_bool(HaveQRDMLAHExt()) then {
        throw(Error_Undefined())
    };
    let 'idxdsize = if H == 0b1 then 128 else 64;
    index : range(0, 7) = undefined;
    Rmhi : bits(1) = undefined;
    match size {
      0b01 => {
          index = UInt((H @ L) @ M);
          Rmhi = 0b0
      },
      0b10 => {
          index = UInt(H @ L);
          Rmhi = M
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let Rmhi = Rmhi;
    let 'index = index;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rmhi @ Rm);
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let rounding : bool = true;
    let sub_op : bool = S == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_high_sisd(d, datasize, elements, esize, idxdsize, index, m, n, rounding, sub_op)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, bitone, bitone, bitone, bitone, _, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 902) = {
    SEE = 902;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let H = Slice(__opcode, 11, 1);
    let S = Slice(__opcode, 13, 1);
    let Rm = Slice(__opcode, 16, 4);
    let M = Slice(__opcode, 20, 1);
    let L = Slice(__opcode, 21, 1);
    let size = Slice(__opcode, 22, 2);
    let Q = Slice(__opcode, 30, 1);
    decode_sqrdmlsh_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_high_simd(Rd, Rn, H, S, Rm, M, L, size, Q)
}

val execute_aarch64_instrs_vector_arithmetic_binary_uniform_shift_sisd : forall 'd 'datasize 'elements 'esize ('is_unsigned : Bool) 'm 'n ('rounding : Bool) ('saturating : Bool),
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'esize in {8, 16, 32, 64} & 'datasize in {8, 16, 32, 64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('m), int('n), bool('rounding), bool('saturating), bool('is_unsigned)) -> unit

function execute_aarch64_instrs_vector_arithmetic_binary_uniform_shift_sisd (d, datasize, elements, esize, m, n, rounding, saturating, is_unsigned) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = V_read(n, datasize);
    let operand2 : bits('datasize) = V_read(m, datasize);
    result : bits('datasize) = undefined;
    sat : bool = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element : int = asl_Int(Elem_read(operand1, e, esize), is_unsigned);
        shift : int = SInt(Elem_read(operand2, e, esize)[7 .. 0]);
        if shift >= 0 then {
            element = (element << shift)
        } else {
            let 'shift = negate(shift);
            element = RShr(element, shift, rounding)
        };
        let 'element = element;
        if saturating then {
            let (__tup_0 : bits('esize), __tup_1 : bool) =
              SatQ(element, esize, is_unsigned)
            in
              {
                  result = Elem_set(result, e, esize, __tup_0);
                  sat = __tup_1
              };
            if sat then {
                FPSR[QC] = 0b1
            };
            ()
        } else {
            result = Elem_set(result, e, esize, element[esize - 1 .. 0])
        }
    };
    V_set(d, datasize) = result
}

val decode_sqrshl_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_shift_sisd : (bits(5), bits(5), bits(1), bits(1), bits(5), bits(2), bits(1)) -> unit

function decode_sqrshl_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_shift_sisd (Rd, Rn, S, R, Rm, size, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = (8 << UInt(size));
    let 'datasize = esize;
    let 'elements = 1;
    let is_unsigned : bool = U == 0b1;
    let rounding : bool = R == 0b1;
    let saturating : bool = S == 0b1;
    if S == 0b0 & size != 0b11 then {
        throw(Error_Undefined())
    };
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_shift_sisd(d, datasize, elements, esize, m, n, rounding, saturating, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitone, bitzero, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 903) = {
    SEE = 903;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let S = Slice(__opcode, 11, 1);
    let R = Slice(__opcode, 12, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    decode_sqrshl_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_shift_sisd(Rd, Rn, S, R, Rm, size, U)
}

val decode_sqrshl_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_shift_simd : (bits(5), bits(5), bits(1), bits(1), bits(5), bits(2), bits(1), bits(1)) -> unit

function decode_sqrshl_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_shift_simd (Rd, Rn, S, R, Rm, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if (size @ Q) == 0b110 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let is_unsigned : bool = U == 0b1;
    let rounding : bool = R == 0b1;
    let saturating : bool = S == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_shift_sisd(d, datasize, elements, esize, m, n, rounding, saturating, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitone, bitzero, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 904) = {
    SEE = 904;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let S = Slice(__opcode, 11, 1);
    let R = Slice(__opcode, 12, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_sqrshl_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_shift_simd(Rd, Rn, S, R, Rm, size, U, Q)
}

val decode_sqshl_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_shift_sisd : (bits(5), bits(5), bits(1), bits(1), bits(5), bits(2), bits(1)) -> unit

function decode_sqshl_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_shift_sisd (Rd, Rn, S, R, Rm, size, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = (8 << UInt(size));
    let 'datasize = esize;
    let 'elements = 1;
    let is_unsigned : bool = U == 0b1;
    let rounding : bool = R == 0b1;
    let saturating : bool = S == 0b1;
    if S == 0b0 & size != 0b11 then {
        throw(Error_Undefined())
    };
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_shift_sisd(d, datasize, elements, esize, m, n, rounding, saturating, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitone, bitzero, bitzero, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 905) = {
    SEE = 905;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let S = Slice(__opcode, 11, 1);
    let R = Slice(__opcode, 12, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    decode_sqshl_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_shift_sisd(Rd, Rn, S, R, Rm, size, U)
}

val decode_sqshl_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_shift_simd : (bits(5), bits(5), bits(1), bits(1), bits(5), bits(2), bits(1), bits(1)) -> unit

function decode_sqshl_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_shift_simd (Rd, Rn, S, R, Rm, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if (size @ Q) == 0b110 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let is_unsigned : bool = U == 0b1;
    let rounding : bool = R == 0b1;
    let saturating : bool = S == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_shift_sisd(d, datasize, elements, esize, m, n, rounding, saturating, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitone, bitzero, bitzero, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 906) = {
    SEE = 906;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let S = Slice(__opcode, 11, 1);
    let R = Slice(__opcode, 12, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_sqshl_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_shift_simd(Rd, Rn, S, R, Rm, size, U, Q)
}

val decode_srshl_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_shift_sisd : (bits(5), bits(5), bits(1), bits(1), bits(5), bits(2), bits(1)) -> unit

function decode_srshl_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_shift_sisd (Rd, Rn, S, R, Rm, size, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = (8 << UInt(size));
    let 'datasize = esize;
    let 'elements = 1;
    let is_unsigned : bool = U == 0b1;
    let rounding : bool = R == 0b1;
    let saturating : bool = S == 0b1;
    if S == 0b0 & size != 0b11 then {
        throw(Error_Undefined())
    };
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_shift_sisd(d, datasize, elements, esize, m, n, rounding, saturating, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitone, bitzero, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 907) = {
    SEE = 907;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let S = Slice(__opcode, 11, 1);
    let R = Slice(__opcode, 12, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    decode_srshl_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_shift_sisd(Rd, Rn, S, R, Rm, size, U)
}

val decode_srshl_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_shift_simd : (bits(5), bits(5), bits(1), bits(1), bits(5), bits(2), bits(1), bits(1)) -> unit

function decode_srshl_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_shift_simd (Rd, Rn, S, R, Rm, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if (size @ Q) == 0b110 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let is_unsigned : bool = U == 0b1;
    let rounding : bool = R == 0b1;
    let saturating : bool = S == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_shift_sisd(d, datasize, elements, esize, m, n, rounding, saturating, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitone, bitzero, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 908) = {
    SEE = 908;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let S = Slice(__opcode, 11, 1);
    let R = Slice(__opcode, 12, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_srshl_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_shift_simd(Rd, Rn, S, R, Rm, size, U, Q)
}

val decode_sshl_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_shift_sisd : (bits(5), bits(5), bits(1), bits(1), bits(5), bits(2), bits(1)) -> unit

function decode_sshl_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_shift_sisd (Rd, Rn, S, R, Rm, size, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = (8 << UInt(size));
    let 'datasize = esize;
    let 'elements = 1;
    let is_unsigned : bool = U == 0b1;
    let rounding : bool = R == 0b1;
    let saturating : bool = S == 0b1;
    if S == 0b0 & size != 0b11 then {
        throw(Error_Undefined())
    };
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_shift_sisd(d, datasize, elements, esize, m, n, rounding, saturating, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitone, bitzero, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 909) = {
    SEE = 909;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let S = Slice(__opcode, 11, 1);
    let R = Slice(__opcode, 12, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    decode_sshl_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_shift_sisd(Rd, Rn, S, R, Rm, size, U)
}

val decode_sshl_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_shift_simd : (bits(5), bits(5), bits(1), bits(1), bits(5), bits(2), bits(1), bits(1)) -> unit

function decode_sshl_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_shift_simd (Rd, Rn, S, R, Rm, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if (size @ Q) == 0b110 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let is_unsigned : bool = U == 0b1;
    let rounding : bool = R == 0b1;
    let saturating : bool = S == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_shift_sisd(d, datasize, elements, esize, m, n, rounding, saturating, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitone, bitzero, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 910) = {
    SEE = 910;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let S = Slice(__opcode, 11, 1);
    let R = Slice(__opcode, 12, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_sshl_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_shift_simd(Rd, Rn, S, R, Rm, size, U, Q)
}

val decode_uqrshl_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_shift_sisd : (bits(5), bits(5), bits(1), bits(1), bits(5), bits(2), bits(1)) -> unit

function decode_uqrshl_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_shift_sisd (Rd, Rn, S, R, Rm, size, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = (8 << UInt(size));
    let 'datasize = esize;
    let 'elements = 1;
    let is_unsigned : bool = U == 0b1;
    let rounding : bool = R == 0b1;
    let saturating : bool = S == 0b1;
    if S == 0b0 & size != 0b11 then {
        throw(Error_Undefined())
    };
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_shift_sisd(d, datasize, elements, esize, m, n, rounding, saturating, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitone, bitzero, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 911) = {
    SEE = 911;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let S = Slice(__opcode, 11, 1);
    let R = Slice(__opcode, 12, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    decode_uqrshl_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_shift_sisd(Rd, Rn, S, R, Rm, size, U)
}

val decode_uqrshl_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_shift_simd : (bits(5), bits(5), bits(1), bits(1), bits(5), bits(2), bits(1), bits(1)) -> unit

function decode_uqrshl_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_shift_simd (Rd, Rn, S, R, Rm, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if (size @ Q) == 0b110 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let is_unsigned : bool = U == 0b1;
    let rounding : bool = R == 0b1;
    let saturating : bool = S == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_shift_sisd(d, datasize, elements, esize, m, n, rounding, saturating, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitone, bitzero, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 912) = {
    SEE = 912;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let S = Slice(__opcode, 11, 1);
    let R = Slice(__opcode, 12, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_uqrshl_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_shift_simd(Rd, Rn, S, R, Rm, size, U, Q)
}

val decode_uqshl_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_shift_sisd : (bits(5), bits(5), bits(1), bits(1), bits(5), bits(2), bits(1)) -> unit

function decode_uqshl_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_shift_sisd (Rd, Rn, S, R, Rm, size, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = (8 << UInt(size));
    let 'datasize = esize;
    let 'elements = 1;
    let is_unsigned : bool = U == 0b1;
    let rounding : bool = R == 0b1;
    let saturating : bool = S == 0b1;
    if S == 0b0 & size != 0b11 then {
        throw(Error_Undefined())
    };
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_shift_sisd(d, datasize, elements, esize, m, n, rounding, saturating, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitone, bitzero, bitzero, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 913) = {
    SEE = 913;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let S = Slice(__opcode, 11, 1);
    let R = Slice(__opcode, 12, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    decode_uqshl_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_shift_sisd(Rd, Rn, S, R, Rm, size, U)
}

val decode_uqshl_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_shift_simd : (bits(5), bits(5), bits(1), bits(1), bits(5), bits(2), bits(1), bits(1)) -> unit

function decode_uqshl_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_shift_simd (Rd, Rn, S, R, Rm, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if (size @ Q) == 0b110 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let is_unsigned : bool = U == 0b1;
    let rounding : bool = R == 0b1;
    let saturating : bool = S == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_shift_sisd(d, datasize, elements, esize, m, n, rounding, saturating, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitone, bitzero, bitzero, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 914) = {
    SEE = 914;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let S = Slice(__opcode, 11, 1);
    let R = Slice(__opcode, 12, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_uqshl_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_shift_simd(Rd, Rn, S, R, Rm, size, U, Q)
}

val decode_urshl_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_shift_sisd : (bits(5), bits(5), bits(1), bits(1), bits(5), bits(2), bits(1)) -> unit

function decode_urshl_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_shift_sisd (Rd, Rn, S, R, Rm, size, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = (8 << UInt(size));
    let 'datasize = esize;
    let 'elements = 1;
    let is_unsigned : bool = U == 0b1;
    let rounding : bool = R == 0b1;
    let saturating : bool = S == 0b1;
    if S == 0b0 & size != 0b11 then {
        throw(Error_Undefined())
    };
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_shift_sisd(d, datasize, elements, esize, m, n, rounding, saturating, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitone, bitzero, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 915) = {
    SEE = 915;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let S = Slice(__opcode, 11, 1);
    let R = Slice(__opcode, 12, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    decode_urshl_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_shift_sisd(Rd, Rn, S, R, Rm, size, U)
}

val decode_urshl_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_shift_simd : (bits(5), bits(5), bits(1), bits(1), bits(5), bits(2), bits(1), bits(1)) -> unit

function decode_urshl_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_shift_simd (Rd, Rn, S, R, Rm, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if (size @ Q) == 0b110 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let is_unsigned : bool = U == 0b1;
    let rounding : bool = R == 0b1;
    let saturating : bool = S == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_shift_sisd(d, datasize, elements, esize, m, n, rounding, saturating, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitone, bitzero, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 916) = {
    SEE = 916;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let S = Slice(__opcode, 11, 1);
    let R = Slice(__opcode, 12, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_urshl_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_shift_simd(Rd, Rn, S, R, Rm, size, U, Q)
}

val decode_ushl_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_shift_sisd : (bits(5), bits(5), bits(1), bits(1), bits(5), bits(2), bits(1)) -> unit

function decode_ushl_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_shift_sisd (Rd, Rn, S, R, Rm, size, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = (8 << UInt(size));
    let 'datasize = esize;
    let 'elements = 1;
    let is_unsigned : bool = U == 0b1;
    let rounding : bool = R == 0b1;
    let saturating : bool = S == 0b1;
    if S == 0b0 & size != 0b11 then {
        throw(Error_Undefined())
    };
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_shift_sisd(d, datasize, elements, esize, m, n, rounding, saturating, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitone, bitzero, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 917) = {
    SEE = 917;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let S = Slice(__opcode, 11, 1);
    let R = Slice(__opcode, 12, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    decode_ushl_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_shift_sisd(Rd, Rn, S, R, Rm, size, U)
}

val decode_ushl_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_shift_simd : (bits(5), bits(5), bits(1), bits(1), bits(5), bits(2), bits(1), bits(1)) -> unit

function decode_ushl_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_shift_simd (Rd, Rn, S, R, Rm, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if (size @ Q) == 0b110 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let is_unsigned : bool = U == 0b1;
    let rounding : bool = R == 0b1;
    let saturating : bool = S == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_shift_sisd(d, datasize, elements, esize, m, n, rounding, saturating, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitone, bitzero, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 918) = {
    SEE = 918;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let S = Slice(__opcode, 11, 1);
    let R = Slice(__opcode, 12, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_ushl_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_shift_simd(Rd, Rn, S, R, Rm, size, U, Q)
}

val execute_aarch64_instrs_vector_shift_right_narrow_uniform_sisd : forall 'd 'datasize 'elements 'esize ('is_unsigned : Bool) 'n 'part ('round : Bool) 'shift,
  ('part in {0, 1} & 0 <= 'n & 'n <= 31 & 'esize in {4, 8, 16, 32, 64} & 'datasize in {4, 8, 16, 32, 64} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('n), int('part), bool('round), int('shift), bool('is_unsigned)) -> unit

function execute_aarch64_instrs_vector_shift_right_narrow_uniform_sisd (d, datasize, elements, esize, n, part, round, shift, is_unsigned) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('datasize * 2) = V_read(n, datasize * 2);
    result : bits('datasize) = undefined;
    element : int = undefined;
    sat : bool = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element = RShr(asl_Int(Elem_read(operand, e, 2 * esize), is_unsigned), shift, round);
        let (__tup_0 : bits('esize), __tup_1 : bool) =
          SatQ(element, esize, is_unsigned)
        in
          {
              result = Elem_set(result, e, esize, __tup_0);
              sat = __tup_1
          };
        if sat then {
            FPSR[QC] = 0b1
        };
        ()
    };
    Vpart_set(d, part, datasize) = result
}

val decode_sqrshrn_advsimd_aarch64_instrs_vector_shift_right_narrow_uniform_sisd : (bits(5), bits(5), bits(1), bits(3), bits(4), bits(1)) -> unit

function decode_sqrshrn_advsimd_aarch64_instrs_vector_shift_right_narrow_uniform_sisd (Rd, Rn, op, immb, immh, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if immh == 0b0000 then {
        throw(Error_Undefined())
    };
    if [immh[3]] == 0b1 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << HighestSetBit(immh));
    let 'datasize = esize;
    let 'elements = 1;
    let 'part = 0;
    let 'shift = 2 * esize - UInt(immh @ immb);
    let round : bool = op == 0b1;
    let is_unsigned : bool = U == 0b1;
    assert(constraint(('esize in {4, 8, 16, 32, 64} & 'datasize in {4, 8, 16, 32, 64})));
    execute_aarch64_instrs_vector_shift_right_narrow_uniform_sisd(d, datasize, elements, esize, n, part, round, shift, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, bitone, bitzero, bitzero, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 919) = {
    SEE = 919;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 11, 1);
    let immb = Slice(__opcode, 16, 3);
    let immh = Slice(__opcode, 19, 4);
    let U = Slice(__opcode, 29, 1);
    decode_sqrshrn_advsimd_aarch64_instrs_vector_shift_right_narrow_uniform_sisd(Rd, Rn, op, immb, immh, U)
}

val decode_sqrshrn_advsimd_aarch64_instrs_vector_shift_right_narrow_uniform_simd : (bits(5), bits(5), bits(1), bits(3), bits(4), bits(1), bits(1)) -> unit

function decode_sqrshrn_advsimd_aarch64_instrs_vector_shift_right_narrow_uniform_simd (Rd, Rn, op, immb, immh, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if immh == 0b0000 then {
        throw(Error_See("asimdimm"))
    };
    if [immh[3]] == 0b1 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << HighestSetBit(immh));
    let 'datasize = 64;
    let 'part = UInt(Q);
    let 'elements = DIV(datasize, esize);
    let 'shift = 2 * esize - UInt(immh @ immb);
    let round : bool = op == 0b1;
    let is_unsigned : bool = U == 0b1;
    assert(constraint('esize in {4, 8, 16, 32, 64}));
    execute_aarch64_instrs_vector_shift_right_narrow_uniform_sisd(d, datasize, elements, esize, n, part, round, shift, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, bitone, bitzero, bitzero, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 920) = {
    SEE = 920;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 11, 1);
    let immb = Slice(__opcode, 16, 3);
    let immh = Slice(__opcode, 19, 4);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_sqrshrn_advsimd_aarch64_instrs_vector_shift_right_narrow_uniform_simd(Rd, Rn, op, immb, immh, U, Q)
}

val decode_sqshrn_advsimd_aarch64_instrs_vector_shift_right_narrow_uniform_sisd : (bits(5), bits(5), bits(1), bits(3), bits(4), bits(1)) -> unit

function decode_sqshrn_advsimd_aarch64_instrs_vector_shift_right_narrow_uniform_sisd (Rd, Rn, op, immb, immh, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if immh == 0b0000 then {
        throw(Error_Undefined())
    };
    if [immh[3]] == 0b1 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << HighestSetBit(immh));
    let 'datasize = esize;
    let 'elements = 1;
    let 'part = 0;
    let 'shift = 2 * esize - UInt(immh @ immb);
    let round : bool = op == 0b1;
    let is_unsigned : bool = U == 0b1;
    assert(constraint(('esize in {4, 8, 16, 32, 64} & 'datasize in {4, 8, 16, 32, 64})));
    execute_aarch64_instrs_vector_shift_right_narrow_uniform_sisd(d, datasize, elements, esize, n, part, round, shift, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, bitone, bitzero, bitzero, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 921) = {
    SEE = 921;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 11, 1);
    let immb = Slice(__opcode, 16, 3);
    let immh = Slice(__opcode, 19, 4);
    let U = Slice(__opcode, 29, 1);
    decode_sqshrn_advsimd_aarch64_instrs_vector_shift_right_narrow_uniform_sisd(Rd, Rn, op, immb, immh, U)
}

val decode_sqshrn_advsimd_aarch64_instrs_vector_shift_right_narrow_uniform_simd : (bits(5), bits(5), bits(1), bits(3), bits(4), bits(1), bits(1)) -> unit

function decode_sqshrn_advsimd_aarch64_instrs_vector_shift_right_narrow_uniform_simd (Rd, Rn, op, immb, immh, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if immh == 0b0000 then {
        throw(Error_See("asimdimm"))
    };
    if [immh[3]] == 0b1 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << HighestSetBit(immh));
    let 'datasize = 64;
    let 'part = UInt(Q);
    let 'elements = DIV(datasize, esize);
    let 'shift = 2 * esize - UInt(immh @ immb);
    let round : bool = op == 0b1;
    let is_unsigned : bool = U == 0b1;
    assert(constraint('esize in {4, 8, 16, 32, 64}));
    execute_aarch64_instrs_vector_shift_right_narrow_uniform_sisd(d, datasize, elements, esize, n, part, round, shift, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, bitone, bitzero, bitzero, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 922) = {
    SEE = 922;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 11, 1);
    let immb = Slice(__opcode, 16, 3);
    let immh = Slice(__opcode, 19, 4);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_sqshrn_advsimd_aarch64_instrs_vector_shift_right_narrow_uniform_simd(Rd, Rn, op, immb, immh, U, Q)
}

val decode_uqrshrn_advsimd_aarch64_instrs_vector_shift_right_narrow_uniform_sisd : (bits(5), bits(5), bits(1), bits(3), bits(4), bits(1)) -> unit

function decode_uqrshrn_advsimd_aarch64_instrs_vector_shift_right_narrow_uniform_sisd (Rd, Rn, op, immb, immh, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if immh == 0b0000 then {
        throw(Error_Undefined())
    };
    if [immh[3]] == 0b1 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << HighestSetBit(immh));
    let 'datasize = esize;
    let 'elements = 1;
    let 'part = 0;
    let 'shift = 2 * esize - UInt(immh @ immb);
    let round : bool = op == 0b1;
    let is_unsigned : bool = U == 0b1;
    assert(constraint(('esize in {4, 8, 16, 32, 64} & 'datasize in {4, 8, 16, 32, 64})));
    execute_aarch64_instrs_vector_shift_right_narrow_uniform_sisd(d, datasize, elements, esize, n, part, round, shift, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, bitone, bitzero, bitzero, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 923) = {
    SEE = 923;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 11, 1);
    let immb = Slice(__opcode, 16, 3);
    let immh = Slice(__opcode, 19, 4);
    let U = Slice(__opcode, 29, 1);
    decode_uqrshrn_advsimd_aarch64_instrs_vector_shift_right_narrow_uniform_sisd(Rd, Rn, op, immb, immh, U)
}

val decode_uqrshrn_advsimd_aarch64_instrs_vector_shift_right_narrow_uniform_simd : (bits(5), bits(5), bits(1), bits(3), bits(4), bits(1), bits(1)) -> unit

function decode_uqrshrn_advsimd_aarch64_instrs_vector_shift_right_narrow_uniform_simd (Rd, Rn, op, immb, immh, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if immh == 0b0000 then {
        throw(Error_See("asimdimm"))
    };
    if [immh[3]] == 0b1 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << HighestSetBit(immh));
    let 'datasize = 64;
    let 'part = UInt(Q);
    let 'elements = DIV(datasize, esize);
    let 'shift = 2 * esize - UInt(immh @ immb);
    let round : bool = op == 0b1;
    let is_unsigned : bool = U == 0b1;
    assert(constraint('esize in {4, 8, 16, 32, 64}));
    execute_aarch64_instrs_vector_shift_right_narrow_uniform_sisd(d, datasize, elements, esize, n, part, round, shift, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, bitone, bitzero, bitzero, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 924) = {
    SEE = 924;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 11, 1);
    let immb = Slice(__opcode, 16, 3);
    let immh = Slice(__opcode, 19, 4);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_uqrshrn_advsimd_aarch64_instrs_vector_shift_right_narrow_uniform_simd(Rd, Rn, op, immb, immh, U, Q)
}

val decode_uqshrn_advsimd_aarch64_instrs_vector_shift_right_narrow_uniform_sisd : (bits(5), bits(5), bits(1), bits(3), bits(4), bits(1)) -> unit

function decode_uqshrn_advsimd_aarch64_instrs_vector_shift_right_narrow_uniform_sisd (Rd, Rn, op, immb, immh, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if immh == 0b0000 then {
        throw(Error_Undefined())
    };
    if [immh[3]] == 0b1 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << HighestSetBit(immh));
    let 'datasize = esize;
    let 'elements = 1;
    let 'part = 0;
    let 'shift = 2 * esize - UInt(immh @ immb);
    let round : bool = op == 0b1;
    let is_unsigned : bool = U == 0b1;
    assert(constraint(('esize in {4, 8, 16, 32, 64} & 'datasize in {4, 8, 16, 32, 64})));
    execute_aarch64_instrs_vector_shift_right_narrow_uniform_sisd(d, datasize, elements, esize, n, part, round, shift, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, bitone, bitzero, bitzero, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 925) = {
    SEE = 925;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 11, 1);
    let immb = Slice(__opcode, 16, 3);
    let immh = Slice(__opcode, 19, 4);
    let U = Slice(__opcode, 29, 1);
    decode_uqshrn_advsimd_aarch64_instrs_vector_shift_right_narrow_uniform_sisd(Rd, Rn, op, immb, immh, U)
}

val decode_uqshrn_advsimd_aarch64_instrs_vector_shift_right_narrow_uniform_simd : (bits(5), bits(5), bits(1), bits(3), bits(4), bits(1), bits(1)) -> unit

function decode_uqshrn_advsimd_aarch64_instrs_vector_shift_right_narrow_uniform_simd (Rd, Rn, op, immb, immh, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if immh == 0b0000 then {
        throw(Error_See("asimdimm"))
    };
    if [immh[3]] == 0b1 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << HighestSetBit(immh));
    let 'datasize = 64;
    let 'part = UInt(Q);
    let 'elements = DIV(datasize, esize);
    let 'shift = 2 * esize - UInt(immh @ immb);
    let round : bool = op == 0b1;
    let is_unsigned : bool = U == 0b1;
    assert(constraint('esize in {4, 8, 16, 32, 64}));
    execute_aarch64_instrs_vector_shift_right_narrow_uniform_sisd(d, datasize, elements, esize, n, part, round, shift, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, bitone, bitzero, bitzero, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 926) = {
    SEE = 926;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 11, 1);
    let immb = Slice(__opcode, 16, 3);
    let immh = Slice(__opcode, 19, 4);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_uqshrn_advsimd_aarch64_instrs_vector_shift_right_narrow_uniform_simd(Rd, Rn, op, immb, immh, U, Q)
}

val execute_aarch64_instrs_vector_shift_right_narrow_nonuniform_sisd : forall 'd 'datasize 'elements 'esize 'n 'part ('round : Bool) 'shift,
  ('part in {0, 1} & 0 <= 'n & 'n <= 31 & 'esize in {4, 8, 16, 32, 64} & 'datasize in {4, 8, 16, 32, 64} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('n), int('part), bool('round), int('shift)) -> unit

function execute_aarch64_instrs_vector_shift_right_narrow_nonuniform_sisd (d, datasize, elements, esize, n, part, round, shift) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('datasize * 2) = V_read(n, datasize * 2);
    result : bits('datasize) = undefined;
    element : int = undefined;
    sat : bool = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element = RShr(SInt(Elem_read(operand, e, 2 * esize)), shift, round);
        let (__tup_0 : bits('esize), __tup_1 : bool) =
          UnsignedSatQ(element, esize)
        in
          {
              result = Elem_set(result, e, esize, __tup_0);
              sat = __tup_1
          };
        if sat then {
            FPSR[QC] = 0b1
        };
        ()
    };
    Vpart_set(d, part, datasize) = result
}

val decode_sqrshrun_advsimd_aarch64_instrs_vector_shift_right_narrow_nonuniform_sisd : (bits(5), bits(5), bits(1), bits(3), bits(4)) -> unit

function decode_sqrshrun_advsimd_aarch64_instrs_vector_shift_right_narrow_nonuniform_sisd (Rd, Rn, op, immb, immh) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if immh == 0b0000 then {
        throw(Error_Undefined())
    };
    if [immh[3]] == 0b1 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << HighestSetBit(immh));
    let 'datasize = esize;
    let 'elements = 1;
    let 'part = 0;
    let 'shift = 2 * esize - UInt(immh @ immb);
    let round : bool = op == 0b1;
    assert(constraint(('esize in {4, 8, 16, 32, 64} & 'datasize in {4, 8, 16, 32, 64})));
    execute_aarch64_instrs_vector_shift_right_narrow_nonuniform_sisd(d, datasize, elements, esize, n, part, round, shift)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, bitone, bitzero, bitzero, bitzero, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 927) = {
    SEE = 927;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 11, 1);
    let immb = Slice(__opcode, 16, 3);
    let immh = Slice(__opcode, 19, 4);
    decode_sqrshrun_advsimd_aarch64_instrs_vector_shift_right_narrow_nonuniform_sisd(Rd, Rn, op, immb, immh)
}

val decode_sqrshrun_advsimd_aarch64_instrs_vector_shift_right_narrow_nonuniform_simd : (bits(5), bits(5), bits(1), bits(3), bits(4), bits(1)) -> unit

function decode_sqrshrun_advsimd_aarch64_instrs_vector_shift_right_narrow_nonuniform_simd (Rd, Rn, op, immb, immh, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if immh == 0b0000 then {
        throw(Error_See("asimdimm"))
    };
    if [immh[3]] == 0b1 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << HighestSetBit(immh));
    let 'datasize = 64;
    let 'part = UInt(Q);
    let 'elements = DIV(datasize, esize);
    let 'shift = 2 * esize - UInt(immh @ immb);
    let round : bool = op == 0b1;
    assert(constraint('esize in {4, 8, 16, 32, 64}));
    execute_aarch64_instrs_vector_shift_right_narrow_nonuniform_sisd(d, datasize, elements, esize, n, part, round, shift)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, bitone, bitzero, bitzero, bitzero, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 928) = {
    SEE = 928;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 11, 1);
    let immb = Slice(__opcode, 16, 3);
    let immh = Slice(__opcode, 19, 4);
    let Q = Slice(__opcode, 30, 1);
    decode_sqrshrun_advsimd_aarch64_instrs_vector_shift_right_narrow_nonuniform_simd(Rd, Rn, op, immb, immh, Q)
}

val decode_sqshrun_advsimd_aarch64_instrs_vector_shift_right_narrow_nonuniform_sisd : (bits(5), bits(5), bits(1), bits(3), bits(4)) -> unit

function decode_sqshrun_advsimd_aarch64_instrs_vector_shift_right_narrow_nonuniform_sisd (Rd, Rn, op, immb, immh) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if immh == 0b0000 then {
        throw(Error_Undefined())
    };
    if [immh[3]] == 0b1 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << HighestSetBit(immh));
    let 'datasize = esize;
    let 'elements = 1;
    let 'part = 0;
    let 'shift = 2 * esize - UInt(immh @ immb);
    let round : bool = op == 0b1;
    assert(constraint(('esize in {4, 8, 16, 32, 64} & 'datasize in {4, 8, 16, 32, 64})));
    execute_aarch64_instrs_vector_shift_right_narrow_nonuniform_sisd(d, datasize, elements, esize, n, part, round, shift)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 929) = {
    SEE = 929;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 11, 1);
    let immb = Slice(__opcode, 16, 3);
    let immh = Slice(__opcode, 19, 4);
    decode_sqshrun_advsimd_aarch64_instrs_vector_shift_right_narrow_nonuniform_sisd(Rd, Rn, op, immb, immh)
}

val decode_sqshrun_advsimd_aarch64_instrs_vector_shift_right_narrow_nonuniform_simd : (bits(5), bits(5), bits(1), bits(3), bits(4), bits(1)) -> unit

function decode_sqshrun_advsimd_aarch64_instrs_vector_shift_right_narrow_nonuniform_simd (Rd, Rn, op, immb, immh, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if immh == 0b0000 then {
        throw(Error_See("asimdimm"))
    };
    if [immh[3]] == 0b1 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << HighestSetBit(immh));
    let 'datasize = 64;
    let 'part = UInt(Q);
    let 'elements = DIV(datasize, esize);
    let 'shift = 2 * esize - UInt(immh @ immb);
    let round : bool = op == 0b1;
    assert(constraint('esize in {4, 8, 16, 32, 64}));
    execute_aarch64_instrs_vector_shift_right_narrow_nonuniform_sisd(d, datasize, elements, esize, n, part, round, shift)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 930) = {
    SEE = 930;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 11, 1);
    let immb = Slice(__opcode, 16, 3);
    let immh = Slice(__opcode, 19, 4);
    let Q = Slice(__opcode, 30, 1);
    decode_sqshrun_advsimd_aarch64_instrs_vector_shift_right_narrow_nonuniform_simd(Rd, Rn, op, immb, immh, Q)
}

val execute_aarch64_instrs_vector_shift_left_sat_sisd : forall 'd 'datasize ('dst_unsigned : Bool) 'elements 'esize 'n 'shift ('src_unsigned : Bool),
  (0 <= 'n & 'n <= 31 & 'esize in {4, 8, 16, 32, 64} & 'datasize in {4, 8, 16, 32, 64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), bool('dst_unsigned), int('elements), int('esize), int('n), int('shift), bool('src_unsigned)) -> unit

function execute_aarch64_instrs_vector_shift_left_sat_sisd (d, datasize, dst_unsigned, elements, esize, n, shift, src_unsigned) = {
    CheckFPAdvSIMDEnabled64();
    assert(constraint('datasize in {8, 16, 32, 64, 128}));
    let operand : bits('datasize) = V_read(n, datasize);
    result : bits('datasize) = undefined;
    element : int = undefined;
    sat : bool = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element = (asl_Int(Elem_read(operand, e, esize), src_unsigned) << shift);
        let (__tup_0 : bits('esize), __tup_1 : bool) =
          SatQ(element, esize, dst_unsigned)
        in
          {
              result = Elem_set(result, e, esize, __tup_0);
              sat = __tup_1
          };
        if sat then {
            FPSR[QC] = 0b1
        };
        ()
    };
    V_set(d, datasize) = result
}

val decode_sqshl_advsimd_imm_aarch64_instrs_vector_shift_left_sat_sisd : (bits(5), bits(5), bits(1), bits(3), bits(4), bits(1)) -> unit

function decode_sqshl_advsimd_imm_aarch64_instrs_vector_shift_left_sat_sisd (Rd, Rn, op, immb, immh, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if immh == 0b0000 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << HighestSetBit(immh));
    let 'datasize = esize;
    let 'elements = 1;
    let 'shift = UInt(immh @ immb) - esize;
    src_unsigned : bool = undefined;
    dst_unsigned : bool = undefined;
    match op @ U {
      0b00 => {
          throw(Error_Undefined())
      },
      0b01 => {
          src_unsigned = false;
          dst_unsigned = true
      },
      0b10 => {
          src_unsigned = false;
          dst_unsigned = false
      },
      0b11 => {
          src_unsigned = true;
          dst_unsigned = true
      }
    };
    let dst_unsigned = dst_unsigned;
    let src_unsigned = src_unsigned;
    assert(constraint(('esize in {4, 8, 16, 32, 64} & 'datasize in {4, 8, 16, 32, 64, 128})));
    execute_aarch64_instrs_vector_shift_left_sat_sisd(d, datasize, dst_unsigned, elements, esize, n, shift, src_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, bitzero, bitone, bitone, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 931) = {
    SEE = 931;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 12, 1);
    let immb = Slice(__opcode, 16, 3);
    let immh = Slice(__opcode, 19, 4);
    let U = Slice(__opcode, 29, 1);
    decode_sqshl_advsimd_imm_aarch64_instrs_vector_shift_left_sat_sisd(Rd, Rn, op, immb, immh, U)
}

val decode_sqshl_advsimd_imm_aarch64_instrs_vector_shift_left_sat_simd : (bits(5), bits(5), bits(1), bits(3), bits(4), bits(1), bits(1)) -> unit

function decode_sqshl_advsimd_imm_aarch64_instrs_vector_shift_left_sat_simd (Rd, Rn, op, immb, immh, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if immh == 0b0000 then {
        throw(Error_See("asimdimm"))
    };
    if ([immh[3]] @ Q) == 0b10 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << HighestSetBit(immh));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let 'shift = UInt(immh @ immb) - esize;
    src_unsigned : bool = undefined;
    dst_unsigned : bool = undefined;
    match op @ U {
      0b00 => {
          throw(Error_Undefined())
      },
      0b01 => {
          src_unsigned = false;
          dst_unsigned = true
      },
      0b10 => {
          src_unsigned = false;
          dst_unsigned = false
      },
      0b11 => {
          src_unsigned = true;
          dst_unsigned = true
      }
    };
    let dst_unsigned = dst_unsigned;
    let src_unsigned = src_unsigned;
    assert(constraint('esize in {4, 8, 16, 32, 64}));
    execute_aarch64_instrs_vector_shift_left_sat_sisd(d, datasize, dst_unsigned, elements, esize, n, shift, src_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, bitzero, bitone, bitone, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 932) = {
    SEE = 932;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 12, 1);
    let immb = Slice(__opcode, 16, 3);
    let immh = Slice(__opcode, 19, 4);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_sqshl_advsimd_imm_aarch64_instrs_vector_shift_left_sat_simd(Rd, Rn, op, immb, immh, U, Q)
}

val decode_sqshlu_advsimd_aarch64_instrs_vector_shift_left_sat_sisd : (bits(5), bits(5), bits(1), bits(3), bits(4), bits(1)) -> unit

function decode_sqshlu_advsimd_aarch64_instrs_vector_shift_left_sat_sisd (Rd, Rn, op, immb, immh, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if immh == 0b0000 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << HighestSetBit(immh));
    let 'datasize = esize;
    let 'elements = 1;
    let 'shift = UInt(immh @ immb) - esize;
    src_unsigned : bool = undefined;
    dst_unsigned : bool = undefined;
    match op @ U {
      0b00 => {
          throw(Error_Undefined())
      },
      0b01 => {
          src_unsigned = false;
          dst_unsigned = true
      },
      0b10 => {
          src_unsigned = false;
          dst_unsigned = false
      },
      0b11 => {
          src_unsigned = true;
          dst_unsigned = true
      }
    };
    let dst_unsigned = dst_unsigned;
    let src_unsigned = src_unsigned;
    assert(constraint(('esize in {4, 8, 16, 32, 64} & 'datasize in {4, 8, 16, 32, 64, 128})));
    execute_aarch64_instrs_vector_shift_left_sat_sisd(d, datasize, dst_unsigned, elements, esize, n, shift, src_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, bitzero, bitone, bitone, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 933) = {
    SEE = 933;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 12, 1);
    let immb = Slice(__opcode, 16, 3);
    let immh = Slice(__opcode, 19, 4);
    let U = Slice(__opcode, 29, 1);
    decode_sqshlu_advsimd_aarch64_instrs_vector_shift_left_sat_sisd(Rd, Rn, op, immb, immh, U)
}

val decode_sqshlu_advsimd_aarch64_instrs_vector_shift_left_sat_simd : (bits(5), bits(5), bits(1), bits(3), bits(4), bits(1), bits(1)) -> unit

function decode_sqshlu_advsimd_aarch64_instrs_vector_shift_left_sat_simd (Rd, Rn, op, immb, immh, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if immh == 0b0000 then {
        throw(Error_See("asimdimm"))
    };
    if ([immh[3]] @ Q) == 0b10 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << HighestSetBit(immh));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let 'shift = UInt(immh @ immb) - esize;
    src_unsigned : bool = undefined;
    dst_unsigned : bool = undefined;
    match op @ U {
      0b00 => {
          throw(Error_Undefined())
      },
      0b01 => {
          src_unsigned = false;
          dst_unsigned = true
      },
      0b10 => {
          src_unsigned = false;
          dst_unsigned = false
      },
      0b11 => {
          src_unsigned = true;
          dst_unsigned = true
      }
    };
    let dst_unsigned = dst_unsigned;
    let src_unsigned = src_unsigned;
    assert(constraint('esize in {4, 8, 16, 32, 64}));
    execute_aarch64_instrs_vector_shift_left_sat_sisd(d, datasize, dst_unsigned, elements, esize, n, shift, src_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, bitzero, bitone, bitone, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 934) = {
    SEE = 934;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 12, 1);
    let immb = Slice(__opcode, 16, 3);
    let immh = Slice(__opcode, 19, 4);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_sqshlu_advsimd_aarch64_instrs_vector_shift_left_sat_simd(Rd, Rn, op, immb, immh, U, Q)
}

val decode_uqshl_advsimd_imm_aarch64_instrs_vector_shift_left_sat_sisd : (bits(5), bits(5), bits(1), bits(3), bits(4), bits(1)) -> unit

function decode_uqshl_advsimd_imm_aarch64_instrs_vector_shift_left_sat_sisd (Rd, Rn, op, immb, immh, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if immh == 0b0000 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << HighestSetBit(immh));
    let 'datasize = esize;
    let 'elements = 1;
    let 'shift = UInt(immh @ immb) - esize;
    src_unsigned : bool = undefined;
    dst_unsigned : bool = undefined;
    match op @ U {
      0b00 => {
          throw(Error_Undefined())
      },
      0b01 => {
          src_unsigned = false;
          dst_unsigned = true
      },
      0b10 => {
          src_unsigned = false;
          dst_unsigned = false
      },
      0b11 => {
          src_unsigned = true;
          dst_unsigned = true
      }
    };
    let dst_unsigned = dst_unsigned;
    let src_unsigned = src_unsigned;
    assert(constraint(('esize in {4, 8, 16, 32, 64} & 'datasize in {4, 8, 16, 32, 64, 128})));
    execute_aarch64_instrs_vector_shift_left_sat_sisd(d, datasize, dst_unsigned, elements, esize, n, shift, src_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, bitzero, bitone, bitone, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 935) = {
    SEE = 935;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 12, 1);
    let immb = Slice(__opcode, 16, 3);
    let immh = Slice(__opcode, 19, 4);
    let U = Slice(__opcode, 29, 1);
    decode_uqshl_advsimd_imm_aarch64_instrs_vector_shift_left_sat_sisd(Rd, Rn, op, immb, immh, U)
}

val decode_uqshl_advsimd_imm_aarch64_instrs_vector_shift_left_sat_simd : (bits(5), bits(5), bits(1), bits(3), bits(4), bits(1), bits(1)) -> unit

function decode_uqshl_advsimd_imm_aarch64_instrs_vector_shift_left_sat_simd (Rd, Rn, op, immb, immh, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if immh == 0b0000 then {
        throw(Error_See("asimdimm"))
    };
    if ([immh[3]] @ Q) == 0b10 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << HighestSetBit(immh));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let 'shift = UInt(immh @ immb) - esize;
    src_unsigned : bool = undefined;
    dst_unsigned : bool = undefined;
    match op @ U {
      0b00 => {
          throw(Error_Undefined())
      },
      0b01 => {
          src_unsigned = false;
          dst_unsigned = true
      },
      0b10 => {
          src_unsigned = false;
          dst_unsigned = false
      },
      0b11 => {
          src_unsigned = true;
          dst_unsigned = true
      }
    };
    let dst_unsigned = dst_unsigned;
    let src_unsigned = src_unsigned;
    assert(constraint('esize in {4, 8, 16, 32, 64}));
    execute_aarch64_instrs_vector_shift_left_sat_sisd(d, datasize, dst_unsigned, elements, esize, n, shift, src_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, bitzero, bitone, bitone, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 936) = {
    SEE = 936;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 12, 1);
    let immb = Slice(__opcode, 16, 3);
    let immh = Slice(__opcode, 19, 4);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_uqshl_advsimd_imm_aarch64_instrs_vector_shift_left_sat_simd(Rd, Rn, op, immb, immh, U, Q)
}

val execute_aarch64_instrs_vector_arithmetic_binary_uniform_sub_saturating_sisd : forall 'd 'datasize 'elements 'esize ('is_unsigned : Bool) 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'esize in {8, 16, 32, 64} & 'datasize in {8, 16, 32, 64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('m), int('n), bool('is_unsigned)) -> unit

function execute_aarch64_instrs_vector_arithmetic_binary_uniform_sub_saturating_sisd (d, datasize, elements, esize, m, n, is_unsigned) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = V_read(n, datasize);
    let operand2 : bits('datasize) = V_read(m, datasize);
    result : bits('datasize) = undefined;
    element1 : int = undefined;
    element2 : int = undefined;
    diff : int = undefined;
    sat : bool = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element1 = asl_Int(Elem_read(operand1, e, esize), is_unsigned);
        element2 = asl_Int(Elem_read(operand2, e, esize), is_unsigned);
        diff = element1 - element2;
        let (__tup_0 : bits('esize), __tup_1 : bool) =
          SatQ(diff, esize, is_unsigned)
        in
          {
              result = Elem_set(result, e, esize, __tup_0);
              sat = __tup_1
          };
        if sat then {
            FPSR[QC] = 0b1
        };
        ()
    };
    V_set(d, datasize) = result
}

val decode_sqsub_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_sub_saturating_sisd : (bits(5), bits(5), bits(5), bits(2), bits(1)) -> unit

function decode_sqsub_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_sub_saturating_sisd (Rd, Rn, Rm, size, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = (8 << UInt(size));
    let 'datasize = esize;
    let 'elements = 1;
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_sub_saturating_sisd(d, datasize, elements, esize, m, n, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitzero, bitone, bitzero, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 937) = {
    SEE = 937;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    decode_sqsub_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_sub_saturating_sisd(Rd, Rn, Rm, size, U)
}

val decode_sqsub_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_sub_saturating_simd : (bits(5), bits(5), bits(5), bits(2), bits(1), bits(1)) -> unit

function decode_sqsub_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_sub_saturating_simd (Rd, Rn, Rm, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if (size @ Q) == 0b110 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_sub_saturating_sisd(d, datasize, elements, esize, m, n, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitzero, bitone, bitzero, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 938) = {
    SEE = 938;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_sqsub_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_sub_saturating_simd(Rd, Rn, Rm, size, U, Q)
}

val decode_uqsub_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_sub_saturating_sisd : (bits(5), bits(5), bits(5), bits(2), bits(1)) -> unit

function decode_uqsub_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_sub_saturating_sisd (Rd, Rn, Rm, size, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = (8 << UInt(size));
    let 'datasize = esize;
    let 'elements = 1;
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_sub_saturating_sisd(d, datasize, elements, esize, m, n, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitzero, bitone, bitzero, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 939) = {
    SEE = 939;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    decode_uqsub_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_sub_saturating_sisd(Rd, Rn, Rm, size, U)
}

val decode_uqsub_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_sub_saturating_simd : (bits(5), bits(5), bits(5), bits(2), bits(1), bits(1)) -> unit

function decode_uqsub_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_sub_saturating_simd (Rd, Rn, Rm, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if (size @ Q) == 0b110 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_sub_saturating_sisd(d, datasize, elements, esize, m, n, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitzero, bitone, bitzero, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 940) = {
    SEE = 940;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_uqsub_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_sub_saturating_simd(Rd, Rn, Rm, size, U, Q)
}

val execute_aarch64_instrs_vector_arithmetic_unary_extract_sat_sisd : forall 'd 'datasize 'elements 'esize ('is_unsigned : Bool) 'n 'part,
  ('part in {0, 1} & 0 <= 'n & 'n <= 31 & 'esize in {8, 16, 32, 64} & 'datasize in {8, 16, 32, 64} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('n), int('part), bool('is_unsigned)) -> unit

function execute_aarch64_instrs_vector_arithmetic_unary_extract_sat_sisd (d, datasize, elements, esize, n, part, is_unsigned) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits(2 * 'datasize) = V_read(n, 2 * datasize);
    result : bits('datasize) = undefined;
    element : bits(2 * 'esize) = undefined;
    sat : bool = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element = Elem_read(operand, e, 2 * esize);
        let (__tup_0 : bits('esize), __tup_1 : bool) =
          SatQ(asl_Int(element, is_unsigned), esize, is_unsigned)
        in
          {
              result = Elem_set(result, e, esize, __tup_0);
              sat = __tup_1
          };
        if sat then {
            FPSR[QC] = 0b1
        };
        ()
    };
    Vpart_set(d, part, datasize) = result
}

val decode_sqxtn_advsimd_aarch64_instrs_vector_arithmetic_unary_extract_sat_sisd : (bits(5), bits(5), bits(2), bits(1)) -> unit

function decode_sqxtn_advsimd_aarch64_instrs_vector_arithmetic_unary_extract_sat_sisd (Rd, Rn, size, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    let 'datasize = esize;
    let 'part = 0;
    let 'elements = 1;
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_extract_sat_sisd(d, datasize, elements, esize, n, part, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 941) = {
    SEE = 941;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    decode_sqxtn_advsimd_aarch64_instrs_vector_arithmetic_unary_extract_sat_sisd(Rd, Rn, size, U)
}

val decode_sqxtn_advsimd_aarch64_instrs_vector_arithmetic_unary_extract_sat_simd : (bits(5), bits(5), bits(2), bits(1), bits(1)) -> unit

function decode_sqxtn_advsimd_aarch64_instrs_vector_arithmetic_unary_extract_sat_simd (Rd, Rn, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    let 'datasize = 64;
    let 'part = UInt(Q);
    let 'elements = DIV(datasize, esize);
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_extract_sat_sisd(d, datasize, elements, esize, n, part, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 942) = {
    SEE = 942;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_sqxtn_advsimd_aarch64_instrs_vector_arithmetic_unary_extract_sat_simd(Rd, Rn, size, U, Q)
}

val decode_uqxtn_advsimd_aarch64_instrs_vector_arithmetic_unary_extract_sat_sisd : (bits(5), bits(5), bits(2), bits(1)) -> unit

function decode_uqxtn_advsimd_aarch64_instrs_vector_arithmetic_unary_extract_sat_sisd (Rd, Rn, size, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    let 'datasize = esize;
    let 'part = 0;
    let 'elements = 1;
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_extract_sat_sisd(d, datasize, elements, esize, n, part, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 943) = {
    SEE = 943;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    decode_uqxtn_advsimd_aarch64_instrs_vector_arithmetic_unary_extract_sat_sisd(Rd, Rn, size, U)
}

val decode_uqxtn_advsimd_aarch64_instrs_vector_arithmetic_unary_extract_sat_simd : (bits(5), bits(5), bits(2), bits(1), bits(1)) -> unit

function decode_uqxtn_advsimd_aarch64_instrs_vector_arithmetic_unary_extract_sat_simd (Rd, Rn, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    let 'datasize = 64;
    let 'part = UInt(Q);
    let 'elements = DIV(datasize, esize);
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_extract_sat_sisd(d, datasize, elements, esize, n, part, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 944) = {
    SEE = 944;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_uqxtn_advsimd_aarch64_instrs_vector_arithmetic_unary_extract_sat_simd(Rd, Rn, size, U, Q)
}

val execute_aarch64_instrs_vector_arithmetic_unary_extract_sqxtun_sisd : forall 'd 'datasize 'elements 'esize 'n 'part,
  ('part in {0, 1} & 0 <= 'n & 'n <= 31 & 'esize in {8, 16, 32, 64} & 'datasize in {8, 16, 32, 64} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('n), int('part)) -> unit

function execute_aarch64_instrs_vector_arithmetic_unary_extract_sqxtun_sisd (d, datasize, elements, esize, n, part) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits(2 * 'datasize) = V_read(n, 2 * datasize);
    result : bits('datasize) = undefined;
    element : bits(2 * 'esize) = undefined;
    sat : bool = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element = Elem_read(operand, e, 2 * esize);
        let (__tup_0 : bits('esize), __tup_1 : bool) =
          UnsignedSatQ(SInt(element), esize)
        in
          {
              result = Elem_set(result, e, esize, __tup_0);
              sat = __tup_1
          };
        if sat then {
            FPSR[QC] = 0b1
        };
        ()
    };
    Vpart_set(d, part, datasize) = result
}

val decode_sqxtun_advsimd_aarch64_instrs_vector_arithmetic_unary_extract_sqxtun_sisd : (bits(5), bits(5), bits(2)) -> unit

function decode_sqxtun_advsimd_aarch64_instrs_vector_arithmetic_unary_extract_sqxtun_sisd (Rd, Rn, size) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    let 'datasize = esize;
    let 'part = 0;
    let 'elements = 1;
    execute_aarch64_instrs_vector_arithmetic_unary_extract_sqxtun_sisd(d, datasize, elements, esize, n, part)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitone, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 945) = {
    SEE = 945;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 22, 2);
    decode_sqxtun_advsimd_aarch64_instrs_vector_arithmetic_unary_extract_sqxtun_sisd(Rd, Rn, size)
}

val decode_sqxtun_advsimd_aarch64_instrs_vector_arithmetic_unary_extract_sqxtun_simd : (bits(5), bits(5), bits(2), bits(1)) -> unit

function decode_sqxtun_advsimd_aarch64_instrs_vector_arithmetic_unary_extract_sqxtun_simd (Rd, Rn, size, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    let 'datasize = 64;
    let 'part = UInt(Q);
    let 'elements = DIV(datasize, esize);
    execute_aarch64_instrs_vector_arithmetic_unary_extract_sqxtun_sisd(d, datasize, elements, esize, n, part)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitone, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 946) = {
    SEE = 946;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 22, 2);
    let Q = Slice(__opcode, 30, 1);
    decode_sqxtun_advsimd_aarch64_instrs_vector_arithmetic_unary_extract_sqxtun_simd(Rd, Rn, size, Q)
}

val execute_aarch64_instrs_vector_arithmetic_binary_uniform_add_halving_rounding : forall 'd 'datasize 'elements 'esize ('is_unsigned : Bool) 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'esize in {8, 16, 32, 64} & 'datasize in {64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('m), int('n), bool('is_unsigned)) -> unit

function execute_aarch64_instrs_vector_arithmetic_binary_uniform_add_halving_rounding (d, datasize, elements, esize, m, n, is_unsigned) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = V_read(n, datasize);
    let operand2 : bits('datasize) = V_read(m, datasize);
    result : bits('datasize) = undefined;
    element1 : int = undefined;
    element2 : int = undefined;
    sum : int = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element1 = asl_Int(Elem_read(operand1, e, esize), is_unsigned);
        element2 = asl_Int(Elem_read(operand2, e, esize), is_unsigned);
        sum = ((element1 + element2 + 1) >> 1);
        result = Elem_set(result, e, esize, sum[esize - 1 .. 0])
    };
    V_set(d, datasize) = result
}

val decode_srhadd_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_add_halving_rounding : (bits(5), bits(5), bits(5), bits(2), bits(1), bits(1)) -> unit

function decode_srhadd_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_add_halving_rounding (Rd, Rn, Rm, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_add_halving_rounding(d, datasize, elements, esize, m, n, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitzero, bitzero, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 947) = {
    SEE = 947;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_srhadd_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_add_halving_rounding(Rd, Rn, Rm, size, U, Q)
}

val decode_urhadd_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_add_halving_rounding : (bits(5), bits(5), bits(5), bits(2), bits(1), bits(1)) -> unit

function decode_urhadd_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_add_halving_rounding (Rd, Rn, Rm, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_add_halving_rounding(d, datasize, elements, esize, m, n, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitzero, bitzero, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 948) = {
    SEE = 948;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_urhadd_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_add_halving_rounding(Rd, Rn, Rm, size, U, Q)
}

val execute_aarch64_instrs_vector_shift_right_insert_sisd : forall 'd 'datasize 'elements 'esize 'n 'shift,
  (0 <= 'n & 'n <= 31 & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('n), int('shift)) -> unit

function execute_aarch64_instrs_vector_shift_right_insert_sisd (d, datasize, elements, esize, n, shift) = {
    CheckFPAdvSIMDEnabled64();
    assert(constraint('datasize in {8, 16, 32, 64, 128}));
    let operand : bits('datasize) = V_read(n, datasize);
    let operand2 : bits('datasize) = V_read(d, datasize);
    result : bits('datasize) = undefined;
    assert(constraint('esize >= 0));
    let mask : bits('esize) = LSR(Ones(esize), shift);
    shifted : bits('esize) = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        assert(constraint(('loop_e * 'esize <= 'loop_e * 'esize + 'esize - 1 | not(('loop_e >= 0 & ('loop_e + 1) * 'esize <= 'datasize)) | not('esize >= 0) | not('datasize in {8, 16, 32, 64, 128}))));
        shifted = LSR(Elem_read(operand, e, esize), shift);
        result = Elem_set(result, e, esize, Elem_read(operand2, e, esize) & not_vec(mask) | shifted)
    };
    V_set(d, datasize) = result
}

val decode_sri_advsimd_aarch64_instrs_vector_shift_right_insert_sisd : (bits(5), bits(5), bits(3), bits(4)) -> unit

function decode_sri_advsimd_aarch64_instrs_vector_shift_right_insert_sisd (Rd, Rn, immb, immh) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if [immh[3]] != 0b1 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << 3);
    let 'datasize = esize;
    let 'elements = 1;
    let 'shift = esize * 2 - UInt(immh @ immb);
    execute_aarch64_instrs_vector_shift_right_insert_sisd(d, datasize, elements, esize, n, shift)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, bitzero, bitone, bitzero, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 949) = {
    SEE = 949;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let immb = Slice(__opcode, 16, 3);
    let immh = Slice(__opcode, 19, 4);
    decode_sri_advsimd_aarch64_instrs_vector_shift_right_insert_sisd(Rd, Rn, immb, immh)
}

val decode_sri_advsimd_aarch64_instrs_vector_shift_right_insert_simd : (bits(5), bits(5), bits(3), bits(4), bits(1)) -> unit

function decode_sri_advsimd_aarch64_instrs_vector_shift_right_insert_simd (Rd, Rn, immb, immh, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if immh == 0b0000 then {
        throw(Error_See("asimdimm"))
    };
    if ([immh[3]] @ Q) == 0b10 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << HighestSetBit(immh));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let 'shift = esize * 2 - UInt(immh @ immb);
    execute_aarch64_instrs_vector_shift_right_insert_sisd(d, datasize, elements, esize, n, shift)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, bitzero, bitone, bitzero, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 950) = {
    SEE = 950;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let immb = Slice(__opcode, 16, 3);
    let immh = Slice(__opcode, 19, 4);
    let Q = Slice(__opcode, 30, 1);
    decode_sri_advsimd_aarch64_instrs_vector_shift_right_insert_simd(Rd, Rn, immb, immh, Q)
}

val execute_aarch64_instrs_vector_shift_right_sisd : forall ('accumulate : Bool) 'd 'datasize 'elements 'esize ('is_unsigned : Bool) 'n ('round : Bool) 'shift,
  (0 <= 'n & 'n <= 31 & 0 <= 'd & 'd <= 31).
  (bool('accumulate), int('d), int('datasize), int('elements), int('esize), int('n), bool('round), int('shift), bool('is_unsigned)) -> unit

function execute_aarch64_instrs_vector_shift_right_sisd (accumulate, d, datasize, elements, esize, n, round, shift, is_unsigned) = {
    CheckFPAdvSIMDEnabled64();
    assert(constraint('datasize in {8, 16, 32, 64, 128}));
    let operand : bits('datasize) = V_read(n, datasize);
    result : bits('datasize) = undefined;
    element : int = undefined;
    let operand2 : bits('datasize) = if accumulate then V_read(d, datasize) else
      Zeros(datasize);
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        assert(constraint('esize >= 0));
        assert(constraint(('loop_e * 'esize <= 'loop_e * 'esize + 'esize - 1 | not(('loop_e >= 0 & ('loop_e + 1) * 'esize <= 'datasize)) | not('datasize in {8, 16, 32, 64, 128}))));
        element = RShr(asl_Int(Elem_read(operand, e, esize), is_unsigned), shift, round);
        result = Elem_set(result, e, esize, Elem_read(operand2, e, esize) + element[esize - 1 .. 0])
    };
    V_set(d, datasize) = result
}

val decode_srshr_advsimd_aarch64_instrs_vector_shift_right_sisd : (bits(5), bits(5), bits(1), bits(1), bits(3), bits(4), bits(1)) -> unit

function decode_srshr_advsimd_aarch64_instrs_vector_shift_right_sisd (Rd, Rn, o0, o1, immb, immh, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if [immh[3]] != 0b1 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << 3);
    let 'datasize = esize;
    let 'elements = 1;
    let 'shift = esize * 2 - UInt(immh @ immb);
    let is_unsigned : bool = U == 0b1;
    let round : bool = o1 == 0b1;
    let accumulate : bool = o0 == 0b1;
    execute_aarch64_instrs_vector_shift_right_sisd(accumulate, d, datasize, elements, esize, n, round, shift, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, bitzero, bitzero, bitone, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 951) = {
    SEE = 951;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o0 = Slice(__opcode, 12, 1);
    let o1 = Slice(__opcode, 13, 1);
    let immb = Slice(__opcode, 16, 3);
    let immh = Slice(__opcode, 19, 4);
    let U = Slice(__opcode, 29, 1);
    decode_srshr_advsimd_aarch64_instrs_vector_shift_right_sisd(Rd, Rn, o0, o1, immb, immh, U)
}

val decode_srshr_advsimd_aarch64_instrs_vector_shift_right_simd : (bits(5), bits(5), bits(1), bits(1), bits(3), bits(4), bits(1), bits(1)) -> unit

function decode_srshr_advsimd_aarch64_instrs_vector_shift_right_simd (Rd, Rn, o0, o1, immb, immh, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if immh == 0b0000 then {
        throw(Error_See("asimdimm"))
    };
    if ([immh[3]] @ Q) == 0b10 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << HighestSetBit(immh));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let 'shift = esize * 2 - UInt(immh @ immb);
    let is_unsigned : bool = U == 0b1;
    let round : bool = o1 == 0b1;
    let accumulate : bool = o0 == 0b1;
    execute_aarch64_instrs_vector_shift_right_sisd(accumulate, d, datasize, elements, esize, n, round, shift, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, bitzero, bitzero, bitone, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 952) = {
    SEE = 952;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o0 = Slice(__opcode, 12, 1);
    let o1 = Slice(__opcode, 13, 1);
    let immb = Slice(__opcode, 16, 3);
    let immh = Slice(__opcode, 19, 4);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_srshr_advsimd_aarch64_instrs_vector_shift_right_simd(Rd, Rn, o0, o1, immb, immh, U, Q)
}

val decode_srsra_advsimd_aarch64_instrs_vector_shift_right_sisd : (bits(5), bits(5), bits(1), bits(1), bits(3), bits(4), bits(1)) -> unit

function decode_srsra_advsimd_aarch64_instrs_vector_shift_right_sisd (Rd, Rn, o0, o1, immb, immh, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if [immh[3]] != 0b1 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << 3);
    let 'datasize = esize;
    let 'elements = 1;
    let 'shift = esize * 2 - UInt(immh @ immb);
    let is_unsigned : bool = U == 0b1;
    let round : bool = o1 == 0b1;
    let accumulate : bool = o0 == 0b1;
    execute_aarch64_instrs_vector_shift_right_sisd(accumulate, d, datasize, elements, esize, n, round, shift, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, bitzero, bitzero, bitone, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 953) = {
    SEE = 953;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o0 = Slice(__opcode, 12, 1);
    let o1 = Slice(__opcode, 13, 1);
    let immb = Slice(__opcode, 16, 3);
    let immh = Slice(__opcode, 19, 4);
    let U = Slice(__opcode, 29, 1);
    decode_srsra_advsimd_aarch64_instrs_vector_shift_right_sisd(Rd, Rn, o0, o1, immb, immh, U)
}

val decode_srsra_advsimd_aarch64_instrs_vector_shift_right_simd : (bits(5), bits(5), bits(1), bits(1), bits(3), bits(4), bits(1), bits(1)) -> unit

function decode_srsra_advsimd_aarch64_instrs_vector_shift_right_simd (Rd, Rn, o0, o1, immb, immh, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if immh == 0b0000 then {
        throw(Error_See("asimdimm"))
    };
    if ([immh[3]] @ Q) == 0b10 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << HighestSetBit(immh));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let 'shift = esize * 2 - UInt(immh @ immb);
    let is_unsigned : bool = U == 0b1;
    let round : bool = o1 == 0b1;
    let accumulate : bool = o0 == 0b1;
    execute_aarch64_instrs_vector_shift_right_sisd(accumulate, d, datasize, elements, esize, n, round, shift, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, bitzero, bitzero, bitone, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 954) = {
    SEE = 954;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o0 = Slice(__opcode, 12, 1);
    let o1 = Slice(__opcode, 13, 1);
    let immb = Slice(__opcode, 16, 3);
    let immh = Slice(__opcode, 19, 4);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_srsra_advsimd_aarch64_instrs_vector_shift_right_simd(Rd, Rn, o0, o1, immb, immh, U, Q)
}

val decode_sshr_advsimd_aarch64_instrs_vector_shift_right_sisd : (bits(5), bits(5), bits(1), bits(1), bits(3), bits(4), bits(1)) -> unit

function decode_sshr_advsimd_aarch64_instrs_vector_shift_right_sisd (Rd, Rn, o0, o1, immb, immh, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if [immh[3]] != 0b1 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << 3);
    let 'datasize = esize;
    let 'elements = 1;
    let 'shift = esize * 2 - UInt(immh @ immb);
    let is_unsigned : bool = U == 0b1;
    let round : bool = o1 == 0b1;
    let accumulate : bool = o0 == 0b1;
    execute_aarch64_instrs_vector_shift_right_sisd(accumulate, d, datasize, elements, esize, n, round, shift, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 955) = {
    SEE = 955;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o0 = Slice(__opcode, 12, 1);
    let o1 = Slice(__opcode, 13, 1);
    let immb = Slice(__opcode, 16, 3);
    let immh = Slice(__opcode, 19, 4);
    let U = Slice(__opcode, 29, 1);
    decode_sshr_advsimd_aarch64_instrs_vector_shift_right_sisd(Rd, Rn, o0, o1, immb, immh, U)
}

val decode_sshr_advsimd_aarch64_instrs_vector_shift_right_simd : (bits(5), bits(5), bits(1), bits(1), bits(3), bits(4), bits(1), bits(1)) -> unit

function decode_sshr_advsimd_aarch64_instrs_vector_shift_right_simd (Rd, Rn, o0, o1, immb, immh, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if immh == 0b0000 then {
        throw(Error_See("asimdimm"))
    };
    if ([immh[3]] @ Q) == 0b10 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << HighestSetBit(immh));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let 'shift = esize * 2 - UInt(immh @ immb);
    let is_unsigned : bool = U == 0b1;
    let round : bool = o1 == 0b1;
    let accumulate : bool = o0 == 0b1;
    execute_aarch64_instrs_vector_shift_right_sisd(accumulate, d, datasize, elements, esize, n, round, shift, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 956) = {
    SEE = 956;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o0 = Slice(__opcode, 12, 1);
    let o1 = Slice(__opcode, 13, 1);
    let immb = Slice(__opcode, 16, 3);
    let immh = Slice(__opcode, 19, 4);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_sshr_advsimd_aarch64_instrs_vector_shift_right_simd(Rd, Rn, o0, o1, immb, immh, U, Q)
}

val decode_ssra_advsimd_aarch64_instrs_vector_shift_right_sisd : (bits(5), bits(5), bits(1), bits(1), bits(3), bits(4), bits(1)) -> unit

function decode_ssra_advsimd_aarch64_instrs_vector_shift_right_sisd (Rd, Rn, o0, o1, immb, immh, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if [immh[3]] != 0b1 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << 3);
    let 'datasize = esize;
    let 'elements = 1;
    let 'shift = esize * 2 - UInt(immh @ immb);
    let is_unsigned : bool = U == 0b1;
    let round : bool = o1 == 0b1;
    let accumulate : bool = o0 == 0b1;
    execute_aarch64_instrs_vector_shift_right_sisd(accumulate, d, datasize, elements, esize, n, round, shift, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, bitzero, bitzero, bitzero, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 957) = {
    SEE = 957;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o0 = Slice(__opcode, 12, 1);
    let o1 = Slice(__opcode, 13, 1);
    let immb = Slice(__opcode, 16, 3);
    let immh = Slice(__opcode, 19, 4);
    let U = Slice(__opcode, 29, 1);
    decode_ssra_advsimd_aarch64_instrs_vector_shift_right_sisd(Rd, Rn, o0, o1, immb, immh, U)
}

val decode_ssra_advsimd_aarch64_instrs_vector_shift_right_simd : (bits(5), bits(5), bits(1), bits(1), bits(3), bits(4), bits(1), bits(1)) -> unit

function decode_ssra_advsimd_aarch64_instrs_vector_shift_right_simd (Rd, Rn, o0, o1, immb, immh, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if immh == 0b0000 then {
        throw(Error_See("asimdimm"))
    };
    if ([immh[3]] @ Q) == 0b10 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << HighestSetBit(immh));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let 'shift = esize * 2 - UInt(immh @ immb);
    let is_unsigned : bool = U == 0b1;
    let round : bool = o1 == 0b1;
    let accumulate : bool = o0 == 0b1;
    execute_aarch64_instrs_vector_shift_right_sisd(accumulate, d, datasize, elements, esize, n, round, shift, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, bitzero, bitzero, bitzero, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 958) = {
    SEE = 958;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o0 = Slice(__opcode, 12, 1);
    let o1 = Slice(__opcode, 13, 1);
    let immb = Slice(__opcode, 16, 3);
    let immh = Slice(__opcode, 19, 4);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_ssra_advsimd_aarch64_instrs_vector_shift_right_simd(Rd, Rn, o0, o1, immb, immh, U, Q)
}

val decode_urshr_advsimd_aarch64_instrs_vector_shift_right_sisd : (bits(5), bits(5), bits(1), bits(1), bits(3), bits(4), bits(1)) -> unit

function decode_urshr_advsimd_aarch64_instrs_vector_shift_right_sisd (Rd, Rn, o0, o1, immb, immh, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if [immh[3]] != 0b1 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << 3);
    let 'datasize = esize;
    let 'elements = 1;
    let 'shift = esize * 2 - UInt(immh @ immb);
    let is_unsigned : bool = U == 0b1;
    let round : bool = o1 == 0b1;
    let accumulate : bool = o0 == 0b1;
    execute_aarch64_instrs_vector_shift_right_sisd(accumulate, d, datasize, elements, esize, n, round, shift, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, bitzero, bitzero, bitone, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 959) = {
    SEE = 959;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o0 = Slice(__opcode, 12, 1);
    let o1 = Slice(__opcode, 13, 1);
    let immb = Slice(__opcode, 16, 3);
    let immh = Slice(__opcode, 19, 4);
    let U = Slice(__opcode, 29, 1);
    decode_urshr_advsimd_aarch64_instrs_vector_shift_right_sisd(Rd, Rn, o0, o1, immb, immh, U)
}

val decode_urshr_advsimd_aarch64_instrs_vector_shift_right_simd : (bits(5), bits(5), bits(1), bits(1), bits(3), bits(4), bits(1), bits(1)) -> unit

function decode_urshr_advsimd_aarch64_instrs_vector_shift_right_simd (Rd, Rn, o0, o1, immb, immh, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if immh == 0b0000 then {
        throw(Error_See("asimdimm"))
    };
    if ([immh[3]] @ Q) == 0b10 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << HighestSetBit(immh));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let 'shift = esize * 2 - UInt(immh @ immb);
    let is_unsigned : bool = U == 0b1;
    let round : bool = o1 == 0b1;
    let accumulate : bool = o0 == 0b1;
    execute_aarch64_instrs_vector_shift_right_sisd(accumulate, d, datasize, elements, esize, n, round, shift, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, bitzero, bitzero, bitone, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 960) = {
    SEE = 960;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o0 = Slice(__opcode, 12, 1);
    let o1 = Slice(__opcode, 13, 1);
    let immb = Slice(__opcode, 16, 3);
    let immh = Slice(__opcode, 19, 4);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_urshr_advsimd_aarch64_instrs_vector_shift_right_simd(Rd, Rn, o0, o1, immb, immh, U, Q)
}

val decode_ursra_advsimd_aarch64_instrs_vector_shift_right_sisd : (bits(5), bits(5), bits(1), bits(1), bits(3), bits(4), bits(1)) -> unit

function decode_ursra_advsimd_aarch64_instrs_vector_shift_right_sisd (Rd, Rn, o0, o1, immb, immh, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if [immh[3]] != 0b1 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << 3);
    let 'datasize = esize;
    let 'elements = 1;
    let 'shift = esize * 2 - UInt(immh @ immb);
    let is_unsigned : bool = U == 0b1;
    let round : bool = o1 == 0b1;
    let accumulate : bool = o0 == 0b1;
    execute_aarch64_instrs_vector_shift_right_sisd(accumulate, d, datasize, elements, esize, n, round, shift, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, bitzero, bitzero, bitone, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 961) = {
    SEE = 961;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o0 = Slice(__opcode, 12, 1);
    let o1 = Slice(__opcode, 13, 1);
    let immb = Slice(__opcode, 16, 3);
    let immh = Slice(__opcode, 19, 4);
    let U = Slice(__opcode, 29, 1);
    decode_ursra_advsimd_aarch64_instrs_vector_shift_right_sisd(Rd, Rn, o0, o1, immb, immh, U)
}

val decode_ursra_advsimd_aarch64_instrs_vector_shift_right_simd : (bits(5), bits(5), bits(1), bits(1), bits(3), bits(4), bits(1), bits(1)) -> unit

function decode_ursra_advsimd_aarch64_instrs_vector_shift_right_simd (Rd, Rn, o0, o1, immb, immh, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if immh == 0b0000 then {
        throw(Error_See("asimdimm"))
    };
    if ([immh[3]] @ Q) == 0b10 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << HighestSetBit(immh));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let 'shift = esize * 2 - UInt(immh @ immb);
    let is_unsigned : bool = U == 0b1;
    let round : bool = o1 == 0b1;
    let accumulate : bool = o0 == 0b1;
    execute_aarch64_instrs_vector_shift_right_sisd(accumulate, d, datasize, elements, esize, n, round, shift, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, bitzero, bitzero, bitone, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 962) = {
    SEE = 962;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o0 = Slice(__opcode, 12, 1);
    let o1 = Slice(__opcode, 13, 1);
    let immb = Slice(__opcode, 16, 3);
    let immh = Slice(__opcode, 19, 4);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_ursra_advsimd_aarch64_instrs_vector_shift_right_simd(Rd, Rn, o0, o1, immb, immh, U, Q)
}

val decode_ushr_advsimd_aarch64_instrs_vector_shift_right_sisd : (bits(5), bits(5), bits(1), bits(1), bits(3), bits(4), bits(1)) -> unit

function decode_ushr_advsimd_aarch64_instrs_vector_shift_right_sisd (Rd, Rn, o0, o1, immb, immh, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if [immh[3]] != 0b1 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << 3);
    let 'datasize = esize;
    let 'elements = 1;
    let 'shift = esize * 2 - UInt(immh @ immb);
    let is_unsigned : bool = U == 0b1;
    let round : bool = o1 == 0b1;
    let accumulate : bool = o0 == 0b1;
    execute_aarch64_instrs_vector_shift_right_sisd(accumulate, d, datasize, elements, esize, n, round, shift, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 963) = {
    SEE = 963;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o0 = Slice(__opcode, 12, 1);
    let o1 = Slice(__opcode, 13, 1);
    let immb = Slice(__opcode, 16, 3);
    let immh = Slice(__opcode, 19, 4);
    let U = Slice(__opcode, 29, 1);
    decode_ushr_advsimd_aarch64_instrs_vector_shift_right_sisd(Rd, Rn, o0, o1, immb, immh, U)
}

val decode_ushr_advsimd_aarch64_instrs_vector_shift_right_simd : (bits(5), bits(5), bits(1), bits(1), bits(3), bits(4), bits(1), bits(1)) -> unit

function decode_ushr_advsimd_aarch64_instrs_vector_shift_right_simd (Rd, Rn, o0, o1, immb, immh, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if immh == 0b0000 then {
        throw(Error_See("asimdimm"))
    };
    if ([immh[3]] @ Q) == 0b10 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << HighestSetBit(immh));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let 'shift = esize * 2 - UInt(immh @ immb);
    let is_unsigned : bool = U == 0b1;
    let round : bool = o1 == 0b1;
    let accumulate : bool = o0 == 0b1;
    execute_aarch64_instrs_vector_shift_right_sisd(accumulate, d, datasize, elements, esize, n, round, shift, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 964) = {
    SEE = 964;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o0 = Slice(__opcode, 12, 1);
    let o1 = Slice(__opcode, 13, 1);
    let immb = Slice(__opcode, 16, 3);
    let immh = Slice(__opcode, 19, 4);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_ushr_advsimd_aarch64_instrs_vector_shift_right_simd(Rd, Rn, o0, o1, immb, immh, U, Q)
}

val decode_usra_advsimd_aarch64_instrs_vector_shift_right_sisd : (bits(5), bits(5), bits(1), bits(1), bits(3), bits(4), bits(1)) -> unit

function decode_usra_advsimd_aarch64_instrs_vector_shift_right_sisd (Rd, Rn, o0, o1, immb, immh, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if [immh[3]] != 0b1 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << 3);
    let 'datasize = esize;
    let 'elements = 1;
    let 'shift = esize * 2 - UInt(immh @ immb);
    let is_unsigned : bool = U == 0b1;
    let round : bool = o1 == 0b1;
    let accumulate : bool = o0 == 0b1;
    execute_aarch64_instrs_vector_shift_right_sisd(accumulate, d, datasize, elements, esize, n, round, shift, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, bitzero, bitzero, bitzero, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 965) = {
    SEE = 965;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o0 = Slice(__opcode, 12, 1);
    let o1 = Slice(__opcode, 13, 1);
    let immb = Slice(__opcode, 16, 3);
    let immh = Slice(__opcode, 19, 4);
    let U = Slice(__opcode, 29, 1);
    decode_usra_advsimd_aarch64_instrs_vector_shift_right_sisd(Rd, Rn, o0, o1, immb, immh, U)
}

val decode_usra_advsimd_aarch64_instrs_vector_shift_right_simd : (bits(5), bits(5), bits(1), bits(1), bits(3), bits(4), bits(1), bits(1)) -> unit

function decode_usra_advsimd_aarch64_instrs_vector_shift_right_simd (Rd, Rn, o0, o1, immb, immh, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if immh == 0b0000 then {
        throw(Error_See("asimdimm"))
    };
    if ([immh[3]] @ Q) == 0b10 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << HighestSetBit(immh));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let 'shift = esize * 2 - UInt(immh @ immb);
    let is_unsigned : bool = U == 0b1;
    let round : bool = o1 == 0b1;
    let accumulate : bool = o0 == 0b1;
    execute_aarch64_instrs_vector_shift_right_sisd(accumulate, d, datasize, elements, esize, n, round, shift, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, bitzero, bitzero, bitzero, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 966) = {
    SEE = 966;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o0 = Slice(__opcode, 12, 1);
    let o1 = Slice(__opcode, 13, 1);
    let immb = Slice(__opcode, 16, 3);
    let immh = Slice(__opcode, 19, 4);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_usra_advsimd_aarch64_instrs_vector_shift_right_simd(Rd, Rn, o0, o1, immb, immh, U, Q)
}

val execute_aarch64_instrs_vector_shift_left_long : forall 'd 'datasize 'elements 'esize ('is_unsigned : Bool) 'n 'part 'shift,
  ('part in {0, 1} & 0 <= 'n & 'n <= 31 & 'esize in {4, 8, 16, 32, 64} & 'datasize == 64 & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('n), int('part), int('shift), bool('is_unsigned)) -> unit

function execute_aarch64_instrs_vector_shift_left_long (d, datasize, elements, esize, n, part, shift, is_unsigned) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('datasize) = Vpart_read(n, part, datasize);
    result : bits('datasize * 2) = undefined;
    element : int = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element = (asl_Int(Elem_read(operand, e, esize), is_unsigned) << shift);
        result = Elem_set(result, e, 2 * esize, element[2 * esize - 1 .. 0])
    };
    V_set(d, datasize * 2) = result
}

val decode_sshll_advsimd_aarch64_instrs_vector_shift_left_long : (bits(5), bits(5), bits(3), bits(4), bits(1), bits(1)) -> unit

function decode_sshll_advsimd_aarch64_instrs_vector_shift_left_long (Rd, Rn, immb, immh, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if immh == 0b0000 then {
        throw(Error_See("asimdimm"))
    };
    if [immh[3]] == 0b1 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << HighestSetBit(immh));
    let 'datasize = 64;
    let 'part = UInt(Q);
    let 'elements = DIV(datasize, esize);
    let 'shift = UInt(immh @ immb) - esize;
    let is_unsigned : bool = U == 0b1;
    assert(constraint('esize in {4, 8, 16, 32, 64}));
    execute_aarch64_instrs_vector_shift_left_long(d, datasize, elements, esize, n, part, shift, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, bitone, bitzero, bitone, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 967) = {
    SEE = 967;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let immb = Slice(__opcode, 16, 3);
    let immh = Slice(__opcode, 19, 4);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_sshll_advsimd_aarch64_instrs_vector_shift_left_long(Rd, Rn, immb, immh, U, Q)
}

val decode_ushll_advsimd_aarch64_instrs_vector_shift_left_long : (bits(5), bits(5), bits(3), bits(4), bits(1), bits(1)) -> unit

function decode_ushll_advsimd_aarch64_instrs_vector_shift_left_long (Rd, Rn, immb, immh, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if immh == 0b0000 then {
        throw(Error_See("asimdimm"))
    };
    if [immh[3]] == 0b1 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << HighestSetBit(immh));
    let 'datasize = 64;
    let 'part = UInt(Q);
    let 'elements = DIV(datasize, esize);
    let 'shift = UInt(immh @ immb) - esize;
    let is_unsigned : bool = U == 0b1;
    assert(constraint('esize in {4, 8, 16, 32, 64}));
    execute_aarch64_instrs_vector_shift_left_long(d, datasize, elements, esize, n, part, shift, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, bitone, bitzero, bitone, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 968) = {
    SEE = 968;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let immb = Slice(__opcode, 16, 3);
    let immh = Slice(__opcode, 19, 4);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_ushll_advsimd_aarch64_instrs_vector_shift_left_long(Rd, Rn, immb, immh, U, Q)
}

val execute_aarch64_instrs_integer_tags_mcsettagpairpost : forall 'n ('postindex : Bool) 't ('writeback : Bool) ('zero_data : Bool),
  (0 <= 't & 't <= 31 & 0 <= 'n & 'n <= 31).
  (int('n), bits(64), bool('postindex), int('t), bool('writeback), bool('zero_data)) -> unit

function execute_aarch64_instrs_integer_tags_mcsettagpairpost (n, offset, postindex, t, writeback, zero_data) = {
    address : bits(64) = undefined;
    let data : bits(64) = if t == 31 then SP_read() else X_read(t, 64);
    let tag : bits(4) = AArch64_AllocationTagFromAddress(data);
    if n == 31 then {
        CheckSPAlignment();
        address = SP_read()
    } else {
        address = X_read(n, 64)
    };
    if not_bool(postindex) then {
        address = address + offset
    };
    let accdesc : AccessDescriptor = CreateAccDescLDGSTG(MemOp_STORE);
    if zero_data then {
        if not_bool(IsAligned__1(address, TAG_GRANULE)) then {
            AArch64_Abort(address, AlignmentFault(accdesc))
        };
        Mem_set(address, TAG_GRANULE, accdesc) = Zeros(TAG_GRANULE * 8);
        Mem_set(address + TAG_GRANULE, TAG_GRANULE, accdesc) = Zeros(TAG_GRANULE * 8)
    };
    AArch64_MemTag_set(address, accdesc) = tag;
    AArch64_MemTag_set(address + TAG_GRANULE, accdesc) = tag;
    if writeback then {
        if postindex then {
            address = address + offset
        };
        if n == 31 then {
            SP_set() = address
        } else {
            X_set(n, 64) = address
        }
    };
    ()
}

val decode_st2g_aarch64_instrs_integer_tags_mcsettagpairpost : (bits(5), bits(5), bits(9)) -> unit

function decode_st2g_aarch64_instrs_integer_tags_mcsettagpairpost (Xt, Xn, imm9) = {
    if not_bool(HaveMTEExt()) then {
        throw(Error_Undefined())
    };
    let 'n = UInt(Xn);
    let 't = UInt(Xt);
    let offset : bits(64) = LSL(SignExtend(imm9, 64), LOG2_TAG_GRANULE);
    let writeback : bool = true;
    let postindex : bool = true;
    let zero_data : bool = false;
    execute_aarch64_instrs_integer_tags_mcsettagpairpost(n, offset, postindex, t, writeback, zero_data)
}

function clause __DecodeA64_LoadStore ((pc, ([bitone, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitone, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 969) = {
    SEE = 969;
    let Xt = Slice(__opcode, 0, 5);
    let Xn = Slice(__opcode, 5, 5);
    let imm9 = Slice(__opcode, 12, 9);
    decode_st2g_aarch64_instrs_integer_tags_mcsettagpairpost(Xt, Xn, imm9)
}

val decode_st2g_aarch64_instrs_integer_tags_mcsettagpairpre : (bits(5), bits(5), bits(9)) -> unit

function decode_st2g_aarch64_instrs_integer_tags_mcsettagpairpre (Xt, Xn, imm9) = {
    if not_bool(HaveMTEExt()) then {
        throw(Error_Undefined())
    };
    let 'n = UInt(Xn);
    let 't = UInt(Xt);
    let offset : bits(64) = LSL(SignExtend(imm9, 64), LOG2_TAG_GRANULE);
    let writeback : bool = true;
    let postindex : bool = false;
    let zero_data : bool = false;
    execute_aarch64_instrs_integer_tags_mcsettagpairpost(n, offset, postindex, t, writeback, zero_data)
}

function clause __DecodeA64_LoadStore ((pc, ([bitone, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitone, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 970) = {
    SEE = 970;
    let Xt = Slice(__opcode, 0, 5);
    let Xn = Slice(__opcode, 5, 5);
    let imm9 = Slice(__opcode, 12, 9);
    decode_st2g_aarch64_instrs_integer_tags_mcsettagpairpre(Xt, Xn, imm9)
}

val decode_st2g_aarch64_instrs_integer_tags_mcsettagpair : (bits(5), bits(5), bits(9)) -> unit

function decode_st2g_aarch64_instrs_integer_tags_mcsettagpair (Xt, Xn, imm9) = {
    if not_bool(HaveMTEExt()) then {
        throw(Error_Undefined())
    };
    let 'n = UInt(Xn);
    let 't = UInt(Xt);
    let offset : bits(64) = LSL(SignExtend(imm9, 64), LOG2_TAG_GRANULE);
    let writeback : bool = false;
    let postindex : bool = false;
    let zero_data : bool = false;
    execute_aarch64_instrs_integer_tags_mcsettagpairpost(n, offset, postindex, t, writeback, zero_data)
}

function clause __DecodeA64_LoadStore ((pc, ([bitone, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitone, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 971) = {
    SEE = 971;
    let Xt = Slice(__opcode, 0, 5);
    let Xn = Slice(__opcode, 5, 5);
    let imm9 = Slice(__opcode, 12, 9);
    decode_st2g_aarch64_instrs_integer_tags_mcsettagpair(Xt, Xn, imm9)
}

val execute_aarch64_instrs_memory_atomicops_st_acc_st64b : forall 'n 't ('tagchecked : Bool),
  (0 <= 't & 't <= 31 & 0 <= 'n & 'n <= 31).
  (bits(2), MemOp, int('n), int('t), bool('tagchecked)) -> unit

function execute_aarch64_instrs_memory_atomicops_st_acc_st64b (lst, memop, n, t, tagchecked) = {
    CheckLDST64BEnabled();
    data : bits(512) = undefined;
    address : bits(64) = undefined;
    value_name : bits(64) = undefined;
    let accdesc : AccessDescriptor = CreateAccDescLS64(memop, tagchecked);
    foreach (i from 0 to 7 by 1 in inc) {
        value_name = X_read(t + i, 64);
        if BigEndian(accdesc.acctype) then {
            value_name = BigEndianReverse(value_name)
        };
        data[63 + 64 * i .. 64 * i] = value_name
    };
    if n == 31 then {
        CheckSPAlignment();
        address = SP_read()
    } else {
        address = X_read(n, 64)
    };
    SetLoadStoreType(lst);
    AArch64_SetLSInstructionSyndrome(64, false, t, true, false);
    MemStore64B(address, data, accdesc);
    if SPESampleInFlight then {
        SPESampleGeneralPurposeLoadStore()
    };
    ()
}

val decode_st64b_aarch64_instrs_memory_atomicops_st_acc_st64b : (bits(5), bits(5)) -> unit

function decode_st64b_aarch64_instrs_memory_atomicops_st_acc_st64b (Rt, Rn) = {
    if not_bool(HaveFeatLS64()) then {
        throw(Error_Undefined())
    };
    if Rt[4 .. 3] == 0b11 | [Rt[0]] == 0b1 then {
        throw(Error_Undefined())
    };
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let memop : MemOp = MemOp_STORE;
    let tagchecked : bool = n != 31;
    let lst : bits(2) = lst_64b;
    execute_aarch64_instrs_memory_atomicops_st_acc_st64b(lst, memop, n, t, tagchecked)
}

function clause __DecodeA64_LoadStore ((pc, ([bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 972) = {
    SEE = 972;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    decode_st64b_aarch64_instrs_memory_atomicops_st_acc_st64b(Rt, Rn)
}

val execute_aarch64_instrs_memory_atomicops_st_acc_st64bv : forall 'n 's 't ('tagchecked : Bool),
  (0 <= 't & 't <= 31 & 0 <= 's & 's <= 31 & 0 <= 'n & 'n <= 31).
  (bits(5), bits(2), MemOp, int('n), int('s), int('t), bool('tagchecked)) -> unit

function execute_aarch64_instrs_memory_atomicops_st_acc_st64bv (Rs, lst, memop, n, s, t, tagchecked) = {
    CheckST64BVEnabled();
    data : bits(512) = undefined;
    address : bits(64) = undefined;
    value_name : bits(64) = undefined;
    let accdesc : AccessDescriptor = CreateAccDescLS64(memop, tagchecked);
    foreach (i from 0 to 7 by 1 in inc) {
        value_name = X_read(t + i, 64);
        if BigEndian(accdesc.acctype) then {
            value_name = BigEndianReverse(value_name)
        };
        data[63 + 64 * i .. 64 * i] = value_name
    };
    if n == 31 then {
        CheckSPAlignment();
        address = SP_read()
    } else {
        address = X_read(n, 64)
    };
    SetLoadStoreType(lst);
    AArch64_SetLSInstructionSyndrome(64, false, t, true, false);
    SetIss2(Rs);
    let status : bits(64) = MemStore64BWithRet(address, data, accdesc);
    if s != 31 then {
        X_set(s, 64) = status
    };
    if SPESampleInFlight then {
        SPESampleGeneralPurposeLoadStore()
    };
    ()
}

val decode_st64bv_aarch64_instrs_memory_atomicops_st_acc_st64bv : (bits(5), bits(5), bits(5)) -> unit

function decode_st64bv_aarch64_instrs_memory_atomicops_st_acc_st64bv (Rt, Rn, Rs) = {
    if not_bool(HaveFeatLS64_V()) then {
        throw(Error_Undefined())
    };
    if Rt[4 .. 3] == 0b11 | [Rt[0]] == 0b1 then {
        throw(Error_Undefined())
    };
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let memop : MemOp = MemOp_STORE;
    let 's = UInt(Rs);
    let tagchecked : bool = n != 31;
    let lst : bits(2) = lst_64bv;
    execute_aarch64_instrs_memory_atomicops_st_acc_st64bv(Rs, lst, memop, n, s, t, tagchecked)
}

function clause __DecodeA64_LoadStore ((pc, ([bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, _, _, _, _, _, bitone, bitzero, bitone, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 973) = {
    SEE = 973;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rs = Slice(__opcode, 16, 5);
    decode_st64bv_aarch64_instrs_memory_atomicops_st_acc_st64bv(Rt, Rn, Rs)
}

val execute_aarch64_instrs_memory_atomicops_st_acc_st64bv0 : forall 'n 's 't ('tagchecked : Bool),
  (0 <= 't & 't <= 31 & 0 <= 's & 's <= 31 & 0 <= 'n & 'n <= 31).
  (bits(5), bits(2), MemOp, int('n), int('s), int('t), bool('tagchecked)) -> unit

function execute_aarch64_instrs_memory_atomicops_st_acc_st64bv0 (Rs, lst, memop, n, s, t, tagchecked) = {
    CheckST64BV0Enabled();
    data : bits(512) = undefined;
    address : bits(64) = undefined;
    value_name : bits(64) = undefined;
    let accdesc : AccessDescriptor = CreateAccDescLS64(memop, tagchecked);
    let Xt : bits(64) = X_read(t, 64);
    value_name[31 .. 0] = ACCDATA_EL1.bits[31 .. 0];
    value_name[63 .. 32] = Xt[63 .. 32];
    if BigEndian(accdesc.acctype) then {
        value_name = BigEndianReverse(value_name)
    };
    data[63 .. 0] = value_name;
    foreach (i from 1 to 7 by 1 in inc) {
        value_name = X_read(t + i, 64);
        if BigEndian(accdesc.acctype) then {
            value_name = BigEndianReverse(value_name)
        };
        data[63 + 64 * i .. 64 * i] = value_name
    };
    if n == 31 then {
        CheckSPAlignment();
        address = SP_read()
    } else {
        address = X_read(n, 64)
    };
    SetLoadStoreType(lst);
    AArch64_SetLSInstructionSyndrome(64, false, t, true, false);
    SetIss2(Rs);
    let status : bits(64) = MemStore64BWithRet(address, data, accdesc);
    if s != 31 then {
        X_set(s, 64) = status
    };
    if SPESampleInFlight then {
        SPESampleGeneralPurposeLoadStore()
    };
    ()
}

val decode_st64bv0_aarch64_instrs_memory_atomicops_st_acc_st64bv0 : (bits(5), bits(5), bits(5)) -> unit

function decode_st64bv0_aarch64_instrs_memory_atomicops_st_acc_st64bv0 (Rt, Rn, Rs) = {
    if not_bool(HaveFeatLS64_ACCDATA()) then {
        throw(Error_Undefined())
    };
    if Rt[4 .. 3] == 0b11 | [Rt[0]] == 0b1 then {
        throw(Error_Undefined())
    };
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let memop : MemOp = MemOp_STORE;
    let 's = UInt(Rs);
    let tagchecked : bool = n != 31;
    let lst : bits(2) = lst_64bv0;
    execute_aarch64_instrs_memory_atomicops_st_acc_st64bv0(Rs, lst, memop, n, s, t, tagchecked)
}

function clause __DecodeA64_LoadStore ((pc, ([bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, _, _, _, _, _, bitone, bitzero, bitone, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 974) = {
    SEE = 974;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rs = Slice(__opcode, 16, 5);
    decode_st64bv0_aarch64_instrs_memory_atomicops_st_acc_st64bv0(Rt, Rn, Rs)
}

val execute_aarch64_instrs_integer_tags_mcsettagpost : forall 'n ('postindex : Bool) 't ('writeback : Bool) ('zero_data : Bool),
  (0 <= 't & 't <= 31 & 0 <= 'n & 'n <= 31).
  (int('n), bits(64), bool('postindex), int('t), bool('writeback), bool('zero_data)) -> unit

function execute_aarch64_instrs_integer_tags_mcsettagpost (n, offset, postindex, t, writeback, zero_data) = {
    address : bits(64) = undefined;
    if n == 31 then {
        CheckSPAlignment();
        address = SP_read()
    } else {
        address = X_read(n, 64)
    };
    if not_bool(postindex) then {
        address = address + offset
    };
    let accdesc : AccessDescriptor = CreateAccDescLDGSTG(MemOp_STORE);
    if zero_data then {
        if not_bool(IsAligned__1(address, TAG_GRANULE)) then {
            AArch64_Abort(address, AlignmentFault(accdesc))
        };
        Mem_set(address, TAG_GRANULE, accdesc) = Zeros(TAG_GRANULE * 8)
    };
    let data : bits(64) = if t == 31 then SP_read() else X_read(t, 64);
    let tag : bits(4) = AArch64_AllocationTagFromAddress(data);
    AArch64_MemTag_set(address, accdesc) = tag;
    if writeback then {
        if postindex then {
            address = address + offset
        };
        if n == 31 then {
            SP_set() = address
        } else {
            X_set(n, 64) = address
        }
    };
    ()
}

val decode_stg_aarch64_instrs_integer_tags_mcsettagpost : (bits(5), bits(5), bits(9)) -> unit

function decode_stg_aarch64_instrs_integer_tags_mcsettagpost (Xt, Xn, imm9) = {
    if not_bool(HaveMTEExt()) then {
        throw(Error_Undefined())
    };
    let 'n = UInt(Xn);
    let 't = UInt(Xt);
    let offset : bits(64) = LSL(SignExtend(imm9, 64), LOG2_TAG_GRANULE);
    let writeback : bool = true;
    let postindex : bool = true;
    let zero_data : bool = false;
    execute_aarch64_instrs_integer_tags_mcsettagpost(n, offset, postindex, t, writeback, zero_data)
}

function clause __DecodeA64_LoadStore ((pc, ([bitone, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitone, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 975) = {
    SEE = 975;
    let Xt = Slice(__opcode, 0, 5);
    let Xn = Slice(__opcode, 5, 5);
    let imm9 = Slice(__opcode, 12, 9);
    decode_stg_aarch64_instrs_integer_tags_mcsettagpost(Xt, Xn, imm9)
}

val decode_stg_aarch64_instrs_integer_tags_mcsettagpre : (bits(5), bits(5), bits(9)) -> unit

function decode_stg_aarch64_instrs_integer_tags_mcsettagpre (Xt, Xn, imm9) = {
    if not_bool(HaveMTEExt()) then {
        throw(Error_Undefined())
    };
    let 'n = UInt(Xn);
    let 't = UInt(Xt);
    let offset : bits(64) = LSL(SignExtend(imm9, 64), LOG2_TAG_GRANULE);
    let writeback : bool = true;
    let postindex : bool = false;
    let zero_data : bool = false;
    execute_aarch64_instrs_integer_tags_mcsettagpost(n, offset, postindex, t, writeback, zero_data)
}

function clause __DecodeA64_LoadStore ((pc, ([bitone, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitone, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 976) = {
    SEE = 976;
    let Xt = Slice(__opcode, 0, 5);
    let Xn = Slice(__opcode, 5, 5);
    let imm9 = Slice(__opcode, 12, 9);
    decode_stg_aarch64_instrs_integer_tags_mcsettagpre(Xt, Xn, imm9)
}

val decode_stg_aarch64_instrs_integer_tags_mcsettag : (bits(5), bits(5), bits(9)) -> unit

function decode_stg_aarch64_instrs_integer_tags_mcsettag (Xt, Xn, imm9) = {
    if not_bool(HaveMTEExt()) then {
        throw(Error_Undefined())
    };
    let 'n = UInt(Xn);
    let 't = UInt(Xt);
    let offset : bits(64) = LSL(SignExtend(imm9, 64), LOG2_TAG_GRANULE);
    let writeback : bool = false;
    let postindex : bool = false;
    let zero_data : bool = false;
    execute_aarch64_instrs_integer_tags_mcsettagpost(n, offset, postindex, t, writeback, zero_data)
}

function clause __DecodeA64_LoadStore ((pc, ([bitone, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitone, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 977) = {
    SEE = 977;
    let Xt = Slice(__opcode, 0, 5);
    let Xn = Slice(__opcode, 5, 5);
    let imm9 = Slice(__opcode, 12, 9);
    decode_stg_aarch64_instrs_integer_tags_mcsettag(Xt, Xn, imm9)
}

val execute_aarch64_instrs_integer_tags_mcsettagarray : forall 'n 't,
  (0 <= 't & 't <= 31 & 0 <= 'n & 'n <= 31).
  (int('n), int('t)) -> unit

function execute_aarch64_instrs_integer_tags_mcsettagarray (n, t) = {
    if PSTATE.EL == EL0 then {
        throw(Error_Undefined())
    };
    let data : bits(64) = X_read(t, 64);
    address : bits(64) = undefined;
    if n == 31 then {
        CheckSPAlignment();
        address = SP_read()
    } else {
        address = X_read(n, 64)
    };
    let 'size = 4 * pow2(UInt(GMID_EL1[BS]));
    address : bits(64) = Align(address, size);
    let 'count = (size >> LOG2_TAG_GRANULE);
    index : int = UInt(address[LOG2_TAG_GRANULE + 3 .. LOG2_TAG_GRANULE]);
    let accdesc : AccessDescriptor = CreateAccDescLDGSTG(MemOp_STORE);
    foreach (i from 0 to (count - 1) by 1 in inc) {
        let tag : bits(4) = let 'index = index in
          {
              assert(constraint((0 <= 'index * 4 & 'index * 4 + 3 < 64)));
              data[index * 4 + 3 .. index * 4]
          };
        AArch64_MemTag_set(address, accdesc) = tag;
        address = address + TAG_GRANULE;
        index = index + 1
    }
}

val decode_stgm_aarch64_instrs_integer_tags_mcsettagarray : (bits(5), bits(5)) -> unit

function decode_stgm_aarch64_instrs_integer_tags_mcsettagarray (Xt, Xn) = {
    if not_bool(HaveMTE2Ext()) then {
        throw(Error_Undefined())
    };
    let 't = UInt(Xt);
    let 'n = UInt(Xn);
    execute_aarch64_instrs_integer_tags_mcsettagarray(n, t)
}

function clause __DecodeA64_LoadStore ((pc, ([bitone, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 978) = {
    SEE = 978;
    let Xt = Slice(__opcode, 0, 5);
    let Xn = Slice(__opcode, 5, 5);
    decode_stgm_aarch64_instrs_integer_tags_mcsettagarray(Xt, Xn)
}

val execute_aarch64_instrs_integer_tags_mcsettaganddatapairpost : forall 'n ('postindex : Bool) 't 't2 ('writeback : Bool),
  (0 <= 't2 & 't2 <= 31 & 0 <= 't & 't <= 31 & 0 <= 'n & 'n <= 31).
  (int('n), bits(64), bool('postindex), int('t), int('t2), bool('writeback)) -> unit

function execute_aarch64_instrs_integer_tags_mcsettaganddatapairpost (n, offset, postindex, t, t2, writeback) = {
    address : bits(64) = undefined;
    if n == 31 then {
        CheckSPAlignment();
        address = SP_read()
    } else {
        address = X_read(n, 64)
    };
    let data1 : bits(64) = X_read(t, 64);
    let data2 : bits(64) = X_read(t2, 64);
    if not_bool(postindex) then {
        address = address + offset
    };
    let accdesc : AccessDescriptor = CreateAccDescLDGSTG(MemOp_STORE);
    if not_bool(IsAligned__1(address, TAG_GRANULE)) then {
        AArch64_Abort(address, AlignmentFault(accdesc))
    };
    Mem_set(address, 8, accdesc) = data1;
    Mem_set(address + 8, 8, accdesc) = data2;
    AArch64_MemTag_set(address, accdesc) = AArch64_AllocationTagFromAddress(address);
    if writeback then {
        if postindex then {
            address = address + offset
        };
        if n == 31 then {
            SP_set() = address
        } else {
            X_set(n, 64) = address
        }
    };
    ()
}

val decode_stgp_aarch64_instrs_integer_tags_mcsettaganddatapairpost : (bits(5), bits(5), bits(5), bits(7)) -> unit

function decode_stgp_aarch64_instrs_integer_tags_mcsettaganddatapairpost (Xt, Xn, Xt2, simm7) = {
    if not_bool(HaveMTEExt()) then {
        throw(Error_Undefined())
    };
    let 'n = UInt(Xn);
    let 't = UInt(Xt);
    let 't2 = UInt(Xt2);
    let offset : bits(64) = LSL(SignExtend(simm7, 64), LOG2_TAG_GRANULE);
    let writeback : bool = true;
    let postindex : bool = true;
    execute_aarch64_instrs_integer_tags_mcsettaganddatapairpost(n, offset, postindex, t, t2, writeback)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, bitone, bitone, bitzero, bitone, bitzero, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 979) = {
    SEE = 979;
    let Xt = Slice(__opcode, 0, 5);
    let Xn = Slice(__opcode, 5, 5);
    let Xt2 = Slice(__opcode, 10, 5);
    let simm7 = Slice(__opcode, 15, 7);
    decode_stgp_aarch64_instrs_integer_tags_mcsettaganddatapairpost(Xt, Xn, Xt2, simm7)
}

val decode_stgp_aarch64_instrs_integer_tags_mcsettaganddatapairpre : (bits(5), bits(5), bits(5), bits(7)) -> unit

function decode_stgp_aarch64_instrs_integer_tags_mcsettaganddatapairpre (Xt, Xn, Xt2, simm7) = {
    if not_bool(HaveMTEExt()) then {
        throw(Error_Undefined())
    };
    let 'n = UInt(Xn);
    let 't = UInt(Xt);
    let 't2 = UInt(Xt2);
    let offset : bits(64) = LSL(SignExtend(simm7, 64), LOG2_TAG_GRANULE);
    let writeback : bool = true;
    let postindex : bool = false;
    execute_aarch64_instrs_integer_tags_mcsettaganddatapairpost(n, offset, postindex, t, t2, writeback)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, bitone, bitone, bitzero, bitone, bitzero, bitzero, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 980) = {
    SEE = 980;
    let Xt = Slice(__opcode, 0, 5);
    let Xn = Slice(__opcode, 5, 5);
    let Xt2 = Slice(__opcode, 10, 5);
    let simm7 = Slice(__opcode, 15, 7);
    decode_stgp_aarch64_instrs_integer_tags_mcsettaganddatapairpre(Xt, Xn, Xt2, simm7)
}

val decode_stgp_aarch64_instrs_integer_tags_mcsettaganddatapair : (bits(5), bits(5), bits(5), bits(7)) -> unit

function decode_stgp_aarch64_instrs_integer_tags_mcsettaganddatapair (Xt, Xn, Xt2, simm7) = {
    if not_bool(HaveMTEExt()) then {
        throw(Error_Undefined())
    };
    let 'n = UInt(Xn);
    let 't = UInt(Xt);
    let 't2 = UInt(Xt2);
    let offset : bits(64) = LSL(SignExtend(simm7, 64), LOG2_TAG_GRANULE);
    let writeback : bool = false;
    let postindex : bool = false;
    execute_aarch64_instrs_integer_tags_mcsettaganddatapairpost(n, offset, postindex, t, t2, writeback)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, bitone, bitone, bitzero, bitone, bitzero, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 981) = {
    SEE = 981;
    let Xt = Slice(__opcode, 0, 5);
    let Xn = Slice(__opcode, 5, 5);
    let Xt2 = Slice(__opcode, 10, 5);
    let simm7 = Slice(__opcode, 15, 7);
    decode_stgp_aarch64_instrs_integer_tags_mcsettaganddatapair(Xt, Xn, Xt2, simm7)
}

val execute_aarch64_instrs_memory_ordered_pair_stilp : forall 'datasize 'n 'offset ('postindex : Bool) ('rt_unknown : Bool) 't 't2 ('tagchecked : Bool) ('wb_unknown : Bool) ('wback : Bool),
  (0 <= 't2 & 't2 <= 31 & 0 <= 't & 't <= 31 & 0 <= 'n & 'n <= 31 & 'datasize in {32, 64}).
  (int('datasize), MemOp, int('n), int('offset), bool('postindex), bool('rt_unknown), int('t), int('t2), bool('tagchecked), bool('wb_unknown), bool('wback)) -> unit

function execute_aarch64_instrs_memory_ordered_pair_stilp (datasize, memop, n, offset, postindex, rt_unknown, t, t2, tagchecked, wb_unknown, wback) = {
    address : bits(64) = undefined;
    data1 : bits('datasize) = undefined;
    data2 : bits('datasize) = undefined;
    let 'dbytes = DIV(datasize, 8);
    let accdesc : AccessDescriptor = CreateAccDescAcqRel(memop, tagchecked);
    if n == 31 then {
        CheckSPAlignment();
        address = SP_read()
    } else {
        address = X_read(n, 64)
    };
    if not_bool(postindex) then {
        address = address + offset
    };
    match memop {
      MemOp_STORE => {
          if rt_unknown & t == n then {
              data1 = __UNKNOWN_bits(datasize)
          } else {
              data1 = X_read(t, datasize)
          };
          if rt_unknown & t2 == n then {
              data2 = __UNKNOWN_bits(datasize)
          } else {
              data2 = X_read(t2, datasize)
          };
          if HaveLSE2Ext() then {
              full_data : bits(2 * 'datasize) = undefined;
              if BigEndian(accdesc.acctype) then {
                  full_data = data1 @ data2
              } else {
                  full_data = data2 @ data1
              };
              let ispair : bool = true;
              let highestAddressfirst : bool = not_bool(postindex) & offset < 0;
              Mem_set__2(address, 2 * dbytes, accdesc, ispair, highestAddressfirst) = full_data
          } else {
              if not_bool(postindex) & offset < 0 then {
                  Mem_set(address + dbytes, dbytes, accdesc) = data2;
                  Mem_set(address + 0, dbytes, accdesc) = data1
              } else {
                  Mem_set(address + 0, dbytes, accdesc) = data1;
                  Mem_set(address + dbytes, dbytes, accdesc) = data2
              }
          }
      },
      MemOp_LOAD => {
          if HaveLSE2Ext() then {
              let ispair : bool = true;
              let full_data : bits(2 * 'datasize) = Mem_read__1(address, 2 * dbytes, accdesc, ispair);
              if BigEndian(accdesc.acctype) then {
                  data2 = full_data[datasize - 1 .. 0];
                  data1 = full_data[2 * datasize - 1 .. datasize]
              } else {
                  data1 = full_data[datasize - 1 .. 0];
                  data2 = full_data[2 * datasize - 1 .. datasize]
              }
          } else {
              data1 = Mem_read(address + 0, dbytes, accdesc);
              data2 = Mem_read(address + dbytes, dbytes, accdesc)
          };
          if rt_unknown then {
              data1 = __UNKNOWN_bits(datasize);
              data2 = __UNKNOWN_bits(datasize)
          };
          X_set(t, datasize) = data1;
          X_set(t2, datasize) = data2
      },
      _ => ()
    };
    if wback then {
        if wb_unknown then {
            address = __UNKNOWN_bits(64)
        } else if postindex then {
            address = address + offset
        } else ();
        if n == 31 then {
            SP_set() = address
        } else {
            X_set(n, 64) = address
        }
    };
    if SPESampleInFlight then {
        SPESampleGeneralPurposeLoadStore()
    };
    ()
}

val decode_stilp_aarch64_instrs_memory_ordered_pair_stilp : (bits(5), bits(5), bits(4), bits(5), bits(1), bits(2)) -> unit

function decode_stilp_aarch64_instrs_memory_ordered_pair_stilp (Rt, Rn, opc2, Rt2, L, size) = {
    let postindex : bool = false;
    wback : bool = [opc2[0]] == 0b0;
    offset : int = undefined;
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 't2 = UInt(Rt2);
    let 'scale = 2 + UInt([size[0]]);
    let 'datasize = (8 << scale);
    memop : MemOp = undefined;
    if L == 0b1 then {
        memop = MemOp_LOAD;
        offset = if [opc2[0]] == 0b0 then (2 << scale) else 0
    } else {
        memop = MemOp_STORE;
        offset = if [opc2[0]] == 0b0 then negate(1) * (2 << scale) else 0
    };
    let 'offset = offset;
    let tagchecked : bool = wback | n != 31;
    rt_unknown : bool = false;
    wb_unknown : bool = false;
    if ((memop == MemOp_LOAD & wback) & (t == n | t2 == n)) & n != 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
        assert(c == Constraint_WBSUPPRESS | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_WBSUPPRESS => {
              wback = false
          },
          Constraint_UNKNOWN => {
              wb_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    if ((memop == MemOp_STORE & wback) & (t == n | t2 == n)) & n != 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
        assert(c == Constraint_NONE | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_NONE => {
              rt_unknown = false
          },
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    if memop == MemOp_LOAD & t == t2 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);
        assert(c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    };
    assert(constraint('datasize in {32, 64}));
    execute_aarch64_instrs_memory_ordered_pair_stilp(datasize, memop, n, offset, postindex, rt_unknown, t, t2, tagchecked, wb_unknown, wback)
}

function clause __DecodeA64_LoadStore ((pc, ([bitone, _, bitzero, bitone, bitone, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, _, _, _, _, _, bitzero, bitzero, bitzero, _, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 982) = {
    SEE = 982;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let opc2 = Slice(__opcode, 12, 4);
    let Rt2 = Slice(__opcode, 16, 5);
    let L = Slice(__opcode, 22, 1);
    let size = Slice(__opcode, 30, 2);
    decode_stilp_aarch64_instrs_memory_ordered_pair_stilp(Rt, Rn, opc2, Rt2, L, size)
}

val execute_aarch64_instrs_integer_tags_mcsettagpairandzerodatapost : forall 'n ('postindex : Bool) 't ('writeback : Bool) ('zero_data : Bool),
  (0 <= 't & 't <= 31 & 0 <= 'n & 'n <= 31).
  (int('n), bits(64), bool('postindex), int('t), bool('writeback), bool('zero_data)) -> unit

function execute_aarch64_instrs_integer_tags_mcsettagpairandzerodatapost (n, offset, postindex, t, writeback, zero_data) = {
    address : bits(64) = undefined;
    let data : bits(64) = if t == 31 then SP_read() else X_read(t, 64);
    let tag : bits(4) = AArch64_AllocationTagFromAddress(data);
    if n == 31 then {
        CheckSPAlignment();
        address = SP_read()
    } else {
        address = X_read(n, 64)
    };
    if not_bool(postindex) then {
        address = address + offset
    };
    let accdesc : AccessDescriptor = CreateAccDescLDGSTG(MemOp_STORE);
    if zero_data then {
        if not_bool(IsAligned__1(address, TAG_GRANULE)) then {
            AArch64_Abort(address, AlignmentFault(accdesc))
        };
        Mem_set(address, TAG_GRANULE, accdesc) = Zeros(TAG_GRANULE * 8);
        Mem_set(address + TAG_GRANULE, TAG_GRANULE, accdesc) = Zeros(TAG_GRANULE * 8)
    };
    AArch64_MemTag_set(address, accdesc) = tag;
    AArch64_MemTag_set(address + TAG_GRANULE, accdesc) = tag;
    if writeback then {
        if postindex then {
            address = address + offset
        };
        if n == 31 then {
            SP_set() = address
        } else {
            X_set(n, 64) = address
        }
    };
    ()
}

val decode_stz2g_aarch64_instrs_integer_tags_mcsettagpairandzerodatapost : (bits(5), bits(5), bits(9)) -> unit

function decode_stz2g_aarch64_instrs_integer_tags_mcsettagpairandzerodatapost (Xt, Xn, imm9) = {
    if not_bool(HaveMTEExt()) then {
        throw(Error_Undefined())
    };
    let 'n = UInt(Xn);
    let 't = UInt(Xt);
    let offset : bits(64) = LSL(SignExtend(imm9, 64), LOG2_TAG_GRANULE);
    let writeback : bool = true;
    let postindex : bool = true;
    let zero_data : bool = true;
    execute_aarch64_instrs_integer_tags_mcsettagpairandzerodatapost(n, offset, postindex, t, writeback, zero_data)
}

function clause __DecodeA64_LoadStore ((pc, ([bitone, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 983) = {
    SEE = 983;
    let Xt = Slice(__opcode, 0, 5);
    let Xn = Slice(__opcode, 5, 5);
    let imm9 = Slice(__opcode, 12, 9);
    decode_stz2g_aarch64_instrs_integer_tags_mcsettagpairandzerodatapost(Xt, Xn, imm9)
}

val decode_stz2g_aarch64_instrs_integer_tags_mcsettagpairandzerodatapre : (bits(5), bits(5), bits(9)) -> unit

function decode_stz2g_aarch64_instrs_integer_tags_mcsettagpairandzerodatapre (Xt, Xn, imm9) = {
    if not_bool(HaveMTEExt()) then {
        throw(Error_Undefined())
    };
    let 'n = UInt(Xn);
    let 't = UInt(Xt);
    let offset : bits(64) = LSL(SignExtend(imm9, 64), LOG2_TAG_GRANULE);
    let writeback : bool = true;
    let postindex : bool = false;
    let zero_data : bool = true;
    execute_aarch64_instrs_integer_tags_mcsettagpairandzerodatapost(n, offset, postindex, t, writeback, zero_data)
}

function clause __DecodeA64_LoadStore ((pc, ([bitone, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 984) = {
    SEE = 984;
    let Xt = Slice(__opcode, 0, 5);
    let Xn = Slice(__opcode, 5, 5);
    let imm9 = Slice(__opcode, 12, 9);
    decode_stz2g_aarch64_instrs_integer_tags_mcsettagpairandzerodatapre(Xt, Xn, imm9)
}

val decode_stz2g_aarch64_instrs_integer_tags_mcsettagpairandzerodata : (bits(5), bits(5), bits(9)) -> unit

function decode_stz2g_aarch64_instrs_integer_tags_mcsettagpairandzerodata (Xt, Xn, imm9) = {
    if not_bool(HaveMTEExt()) then {
        throw(Error_Undefined())
    };
    let 'n = UInt(Xn);
    let 't = UInt(Xt);
    let offset : bits(64) = LSL(SignExtend(imm9, 64), LOG2_TAG_GRANULE);
    let writeback : bool = false;
    let postindex : bool = false;
    let zero_data : bool = true;
    execute_aarch64_instrs_integer_tags_mcsettagpairandzerodatapost(n, offset, postindex, t, writeback, zero_data)
}

function clause __DecodeA64_LoadStore ((pc, ([bitone, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 985) = {
    SEE = 985;
    let Xt = Slice(__opcode, 0, 5);
    let Xn = Slice(__opcode, 5, 5);
    let imm9 = Slice(__opcode, 12, 9);
    decode_stz2g_aarch64_instrs_integer_tags_mcsettagpairandzerodata(Xt, Xn, imm9)
}

val execute_aarch64_instrs_integer_tags_mcsettagandzerodatapost : forall 'n ('postindex : Bool) 't ('writeback : Bool) ('zero_data : Bool),
  (0 <= 't & 't <= 31 & 0 <= 'n & 'n <= 31).
  (int('n), bits(64), bool('postindex), int('t), bool('writeback), bool('zero_data)) -> unit

function execute_aarch64_instrs_integer_tags_mcsettagandzerodatapost (n, offset, postindex, t, writeback, zero_data) = {
    address : bits(64) = undefined;
    if n == 31 then {
        CheckSPAlignment();
        address = SP_read()
    } else {
        address = X_read(n, 64)
    };
    if not_bool(postindex) then {
        address = address + offset
    };
    let accdesc : AccessDescriptor = CreateAccDescLDGSTG(MemOp_STORE);
    if zero_data then {
        if not_bool(IsAligned__1(address, TAG_GRANULE)) then {
            AArch64_Abort(address, AlignmentFault(accdesc))
        };
        Mem_set(address, TAG_GRANULE, accdesc) = Zeros(TAG_GRANULE * 8)
    };
    let data : bits(64) = if t == 31 then SP_read() else X_read(t, 64);
    let tag : bits(4) = AArch64_AllocationTagFromAddress(data);
    AArch64_MemTag_set(address, accdesc) = tag;
    if writeback then {
        if postindex then {
            address = address + offset
        };
        if n == 31 then {
            SP_set() = address
        } else {
            X_set(n, 64) = address
        }
    };
    ()
}

val decode_stzg_aarch64_instrs_integer_tags_mcsettagandzerodatapost : (bits(5), bits(5), bits(9)) -> unit

function decode_stzg_aarch64_instrs_integer_tags_mcsettagandzerodatapost (Xt, Xn, imm9) = {
    if not_bool(HaveMTEExt()) then {
        throw(Error_Undefined())
    };
    let 'n = UInt(Xn);
    let 't = UInt(Xt);
    let offset : bits(64) = LSL(SignExtend(imm9, 64), LOG2_TAG_GRANULE);
    let writeback : bool = true;
    let postindex : bool = true;
    let zero_data : bool = true;
    execute_aarch64_instrs_integer_tags_mcsettagandzerodatapost(n, offset, postindex, t, writeback, zero_data)
}

function clause __DecodeA64_LoadStore ((pc, ([bitone, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitone, bitzero, bitone, bitone, _, _, _, _, _, _, _, _, _, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 986) = {
    SEE = 986;
    let Xt = Slice(__opcode, 0, 5);
    let Xn = Slice(__opcode, 5, 5);
    let imm9 = Slice(__opcode, 12, 9);
    decode_stzg_aarch64_instrs_integer_tags_mcsettagandzerodatapost(Xt, Xn, imm9)
}

val decode_stzg_aarch64_instrs_integer_tags_mcsettagandzerodatapre : (bits(5), bits(5), bits(9)) -> unit

function decode_stzg_aarch64_instrs_integer_tags_mcsettagandzerodatapre (Xt, Xn, imm9) = {
    if not_bool(HaveMTEExt()) then {
        throw(Error_Undefined())
    };
    let 'n = UInt(Xn);
    let 't = UInt(Xt);
    let offset : bits(64) = LSL(SignExtend(imm9, 64), LOG2_TAG_GRANULE);
    let writeback : bool = true;
    let postindex : bool = false;
    let zero_data : bool = true;
    execute_aarch64_instrs_integer_tags_mcsettagandzerodatapost(n, offset, postindex, t, writeback, zero_data)
}

function clause __DecodeA64_LoadStore ((pc, ([bitone, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitone, bitzero, bitone, bitone, _, _, _, _, _, _, _, _, _, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 987) = {
    SEE = 987;
    let Xt = Slice(__opcode, 0, 5);
    let Xn = Slice(__opcode, 5, 5);
    let imm9 = Slice(__opcode, 12, 9);
    decode_stzg_aarch64_instrs_integer_tags_mcsettagandzerodatapre(Xt, Xn, imm9)
}

val decode_stzg_aarch64_instrs_integer_tags_mcsettagandzerodata : (bits(5), bits(5), bits(9)) -> unit

function decode_stzg_aarch64_instrs_integer_tags_mcsettagandzerodata (Xt, Xn, imm9) = {
    if not_bool(HaveMTEExt()) then {
        throw(Error_Undefined())
    };
    let 'n = UInt(Xn);
    let 't = UInt(Xt);
    let offset : bits(64) = LSL(SignExtend(imm9, 64), LOG2_TAG_GRANULE);
    let writeback : bool = false;
    let postindex : bool = false;
    let zero_data : bool = true;
    execute_aarch64_instrs_integer_tags_mcsettagandzerodatapost(n, offset, postindex, t, writeback, zero_data)
}

function clause __DecodeA64_LoadStore ((pc, ([bitone, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitone, bitzero, bitone, bitone, _, _, _, _, _, _, _, _, _, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 988) = {
    SEE = 988;
    let Xt = Slice(__opcode, 0, 5);
    let Xn = Slice(__opcode, 5, 5);
    let imm9 = Slice(__opcode, 12, 9);
    decode_stzg_aarch64_instrs_integer_tags_mcsettagandzerodata(Xt, Xn, imm9)
}

val execute_aarch64_instrs_integer_tags_mcsettagandzeroarray : forall 'n 't,
  (0 <= 't & 't <= 31 & 0 <= 'n & 'n <= 31).
  (int('n), int('t)) -> unit

function execute_aarch64_instrs_integer_tags_mcsettagandzeroarray (n, t) = {
    if PSTATE.EL == EL0 then {
        throw(Error_Undefined())
    };
    let data : bits(64) = X_read(t, 64);
    let tag : bits(4) = data[3 .. 0];
    address : bits(64) = undefined;
    if n == 31 then {
        CheckSPAlignment();
        address = SP_read()
    } else {
        address = X_read(n, 64)
    };
    let 'size = 4 * pow2(UInt(DCZID_EL0[BS]));
    address : bits(64) = Align(address, size);
    let 'count = (size >> LOG2_TAG_GRANULE);
    let accdesc : AccessDescriptor = CreateAccDescLDGSTG(MemOp_STORE);
    foreach (i from 0 to (count - 1) by 1 in inc) {
        AArch64_MemTag_set(address, accdesc) = tag;
        Mem_set(address, TAG_GRANULE, accdesc) = Zeros(8 * TAG_GRANULE);
        address = address + TAG_GRANULE
    }
}

val decode_stzgm_aarch64_instrs_integer_tags_mcsettagandzeroarray : (bits(5), bits(5)) -> unit

function decode_stzgm_aarch64_instrs_integer_tags_mcsettagandzeroarray (Xt, Xn) = {
    if not_bool(HaveMTE2Ext()) then {
        throw(Error_Undefined())
    };
    let 't = UInt(Xt);
    let 'n = UInt(Xn);
    execute_aarch64_instrs_integer_tags_mcsettagandzeroarray(n, t)
}

function clause __DecodeA64_LoadStore ((pc, ([bitone, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitone, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 989) = {
    SEE = 989;
    let Xt = Slice(__opcode, 0, 5);
    let Xn = Slice(__opcode, 5, 5);
    decode_stzgm_aarch64_instrs_integer_tags_mcsettagandzeroarray(Xt, Xn)
}

val execute_aarch64_instrs_integer_tags_mcsubtag : forall ('ADD : Bool) 'd 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'd & 'd <= 31).
  (bool('ADD), int('d), int('n), bits(64), bits(4)) -> unit

function execute_aarch64_instrs_integer_tags_mcsubtag (ADD, d, n, offset, tag_offset) = {
    let operand1 : bits(64) = if n == 31 then SP_read() else X_read(n, 64);
    let start_tag : bits(4) = AArch64_AllocationTagFromAddress(operand1);
    let exclude : bits(16) = GCR_EL1[Exclude];
    result : bits(64) = undefined;
    rtag : bits(4) = undefined;
    if AArch64_AllocationTagAccessIsEnabled(PSTATE.EL) then {
        rtag = AArch64_ChooseNonExcludedTag(start_tag, tag_offset, exclude)
    } else {
        rtag = 0b0000
    };
    if ADD then {
        let (__tup_0 : bits(64), _) = AddWithCarry(operand1, offset, 0b0);
        result = __tup_0
    } else {
        let (__tup_0 : bits(64), _) = AddWithCarry(operand1, not_vec(offset), 0b1);
        result = __tup_0
    };
    let result : bits(64) = AArch64_AddressWithAllocationTag(result, rtag);
    if d == 31 then {
        SP_set() = result
    } else {
        X_set(d, 64) = result
    }
}

val decode_subg_aarch64_instrs_integer_tags_mcsubtag : (bits(5), bits(5), bits(4), bits(2), bits(6)) -> unit

function decode_subg_aarch64_instrs_integer_tags_mcsubtag (Xd, Xn, uimm4, op3, uimm6) = {
    if not_bool(HaveMTEExt()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Xd);
    let 'n = UInt(Xn);
    let tag_offset : bits(4) = uimm4;
    let offset : bits(64) = LSL(ZeroExtend(uimm6, 64), LOG2_TAG_GRANULE);
    let ADD : bool = false;
    execute_aarch64_instrs_integer_tags_mcsubtag(ADD, d, n, offset, tag_offset)
}

function clause __DecodeA64_DataProcImm ((pc, ([bitone, bitone, bitzero, bitone, bitzero, bitzero, bitzero, bitone, bitone, bitzero, _, _, _, _, _, _, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 990) = {
    SEE = 990;
    let Xd = Slice(__opcode, 0, 5);
    let Xn = Slice(__opcode, 5, 5);
    let uimm4 = Slice(__opcode, 10, 4);
    let op3 = Slice(__opcode, 14, 2);
    let uimm6 = Slice(__opcode, 16, 6);
    if [__opcode[14]] != 0b0 | [__opcode[15]] != 0b0 then {
        throw(Error_ConstrainedUnpredictable())
    } else {
        decode_subg_aarch64_instrs_integer_tags_mcsubtag(Xd, Xn, uimm4, op3, uimm6)
    }
}

val execute_aarch64_instrs_integer_arithmetic_pointer_mcsubtracttaggedaddress : forall 'd 'm 'n ('setflags : Bool),
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 0 <= 'd & 'd <= 31).
  (int('d), int('m), int('n), bool('setflags)) -> unit

function execute_aarch64_instrs_integer_arithmetic_pointer_mcsubtracttaggedaddress (d, m, n, setflags) = {
    operand1 : bits(64) = if n == 31 then SP_read() else X_read(n, 64);
    operand2 : bits(64) = if m == 31 then SP_read() else X_read(m, 64);
    let operand1 : bits(64) = SignExtend(operand1[55 .. 0], 64);
    operand2 : bits(64) = SignExtend(operand2[55 .. 0], 64);
    result : bits(64) = undefined;
    nzcv : bits(4) = undefined;
    let operand2 : bits(64) = not_vec(operand2);
    (result, nzcv) = AddWithCarry(operand1, operand2, 0b1);
    if setflags then {
        (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V) = nzcv
    };
    X_set(d, 64) = result
}

val decode_subp_aarch64_instrs_integer_arithmetic_pointer_mcsubtracttaggedaddress : (bits(5), bits(5), bits(5)) -> unit

function decode_subp_aarch64_instrs_integer_arithmetic_pointer_mcsubtracttaggedaddress (Xd, Xn, Xm) = {
    if not_bool(HaveMTEExt()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Xd);
    let 'n = UInt(Xn);
    let 'm = UInt(Xm);
    let setflags : bool = false;
    execute_aarch64_instrs_integer_arithmetic_pointer_mcsubtracttaggedaddress(d, m, n, setflags)
}

function clause __DecodeA64_DataProcReg ((pc, ([bitone, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 991) = {
    SEE = 991;
    let Xd = Slice(__opcode, 0, 5);
    let Xn = Slice(__opcode, 5, 5);
    let Xm = Slice(__opcode, 16, 5);
    decode_subp_aarch64_instrs_integer_arithmetic_pointer_mcsubtracttaggedaddress(Xd, Xn, Xm)
}

val execute_aarch64_instrs_integer_arithmetic_pointer_mcsubtracttaggedaddresssetflags : forall 'd 'm 'n ('setflags : Bool),
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 0 <= 'd & 'd <= 31).
  (int('d), int('m), int('n), bool('setflags)) -> unit

function execute_aarch64_instrs_integer_arithmetic_pointer_mcsubtracttaggedaddresssetflags (d, m, n, setflags) = {
    operand1 : bits(64) = if n == 31 then SP_read() else X_read(n, 64);
    operand2 : bits(64) = if m == 31 then SP_read() else X_read(m, 64);
    let operand1 : bits(64) = SignExtend(operand1[55 .. 0], 64);
    operand2 : bits(64) = SignExtend(operand2[55 .. 0], 64);
    result : bits(64) = undefined;
    nzcv : bits(4) = undefined;
    let operand2 : bits(64) = not_vec(operand2);
    (result, nzcv) = AddWithCarry(operand1, operand2, 0b1);
    if setflags then {
        (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V) = nzcv
    };
    X_set(d, 64) = result
}

val decode_subps_aarch64_instrs_integer_arithmetic_pointer_mcsubtracttaggedaddresssetflags : (bits(5), bits(5), bits(5)) -> unit

function decode_subps_aarch64_instrs_integer_arithmetic_pointer_mcsubtracttaggedaddresssetflags (Xd, Xn, Xm) = {
    if not_bool(HaveMTEExt()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Xd);
    let 'n = UInt(Xn);
    let 'm = UInt(Xm);
    let setflags : bool = true;
    execute_aarch64_instrs_integer_arithmetic_pointer_mcsubtracttaggedaddresssetflags(d, m, n, setflags)
}

function clause __DecodeA64_DataProcReg ((pc, ([bitone, bitzero, bitone, bitone, bitone, bitzero, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 992) = {
    SEE = 992;
    let Xd = Slice(__opcode, 0, 5);
    let Xn = Slice(__opcode, 5, 5);
    let Xm = Slice(__opcode, 16, 5);
    decode_subps_aarch64_instrs_integer_arithmetic_pointer_mcsubtracttaggedaddresssetflags(Xd, Xn, Xm)
}

val execute_aarch64_instrs_vector_arithmetic_binary_element_mat_mul_int_dotp : forall 'd 'datasize 'elements 'i 'm 'n ('op1_unsigned : Bool) ('op2_unsigned : Bool),
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'i in {0, 1, 2, 3} & 'elements in {2, 4} & 'datasize in {64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('i), int('m), int('n), bool('op1_unsigned), bool('op2_unsigned)) -> unit

function execute_aarch64_instrs_vector_arithmetic_binary_element_mat_mul_int_dotp (d, datasize, elements, i, m, n, op1_unsigned, op2_unsigned) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = V_read(n, datasize);
    let operand2 : bits(128) = V_read(m, 128);
    let operand3 : bits('datasize) = V_read(d, datasize);
    result : bits('datasize) = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        res : bits(32) = Elem_read(operand3, e, 32);
        foreach (b from 0 to 3 by 1 in inc) {
            let 'element1 = asl_Int(Elem_read(operand1, 4 * e + b, 8), op1_unsigned);
            let 'element2 = asl_Int(Elem_read(operand2, 4 * i + b, 8), op2_unsigned);
            res = res + element1 * element2
        };
        result = Elem_set(result, e, 32, res)
    };
    V_set(d, datasize) = result
}

val decode_sudot_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mat_mul_int_dotp : (bits(5), bits(5), bits(1), bits(4), bits(1), bits(1), bits(1), bits(1)) -> unit

function decode_sudot_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mat_mul_int_dotp (Rd, Rn, H, Rm, M, L, US, Q) = {
    if not_bool(HaveInt8MatMulExt()) then {
        throw(Error_Undefined())
    };
    let op1_unsigned : bool = US == 0b1;
    let op2_unsigned : bool = US == 0b0;
    let 'n = UInt(Rn);
    let 'm = UInt(M @ Rm);
    let 'd = UInt(Rd);
    let 'i = UInt(H @ L);
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, 32);
    execute_aarch64_instrs_vector_arithmetic_binary_element_mat_mul_int_dotp(d, datasize, elements, i, m, n, op1_unsigned, op2_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, _, _, _, _, _, _, bitone, bitone, bitone, bitone, _, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 993) = {
    SEE = 993;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let H = Slice(__opcode, 11, 1);
    let Rm = Slice(__opcode, 16, 4);
    let M = Slice(__opcode, 20, 1);
    let L = Slice(__opcode, 21, 1);
    let US = Slice(__opcode, 23, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_sudot_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mat_mul_int_dotp(Rd, Rn, H, Rm, M, L, US, Q)
}

val decode_usdot_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mat_mul_int_dotp : (bits(5), bits(5), bits(1), bits(4), bits(1), bits(1), bits(1), bits(1)) -> unit

function decode_usdot_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mat_mul_int_dotp (Rd, Rn, H, Rm, M, L, US, Q) = {
    if not_bool(HaveInt8MatMulExt()) then {
        throw(Error_Undefined())
    };
    let op1_unsigned : bool = US == 0b1;
    let op2_unsigned : bool = US == 0b0;
    let 'n = UInt(Rn);
    let 'm = UInt(M @ Rm);
    let 'd = UInt(Rd);
    let 'i = UInt(H @ L);
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, 32);
    execute_aarch64_instrs_vector_arithmetic_binary_element_mat_mul_int_dotp(d, datasize, elements, i, m, n, op1_unsigned, op2_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, bitone, bitone, bitone, bitone, _, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 994) = {
    SEE = 994;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let H = Slice(__opcode, 11, 1);
    let Rm = Slice(__opcode, 16, 4);
    let M = Slice(__opcode, 20, 1);
    let L = Slice(__opcode, 21, 1);
    let US = Slice(__opcode, 23, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_usdot_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mat_mul_int_dotp(Rd, Rn, H, Rm, M, L, US, Q)
}

val execute_aarch64_instrs_vector_arithmetic_unary_add_saturating_sisd : forall 'd 'datasize 'elements 'esize ('is_unsigned : Bool) 'n,
  (0 <= 'n & 'n <= 31 & 'esize in {8, 16, 32, 64} & 'datasize in {8, 16, 32, 64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('n), bool('is_unsigned)) -> unit

function execute_aarch64_instrs_vector_arithmetic_unary_add_saturating_sisd (d, datasize, elements, esize, n, is_unsigned) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('datasize) = V_read(n, datasize);
    result : bits('datasize) = undefined;
    let operand2 : bits('datasize) = V_read(d, datasize);
    op1 : int = undefined;
    op2 : int = undefined;
    sat : bool = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        op1 = asl_Int(Elem_read(operand, e, esize), not_bool(is_unsigned));
        op2 = asl_Int(Elem_read(operand2, e, esize), is_unsigned);
        let (__tup_0 : bits('esize), __tup_1 : bool) =
          SatQ(op1 + op2, esize, is_unsigned)
        in
          {
              result = Elem_set(result, e, esize, __tup_0);
              sat = __tup_1
          };
        if sat then {
            FPSR[QC] = 0b1
        };
        ()
    };
    V_set(d, datasize) = result
}

val decode_suqadd_advsimd_aarch64_instrs_vector_arithmetic_unary_add_saturating_sisd : (bits(5), bits(5), bits(2), bits(1)) -> unit

function decode_suqadd_advsimd_aarch64_instrs_vector_arithmetic_unary_add_saturating_sisd (Rd, Rn, size, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = (8 << UInt(size));
    let 'datasize = esize;
    let 'elements = 1;
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_add_saturating_sisd(d, datasize, elements, esize, n, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 995) = {
    SEE = 995;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    decode_suqadd_advsimd_aarch64_instrs_vector_arithmetic_unary_add_saturating_sisd(Rd, Rn, size, U)
}

val decode_suqadd_advsimd_aarch64_instrs_vector_arithmetic_unary_add_saturating_simd : (bits(5), bits(5), bits(2), bits(1), bits(1)) -> unit

function decode_suqadd_advsimd_aarch64_instrs_vector_arithmetic_unary_add_saturating_simd (Rd, Rn, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (size @ Q) == 0b110 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_add_saturating_sisd(d, datasize, elements, esize, n, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 996) = {
    SEE = 996;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_suqadd_advsimd_aarch64_instrs_vector_arithmetic_unary_add_saturating_simd(Rd, Rn, size, U, Q)
}

val decode_usqadd_advsimd_aarch64_instrs_vector_arithmetic_unary_add_saturating_sisd : (bits(5), bits(5), bits(2), bits(1)) -> unit

function decode_usqadd_advsimd_aarch64_instrs_vector_arithmetic_unary_add_saturating_sisd (Rd, Rn, size, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = (8 << UInt(size));
    let 'datasize = esize;
    let 'elements = 1;
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_add_saturating_sisd(d, datasize, elements, esize, n, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 997) = {
    SEE = 997;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    decode_usqadd_advsimd_aarch64_instrs_vector_arithmetic_unary_add_saturating_sisd(Rd, Rn, size, U)
}

val decode_usqadd_advsimd_aarch64_instrs_vector_arithmetic_unary_add_saturating_simd : (bits(5), bits(5), bits(2), bits(1), bits(1)) -> unit

function decode_usqadd_advsimd_aarch64_instrs_vector_arithmetic_unary_add_saturating_simd (Rd, Rn, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (size @ Q) == 0b110 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_add_saturating_sisd(d, datasize, elements, esize, n, is_unsigned)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 998) = {
    SEE = 998;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_usqadd_advsimd_aarch64_instrs_vector_arithmetic_unary_add_saturating_simd(Rd, Rn, size, U, Q)
}

val execute_aarch64_instrs_system_exceptions_runtime_svc : bits(16) -> unit

function execute_aarch64_instrs_system_exceptions_runtime_svc imm = {
    AArch64_CheckForSVCTrap(imm);
    AArch64_CallSupervisor(imm)
}

val decode_svc_aarch64_instrs_system_exceptions_runtime_svc : bits(16) -> unit

function decode_svc_aarch64_instrs_system_exceptions_runtime_svc imm16 = {
    let imm : bits(16) = imm16;
    execute_aarch64_instrs_system_exceptions_runtime_svc(imm)
}

function clause __DecodeA64_BranchExcSys ((pc, ([bitone, bitone, bitzero, bitone, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, bitzero, bitzero, bitzero, bitzero, bitone] as __opcode)) if SEE < 999) = {
    SEE = 999;
    let imm16 = Slice(__opcode, 5, 16);
    decode_svc_aarch64_instrs_system_exceptions_runtime_svc(imm16)
}

val execute_aarch64_instrs_memory_atomicops_swp : forall ('acquire : Bool) 'datasize 'n 'regsize ('release : Bool) 's 't ('tagchecked : Bool),
  (0 <= 't & 't <= 31 & 0 <= 's & 's <= 31 & 'regsize in {32, 64} & 0 <= 'n & 'n <= 31 & 'datasize in {8, 16, 32, 64}).
  (bool('acquire), int('datasize), int('n), int('regsize), bool('release), int('s), int('t), bool('tagchecked)) -> unit

function execute_aarch64_instrs_memory_atomicops_swp (acquire, datasize, n, regsize, release, s, t, tagchecked) = {
    address : bits(64) = undefined;
    let accdesc : AccessDescriptor = CreateAccDescAtomicOp(MemAtomicOp_SWP, acquire, release, tagchecked);
    if n == 31 then {
        CheckSPAlignment();
        address = SP_read()
    } else {
        address = X_read(n, 64)
    };
    let store_value : bits('datasize) = X_read(s, datasize);
    let comparevalue : bits('datasize) = __UNKNOWN_bits(datasize);
    let data : bits('datasize) = MemAtomic(address, comparevalue, store_value, accdesc);
    assert(constraint('regsize >= 'datasize));
    X_set(t, regsize) = ZeroExtend(data, regsize);
    if SPESampleInFlight then {
        let ar : bits(1) = if acquire | release then 0b1 else 0b0;
        let excl : bits(1) = 0b0;
        let at : bits(1) = 0b1;
        let is_load : bool = true;
        SPESampleExtendedLoadStore(ar, excl, at, is_load)
    };
    ()
}

val decode_swp_aarch64_instrs_memory_atomicops_swp : (bits(5), bits(5), bits(5), bits(1), bits(1), bits(2)) -> unit

function decode_swp_aarch64_instrs_memory_atomicops_swp (Rt, Rn, Rs, R, A, size) = {
    if not_bool(HaveAtomicExt()) then {
        throw(Error_Undefined())
    };
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 's = UInt(Rs);
    let 'datasize = (8 << UInt(size));
    let 'regsize = if datasize == 64 then 64 else 32;
    let acquire : bool = A == 0b1 & Rt != 0b11111;
    let release : bool = R == 0b1;
    let tagchecked : bool = n != 31;
    execute_aarch64_instrs_memory_atomicops_swp(acquire, datasize, n, regsize, release, s, t, tagchecked)
}

function clause __DecodeA64_LoadStore ((pc, ([bitone, _, bitone, bitone, bitone, bitzero, bitzero, bitzero, _, _, bitone, _, _, _, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 1000) = {
    SEE = 1000;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rs = Slice(__opcode, 16, 5);
    let R = Slice(__opcode, 22, 1);
    let A = Slice(__opcode, 23, 1);
    let size = Slice(__opcode, 30, 2);
    decode_swp_aarch64_instrs_memory_atomicops_swp(Rt, Rn, Rs, R, A, size)
}

val decode_swpb_aarch64_instrs_memory_atomicops_swp : (bits(5), bits(5), bits(5), bits(1), bits(1), bits(2)) -> unit

function decode_swpb_aarch64_instrs_memory_atomicops_swp (Rt, Rn, Rs, R, A, size) = {
    if not_bool(HaveAtomicExt()) then {
        throw(Error_Undefined())
    };
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 's = UInt(Rs);
    let 'datasize = (8 << UInt(size));
    let 'regsize = if datasize == 64 then 64 else 32;
    let acquire : bool = A == 0b1 & Rt != 0b11111;
    let release : bool = R == 0b1;
    let tagchecked : bool = n != 31;
    execute_aarch64_instrs_memory_atomicops_swp(acquire, datasize, n, regsize, release, s, t, tagchecked)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitzero, _, _, bitone, _, _, _, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 1001) = {
    SEE = 1001;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rs = Slice(__opcode, 16, 5);
    let R = Slice(__opcode, 22, 1);
    let A = Slice(__opcode, 23, 1);
    let size = Slice(__opcode, 30, 2);
    decode_swpb_aarch64_instrs_memory_atomicops_swp(Rt, Rn, Rs, R, A, size)
}

val decode_swph_aarch64_instrs_memory_atomicops_swp : (bits(5), bits(5), bits(5), bits(1), bits(1), bits(2)) -> unit

function decode_swph_aarch64_instrs_memory_atomicops_swp (Rt, Rn, Rs, R, A, size) = {
    if not_bool(HaveAtomicExt()) then {
        throw(Error_Undefined())
    };
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 's = UInt(Rs);
    let 'datasize = (8 << UInt(size));
    let 'regsize = if datasize == 64 then 64 else 32;
    let acquire : bool = A == 0b1 & Rt != 0b11111;
    let release : bool = R == 0b1;
    let tagchecked : bool = n != 31;
    execute_aarch64_instrs_memory_atomicops_swp(acquire, datasize, n, regsize, release, s, t, tagchecked)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, _, _, bitone, _, _, _, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 1002) = {
    SEE = 1002;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rs = Slice(__opcode, 16, 5);
    let R = Slice(__opcode, 22, 1);
    let A = Slice(__opcode, 23, 1);
    let size = Slice(__opcode, 30, 2);
    decode_swph_aarch64_instrs_memory_atomicops_swp(Rt, Rn, Rs, R, A, size)
}

val execute_aarch64_instrs_memory_atomicops_swp_128 : forall ('acquire : Bool) 'n ('release : Bool) 't 't2 ('tagchecked : Bool),
  (0 <= 't2 & 't2 <= 31 & 0 <= 't & 't <= 31 & 0 <= 'n & 'n <= 31).
  (bool('acquire), int('n), bool('release), int('t), int('t2), bool('tagchecked)) -> unit

function execute_aarch64_instrs_memory_atomicops_swp_128 (acquire, n, release, t, t2, tagchecked) = {
    address : bits(64) = undefined;
    let value1_name : bits(64) = X_read(t, 64);
    let value2_name : bits(64) = X_read(t2, 64);
    let accdesc : AccessDescriptor = CreateAccDescAtomicOp(MemAtomicOp_SWP, acquire, release, tagchecked);
    if n == 31 then {
        CheckSPAlignment();
        address = SP_read()
    } else {
        address = X_read(n, 64)
    };
    let store_value : bits(128) = if BigEndian(accdesc.acctype) then
      value1_name @ value2_name
    else
      value2_name @ value1_name;
    let comparevalue : bits(128) = __UNKNOWN_bits(128);
    let data : bits(128) = MemAtomic(address, comparevalue, store_value, accdesc);
    if BigEndian(accdesc.acctype) then {
        X_set(t, 64) = data[127 .. 64];
        X_set(t2, 64) = data[63 .. 0]
    } else {
        X_set(t, 64) = data[63 .. 0];
        X_set(t2, 64) = data[127 .. 64]
    }
}

val decode_swpp_aarch64_instrs_memory_atomicops_swp_128 : (bits(5), bits(5), bits(3), bits(1), bits(5), bits(1), bits(1), bits(1)) -> unit

function decode_swpp_aarch64_instrs_memory_atomicops_swp_128 (Rt, Rn, opc, o3, Rt2, R, A, S) = {
    if not_bool(HaveLSE128()) then {
        throw(Error_Undefined())
    };
    if Rt == 0b11111 then {
        throw(Error_Undefined())
    };
    if Rt2 == 0b11111 then {
        throw(Error_Undefined())
    };
    let 't = UInt(Rt);
    let 't2 = UInt(Rt2);
    let 'n = UInt(Rn);
    let acquire : bool = A == 0b1;
    let release : bool = R == 0b1;
    let tagchecked : bool = n != 31;
    execute_aarch64_instrs_memory_atomicops_swp_128(acquire, n, release, t, t2, tagchecked)
}

function clause __DecodeA64_LoadStore ((pc, ([bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitone, _, _, bitone, _, _, _, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 1003) = {
    SEE = 1003;
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let opc = Slice(__opcode, 12, 3);
    let o3 = Slice(__opcode, 15, 1);
    let Rt2 = Slice(__opcode, 16, 5);
    let R = Slice(__opcode, 22, 1);
    let A = Slice(__opcode, 23, 1);
    let S = Slice(__opcode, 30, 1);
    decode_swpp_aarch64_instrs_memory_atomicops_swp_128(Rt, Rn, opc, o3, Rt2, R, A, S)
}

val execute_aarch64_instrs_system_sysops : forall ('has_result : Bool) 'sys_crm 'sys_crn 'sys_op0 'sys_op1 'sys_op2 't,
  (0 <= 't & 't <= 31 & 'sys_op2 in {0, 1, 2, 3, 4, 5, 6, 7} & 'sys_op1 in {0, 1, 2, 3, 4, 5, 6, 7} & 'sys_op0 == 1 & 0 <= 'sys_crn & 'sys_crn <= 15 & 0 <= 'sys_crm & 'sys_crm <= 15).
  (bool('has_result), int('sys_crm), int('sys_crn), int('sys_op0), int('sys_op1), int('sys_op2), int('t)) -> unit

function execute_aarch64_instrs_system_sysops (has_result, sys_crm, sys_crn, sys_op0, sys_op1, sys_op2, t) = {
    if has_result then {
        AArch64_SysInstrWithResult(sys_op0, sys_op1, sys_crn, sys_crm, sys_op2, t)
    } else {
        AArch64_SysInstr(sys_op0, sys_op1, sys_crn, sys_crm, sys_op2, t)
    }
}

val decode_sys_aarch64_instrs_system_sysops : (bits(5), bits(3), bits(4), bits(4), bits(3), bits(1)) -> unit

function decode_sys_aarch64_instrs_system_sysops (Rt, op2, CRm, CRn, op1, L) = {
    AArch64_CheckSystemAccess(0b01, op1, CRn, CRm, op2, Rt, L);
    let 't = UInt(Rt);
    let 'sys_op0 = 1;
    let 'sys_op1 = UInt(op1);
    let 'sys_op2 = UInt(op2);
    let 'sys_crn = UInt(CRn);
    let 'sys_crm = UInt(CRm);
    let has_result : bool = L == 0b1;
    execute_aarch64_instrs_system_sysops(has_result, sys_crm, sys_crn, sys_op0, sys_op1, sys_op2, t)
}

function clause __DecodeA64_BranchExcSys ((pc, ([bitone, bitone, bitzero, bitone, bitzero, bitone, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 1004) = {
    SEE = 1004;
    let Rt = Slice(__opcode, 0, 5);
    let op2 = Slice(__opcode, 5, 3);
    let CRm = Slice(__opcode, 8, 4);
    let CRn = Slice(__opcode, 12, 4);
    let op1 = Slice(__opcode, 16, 3);
    let L = Slice(__opcode, 21, 1);
    decode_sys_aarch64_instrs_system_sysops(Rt, op2, CRm, CRn, op1, L)
}

val decode_sysl_aarch64_instrs_system_sysops : (bits(5), bits(3), bits(4), bits(4), bits(3), bits(1)) -> unit

function decode_sysl_aarch64_instrs_system_sysops (Rt, op2, CRm, CRn, op1, L) = {
    AArch64_CheckSystemAccess(0b01, op1, CRn, CRm, op2, Rt, L);
    let 't = UInt(Rt);
    let 'sys_op0 = 1;
    let 'sys_op1 = UInt(op1);
    let 'sys_op2 = UInt(op2);
    let 'sys_crn = UInt(CRn);
    let 'sys_crm = UInt(CRm);
    let has_result : bool = L == 0b1;
    execute_aarch64_instrs_system_sysops(has_result, sys_crm, sys_crn, sys_op0, sys_op1, sys_op2, t)
}

function clause __DecodeA64_BranchExcSys ((pc, ([bitone, bitone, bitzero, bitone, bitzero, bitone, bitzero, bitone, bitzero, bitzero, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 1005) = {
    SEE = 1005;
    let Rt = Slice(__opcode, 0, 5);
    let op2 = Slice(__opcode, 5, 3);
    let CRm = Slice(__opcode, 8, 4);
    let CRn = Slice(__opcode, 12, 4);
    let op1 = Slice(__opcode, 16, 3);
    let L = Slice(__opcode, 21, 1);
    decode_sysl_aarch64_instrs_system_sysops(Rt, op2, CRm, CRn, op1, L)
}

val execute_aarch64_instrs_system_sysops_128 : forall 'sys_crm 'sys_crn 'sys_op0 'sys_op1 'sys_op2 't 't2,
  (1 <= 't2 & 't2 <= 32 & 0 <= 't & 't <= 31 & 'sys_op2 in {0, 1, 2, 3, 4, 5, 6, 7} & 'sys_op1 in {0, 1, 2, 3, 4, 5, 6, 7} & 'sys_op0 == 1 & 0 <= 'sys_crn & 'sys_crn <= 15 & 0 <= 'sys_crm & 'sys_crm <= 15).
  (int('sys_crm), int('sys_crn), int('sys_op0), int('sys_op1), int('sys_op2), int('t), int('t2)) -> unit

function execute_aarch64_instrs_system_sysops_128 (sys_crm, sys_crn, sys_op0, sys_op1, sys_op2, t, t2) = {
    AArch64_SysInstr128(sys_op0, sys_op1, sys_crn, sys_crm, sys_op2, t, t2)
}

val decode_sysp_aarch64_instrs_system_sysops_128 : (bits(5), bits(3), bits(4), bits(4), bits(3), bits(1)) -> unit

function decode_sysp_aarch64_instrs_system_sysops_128 (Rt, op2, CRm, CRn, op1, L) = {
    if not_bool(HaveSysInstr128()) then {
        throw(Error_Undefined())
    };
    if [Rt[0]] == 0b1 & Rt != 0b11111 then {
        throw(Error_Undefined())
    };
    AArch64_CheckSystemAccess(0b01, op1, CRn, CRm, op2, Rt, L);
    let 't = UInt(Rt);
    let 't2 = if t == 31 then 31 else 't + 1;
    let 'sys_op0 = 1;
    let 'sys_op1 = UInt(op1);
    let 'sys_op2 = UInt(op2);
    let 'sys_crn = UInt(CRn);
    let 'sys_crm = UInt(CRm);
    execute_aarch64_instrs_system_sysops_128(sys_crm, sys_crn, sys_op0, sys_op1, sys_op2, t, t2)
}

function clause __DecodeA64_BranchExcSys ((pc, ([bitone, bitone, bitzero, bitone, bitzero, bitone, bitzero, bitone, bitzero, bitone, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 1006) = {
    SEE = 1006;
    let Rt = Slice(__opcode, 0, 5);
    let op2 = Slice(__opcode, 5, 3);
    let CRm = Slice(__opcode, 8, 4);
    let CRn = Slice(__opcode, 12, 4);
    let op1 = Slice(__opcode, 16, 3);
    let L = Slice(__opcode, 21, 1);
    decode_sysp_aarch64_instrs_system_sysops_128(Rt, op2, CRm, CRn, op1, L)
}

val execute_aarch64_instrs_vector_transfer_vector_table : forall 'd 'datasize 'elements ('is_tbl : Bool) 'm 'n 'regs,
  ('regs in {1, 2, 3, 4} & 0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'elements in {8, 16} & 'datasize in {64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), bool('is_tbl), int('m), int('n), int('regs)) -> unit

function execute_aarch64_instrs_vector_transfer_vector_table (d, datasize, elements, is_tbl, m, n__arg, regs) = {
    n : int = n__arg;
    CheckFPAdvSIMDEnabled64();
    let indices : bits('datasize) = V_read(m, datasize);
    table : bits(128 * 'regs) = Zeros(128 * regs);
    index : int = undefined;
    foreach (i from 0 to (regs - 1) by 1 in inc) {
        table[128 * i + 127 .. 128 * i] = V_read(n, 128);
        n = MOD(n + 1, 32)
    };
    result : bits('datasize) = if is_tbl then Zeros(datasize) else
      V_read(d, datasize);
    foreach (i from 0 to (elements - 1) by 1 in inc) {
        index = UInt(Elem_read(indices, i, 8));
        let 'index = index;
        if index < 16 * regs then {
            result = Elem_set(result, i, 8, Elem_read(table, index, 8))
        };
        ()
    };
    V_set(d, datasize) = result
}

val decode_tbl_advsimd_aarch64_instrs_vector_transfer_vector_table : (bits(5), bits(5), bits(1), bits(2), bits(5), bits(1)) -> unit

function decode_tbl_advsimd_aarch64_instrs_vector_transfer_vector_table (Rd, Rn, op, len, Rm, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, 8);
    let 'regs = UInt(len) + 1;
    let is_tbl : bool = op == 0b0;
    execute_aarch64_instrs_vector_transfer_vector_table(d, datasize, elements, is_tbl, m, n, regs)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, bitzero, _, _, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 1007) = {
    SEE = 1007;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 12, 1);
    let len = Slice(__opcode, 13, 2);
    let Rm = Slice(__opcode, 16, 5);
    let Q = Slice(__opcode, 30, 1);
    decode_tbl_advsimd_aarch64_instrs_vector_transfer_vector_table(Rd, Rn, op, len, Rm, Q)
}

val decode_tbx_advsimd_aarch64_instrs_vector_transfer_vector_table : (bits(5), bits(5), bits(1), bits(2), bits(5), bits(1)) -> unit

function decode_tbx_advsimd_aarch64_instrs_vector_transfer_vector_table (Rd, Rn, op, len, Rm, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, 8);
    let 'regs = UInt(len) + 1;
    let is_tbl : bool = op == 0b0;
    execute_aarch64_instrs_vector_transfer_vector_table(d, datasize, elements, is_tbl, m, n, regs)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, bitzero, _, _, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 1008) = {
    SEE = 1008;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 12, 1);
    let len = Slice(__opcode, 13, 2);
    let Rm = Slice(__opcode, 16, 5);
    let Q = Slice(__opcode, 30, 1);
    decode_tbx_advsimd_aarch64_instrs_vector_transfer_vector_table(Rd, Rn, op, len, Rm, Q)
}

val execute_aarch64_instrs_branch_conditional_test : forall 'bit_pos 'datasize 't,
  (0 <= 't & 't <= 31 & 'datasize in {32, 64} & 0 <= 'bit_pos & 'bit_pos <= 63).
  (int('bit_pos), bits(1), int('datasize), bits(64), int('t)) -> unit

function execute_aarch64_instrs_branch_conditional_test (bit_pos, bit_val, datasize, offset, t) = {
    let operand : bits('datasize) = X_read(t, datasize);
    let branch_conditional : bool = true;
    assert(constraint('bit_pos < 'datasize));
    if [operand[bit_pos]] == bit_val then {
        BranchTo(PC_read() + offset, BranchType_DIR, branch_conditional)
    } else {
        BranchNotTaken(BranchType_DIR, branch_conditional)
    }
}

val decode_tbnz_aarch64_instrs_branch_conditional_test : (bits(5), bits(14), bits(5), bits(1), bits(1)) -> unit

function decode_tbnz_aarch64_instrs_branch_conditional_test (Rt, imm14, b40, op, b5) = {
    let 't = UInt(Rt);
    let 'datasize = if b5 == 0b1 then 64 else 32;
    let 'bit_pos = UInt(b5 @ b40);
    let bit_val : bits(1) = op;
    let offset : bits(64) = SignExtend(imm14 @ 0b00, 64);
    execute_aarch64_instrs_branch_conditional_test(bit_pos, bit_val, datasize, offset, t)
}

function clause __DecodeA64_BranchExcSys ((pc, ([_, bitzero, bitone, bitone, bitzero, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 1009) = {
    SEE = 1009;
    let Rt = Slice(__opcode, 0, 5);
    let imm14 = Slice(__opcode, 5, 14);
    let b40 = Slice(__opcode, 19, 5);
    let op = Slice(__opcode, 24, 1);
    let b5 = Slice(__opcode, 31, 1);
    decode_tbnz_aarch64_instrs_branch_conditional_test(Rt, imm14, b40, op, b5)
}

val decode_tbz_aarch64_instrs_branch_conditional_test : (bits(5), bits(14), bits(5), bits(1), bits(1)) -> unit

function decode_tbz_aarch64_instrs_branch_conditional_test (Rt, imm14, b40, op, b5) = {
    let 't = UInt(Rt);
    let 'datasize = if b5 == 0b1 then 64 else 32;
    let 'bit_pos = UInt(b5 @ b40);
    let bit_val : bits(1) = op;
    let offset : bits(64) = SignExtend(imm14 @ 0b00, 64);
    execute_aarch64_instrs_branch_conditional_test(bit_pos, bit_val, datasize, offset, t)
}

function clause __DecodeA64_BranchExcSys ((pc, ([_, bitzero, bitone, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 1010) = {
    SEE = 1010;
    let Rt = Slice(__opcode, 0, 5);
    let imm14 = Slice(__opcode, 5, 14);
    let b40 = Slice(__opcode, 19, 5);
    let op = Slice(__opcode, 24, 1);
    let b5 = Slice(__opcode, 31, 1);
    decode_tbz_aarch64_instrs_branch_conditional_test(Rt, imm14, b40, op, b5)
}

val execute_aarch64_instrs_system_tme_tcancel : forall ('retry : Bool).
  (bits(15), bool('retry)) -> unit

function execute_aarch64_instrs_system_tme_tcancel (reason, retry) = {
    if not_bool(IsTMEEnabled()) then {
        throw(Error_Undefined())
    };
    if TSTATE.depth > 0 then {
        FailTransaction__1(TMFailure_CNCL, retry, false, reason)
    };
    ()
}

val decode_tcancel_aarch64_instrs_system_tme_tcancel : bits(16) -> unit

function decode_tcancel_aarch64_instrs_system_tme_tcancel imm16 = {
    if not_bool(HaveTME()) then {
        throw(Error_Undefined())
    };
    let retry : bool = [imm16[15]] == 0b1;
    let reason : bits(15) = imm16[14 .. 0];
    execute_aarch64_instrs_system_tme_tcancel(reason, retry)
}

function clause __DecodeA64_BranchExcSys ((pc, ([bitone, bitone, bitzero, bitone, bitzero, bitone, bitzero, bitzero, bitzero, bitone, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, bitzero, bitzero, bitzero, bitzero, bitzero] as __opcode)) if SEE < 1011) = {
    SEE = 1011;
    let imm16 = Slice(__opcode, 5, 16);
    decode_tcancel_aarch64_instrs_system_tme_tcancel(imm16)
}

val execute_aarch64_instrs_system_tme_tcommit : unit -> unit

function execute_aarch64_instrs_system_tme_tcommit () = {
    if not_bool(IsTMEEnabled()) then {
        throw(Error_Undefined())
    };
    if TSTATE.depth == 0 then {
        throw(Error_Undefined())
    };
    if TSTATE.depth == 1 then {
        CommitTransactionalWrites();
        ClearExclusiveLocal(ProcessorID())
    };
    TSTATE.depth = TSTATE.depth - 1
}

val decode_tcommit_aarch64_instrs_system_tme_tcommit : unit -> unit

function decode_tcommit_aarch64_instrs_system_tme_tcommit () = {
    if not_bool(HaveTME()) then {
        throw(Error_Undefined())
    };
    execute_aarch64_instrs_system_tme_tcommit()
}

function clause __DecodeA64_BranchExcSys ((pc, (0b11010101000000110011000001111111 as __opcode)) if SEE < 1012) = {
    SEE = 1012;
    decode_tcommit_aarch64_instrs_system_tme_tcommit()
}

val execute_aarch64_instrs_vector_transfer_vector_permute_transpose : forall 'd 'datasize 'esize 'm 'n 'pairs 'part,
  ('part in {0, 1} & 0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'esize in {8, 16, 32, 64} & 'datasize in {64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('esize), int('m), int('n), int('pairs), int('part)) -> unit

function execute_aarch64_instrs_vector_transfer_vector_permute_transpose (d, datasize, esize, m, n, pairs, part) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = V_read(n, datasize);
    let operand2 : bits('datasize) = V_read(m, datasize);
    result : bits('datasize) = undefined;
    foreach (p from 0 to (pairs - 1) by 1 in inc) {
        result = Elem_set(result, 2 * p + 0, esize, Elem_read(operand1, 2 * p + part, esize));
        result = Elem_set(result, 2 * p + 1, esize, Elem_read(operand2, 2 * p + part, esize))
    };
    V_set(d, datasize) = result
}

val decode_trn1_advsimd_aarch64_instrs_vector_transfer_vector_permute_transpose : (bits(5), bits(5), bits(1), bits(5), bits(2), bits(1)) -> unit

function decode_trn1_advsimd_aarch64_instrs_vector_transfer_vector_permute_transpose (Rd, Rn, op, Rm, size, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if (size @ Q) == 0b110 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let 'part = UInt(op);
    let 'pairs = DIV(elements, 2);
    execute_aarch64_instrs_vector_transfer_vector_permute_transpose(d, datasize, esize, m, n, pairs, part)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, bitzero, _, _, _, _, _, bitzero, bitzero, bitone, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 1013) = {
    SEE = 1013;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 14, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let Q = Slice(__opcode, 30, 1);
    decode_trn1_advsimd_aarch64_instrs_vector_transfer_vector_permute_transpose(Rd, Rn, op, Rm, size, Q)
}

val decode_trn2_advsimd_aarch64_instrs_vector_transfer_vector_permute_transpose : (bits(5), bits(5), bits(1), bits(5), bits(2), bits(1)) -> unit

function decode_trn2_advsimd_aarch64_instrs_vector_transfer_vector_permute_transpose (Rd, Rn, op, Rm, size, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if (size @ Q) == 0b110 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let 'part = UInt(op);
    let 'pairs = DIV(elements, 2);
    execute_aarch64_instrs_vector_transfer_vector_permute_transpose(d, datasize, esize, m, n, pairs, part)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, bitzero, _, _, _, _, _, bitzero, bitone, bitone, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 1014) = {
    SEE = 1014;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 14, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let Q = Slice(__opcode, 30, 1);
    decode_trn2_advsimd_aarch64_instrs_vector_transfer_vector_permute_transpose(Rd, Rn, op, Rm, size, Q)
}

val execute_aarch64_instrs_system_tme_tstart : forall 'VL 't,
  (0 <= 't & 't <= 31 & is_VL('VL)).
  (int('VL), int('t)) -> unit

function execute_aarch64_instrs_system_tme_tstart (VL, t) = {
    if not_bool(IsTMEEnabled()) then {
        throw(Error_Undefined())
    };
    IsEL1Regime : bool = undefined;
    tme : bits(1) = undefined;
    tmt : bits(1) = undefined;
    match PSTATE.EL {
      ? if ? == EL0 => {
          let IsEL1Regime : bool = S1TranslationRegime__1() == EL1;
          if IsEL1Regime then {
              tme = SCTLR_EL1[TME0];
              tmt = SCTLR_EL1[TMT0]
          } else {
              tme = SCTLR_EL2[TME0];
              tmt = SCTLR_EL2[TMT0]
          }
      },
      ? if ? == EL1 => {
          tme = SCTLR_EL1[TME];
          tmt = SCTLR_EL1[TMT]
      },
      ? if ? == EL2 => {
          tme = SCTLR_EL2[TME];
          tmt = SCTLR_EL2[TMT]
      },
      ? if ? == EL3 => {
          tme = SCTLR_EL3[TME];
          tmt = SCTLR_EL3[TMT]
      },
      _ => {
          Unreachable()
      }
    };
    let enable : bool = tme == 0b1;
    let trivial : bool = tmt == 0b1;
    if not_bool(enable) then {
        TransactionStartTrap(t)
    } else if trivial then {
        TSTATE.nPC = NextInstrAddr(64);
        TSTATE.Rt = t;
        FailTransaction(TMFailure_TRIVIAL, false)
    } else if HaveSME() & PSTATE.SM == 0b1 then {
        FailTransaction(TMFailure_ERR, false)
    } else if TSTATE.depth == 255 then {
        FailTransaction(TMFailure_NEST, false)
    } else if TSTATE.depth == 0 then {
        TSTATE.nPC = NextInstrAddr(64);
        TSTATE.Rt = t;
        ClearExclusiveLocal(ProcessorID());
        TakeTransactionCheckpoint(VL, DIV(VL, 8));
        StartTrackingTransactionalReadsWrites()
    } else ();
    TSTATE.depth = TSTATE.depth + 1;
    X_set(t, 64) = Zeros(64)
}

val decode_tstart_aarch64_instrs_system_tme_tstart : bits(5) -> unit

function decode_tstart_aarch64_instrs_system_tme_tstart Rt = {
    let 'VL = CurrentVL_read();
    if not_bool(HaveTME()) then {
        throw(Error_Undefined())
    };
    let 't = UInt(Rt);
    match VL {
      128 => {
          execute_aarch64_instrs_system_tme_tstart(128, t)
      },
      256 => {
          execute_aarch64_instrs_system_tme_tstart(256, t)
      },
      512 => {
          execute_aarch64_instrs_system_tme_tstart(512, t)
      },
      1024 => {
          execute_aarch64_instrs_system_tme_tstart(1024, t)
      },
      2048 => {
          execute_aarch64_instrs_system_tme_tstart(2048, t)
      },
      _ => ()
    }
}

function clause __DecodeA64_BranchExcSys ((pc, ([bitone, bitone, bitzero, bitone, bitzero, bitone, bitzero, bitone, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitone, _, _, _, _, _] as __opcode)) if SEE < 1015) = {
    SEE = 1015;
    let Rt = Slice(__opcode, 0, 5);
    decode_tstart_aarch64_instrs_system_tme_tstart(Rt)
}

val execute_aarch64_instrs_system_tme_ttest : forall 't, (0 <= 't & 't <= 31).
  int('t) -> unit

function execute_aarch64_instrs_system_tme_ttest t = {
    if not_bool(IsTMEEnabled()) then {
        throw(Error_Undefined())
    };
    X_set(t, 64) = TSTATE.depth[63 .. 0]
}

val decode_ttest_aarch64_instrs_system_tme_ttest : bits(5) -> unit

function decode_ttest_aarch64_instrs_system_tme_ttest Rt = {
    if not_bool(HaveTME()) then {
        throw(Error_Undefined())
    };
    let 't = UInt(Rt);
    execute_aarch64_instrs_system_tme_ttest(t)
}

function clause __DecodeA64_BranchExcSys ((pc, ([bitone, bitone, bitzero, bitone, bitzero, bitone, bitzero, bitone, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, _, _, _, _, _] as __opcode)) if SEE < 1016) = {
    SEE = 1016;
    let Rt = Slice(__opcode, 0, 5);
    decode_ttest_aarch64_instrs_system_tme_ttest(Rt)
}

val execute_aarch64_instrs_udf : unit -> unit

function execute_aarch64_instrs_udf () = {
    ()
}

val decode_udf_perm_undef_aarch64_instrs_udf : bits(16) -> unit

function decode_udf_perm_undef_aarch64_instrs_udf imm16 = {
    throw(Error_Undefined());
    execute_aarch64_instrs_udf()
}

function clause __DecodeA64_Reserved ((pc, ([bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 1017) = {
    SEE = 1017;
    let imm16 = Slice(__opcode, 0, 16);
    decode_udf_perm_undef_aarch64_instrs_udf(imm16)
}

val execute_aarch64_instrs_integer_arithmetic_max_min_umax_imm : forall 'd 'datasize 'imm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'imm & 'imm <= 255 & 'datasize in {32, 64} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('imm), int('n)) -> unit

function execute_aarch64_instrs_integer_arithmetic_max_min_umax_imm (d, datasize, imm, n) = {
    let operand1 : bits('datasize) = X_read(n, datasize);
    let 'result = Max(UInt(operand1), imm);
    X_set(d, datasize) = result[datasize - 1 .. 0]
}

val decode_umax_imm_aarch64_instrs_integer_arithmetic_max_min_umax_imm : (bits(5), bits(5), bits(8), bits(1)) -> unit

function decode_umax_imm_aarch64_instrs_integer_arithmetic_max_min_umax_imm (Rd, Rn, imm8, sf) = {
    if not_bool(HaveCSSC()) then {
        throw(Error_Undefined())
    };
    let 'datasize = (32 << UInt(sf));
    let 'n = UInt(Rn);
    let 'd = UInt(Rd);
    let 'imm = UInt(imm8);
    execute_aarch64_instrs_integer_arithmetic_max_min_umax_imm(d, datasize, imm, n)
}

function clause __DecodeA64_DataProcImm ((pc, ([_, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 1018) = {
    SEE = 1018;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm8 = Slice(__opcode, 10, 8);
    let sf = Slice(__opcode, 31, 1);
    decode_umax_imm_aarch64_instrs_integer_arithmetic_max_min_umax_imm(Rd, Rn, imm8, sf)
}

val execute_aarch64_instrs_integer_arithmetic_max_min_umax_reg : forall 'd 'datasize 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'datasize in {32, 64} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('m), int('n)) -> unit

function execute_aarch64_instrs_integer_arithmetic_max_min_umax_reg (d, datasize, m, n) = {
    let operand1 : bits('datasize) = X_read(n, datasize);
    let operand2 : bits('datasize) = X_read(m, datasize);
    let 'result = Max(UInt(operand1), UInt(operand2));
    X_set(d, datasize) = result[datasize - 1 .. 0]
}

val decode_umax_reg_aarch64_instrs_integer_arithmetic_max_min_umax_reg : (bits(5), bits(5), bits(5), bits(1)) -> unit

function decode_umax_reg_aarch64_instrs_integer_arithmetic_max_min_umax_reg (Rd, Rn, Rm, sf) = {
    if not_bool(HaveCSSC()) then {
        throw(Error_Undefined())
    };
    let 'datasize = (32 << UInt(sf));
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'd = UInt(Rd);
    execute_aarch64_instrs_integer_arithmetic_max_min_umax_reg(d, datasize, m, n)
}

function clause __DecodeA64_DataProcReg ((pc, ([_, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, bitzero, bitone, bitone, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 1019) = {
    SEE = 1019;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let sf = Slice(__opcode, 31, 1);
    decode_umax_reg_aarch64_instrs_integer_arithmetic_max_min_umax_reg(Rd, Rn, Rm, sf)
}

val execute_aarch64_instrs_integer_arithmetic_max_min_umin_reg : forall 'd 'datasize 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'datasize in {32, 64} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('m), int('n)) -> unit

function execute_aarch64_instrs_integer_arithmetic_max_min_umin_reg (d, datasize, m, n) = {
    let operand1 : bits('datasize) = X_read(n, datasize);
    let operand2 : bits('datasize) = X_read(m, datasize);
    let 'result = Min(UInt(operand1), UInt(operand2));
    X_set(d, datasize) = result[datasize - 1 .. 0]
}

val decode_umin_reg_aarch64_instrs_integer_arithmetic_max_min_umin_reg : (bits(5), bits(5), bits(5), bits(1)) -> unit

function decode_umin_reg_aarch64_instrs_integer_arithmetic_max_min_umin_reg (Rd, Rn, Rm, sf) = {
    if not_bool(HaveCSSC()) then {
        throw(Error_Undefined())
    };
    let 'datasize = (32 << UInt(sf));
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'd = UInt(Rd);
    execute_aarch64_instrs_integer_arithmetic_max_min_umin_reg(d, datasize, m, n)
}

function clause __DecodeA64_DataProcReg ((pc, ([_, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, bitzero, bitone, bitone, bitzero, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 1020) = {
    SEE = 1020;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let sf = Slice(__opcode, 31, 1);
    decode_umin_reg_aarch64_instrs_integer_arithmetic_max_min_umin_reg(Rd, Rn, Rm, sf)
}

val execute_aarch64_instrs_integer_arithmetic_max_min_umin_imm : forall 'd 'datasize 'imm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'imm & 'imm <= 255 & 'datasize in {32, 64} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('imm), int('n)) -> unit

function execute_aarch64_instrs_integer_arithmetic_max_min_umin_imm (d, datasize, imm, n) = {
    let operand1 : bits('datasize) = X_read(n, datasize);
    let 'result = Min(UInt(operand1), imm);
    X_set(d, datasize) = result[datasize - 1 .. 0]
}

val decode_umin_imm_aarch64_instrs_integer_arithmetic_max_min_umin_imm : (bits(5), bits(5), bits(8), bits(1)) -> unit

function decode_umin_imm_aarch64_instrs_integer_arithmetic_max_min_umin_imm (Rd, Rn, imm8, sf) = {
    if not_bool(HaveCSSC()) then {
        throw(Error_Undefined())
    };
    let 'datasize = (32 << UInt(sf));
    let 'n = UInt(Rn);
    let 'd = UInt(Rd);
    let 'imm = UInt(imm8);
    execute_aarch64_instrs_integer_arithmetic_max_min_umin_imm(d, datasize, imm, n)
}

function clause __DecodeA64_DataProcImm ((pc, ([_, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 1021) = {
    SEE = 1021;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm8 = Slice(__opcode, 10, 8);
    let sf = Slice(__opcode, 31, 1);
    decode_umin_imm_aarch64_instrs_integer_arithmetic_max_min_umin_imm(Rd, Rn, imm8, sf)
}

val execute_aarch64_instrs_vector_transfer_integer_move_unsigned : forall 'd 'datasize 'esize 'idxdsize 'index 'n,
  (0 <= 'n & 'n <= 31 & 'idxdsize in {64, 128} & 'esize in {8, 16, 32, 64} & 'datasize in {32, 64} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('esize), int('idxdsize), int('index), int('n)) -> unit

function execute_aarch64_instrs_vector_transfer_integer_move_unsigned (d, datasize, esize, idxdsize, index, n) = {
    if index == 0 then {
        CheckFPEnabled64()
    } else {
        CheckFPAdvSIMDEnabled64()
    };
    let operand : bits('idxdsize) = V_read(n, idxdsize);
    assert(constraint('datasize >= 'esize));
    X_set(d, datasize) = ZeroExtend(Elem_read(operand, index, esize), datasize)
}

val decode_umov_advsimd_aarch64_instrs_vector_transfer_integer_move_unsigned : (bits(5), bits(5), bits(5), bits(1)) -> unit

function decode_umov_advsimd_aarch64_instrs_vector_transfer_integer_move_unsigned (Rd, Rn, imm5, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    size : {0, 1, 2, 3} = 0;
    match Q @ imm5 {
      [bitzero, _, _, _, _, bitone] => {
          size = 0
      },
      [bitzero, _, _, _, bitone, bitzero] => {
          size = 1
      },
      [bitzero, _, _, bitone, bitzero, bitzero] => {
          size = 2
      },
      [bitone, _, bitone, bitzero, bitzero, bitzero] => {
          size = 3
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let 'size = size;
    let 'idxdsize = if [imm5[4]] == 0b1 then 128 else 64;
    let 'index = UInt(imm5[4 .. size + 1]);
    let 'esize = (8 << size);
    let 'datasize = if Q == 0b1 then 64 else 32;
    execute_aarch64_instrs_vector_transfer_integer_move_unsigned(d, datasize, esize, idxdsize, index, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, bitzero, bitzero, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 1022) = {
    SEE = 1022;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm5 = Slice(__opcode, 16, 5);
    let Q = Slice(__opcode, 30, 1);
    decode_umov_advsimd_aarch64_instrs_vector_transfer_integer_move_unsigned(Rd, Rn, imm5, Q)
}

val execute_aarch64_instrs_vector_arithmetic_unary_special_recip_int : forall 'd 'datasize 'elements 'n,
  (0 <= 'n & 'n <= 31 & 'datasize in {64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('n)) -> unit

function execute_aarch64_instrs_vector_arithmetic_unary_special_recip_int (d, datasize, elements, n) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('datasize) = V_read(n, datasize);
    result : bits('datasize) = undefined;
    element : bits(32) = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element = Elem_read(operand, e, 32);
        result = Elem_set(result, e, 32, UnsignedRecipEstimate(element))
    };
    V_set(d, datasize) = result
}

val decode_urecpe_advsimd_aarch64_instrs_vector_arithmetic_unary_special_recip_int : (bits(5), bits(5), bits(1), bits(1)) -> unit

function decode_urecpe_advsimd_aarch64_instrs_vector_arithmetic_unary_special_recip_int (Rd, Rn, sz, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if sz == 0b1 then {
        throw(Error_Undefined())
    };
    let 'esize = 32;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    execute_aarch64_instrs_vector_arithmetic_unary_special_recip_int(d, datasize, elements, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitone, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 1023) = {
    SEE = 1023;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let sz = Slice(__opcode, 22, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_urecpe_advsimd_aarch64_instrs_vector_arithmetic_unary_special_recip_int(Rd, Rn, sz, Q)
}

val execute_aarch64_instrs_vector_arithmetic_unary_special_sqrt_est_int : forall 'd 'datasize 'elements 'n,
  (0 <= 'n & 'n <= 31 & 'datasize in {64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('n)) -> unit

function execute_aarch64_instrs_vector_arithmetic_unary_special_sqrt_est_int (d, datasize, elements, n) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('datasize) = V_read(n, datasize);
    result : bits('datasize) = undefined;
    element : bits(32) = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element = Elem_read(operand, e, 32);
        result = Elem_set(result, e, 32, UnsignedRSqrtEstimate(element))
    };
    V_set(d, datasize) = result
}

val decode_ursqrte_advsimd_aarch64_instrs_vector_arithmetic_unary_special_sqrt_est_int : (bits(5), bits(5), bits(1), bits(1)) -> unit

function decode_ursqrte_advsimd_aarch64_instrs_vector_arithmetic_unary_special_sqrt_est_int (Rd, Rn, sz, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if sz == 0b1 then {
        throw(Error_Undefined())
    };
    let 'esize = 32;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    execute_aarch64_instrs_vector_arithmetic_unary_special_sqrt_est_int(d, datasize, elements, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, bitone, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 1024) = {
    SEE = 1024;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let sz = Slice(__opcode, 22, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_ursqrte_advsimd_aarch64_instrs_vector_arithmetic_unary_special_sqrt_est_int(Rd, Rn, sz, Q)
}

val execute_aarch64_instrs_vector_arithmetic_binary_uniform_mat_mul_int_usdot : forall 'd 'datasize 'elements 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'elements in {2, 4} & 'datasize in {64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('m), int('n)) -> unit

function execute_aarch64_instrs_vector_arithmetic_binary_uniform_mat_mul_int_usdot (d, datasize, elements, m, n) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = V_read(n, datasize);
    let operand2 : bits('datasize) = V_read(m, datasize);
    let operand3 : bits('datasize) = V_read(d, datasize);
    result : bits('datasize) = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        res : bits(32) = Elem_read(operand3, e, 32);
        foreach (b from 0 to 3 by 1 in inc) {
            let 'element1 = UInt(Elem_read(operand1, 4 * e + b, 8));
            let 'element2 = SInt(Elem_read(operand2, 4 * e + b, 8));
            res = res + element1 * element2
        };
        result = Elem_set(result, e, 32, res)
    };
    V_set(d, datasize) = result
}

val decode_usdot_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mat_mul_int_usdot : (bits(5), bits(5), bits(5), bits(1)) -> unit

function decode_usdot_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mat_mul_int_usdot (Rd, Rn, Rm, Q) = {
    if not_bool(HaveInt8MatMulExt()) then {
        throw(Error_Undefined())
    };
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'd = UInt(Rd);
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, 32);
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_mat_mul_int_usdot(d, datasize, elements, m, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, bitone, bitzero, bitzero, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 1025) = {
    SEE = 1025;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let Q = Slice(__opcode, 30, 1);
    decode_usdot_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mat_mul_int_usdot(Rd, Rn, Rm, Q)
}

val execute_aarch64_instrs_vector_transfer_vector_permute_unzip : forall 'd 'datasize 'elements 'esize 'm 'n 'part,
  ('part in {0, 1} & 0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'esize in {8, 16, 32, 64} & 'datasize in {64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('m), int('n), int('part)) -> unit

function execute_aarch64_instrs_vector_transfer_vector_permute_unzip (d, datasize, elements, esize, m, n, part) = {
    CheckFPAdvSIMDEnabled64();
    let operandl : bits('datasize) = V_read(n, datasize);
    let operandh : bits('datasize) = V_read(m, datasize);
    result : bits('datasize) = undefined;
    let zipped : bits('datasize * 2) = operandh @ operandl;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        result = Elem_set(result, e, esize, Elem_read(zipped, 2 * e + part, esize))
    };
    V_set(d, datasize) = result
}

val decode_uzp1_advsimd_aarch64_instrs_vector_transfer_vector_permute_unzip : (bits(5), bits(5), bits(1), bits(5), bits(2), bits(1)) -> unit

function decode_uzp1_advsimd_aarch64_instrs_vector_transfer_vector_permute_unzip (Rd, Rn, op, Rm, size, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if (size @ Q) == 0b110 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let 'part = UInt(op);
    execute_aarch64_instrs_vector_transfer_vector_permute_unzip(d, datasize, elements, esize, m, n, part)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, bitzero, _, _, _, _, _, bitzero, bitzero, bitzero, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 1026) = {
    SEE = 1026;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 14, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let Q = Slice(__opcode, 30, 1);
    decode_uzp1_advsimd_aarch64_instrs_vector_transfer_vector_permute_unzip(Rd, Rn, op, Rm, size, Q)
}

val decode_uzp2_advsimd_aarch64_instrs_vector_transfer_vector_permute_unzip : (bits(5), bits(5), bits(1), bits(5), bits(2), bits(1)) -> unit

function decode_uzp2_advsimd_aarch64_instrs_vector_transfer_vector_permute_unzip (Rd, Rn, op, Rm, size, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if (size @ Q) == 0b110 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let 'part = UInt(op);
    execute_aarch64_instrs_vector_transfer_vector_permute_unzip(d, datasize, elements, esize, m, n, part)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, bitzero, _, _, _, _, _, bitzero, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 1027) = {
    SEE = 1027;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 14, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let Q = Slice(__opcode, 30, 1);
    decode_uzp2_advsimd_aarch64_instrs_vector_transfer_vector_permute_unzip(Rd, Rn, op, Rm, size, Q)
}

val execute_aarch64_instrs_system_sysinstwithreg_wfet : forall 'd, (0 <= 'd & 'd <= 31).
  int('d) -> unit

function execute_aarch64_instrs_system_sysinstwithreg_wfet d = {
    let 'localtimeout = UInt(X_read(d, 64));
    if Halted() & ConstrainUnpredictableBool(Unpredictable_WFxTDEBUG) then {
        EndOfInstruction()
    };
    Hint_WFE(localtimeout, WFxType_WFET)
}

val decode_wfet_aarch64_instrs_system_sysinstwithreg_wfet : bits(5) -> unit

function decode_wfet_aarch64_instrs_system_sysinstwithreg_wfet Rd = {
    if not_bool(HaveFeatWFxT()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    execute_aarch64_instrs_system_sysinstwithreg_wfet(d)
}

function clause __DecodeA64_BranchExcSys ((pc, ([bitone, bitone, bitzero, bitone, bitzero, bitone, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _] as __opcode)) if SEE < 1028) = {
    SEE = 1028;
    let Rd = Slice(__opcode, 0, 5);
    decode_wfet_aarch64_instrs_system_sysinstwithreg_wfet(Rd)
}

val execute_aarch64_instrs_system_sysinstwithreg_wfit : forall 'd, (0 <= 'd & 'd <= 31).
  int('d) -> unit

function execute_aarch64_instrs_system_sysinstwithreg_wfit d = {
    let 'localtimeout = UInt(X_read(d, 64));
    if Halted() & ConstrainUnpredictableBool(Unpredictable_WFxTDEBUG) then {
        EndOfInstruction()
    };
    Hint_WFI(localtimeout, WFxType_WFIT)
}

val decode_wfit_aarch64_instrs_system_sysinstwithreg_wfit : bits(5) -> unit

function decode_wfit_aarch64_instrs_system_sysinstwithreg_wfit Rd = {
    if not_bool(HaveFeatWFxT()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    execute_aarch64_instrs_system_sysinstwithreg_wfit(d)
}

function clause __DecodeA64_BranchExcSys ((pc, ([bitone, bitone, bitzero, bitone, bitzero, bitone, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, _, _, _, _, _] as __opcode)) if SEE < 1029) = {
    SEE = 1029;
    let Rd = Slice(__opcode, 0, 5);
    decode_wfit_aarch64_instrs_system_sysinstwithreg_wfit(Rd)
}

val execute_aarch64_instrs_integer_flags_xaflag : unit -> unit

function execute_aarch64_instrs_integer_flags_xaflag () = {
    let n : bits(1) = not_vec(PSTATE.C) & not_vec(PSTATE.Z);
    let z : bits(1) = PSTATE.Z & PSTATE.C;
    let c : bits(1) = PSTATE.C | PSTATE.Z;
    let v : bits(1) = not_vec(PSTATE.C) & PSTATE.Z;
    PSTATE.N = n;
    PSTATE.Z = z;
    PSTATE.C = c;
    PSTATE.V = v
}

val decode_xaflag_aarch64_instrs_integer_flags_xaflag : bits(4) -> unit

function decode_xaflag_aarch64_instrs_integer_flags_xaflag CRm = {
    if not_bool(HaveFlagFormatExt()) then {
        throw(Error_Undefined())
    };
    execute_aarch64_instrs_integer_flags_xaflag()
}

function clause __DecodeA64_BranchExcSys ((pc, (0b11010101000000000100000000111111 as __opcode)) if SEE < 1030) = {
    SEE = 1030;
    let CRm = Slice(__opcode, 8, 4);
    if (([__opcode[8]] != 0b0 | [__opcode[9]] != 0b0) | [__opcode[10]] != 0b0) | [__opcode[11]] != 0b0 then {
        throw(Error_ConstrainedUnpredictable())
    } else {
        decode_xaflag_aarch64_instrs_integer_flags_xaflag(CRm)
    }
}

val execute_aarch64_instrs_vector_crypto_sha3_xar : forall 'd 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 0 <= 'd & 'd <= 31).
  (int('d), bits(6), int('m), int('n)) -> unit

function execute_aarch64_instrs_vector_crypto_sha3_xar (d, imm6, m, n) = {
    AArch64_CheckFPAdvSIMDEnabled();
    let Vm : bits(128) = V_read(m, 128);
    let Vn : bits(128) = V_read(n, 128);
    let tmp : bits(128) = EOR(Vn, Vm);
    V_set(d, 128) = ROR(tmp[127 .. 64], UInt(imm6)) @ ROR(tmp[63 .. 0], UInt(imm6))
}

val decode_xar_advsimd_aarch64_instrs_vector_crypto_sha3_xar : (bits(5), bits(5), bits(6), bits(5)) -> unit

function decode_xar_advsimd_aarch64_instrs_vector_crypto_sha3_xar (Rd, Rn, imm6, Rm) = {
    if not_bool(HaveSHA3Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    execute_aarch64_instrs_vector_crypto_sha3_xar(d, imm6, m, n)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitone, bitone, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 1031) = {
    SEE = 1031;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm6 = Slice(__opcode, 10, 6);
    let Rm = Slice(__opcode, 16, 5);
    decode_xar_advsimd_aarch64_instrs_vector_crypto_sha3_xar(Rd, Rn, imm6, Rm)
}

val execute_aarch64_instrs_integer_pac_strip_dp_1src : forall 'd ('data : Bool), (0 <= 'd & 'd <= 31).
  (int('d), bool('data)) -> unit

function execute_aarch64_instrs_integer_pac_strip_dp_1src (d, data) = {
    if HavePACExt() then {
        X_set(d, 64) = Strip(X_read(d, 64), data)
    };
    ()
}

val decode_xpac_aarch64_instrs_integer_pac_strip_dp_1src : (bits(5), bits(5), bits(1)) -> unit

function decode_xpac_aarch64_instrs_integer_pac_strip_dp_1src (Rd, Rn, D) = {
    let data : bool = D == 0b1;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if not_bool(HavePACExt()) then {
        throw(Error_Undefined())
    };
    if n != 31 then {
        throw(Error_Undefined())
    };
    execute_aarch64_instrs_integer_pac_strip_dp_1src(d, data)
}

function clause __DecodeA64_DataProcReg ((pc, ([bitone, bitone, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitzero, bitzero, bitzero, _, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _] as __opcode)) if SEE < 1032) = {
    SEE = 1032;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let D = Slice(__opcode, 10, 1);
    decode_xpac_aarch64_instrs_integer_pac_strip_dp_1src(Rd, Rn, D)
}

val decode_xpac_aarch64_instrs_integer_pac_strip_hint : unit -> unit

function decode_xpac_aarch64_instrs_integer_pac_strip_hint () = {
    let 'd = 30;
    let data : bool = false;
    execute_aarch64_instrs_integer_pac_strip_dp_1src(d, data)
}

function clause __DecodeA64_BranchExcSys ((pc, (0b11010101000000110010000011111111 as __opcode)) if SEE < 1033) = {
    SEE = 1033;
    decode_xpac_aarch64_instrs_integer_pac_strip_hint()
}

val execute_aarch64_instrs_vector_arithmetic_unary_extract_nosat : forall 'd 'datasize 'elements 'esize 'n 'part,
  ('part in {0, 1} & 0 <= 'n & 'n <= 31 & 'esize in {8, 16, 32, 64} & 'datasize == 64 & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('n), int('part)) -> unit

function execute_aarch64_instrs_vector_arithmetic_unary_extract_nosat (d, datasize, elements, esize, n, part) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits(2 * 'datasize) = V_read(n, 2 * datasize);
    result : bits('datasize) = undefined;
    element : bits(2 * 'esize) = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element = Elem_read(operand, e, 2 * esize);
        result = Elem_set(result, e, esize, element[esize - 1 .. 0])
    };
    Vpart_set(d, part, datasize) = result
}

val decode_xtn_advsimd_aarch64_instrs_vector_arithmetic_unary_extract_nosat : (bits(5), bits(5), bits(2), bits(1)) -> unit

function decode_xtn_advsimd_aarch64_instrs_vector_arithmetic_unary_extract_nosat (Rd, Rn, size, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    let 'datasize = 64;
    let 'part = UInt(Q);
    let 'elements = DIV(datasize, esize);
    execute_aarch64_instrs_vector_arithmetic_unary_extract_nosat(d, datasize, elements, esize, n, part)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitone, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 1034) = {
    SEE = 1034;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 22, 2);
    let Q = Slice(__opcode, 30, 1);
    decode_xtn_advsimd_aarch64_instrs_vector_arithmetic_unary_extract_nosat(Rd, Rn, size, Q)
}

val execute_aarch64_instrs_vector_transfer_vector_permute_zip : forall 'd 'datasize 'esize 'm 'n 'pairs 'part,
  ('part in {0, 1} & 0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'esize in {8, 16, 32, 64} & 'datasize in {64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('esize), int('m), int('n), int('pairs), int('part)) -> unit

function execute_aarch64_instrs_vector_transfer_vector_permute_zip (d, datasize, esize, m, n, pairs, part) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = V_read(n, datasize);
    let operand2 : bits('datasize) = V_read(m, datasize);
    result : bits('datasize) = undefined;
    let 'base = part * pairs;
    foreach (p from 0 to (pairs - 1) by 1 in inc) {
        result = Elem_set(result, 2 * p + 0, esize, Elem_read(operand1, base + p, esize));
        result = Elem_set(result, 2 * p + 1, esize, Elem_read(operand2, base + p, esize))
    };
    V_set(d, datasize) = result
}

val decode_zip1_advsimd_aarch64_instrs_vector_transfer_vector_permute_zip : (bits(5), bits(5), bits(1), bits(5), bits(2), bits(1)) -> unit

function decode_zip1_advsimd_aarch64_instrs_vector_transfer_vector_permute_zip (Rd, Rn, op, Rm, size, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if (size @ Q) == 0b110 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let 'part = UInt(op);
    let 'pairs = DIV(elements, 2);
    execute_aarch64_instrs_vector_transfer_vector_permute_zip(d, datasize, esize, m, n, pairs, part)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, bitzero, _, _, _, _, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 1035) = {
    SEE = 1035;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 14, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let Q = Slice(__opcode, 30, 1);
    decode_zip1_advsimd_aarch64_instrs_vector_transfer_vector_permute_zip(Rd, Rn, op, Rm, size, Q)
}

val decode_zip2_advsimd_aarch64_instrs_vector_transfer_vector_permute_zip : (bits(5), bits(5), bits(1), bits(5), bits(2), bits(1)) -> unit

function decode_zip2_advsimd_aarch64_instrs_vector_transfer_vector_permute_zip (Rd, Rn, op, Rm, size, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if (size @ Q) == 0b110 then {
        throw(Error_Undefined())
    };
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let 'part = UInt(op);
    let 'pairs = DIV(elements, 2);
    execute_aarch64_instrs_vector_transfer_vector_permute_zip(d, datasize, esize, m, n, pairs, part)
}

function clause __DecodeA64_DataProcFPSIMD ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, bitzero, _, _, _, _, _, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) if SEE < 1036) = {
    SEE = 1036;
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 14, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let Q = Slice(__opcode, 30, 1);
    decode_zip2_advsimd_aarch64_instrs_vector_transfer_vector_permute_zip(Rd, Rn, op, Rm, size, Q)
}
